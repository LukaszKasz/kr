[33mcommit fb0a2a9a0b40983e6e1ae37e1edb690708f81835[m[33m ([m[1;31morigin/feature/qr-app[m[33m, [m[1;32mfeature/qr-app[m[33m)[m
Author: ≈Åukasz Kasztelan <lkasztelan@gazeta.pl>
Date:   Wed Feb 18 22:48:50 2026 +0100

    first commit 4

[1mdiff --git a/deploy/assets/index-BjN-r06w.css b/deploy/assets/index-BjN-r06w.css[m
[1mnew file mode 100644[m
[1mindex 0000000..b5c0920[m
[1m--- /dev/null[m
[1m+++ b/deploy/assets/index-BjN-r06w.css[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32m*,*:before,*:after{box-sizing:border-box;margin:0;padding:0}:root{--color-bg: #0f172a;--color-bg-card: rgba(30, 41, 59, .7);--color-surface: #1e293b;--color-border: rgba(148, 163, 184, .15);--color-text: #f1f5f9;--color-text-muted: #94a3b8;--color-text-dim: #64748b;--color-accent: #6366f1;--color-accent-glow: rgba(99, 102, 241, .3);--color-success: #22c55e;--color-success-bg: rgba(34, 197, 94, .1);--color-error: #ef4444;--color-error-bg: rgba(239, 68, 68, .1);--color-warning: #f59e0b;--color-warning-bg: rgba(245, 158, 11, .1);--radius: 16px;--radius-sm: 10px;--shadow: 0 4px 24px rgba(0, 0, 0, .3);--transition: .25s cubic-bezier(.4, 0, .2, 1);--font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif}html{font-size:16px;-webkit-text-size-adjust:100%}body{font-family:var(--font);background:var(--color-bg);color:var(--color-text);line-height:1.6;min-height:100dvh;-webkit-font-smoothing:antialiased}body:before{content:"";position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(ellipse at 20% 0%,rgba(99,102,241,.12) 0%,transparent 60%),radial-gradient(ellipse at 80% 100%,rgba(139,92,246,.08) 0%,transparent 60%);pointer-events:none;z-index:0}.app{position:relative;z-index:1;display:flex;flex-direction:column;min-height:100dvh;max-width:480px;margin:0 auto;padding:0 16px}.main{flex:1;display:flex;flex-direction:column;gap:16px;padding-top:24px;padding-bottom:24px}.card{background:var(--color-bg-card);border:1px solid var(--color-border);border-radius:var(--radius);padding:20px;backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);box-shadow:var(--shadow)}.card-label{font-size:.75rem;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--color-text-muted);margin-bottom:10px}.scanner-card{padding:16px}.scanner-title{font-size:1.25rem;font-weight:700;text-align:center;margin-bottom:16px;color:var(--color-text);background:linear-gradient(135deg,#e2e8f0,#6366f1);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.scanner-placeholder-wrapper{width:100%;min-height:280px;border-radius:var(--radius-sm);background:var(--color-surface);border:2px dashed var(--color-border);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;color:var(--color-text-dim);font-size:.875rem;text-align:center;line-height:1.5}.scanner-placeholder-icon{font-size:3rem;opacity:.5}.scanner-video-wrapper{position:relative;border-radius:var(--radius-sm);overflow:hidden;border:2px solid var(--color-accent);box-shadow:0 0 20px var(--color-accent-glow)}.scanner-video{width:100%;display:block;background:#000}.focus-indicator{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70px;height:70px;border:3px solid #fff;border-radius:50%;animation:focus-pulse .6s ease-out forwards;pointer-events:none}@keyframes focus-pulse{0%{transform:translate(-50%,-50%) scale(1.3);opacity:1}to{transform:translate(-50%,-50%) scale(.9);opacity:0}}.tap-hint{position:absolute;bottom:8px;left:0;right:0;text-align:center;font-size:.7rem;color:#fff9;text-shadow:0 1px 3px rgba(0,0,0,.8);pointer-events:none}.zoom-control{display:flex;align-items:center;gap:10px;margin-top:12px;padding:8px 12px;background:var(--color-surface);border-radius:var(--radius-sm);border:1px solid var(--color-border)}.zoom-label{font-size:1.2rem;flex-shrink:0}.zoom-slider{flex:1;height:6px;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:var(--color-border);border-radius:3px;outline:none}.zoom-slider::-webkit-slider-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:24px;height:24px;border-radius:50%;background:var(--color-accent);cursor:pointer;box-shadow:0 0 8px var(--color-accent-glow)}.zoom-value{font-size:.85rem;font-weight:600;color:var(--color-accent);min-width:36px;text-align:right}.scanner-controls{margin-top:16px;display:flex;justify-content:center}.btn{display:inline-flex;align-items:center;gap:8px;padding:14px 28px;border:none;border-radius:var(--radius-sm);font-family:var(--font);font-size:1rem;font-weight:600;cursor:pointer;transition:all var(--transition);-webkit-tap-highlight-color:transparent;-webkit-user-select:none;user-select:none}.btn:active{transform:scale(.97)}.btn-icon{font-size:.875rem}.btn-start{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;box-shadow:0 4px 16px var(--color-accent-glow)}.btn-start:hover{box-shadow:0 6px 24px #6366f173}.btn-stop{background:#ef444426;color:var(--color-error);border:1px solid rgba(239,68,68,.3)}.btn-stop:hover{background:#ef444440}.camera-error{display:flex;align-items:flex-start;gap:10px;margin-top:12px;padding:12px 16px;background:var(--color-warning-bg);border:1px solid rgba(245,158,11,.25);border-radius:var(--radius-sm);font-size:.85rem;color:var(--color-warning);line-height:1.5}.camera-error-icon{flex-shrink:0;font-size:1.1rem}.scan-result{font-size:1rem;color:var(--color-text-dim);padding:12px 16px;background:var(--color-surface);border-radius:var(--radius-sm);border:1px solid var(--color-border);word-break:break-all;font-family:SF Mono,Fira Code,Consolas,monospace;min-height:44px;display:flex;align-items:center;transition:all var(--transition)}.scan-result.has-value{color:var(--color-text);border-color:#6366f14d;background:#6366f10f;animation:flash-in .3s ease-out}@keyframes flash-in{0%{background:#6366f133}to{background:#6366f10f}}.status-row{display:flex;align-items:center;gap:10px;padding:12px 16px;border-radius:var(--radius-sm);background:var(--color-surface);border:1px solid var(--color-border);transition:all var(--transition)}.status-icon{font-size:1.25rem;flex-shrink:0}.status-text{font-size:.9rem;font-weight:500}.status-saving .status-row{border-color:#6366f14d}.status-saving .status-icon{animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.status-saved .status-row{border-color:#22c55e4d;background:var(--color-success-bg)}.status-saved .status-text{color:var(--color-success)}.status-error .status-row{border-color:#ef44444d;background:var(--color-error-bg)}.status-error .status-text{color:var(--color-error)}.counter{text-align:center;font-size:.85rem;color:var(--color-text-muted);padding:12px;background:var(--color-bg-card);border-radius:var(--radius-sm);border:1px solid var(--color-border)}.counter strong{color:var(--color-accent);font-weight:700;font-size:1.1rem}.footer{text-align:center;padding:20px 0;font-size:.75rem;color:var(--color-text-dim);letter-spacing:.02em}@media (max-width: 360px){.btn{padding:12px 24px;font-size:.9rem}.scanner-placeholder-wrapper{min-height:240px}}@media (min-width: 481px){.app{padding:0 24px}}[m
[1mdiff --git a/deploy/assets/index-CL4UxkMi.js b/deploy/assets/index-CL4UxkMi.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d336c8e[m
[1m--- /dev/null[m
[1m+++ b/deploy/assets/index-CL4UxkMi.js[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32m(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const l of document.querySelectorAll('link[rel="modulepreload"]'))r(l);new MutationObserver(l=>{for(const u of l)if(u.type==="childList")for(const o of u.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(l){const u={};return l.integrity&&(u.integrity=l.integrity),l.referrerPolicy&&(u.referrerPolicy=l.referrerPolicy),l.crossOrigin==="use-credentials"?u.credentials="include":l.crossOrigin==="anonymous"?u.credentials="omit":u.credentials="same-origin",u}function r(l){if(l.ep)return;l.ep=!0;const u=n(l);fetch(l.href,u)}})();function nc(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Hi={exports:{}},el={},Wi={exports:{}},L={};/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var Xn=Symbol.for("react.element"),rc=Symbol.for("react.portal"),lc=Symbol.for("react.fragment"),uc=Symbol.for("react.strict_mode"),oc=Symbol.for("react.profiler"),ic=Symbol.for("react.provider"),sc=Symbol.for("react.context"),ac=Symbol.for("react.forward_ref"),cc=Symbol.for("react.suspense"),fc=Symbol.for("react.memo"),dc=Symbol.for("react.lazy"),Mo=Symbol.iterator;function pc(e){return e===null||typeof e!="object"?null:(e=Mo&&e[Mo]||e["@@iterator"],typeof e=="function"?e:null)}var Qi={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Ki=Object.assign,Yi={};function ln(e,t,n){this.props=e,this.context=t,this.refs=Yi,this.updater=n||Qi}ln.prototype.isReactComponent={};ln.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};ln.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function Xi(){}Xi.prototype=ln.prototype;function Uu(e,t,n){this.props=e,this.context=t,this.refs=Yi,this.updater=n||Qi}var Au=Uu.prototype=new Xi;Au.constructor=Uu;Ki(Au,ln.prototype);Au.isPureReactComponent=!0;var Do=Array.isArray,Gi=Object.prototype.hasOwnProperty,Vu={current:null},Zi={key:!0,ref:!0,__self:!0,__source:!0};function Ji(e,t,n){var r,l={},u=null,o=null;if(t!=null)for(r in t.ref!==void 0&&(o=t.ref),t.key!==void 0&&(u=""+t.key),t)Gi.call(t,r)&&!Zi.hasOwnProperty(r)&&(l[r]=t[r]);var i=arguments.length-2;if(i===1)l.children=n;else if(1<i){for(var s=Array(i),c=0;c<i;c++)s[c]=arguments[c+2];l.children=s}if(e&&e.defaultProps)for(r in i=e.defaultProps,i)l[r]===void 0&&(l[r]=i[r]);return{$$typeof:Xn,type:e,key:u,ref:o,props:l,_owner:Vu.current}}function mc(e,t){return{$$typeof:Xn,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function Bu(e){return typeof e=="object"&&e!==null&&e.$$typeof===Xn}function hc(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var Io=/\/+/g;function wl(e,t){return typeof e=="object"&&e!==null&&e.key!=null?hc(""+e.key):t.toString(36)}function gr(e,t,n,r,l){var u=typeof e;(u==="undefined"||u==="boolean")&&(e=null);var o=!1;if(e===null)o=!0;else switch(u){case"string":case"number":o=!0;break;case"object":switch(e.$$typeof){case Xn:case rc:o=!0}}if(o)return o=e,l=l(o),e=r===""?"."+wl(o,0):r,Do(l)?(n="",e!=null&&(n=e.replace(Io,"$&/")+"/"),gr(l,t,n,"",function(c){return c})):l!=null&&(Bu(l)&&(l=mc(l,n+(!l.key||o&&o.key===l.key?"":(""+l.key).replace(Io,"$&/")+"/")+e)),t.push(l)),1;if(o=0,r=r===""?".":r+":",Do(e))for(var i=0;i<e.length;i++){u=e[i];var s=r+wl(u,i);o+=gr(u,t,n,s,l)}else if(s=pc(e),typeof s=="function")for(e=s.call(e),i=0;!(u=e.next()).done;)u=u.value,s=r+wl(u,i++),o+=gr(u,t,n,s,l);else if(u==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return o}function tr(e,t,n){if(e==null)return e;var r=[],l=0;return gr(e,r,"","",function(u){return t.call(n,u,l++)}),r}function vc(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var se={current:null},wr={transition:null},yc={ReactCurrentDispatcher:se,ReactCurrentBatchConfig:wr,ReactCurrentOwner:Vu};function qi(){throw Error("act(...) is not supported in production builds of React.")}L.Children={map:tr,forEach:function(e,t,n){tr(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return tr(e,function(){t++}),t},toArray:function(e){return tr(e,function(t){return t})||[]},only:function(e){if(!Bu(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};L.Component=ln;L.Fragment=lc;L.Profiler=oc;L.PureComponent=Uu;L.StrictMode=uc;L.Suspense=cc;L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=yc;L.act=qi;L.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=Ki({},e.props),l=e.key,u=e.ref,o=e._owner;if(t!=null){if(t.ref!==void 0&&(u=t.ref,o=Vu.current),t.key!==void 0&&(l=""+t.key),e.type&&e.type.defaultProps)var i=e.type.defaultProps;for(s in t)Gi.call(t,s)&&!Zi.hasOwnProperty(s)&&(r[s]=t[s]===void 0&&i!==void 0?i[s]:t[s])}var s=arguments.length-2;if(s===1)r.children=n;else if(1<s){i=Array(s);for(var c=0;c<s;c++)i[c]=arguments[c+2];r.children=i}return{$$typeof:Xn,type:e.type,key:l,ref:u,props:r,_owner:o}};L.createContext=function(e){return e={$$typeof:sc,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:ic,_context:e},e.Consumer=e};L.createElement=Ji;L.createFactory=function(e){var t=Ji.bind(null,e);return t.type=e,t};L.createRef=function(){return{current:null}};L.forwardRef=function(e){return{$$typeof:ac,render:e}};L.isValidElement=Bu;L.lazy=function(e){return{$$typeof:dc,_payload:{_status:-1,_result:e},_init:vc}};L.memo=function(e,t){return{$$typeof:fc,type:e,compare:t===void 0?null:t}};L.startTransition=function(e){var t=wr.transition;wr.transition={};try{e()}finally{wr.transition=t}};L.unstable_act=qi;L.useCallback=function(e,t){return se.current.useCallback(e,t)};L.useContext=function(e){return se.current.useContext(e)};L.useDebugValue=function(){};L.useDeferredValue=function(e){return se.current.useDeferredValue(e)};L.useEffect=function(e,t){return se.current.useEffect(e,t)};L.useId=function(){return se.current.useId()};L.useImperativeHandle=function(e,t,n){return se.current.useImperativeHandle(e,t,n)};L.useInsertionEffect=function(e,t){return se.current.useInsertionEffect(e,t)};L.useLayoutEffect=function(e,t){return se.current.useLayoutEffect(e,t)};L.useMemo=function(e,t){return se.current.useMemo(e,t)};L.useReducer=function(e,t,n){return se.current.useReducer(e,t,n)};L.useRef=function(e){return se.current.useRef(e)};L.useState=function(e){return se.current.useState(e)};L.useSyncExternalStore=function(e,t,n){return se.current.useSyncExternalStore(e,t,n)};L.useTransition=function(){return se.current.useTransition()};L.version="18.3.1";Wi.exports=L;var Y=Wi.exports;const gc=nc(Y);/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react-jsx-runtime.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var wc=Y,Sc=Symbol.for("react.element"),kc=Symbol.for("react.fragment"),Ec=Object.prototype.hasOwnProperty,Cc=wc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,xc={key:!0,ref:!0,__self:!0,__source:!0};function bi(e,t,n){var r,l={},u=null,o=null;n!==void 0&&(u=""+n),t.key!==void 0&&(u=""+t.key),t.ref!==void 0&&(o=t.ref);for(r in t)Ec.call(t,r)&&!xc.hasOwnProperty(r)&&(l[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)l[r]===void 0&&(l[r]=t[r]);return{$$typeof:Sc,type:e,key:u,ref:o,props:l,_owner:Cc.current}}el.Fragment=kc;el.jsx=bi;el.jsxs=bi;Hi.exports=el;var O=Hi.exports,Ql={},es={exports:{}},we={},ts={exports:{}},ns={};/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * scheduler.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */(function(e){function t(_,z){var T=_.length;_.push(z);e:for(;0<T;){var W=T-1>>>1,Z=_[W];if(0<l(Z,z))_[W]=z,_[T]=Z,T=W;else break e}}function n(_){return _.length===0?null:_[0]}function r(_){if(_.length===0)return null;var z=_[0],T=_.pop();if(T!==z){_[0]=T;e:for(var W=0,Z=_.length,bn=Z>>>1;W<bn;){var vt=2*(W+1)-1,gl=_[vt],yt=vt+1,er=_[yt];if(0>l(gl,T))yt<Z&&0>l(er,gl)?(_[W]=er,_[yt]=T,W=yt):(_[W]=gl,_[vt]=T,W=vt);else if(yt<Z&&0>l(er,T))_[W]=er,_[yt]=T,W=yt;else break e}}return z}function l(_,z){var T=_.sortIndex-z.sortIndex;return T!==0?T:_.id-z.id}if(typeof performance=="object"&&typeof performance.now=="function"){var u=performance;e.unstable_now=function(){return u.now()}}else{var o=Date,i=o.now();e.unstable_now=function(){return o.now()-i}}var s=[],c=[],h=1,m=null,p=3,g=!1,w=!1,S=!1,D=typeof setTimeout=="function"?setTimeout:null,f=typeof clearTimeout=="function"?clearTimeout:null,a=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function d(_){for(var z=n(c);z!==null;){if(z.callback===null)r(c);else if(z.startTime<=_)r(c),z.sortIndex=z.expirationTime,t(s,z);else break;z=n(c)}}function v(_){if(S=!1,d(_),!w)if(n(s)!==null)w=!0,vl(E);else{var z=n(c);z!==null&&yl(v,z.startTime-_)}}function E(_,z){w=!1,S&&(S=!1,f(x),x=-1),g=!0;var T=p;try{for(d(z),m=n(s);m!==null&&(!(m.expirationTime>z)||_&&!Pe());){var W=m.callback;if(typeof W=="function"){m.callback=null,p=m.priorityLevel;var Z=W(m.expirationTime<=z);z=e.unstable_now(),typeof Z=="function"?m.callback=Z:m===n(s)&&r(s),d(z)}else r(s);m=n(s)}if(m!==null)var bn=!0;else{var vt=n(c);vt!==null&&yl(v,vt.startTime-z),bn=!1}return bn}finally{m=null,p=T,g=!1}}var N=!1,k=null,x=-1,R=5,P=-1;function Pe(){return!(e.unstable_now()-P<R)}function sn(){if(k!==null){var _=e.unstable_now();P=_;var z=!0;try{z=k(!0,_)}finally{z?an():(N=!1,k=null)}}else N=!1}var an;if(typeof a=="function")an=function(){a(sn)};else if(typeof MessageChannel<"u"){var Oo=new MessageChannel,tc=Oo.port2;Oo.port1.onmessage=sn,an=function(){tc.postMessage(null)}}else an=function(){D(sn,0)};function vl(_){k=_,N||(N=!0,an())}function yl(_,z){x=D(function(){_(e.unstable_now())},z)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(_){_.callback=null},e.unstable_continueExecution=function(){w||g||(w=!0,vl(E))},e.unstable_forceFrameRate=function(_){0>_||125<_?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<_?Math.floor(1e3/_):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(s)},e.unstable_next=function(_){switch(p){case 1:case 2:case 3:var z=3;break;default:z=p}var T=p;p=z;try{return _()}finally{p=T}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(_,z){switch(_){case 1:case 2:case 3:case 4:case 5:break;default:_=3}var T=p;p=_;try{return z()}finally{p=T}},e.unstable_scheduleCallback=function(_,z,T){var W=e.unstable_now();switch(typeof T=="object"&&T!==null?(T=T.delay,T=typeof T=="number"&&0<T?W+T:W):T=W,_){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=T+Z,_={id:h++,callback:z,priorityLevel:_,startTime:T,expirationTime:Z,sortIndex:-1},T>W?(_.sortIndex=T,t(c,_),n(s)===null&&_===n(c)&&(S?(f(x),x=-1):S=!0,yl(v,T-W))):(_.sortIndex=Z,t(s,_),w||g||(w=!0,vl(E))),_},e.unstable_shouldYield=Pe,e.unstable_wrapCallback=function(_){var z=p;return function(){var T=p;p=z;try{return _.apply(this,arguments)}finally{p=T}}}})(ns);ts.exports=ns;var _c=ts.exports;/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react-dom.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var Nc=Y,ge=_c;function y(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var rs=new Set,Rn={};function Lt(e,t){Jt(e,t),Jt(e+"Capture",t)}function Jt(e,t){for(Rn[e]=t,e=0;e<t.length;e++)rs.add(t[e])}var Qe=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Kl=Object.prototype.hasOwnProperty,Pc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Fo={},Uo={};function zc(e){return Kl.call(Uo,e)?!0:Kl.call(Fo,e)?!1:Pc.test(e)?Uo[e]=!0:(Fo[e]=!0,!1)}function Tc(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Lc(e,t,n,r){if(t===null||typeof t>"u"||Tc(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function ae(e,t,n,r,l,u,o){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=l,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=u,this.removeEmptyString=o}var te={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){te[e]=new ae(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];te[t]=new ae(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){te[e]=new ae(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){te[e]=new ae(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){te[e]=new ae(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){te[e]=new ae(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){te[e]=new ae(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){te[e]=new ae(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){te[e]=new ae(e,5,!1,e.toLowerCase(),null,!1,!1)});var $u=/[\-:]([a-z])/g;function Hu(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){te[e]=new ae(e,1,!1,e.toLowerCase(),null,!1,!1)});te.xlinkHref=new ae("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){te[e]=new ae(e,1,!1,e.toLowerCase(),null,!0,!0)});function Wu(e,t,n,r){var l=te.hasOwnProperty(t)?te[t]:null;(l!==null?l.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Lc(t,n,l,r)&&(n=null),r||l===null?zc(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):l.mustUseProperty?e[l.propertyName]=n===null?l.type===3?!1:"":n:(t=l.attributeName,r=l.attributeNamespace,n===null?e.removeAttribute(t):(l=l.type,n=l===3||l===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var Ge=Nc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,nr=Symbol.for("react.element"),Ot=Symbol.for("react.portal"),Mt=Symbol.for("react.fragment"),Qu=Symbol.for("react.strict_mode"),Yl=Symbol.for("react.profiler"),ls=Symbol.for("react.provider"),us=Symbol.for("react.context"),Ku=Symbol.for("react.forward_ref"),Xl=Symbol.for("react.suspense"),Gl=Symbol.for("react.suspense_list"),Yu=Symbol.for("react.memo"),Je=Symbol.for("react.lazy"),os=Symbol.for("react.offscreen"),Ao=Symbol.iterator;function cn(e){return e===null||typeof e!="object"?null:(e=Ao&&e[Ao]||e["@@iterator"],typeof e=="function"?e:null)}var $=Object.assign,Sl;function gn(e){if(Sl===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Sl=t&&t[1]||""}return`[m
[32m+[m[32m`+Sl+e}var kl=!1;function El(e,t){if(!e||kl)return"";kl=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(c){var r=c}Reflect.construct(e,[],t)}else{try{t.call()}catch(c){r=c}e.call(t.prototype)}else{try{throw Error()}catch(c){r=c}e()}}catch(c){if(c&&r&&typeof c.stack=="string"){for(var l=c.stack.split(`[m
[32m+[m[32m`),u=r.stack.split(`[m
[32m+[m[32m`),o=l.length-1,i=u.length-1;1<=o&&0<=i&&l[o]!==u[i];)i--;for(;1<=o&&0<=i;o--,i--)if(l[o]!==u[i]){if(o!==1||i!==1)do if(o--,i--,0>i||l[o]!==u[i]){var s=`[m
[32m+[m[32m`+l[o].replace(" at new "," at ");return e.displayName&&s.includes("<anonymous>")&&(s=s.replace("<anonymous>",e.displayName)),s}while(1<=o&&0<=i);break}}}finally{kl=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?gn(e):""}function Rc(e){switch(e.tag){case 5:return gn(e.type);case 16:return gn("Lazy");case 13:return gn("Suspense");case 19:return gn("SuspenseList");case 0:case 2:case 15:return e=El(e.type,!1),e;case 11:return e=El(e.type.render,!1),e;case 1:return e=El(e.type,!0),e;default:return""}}function Zl(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Mt:return"Fragment";case Ot:return"Portal";case Yl:return"Profiler";case Qu:return"StrictMode";case Xl:return"Suspense";case Gl:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case us:return(e.displayName||"Context")+".Consumer";case ls:return(e._context.displayName||"Context")+".Provider";case Ku:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Yu:return t=e.displayName||null,t!==null?t:Zl(e.type)||"Memo";case Je:t=e._payload,e=e._init;try{return Zl(e(t))}catch{}}return null}function jc(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Zl(t);case 8:return t===Qu?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function ft(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function is(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Oc(e){var t=is(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var l=n.get,u=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return l.call(this)},set:function(o){r=""+o,u.call(this,o)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(o){r=""+o},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function rr(e){e._valueTracker||(e._valueTracker=Oc(e))}function ss(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=is(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function Lr(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Jl(e,t){var n=t.checked;return $({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function Vo(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=ft(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function as(e,t){t=t.checked,t!=null&&Wu(e,"checked",t,!1)}function ql(e,t){as(e,t);var n=ft(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?bl(e,t.type,n):t.hasOwnProperty("defaultValue")&&bl(e,t.type,ft(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function Bo(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function bl(e,t,n){(t!=="number"||Lr(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var wn=Array.isArray;function Qt(e,t,n,r){if(e=e.options,t){t={};for(var l=0;l<n.length;l++)t["$"+n[l]]=!0;for(n=0;n<e.length;n++)l=t.hasOwnProperty("$"+e[n].value),e[n].selected!==l&&(e[n].selected=l),l&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ft(n),t=null,l=0;l<e.length;l++){if(e[l].value===n){e[l].selected=!0,r&&(e[l].defaultSelected=!0);return}t!==null||e[l].disabled||(t=e[l])}t!==null&&(t.selected=!0)}}function eu(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(y(91));return $({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function $o(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(y(92));if(wn(n)){if(1<n.length)throw Error(y(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:ft(n)}}function cs(e,t){var n=ft(t.value),r=ft(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function Ho(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function fs(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function tu(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?fs(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var lr,ds=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,l){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,l)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(lr=lr||document.createElement("div"),lr.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=lr.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function jn(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var En={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Mc=["Webkit","ms","Moz","O"];Object.keys(En).forEach(function(e){Mc.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),En[t]=En[e]})});function ps(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||En.hasOwnProperty(e)&&En[e]?(""+t).trim():t+"px"}function ms(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,l=ps(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,l):e[n]=l}}var Dc=$({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function nu(e,t){if(t){if(Dc[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(y(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(y(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(y(61))}if(t.style!=null&&typeof t.style!="object")throw Error(y(62))}}function ru(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var lu=null;function Xu(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var uu=null,Kt=null,Yt=null;function Wo(e){if(e=Jn(e)){if(typeof uu!="function")throw Error(y(280));var t=e.stateNode;t&&(t=ul(t),uu(e.stateNode,e.type,t))}}function hs(e){Kt?Yt?Yt.push(e):Yt=[e]:Kt=e}function vs(){if(Kt){var e=Kt,t=Yt;if(Yt=Kt=null,Wo(e),t)for(e=0;e<t.length;e++)Wo(t[e])}}function ys(e,t){return e(t)}function gs(){}var Cl=!1;function ws(e,t,n){if(Cl)return e(t,n);Cl=!0;try{return ys(e,t,n)}finally{Cl=!1,(Kt!==null||Yt!==null)&&(gs(),vs())}}function On(e,t){var n=e.stateNode;if(n===null)return null;var r=ul(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(y(231,t,typeof n));return n}var ou=!1;if(Qe)try{var fn={};Object.defineProperty(fn,"passive",{get:function(){ou=!0}}),window.addEventListener("test",fn,fn),window.removeEventListener("test",fn,fn)}catch{ou=!1}function Ic(e,t,n,r,l,u,o,i,s){var c=Array.prototype.slice.call(arguments,3);try{t.apply(n,c)}catch(h){this.onError(h)}}var Cn=!1,Rr=null,jr=!1,iu=null,Fc={onError:function(e){Cn=!0,Rr=e}};function Uc(e,t,n,r,l,u,o,i,s){Cn=!1,Rr=null,Ic.apply(Fc,arguments)}function Ac(e,t,n,r,l,u,o,i,s){if(Uc.apply(this,arguments),Cn){if(Cn){var c=Rr;Cn=!1,Rr=null}else throw Error(y(198));jr||(jr=!0,iu=c)}}function Rt(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function Ss(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function Qo(e){if(Rt(e)!==e)throw Error(y(188))}function Vc(e){var t=e.alternate;if(!t){if(t=Rt(e),t===null)throw Error(y(188));return t!==e?null:e}for(var n=e,r=t;;){var l=n.return;if(l===null)break;var u=l.alternate;if(u===null){if(r=l.return,r!==null){n=r;continue}break}if(l.child===u.child){for(u=l.child;u;){if(u===n)return Qo(l),e;if(u===r)return Qo(l),t;u=u.sibling}throw Error(y(188))}if(n.return!==r.return)n=l,r=u;else{for(var o=!1,i=l.child;i;){if(i===n){o=!0,n=l,r=u;break}if(i===r){o=!0,r=l,n=u;break}i=i.sibling}if(!o){for(i=u.child;i;){if(i===n){o=!0,n=u,r=l;break}if(i===r){o=!0,r=u,n=l;break}i=i.sibling}if(!o)throw Error(y(189))}}if(n.alternate!==r)throw Error(y(190))}if(n.tag!==3)throw Error(y(188));return n.stateNode.current===n?e:t}function ks(e){return e=Vc(e),e!==null?Es(e):null}function Es(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=Es(e);if(t!==null)return t;e=e.sibling}return null}var Cs=ge.unstable_scheduleCallback,Ko=ge.unstable_cancelCallback,Bc=ge.unstable_shouldYield,$c=ge.unstable_requestPaint,Q=ge.unstable_now,Hc=ge.unstable_getCurrentPriorityLevel,Gu=ge.unstable_ImmediatePriority,xs=ge.unstable_UserBlockingPriority,Or=ge.unstable_NormalPriority,Wc=ge.unstable_LowPriority,_s=ge.unstable_IdlePriority,tl=null,Ue=null;function Qc(e){if(Ue&&typeof Ue.onCommitFiberRoot=="function")try{Ue.onCommitFiberRoot(tl,e,void 0,(e.current.flags&128)===128)}catch{}}var je=Math.clz32?Math.clz32:Xc,Kc=Math.log,Yc=Math.LN2;function Xc(e){return e>>>=0,e===0?32:31-(Kc(e)/Yc|0)|0}var ur=64,or=4194304;function Sn(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Mr(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,l=e.suspendedLanes,u=e.pingedLanes,o=n&268435455;if(o!==0){var i=o&~l;i!==0?r=Sn(i):(u&=o,u!==0&&(r=Sn(u)))}else o=n&~l,o!==0?r=Sn(o):u!==0&&(r=Sn(u));if(r===0)return 0;if(t!==0&&t!==r&&!(t&l)&&(l=r&-r,u=t&-t,l>=u||l===16&&(u&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-je(t),l=1<<n,r|=e[n],t&=~l;return r}function Gc(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Zc(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,l=e.expirationTimes,u=e.pendingLanes;0<u;){var o=31-je(u),i=1<<o,s=l[o];s===-1?(!(i&n)||i&r)&&(l[o]=Gc(i,t)):s<=t&&(e.expiredLanes|=i),u&=~i}}function su(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Ns(){var e=ur;return ur<<=1,!(ur&4194240)&&(ur=64),e}function xl(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Gn(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-je(t),e[t]=n}function Jc(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var l=31-je(n),u=1<<l;t[l]=0,r[l]=-1,e[l]=-1,n&=~u}}function Zu(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-je(n),l=1<<r;l&t|e[r]&t&&(e[r]|=t),n&=~l}}var M=0;function Ps(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var zs,Ju,Ts,Ls,Rs,au=!1,ir=[],rt=null,lt=null,ut=null,Mn=new Map,Dn=new Map,be=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Yo(e,t){switch(e){case"focusin":case"focusout":rt=null;break;case"dragenter":case"dragleave":lt=null;break;case"mouseover":case"mouseout":ut=null;break;case"pointerover":case"pointerout":Mn.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Dn.delete(t.pointerId)}}function dn(e,t,n,r,l,u){return e===null||e.nativeEvent!==u?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:u,targetContainers:[l]},t!==null&&(t=Jn(t),t!==null&&Ju(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,l!==null&&t.indexOf(l)===-1&&t.push(l),e)}function bc(e,t,n,r,l){switch(t){case"focusin":return rt=dn(rt,e,t,n,r,l),!0;case"dragenter":return lt=dn(lt,e,t,n,r,l),!0;case"mouseover":return ut=dn(ut,e,t,n,r,l),!0;case"pointerover":var u=l.pointerId;return Mn.set(u,dn(Mn.get(u)||null,e,t,n,r,l)),!0;case"gotpointercapture":return u=l.pointerId,Dn.set(u,dn(Dn.get(u)||null,e,t,n,r,l)),!0}return!1}function js(e){var t=St(e.target);if(t!==null){var n=Rt(t);if(n!==null){if(t=n.tag,t===13){if(t=Ss(n),t!==null){e.blockedOn=t,Rs(e.priority,function(){Ts(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Sr(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=cu(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);lu=r,n.target.dispatchEvent(r),lu=null}else return t=Jn(n),t!==null&&Ju(t),e.blockedOn=n,!1;t.shift()}return!0}function Xo(e,t,n){Sr(e)&&n.delete(t)}function ef(){au=!1,rt!==null&&Sr(rt)&&(rt=null),lt!==null&&Sr(lt)&&(lt=null),ut!==null&&Sr(ut)&&(ut=null),Mn.forEach(Xo),Dn.forEach(Xo)}function pn(e,t){e.blockedOn===t&&(e.blockedOn=null,au||(au=!0,ge.unstable_scheduleCallback(ge.unstable_NormalPriority,ef)))}function In(e){function t(l){return pn(l,e)}if(0<ir.length){pn(ir[0],e);for(var n=1;n<ir.length;n++){var r=ir[n];r.blockedOn===e&&(r.blockedOn=null)}}for(rt!==null&&pn(rt,e),lt!==null&&pn(lt,e),ut!==null&&pn(ut,e),Mn.forEach(t),Dn.forEach(t),n=0;n<be.length;n++)r=be[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<be.length&&(n=be[0],n.blockedOn===null);)js(n),n.blockedOn===null&&be.shift()}var Xt=Ge.ReactCurrentBatchConfig,Dr=!0;function tf(e,t,n,r){var l=M,u=Xt.transition;Xt.transition=null;try{M=1,qu(e,t,n,r)}finally{M=l,Xt.transition=u}}function nf(e,t,n,r){var l=M,u=Xt.transition;Xt.transition=null;try{M=4,qu(e,t,n,r)}finally{M=l,Xt.transition=u}}function qu(e,t,n,r){if(Dr){var l=cu(e,t,n,r);if(l===null)Ml(e,t,r,Ir,n),Yo(e,r);else if(bc(l,e,t,n,r))r.stopPropagation();else if(Yo(e,r),t&4&&-1<qc.indexOf(e)){for(;l!==null;){var u=Jn(l);if(u!==null&&zs(u),u=cu(e,t,n,r),u===null&&Ml(e,t,r,Ir,n),u===l)break;l=u}l!==null&&r.stopPropagation()}else Ml(e,t,r,null,n)}}var Ir=null;function cu(e,t,n,r){if(Ir=null,e=Xu(r),e=St(e),e!==null)if(t=Rt(e),t===null)e=null;else if(n=t.tag,n===13){if(e=Ss(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Ir=e,null}function Os(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Hc()){case Gu:return 1;case xs:return 4;case Or:case Wc:return 16;case _s:return 536870912;default:return 16}default:return 16}}var tt=null,bu=null,kr=null;function Ms(){if(kr)return kr;var e,t=bu,n=t.length,r,l="value"in tt?tt.value:tt.textContent,u=l.length;for(e=0;e<n&&t[e]===l[e];e++);var o=n-e;for(r=1;r<=o&&t[n-r]===l[u-r];r++);return kr=l.slice(e,1<r?1-r:void 0)}function Er(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function sr(){return!0}function Go(){return!1}function Se(e){function t(n,r,l,u,o){this._reactName=n,this._targetInst=l,this.type=r,this.nativeEvent=u,this.target=o,this.currentTarget=null;for(var i in e)e.hasOwnProperty(i)&&(n=e[i],this[i]=n?n(u):u[i]);return this.isDefaultPrevented=(u.defaultPrevented!=null?u.defaultPrevented:u.returnValue===!1)?sr:Go,this.isPropagationStopped=Go,this}return $(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=sr)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=sr)},persist:function(){},isPersistent:sr}),t}var un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},eo=Se(un),Zn=$({},un,{view:0,detail:0}),rf=Se(Zn),_l,Nl,mn,nl=$({},Zn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:to,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==mn&&(mn&&e.type==="mousemove"?(_l=e.screenX-mn.screenX,Nl=e.screenY-mn.screenY):Nl=_l=0,mn=e),_l)},movementY:function(e){return"movementY"in e?e.movementY:Nl}}),Zo=Se(nl),lf=$({},nl,{dataTransfer:0}),uf=Se(lf),of=$({},Zn,{relatedTarget:0}),Pl=Se(of),sf=$({},un,{animationName:0,elapsedTime:0,pseudoElement:0}),af=Se(sf),cf=$({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),ff=Se(cf),df=$({},un,{data:0}),Jo=Se(df),pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},mf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},hf={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function vf(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=hf[e])?!!t[e]:!1}function to(){return vf}var yf=$({},Zn,{key:function(e){if(e.key){var t=pf[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Er(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?mf[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:to,charCode:function(e){return e.type==="keypress"?Er(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Er(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),gf=Se(yf),wf=$({},nl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),qo=Se(wf),Sf=$({},Zn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:to}),kf=Se(Sf),Ef=$({},un,{propertyName:0,elapsedTime:0,pseudoElement:0}),Cf=Se(Ef),xf=$({},nl,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),_f=Se(xf),Nf=[9,13,27,32],no=Qe&&"CompositionEvent"in window,xn=null;Qe&&"documentMode"in document&&(xn=document.documentMode);var Pf=Qe&&"TextEvent"in window&&!xn,Ds=Qe&&(!no||xn&&8<xn&&11>=xn),bo=" ",ei=!1;function Is(e,t){switch(e){case"keyup":return Nf.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Fs(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Dt=!1;function zf(e,t){switch(e){case"compositionend":return Fs(t);case"keypress":return t.which!==32?null:(ei=!0,bo);case"textInput":return e=t.data,e===bo&&ei?null:e;default:return null}}function Tf(e,t){if(Dt)return e==="compositionend"||!no&&Is(e,t)?(e=Ms(),kr=bu=tt=null,Dt=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ds&&t.locale!=="ko"?null:t.data;default:return null}}var Lf={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function ti(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!Lf[e.type]:t==="textarea"}function Us(e,t,n,r){hs(r),t=Fr(t,"onChange"),0<t.length&&(n=new eo("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var _n=null,Fn=null;function Rf(e){Gs(e,0)}function rl(e){var t=Ut(e);if(ss(t))return e}function jf(e,t){if(e==="change")return t}var As=!1;if(Qe){var zl;if(Qe){var Tl="oninput"in document;if(!Tl){var ni=document.createElement("div");ni.setAttribute("oninput","return;"),Tl=typeof ni.oninput=="function"}zl=Tl}else zl=!1;As=zl&&(!document.documentMode||9<document.documentMode)}function ri(){_n&&(_n.detachEvent("onpropertychange",Vs),Fn=_n=null)}function Vs(e){if(e.propertyName==="value"&&rl(Fn)){var t=[];Us(t,Fn,e,Xu(e)),ws(Rf,t)}}function Of(e,t,n){e==="focusin"?(ri(),_n=t,Fn=n,_n.attachEvent("onpropertychange",Vs)):e==="focusout"&&ri()}function Mf(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return rl(Fn)}function Df(e,t){if(e==="click")return rl(t)}function If(e,t){if(e==="input"||e==="change")return rl(t)}function Ff(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Me=typeof Object.is=="function"?Object.is:Ff;function Un(e,t){if(Me(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var l=n[r];if(!Kl.call(t,l)||!Me(e[l],t[l]))return!1}return!0}function li(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ui(e,t){var n=li(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=li(n)}}function Bs(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?Bs(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function $s(){for(var e=window,t=Lr();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=Lr(e.document)}return t}function ro(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function Uf(e){var t=$s(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&Bs(n.ownerDocument.documentElement,n)){if(r!==null&&ro(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var l=n.textContent.length,u=Math.min(r.start,l);r=r.end===void 0?u:Math.min(r.end,l),!e.extend&&u>r&&(l=r,r=u,u=l),l=ui(n,u);var o=ui(n,r);l&&o&&(e.rangeCount!==1||e.anchorNode!==l.node||e.anchorOffset!==l.offset||e.focusNode!==o.node||e.focusOffset!==o.offset)&&(t=t.createRange(),t.setStart(l.node,l.offset),e.removeAllRanges(),u>r?(e.addRange(t),e.extend(o.node,o.offset)):(t.setEnd(o.node,o.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Af=Qe&&"documentMode"in document&&11>=document.documentMode,It=null,fu=null,Nn=null,du=!1;function oi(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;du||It==null||It!==Lr(r)||(r=It,"selectionStart"in r&&ro(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Nn&&Un(Nn,r)||(Nn=r,r=Fr(fu,"onSelect"),0<r.length&&(t=new eo("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=It)))}function ar(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Ft={animationend:ar("Animation","AnimationEnd"),animationiteration:ar("Animation","AnimationIteration"),animationstart:ar("Animation","AnimationStart"),transitionend:ar("Transition","TransitionEnd")},Ll={},Hs={};Qe&&(Hs=document.createElement("div").style,"AnimationEvent"in window||(delete Ft.animationend.animation,delete Ft.animationiteration.animation,delete Ft.animationstart.animation),"TransitionEvent"in window||delete Ft.transitionend.transition);function ll(e){if(Ll[e])return Ll[e];if(!Ft[e])return e;var t=Ft[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in Hs)return Ll[e]=t[n];return e}var Ws=ll("animationend"),Qs=ll("animationiteration"),Ks=ll("animationstart"),Ys=ll("transitionend"),Xs=new Map,ii="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function pt(e,t){Xs.set(e,t),Lt(t,[e])}for(var Rl=0;Rl<ii.length;Rl++){var jl=ii[Rl],Vf=jl.toLowerCase(),Bf=jl[0].toUpperCase()+jl.slice(1);pt(Vf,"on"+Bf)}pt(Ws,"onAnimationEnd");pt(Qs,"onAnimationIteration");pt(Ks,"onAnimationStart");pt("dblclick","onDoubleClick");pt("focusin","onFocus");pt("focusout","onBlur");pt(Ys,"onTransitionEnd");Jt("onMouseEnter",["mouseout","mouseover"]);Jt("onMouseLeave",["mouseout","mouseover"]);Jt("onPointerEnter",["pointerout","pointerover"]);Jt("onPointerLeave",["pointerout","pointerover"]);Lt("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Lt("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Lt("onBeforeInput",["compositionend","keypress","textInput","paste"]);Lt("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var kn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),$f=new Set("cancel close invalid load scroll toggle".split(" ").concat(kn));function si(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,Ac(r,t,void 0,e),e.currentTarget=null}function Gs(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],l=r.event;r=r.listeners;e:{var u=void 0;if(t)for(var o=r.length-1;0<=o;o--){var i=r[o],s=i.instance,c=i.currentTarget;if(i=i.listener,s!==u&&l.isPropagationStopped())break e;si(l,i,c),u=s}else for(o=0;o<r.length;o++){if(i=r[o],s=i.instance,c=i.currentTarget,i=i.listener,s!==u&&l.isPropagationStopped())break e;si(l,i,c),u=s}}}if(jr)throw e=iu,jr=!1,iu=null,e}function F(e,t){var n=t[yu];n===void 0&&(n=t[yu]=new Set);var r=e+"__bubble";n.has(r)||(Zs(t,e,2,!1),n.add(r))}function Ol(e,t,n){var r=0;t&&(r|=4),Zs(n,e,r,t)}var cr="_reactListening"+Math.random().toString(36).slice(2);function An(e){if(!e[cr]){e[cr]=!0,rs.forEach(function(n){n!=="selectionchange"&&($f.has(n)||Ol(n,!1,e),Ol(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[cr]||(t[cr]=!0,Ol("selectionchange",!1,t))}}function Zs(e,t,n,r){switch(Os(t)){case 1:var l=tf;break;case 4:l=nf;break;default:l=qu}n=l.bind(null,t,n,e),l=void 0,!ou||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(l=!0),r?l!==void 0?e.addEventListener(t,n,{capture:!0,passive:l}):e.addEventListener(t,n,!0):l!==void 0?e.addEventListener(t,n,{passive:l}):e.addEventListener(t,n,!1)}function Ml(e,t,n,r,l){var u=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var o=r.tag;if(o===3||o===4){var i=r.stateNode.containerInfo;if(i===l||i.nodeType===8&&i.parentNode===l)break;if(o===4)for(o=r.return;o!==null;){var s=o.tag;if((s===3||s===4)&&(s=o.stateNode.containerInfo,s===l||s.nodeType===8&&s.parentNode===l))return;o=o.return}for(;i!==null;){if(o=St(i),o===null)return;if(s=o.tag,s===5||s===6){r=u=o;continue e}i=i.parentNode}}r=r.return}ws(function(){var c=u,h=Xu(n),m=[];e:{var p=Xs.get(e);if(p!==void 0){var g=eo,w=e;switch(e){case"keypress":if(Er(n)===0)break e;case"keydown":case"keyup":g=gf;break;case"focusin":w="focus",g=Pl;break;case"focusout":w="blur",g=Pl;break;case"beforeblur":case"afterblur":g=Pl;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":g=Zo;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":g=uf;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":g=kf;break;case Ws:case Qs:case Ks:g=af;break;case Ys:g=Cf;break;case"scroll":g=rf;break;case"wheel":g=_f;break;case"copy":case"cut":case"paste":g=ff;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":g=qo}var S=(t&4)!==0,D=!S&&e==="scroll",f=S?p!==null?p+"Capture":null:p;S=[];for(var a=c,d;a!==null;){d=a;var v=d.stateNode;if(d.tag===5&&v!==null&&(d=v,f!==null&&(v=On(a,f),v!=null&&S.push(Vn(a,v,d)))),D)break;a=a.return}0<S.length&&(p=new g(p,w,null,n,h),m.push({event:p,listeners:S}))}}if(!(t&7)){e:{if(p=e==="mouseover"||e==="pointerover",g=e==="mouseout"||e==="pointerout",p&&n!==lu&&(w=n.relatedTarget||n.fromElement)&&(St(w)||w[Ke]))break e;if((g||p)&&(p=h.window===h?h:(p=h.ownerDocument)?p.defaultView||p.parentWindow:window,g?(w=n.relatedTarget||n.toElement,g=c,w=w?St(w):null,w!==null&&(D=Rt(w),w!==D||w.tag!==5&&w.tag!==6)&&(w=null)):(g=null,w=c),g!==w)){if(S=Zo,v="onMouseLeave",f="onMouseEnter",a="mouse",(e==="pointerout"||e==="pointerover")&&(S=qo,v="onPointerLeave",f="onPointerEnter",a="pointer"),D=g==null?p:Ut(g),d=w==null?p:Ut(w),p=new S(v,a+"leave",g,n,h),p.target=D,p.relatedTarget=d,v=null,St(h)===c&&(S=new S(f,a+"enter",w,n,h),S.target=d,S.relatedTarget=D,v=S),D=v,g&&w)t:{for(S=g,f=w,a=0,d=S;d;d=jt(d))a++;for(d=0,v=f;v;v=jt(v))d++;for(;0<a-d;)S=jt(S),a--;for(;0<d-a;)f=jt(f),d--;for(;a--;){if(S===f||f!==null&&S===f.alternate)break t;S=jt(S),f=jt(f)}S=null}else S=null;g!==null&&ai(m,p,g,S,!1),w!==null&&D!==null&&ai(m,D,w,S,!0)}}e:{if(p=c?Ut(c):window,g=p.nodeName&&p.nodeName.toLowerCase(),g==="select"||g==="input"&&p.type==="file")var E=jf;else if(ti(p))if(As)E=If;else{E=Mf;var N=Of}else(g=p.nodeName)&&g.toLowerCase()==="input"&&(p.type==="checkbox"||p.type==="radio")&&(E=Df);if(E&&(E=E(e,c))){Us(m,E,n,h);break e}N&&N(e,p,c),e==="focusout"&&(N=p._wrapperState)&&N.controlled&&p.type==="number"&&bl(p,"number",p.value)}switch(N=c?Ut(c):window,e){case"focusin":(ti(N)||N.contentEditable==="true")&&(It=N,fu=c,Nn=null);break;case"focusout":Nn=fu=It=null;break;case"mousedown":du=!0;break;case"contextmenu":case"mouseup":case"dragend":du=!1,oi(m,n,h);break;case"selectionchange":if(Af)break;case"keydown":case"keyup":oi(m,n,h)}var k;if(no)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Dt?Is(e,n)&&(x="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(x="onCompositionStart");x&&(Ds&&n.locale!=="ko"&&(Dt||x!=="onCompositionStart"?x==="onCompositionEnd"&&Dt&&(k=Ms()):(tt=h,bu="value"in tt?tt.value:tt.textContent,Dt=!0)),N=Fr(c,x),0<N.length&&(x=new Jo(x,e,null,n,h),m.push({event:x,listeners:N}),k?x.data=k:(k=Fs(n),k!==null&&(x.data=k)))),(k=Pf?zf(e,n):Tf(e,n))&&(c=Fr(c,"onBeforeInput"),0<c.length&&(h=new Jo("onBeforeInput","beforeinput",null,n,h),m.push({event:h,listeners:c}),h.data=k))}Gs(m,t)})}function Vn(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Fr(e,t){for(var n=t+"Capture",r=[];e!==null;){var l=e,u=l.stateNode;l.tag===5&&u!==null&&(l=u,u=On(e,n),u!=null&&r.unshift(Vn(e,u,l)),u=On(e,t),u!=null&&r.push(Vn(e,u,l))),e=e.return}return r}function jt(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function ai(e,t,n,r,l){for(var u=t._reactName,o=[];n!==null&&n!==r;){var i=n,s=i.alternate,c=i.stateNode;if(s!==null&&s===r)break;i.tag===5&&c!==null&&(i=c,l?(s=On(n,u),s!=null&&o.unshift(Vn(n,s,i))):l||(s=On(n,u),s!=null&&o.push(Vn(n,s,i)))),n=n.return}o.length!==0&&e.push({event:t,listeners:o})}var Hf=/\r\n?/g,Wf=/\u0000|\uFFFD/g;function ci(e){return(typeof e=="string"?e:""+e).replace(Hf,`[m
[32m+[m[32m`).replace(Wf,"")}function fr(e,t,n){if(t=ci(t),ci(e)!==t&&n)throw Error(y(425))}function Ur(){}var pu=null,mu=null;function hu(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var vu=typeof setTimeout=="function"?setTimeout:void 0,Qf=typeof clearTimeout=="function"?clearTimeout:void 0,fi=typeof Promise=="function"?Promise:void 0,Kf=typeof queueMicrotask=="function"?queueMicrotask:typeof fi<"u"?function(e){return fi.resolve(null).then(e).catch(Yf)}:vu;function Yf(e){setTimeout(function(){throw e})}function Dl(e,t){var n=t,r=0;do{var l=n.nextSibling;if(e.removeChild(n),l&&l.nodeType===8)if(n=l.data,n==="/$"){if(r===0){e.removeChild(l),In(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=l}while(n);In(t)}function ot(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function di(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var on=Math.random().toString(36).slice(2),Fe="__reactFiber$"+on,Bn="__reactProps$"+on,Ke="__reactContainer$"+on,yu="__reactEvents$"+on,Xf="__reactListeners$"+on,Gf="__reactHandles$"+on;function St(e){var t=e[Fe];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Ke]||n[Fe]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=di(e);e!==null;){if(n=e[Fe])return n;e=di(e)}return t}e=n,n=e.parentNode}return null}function Jn(e){return e=e[Fe]||e[Ke],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Ut(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(y(33))}function ul(e){return e[Bn]||null}var gu=[],At=-1;function mt(e){return{current:e}}function U(e){0>At||(e.current=gu[At],gu[At]=null,At--)}function I(e,t){At++,gu[At]=e.current,e.current=t}var dt={},ue=mt(dt),de=mt(!1),_t=dt;function qt(e,t){var n=e.type.contextTypes;if(!n)return dt;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var l={},u;for(u in n)l[u]=t[u];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=l),l}function pe(e){return e=e.childContextTypes,e!=null}function Ar(){U(de),U(ue)}function pi(e,t,n){if(ue.current!==dt)throw Error(y(168));I(ue,t),I(de,n)}function Js(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var l in r)if(!(l in t))throw Error(y(108,jc(e)||"Unknown",l));return $({},n,r)}function Vr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||dt,_t=ue.current,I(ue,e),I(de,de.current),!0}function mi(e,t,n){var r=e.stateNode;if(!r)throw Error(y(169));n?(e=Js(e,t,_t),r.__reactInternalMemoizedMergedChildContext=e,U(de),U(ue),I(ue,e)):U(de),I(de,n)}var Be=null,ol=!1,Il=!1;function qs(e){Be===null?Be=[e]:Be.push(e)}function Zf(e){ol=!0,qs(e)}function ht(){if(!Il&&Be!==null){Il=!0;var e=0,t=M;try{var n=Be;for(M=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}Be=null,ol=!1}catch(l){throw Be!==null&&(Be=Be.slice(e+1)),Cs(Gu,ht),l}finally{M=t,Il=!1}}return null}var Vt=[],Bt=0,Br=null,$r=0,ke=[],Ee=0,Nt=null,$e=1,He="";function gt(e,t){Vt[Bt++]=$r,Vt[Bt++]=Br,Br=e,$r=t}function bs(e,t,n){ke[Ee++]=$e,ke[Ee++]=He,ke[Ee++]=Nt,Nt=e;var r=$e;e=He;var l=32-je(r)-1;r&=~(1<<l),n+=1;var u=32-je(t)+l;if(30<u){var o=l-l%5;u=(r&(1<<o)-1).toString(32),r>>=o,l-=o,$e=1<<32-je(t)+l|n<<l|r,He=u+e}else $e=1<<u|n<<l|r,He=e}function lo(e){e.return!==null&&(gt(e,1),bs(e,1,0))}function uo(e){for(;e===Br;)Br=Vt[--Bt],Vt[Bt]=null,$r=Vt[--Bt],Vt[Bt]=null;for(;e===Nt;)Nt=ke[--Ee],ke[Ee]=null,He=ke[--Ee],ke[Ee]=null,$e=ke[--Ee],ke[Ee]=null}var ye=null,ve=null,A=!1,Re=null;function ea(e,t){var n=Ce(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function hi(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,ye=e,ve=ot(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,ye=e,ve=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Nt!==null?{id:$e,overflow:He}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Ce(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,ye=e,ve=null,!0):!1;default:return!1}}function wu(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Su(e){if(A){var t=ve;if(t){var n=t;if(!hi(e,t)){if(wu(e))throw Error(y(418));t=ot(n.nextSibling);var r=ye;t&&hi(e,t)?ea(r,n):(e.flags=e.flags&-4097|2,A=!1,ye=e)}}else{if(wu(e))throw Error(y(418));e.flags=e.flags&-4097|2,A=!1,ye=e}}}function vi(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;ye=e}function dr(e){if(e!==ye)return!1;if(!A)return vi(e),A=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!hu(e.type,e.memoizedProps)),t&&(t=ve)){if(wu(e))throw ta(),Error(y(418));for(;t;)ea(e,t),t=ot(t.nextSibling)}if(vi(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(y(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){ve=ot(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}ve=null}}else ve=ye?ot(e.stateNode.nextSibling):null;return!0}function ta(){for(var e=ve;e;)e=ot(e.nextSibling)}function bt(){ve=ye=null,A=!1}function oo(e){Re===null?Re=[e]:Re.push(e)}var Jf=Ge.ReactCurrentBatchConfig;function hn(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(y(309));var r=n.stateNode}if(!r)throw Error(y(147,e));var l=r,u=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===u?t.ref:(t=function(o){var i=l.refs;o===null?delete i[u]:i[u]=o},t._stringRef=u,t)}if(typeof e!="string")throw Error(y(284));if(!n._owner)throw Error(y(290,e))}return e}function pr(e,t){throw e=Object.prototype.toString.call(t),Error(y(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function yi(e){var t=e._init;return t(e._payload)}function na(e){function t(f,a){if(e){var d=f.deletions;d===null?(f.deletions=[a],f.flags|=16):d.push(a)}}function n(f,a){if(!e)return null;for(;a!==null;)t(f,a),a=a.sibling;return null}function r(f,a){for(f=new Map;a!==null;)a.key!==null?f.set(a.key,a):f.set(a.index,a),a=a.sibling;return f}function l(f,a){return f=ct(f,a),f.index=0,f.sibling=null,f}function u(f,a,d){return f.index=d,e?(d=f.alternate,d!==null?(d=d.index,d<a?(f.flags|=2,a):d):(f.flags|=2,a)):(f.flags|=1048576,a)}function o(f){return e&&f.alternate===null&&(f.flags|=2),f}function i(f,a,d,v){return a===null||a.tag!==6?(a=Hl(d,f.mode,v),a.return=f,a):(a=l(a,d),a.return=f,a)}function s(f,a,d,v){var E=d.type;return E===Mt?h(f,a,d.props.children,v,d.key):a!==null&&(a.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===Je&&yi(E)===a.type)?(v=l(a,d.props),v.ref=hn(f,a,d),v.return=f,v):(v=Tr(d.type,d.key,d.props,null,f.mode,v),v.ref=hn(f,a,d),v.return=f,v)}function c(f,a,d,v){return a===null||a.tag!==4||a.stateNode.containerInfo!==d.containerInfo||a.stateNode.implementation!==d.implementation?(a=Wl(d,f.mode,v),a.return=f,a):(a=l(a,d.children||[]),a.return=f,a)}function h(f,a,d,v,E){return a===null||a.tag!==7?(a=xt(d,f.mode,v,E),a.return=f,a):(a=l(a,d),a.return=f,a)}function m(f,a,d){if(typeof a=="string"&&a!==""||typeof a=="number")return a=Hl(""+a,f.mode,d),a.return=f,a;if(typeof a=="object"&&a!==null){switch(a.$$typeof){case nr:return d=Tr(a.type,a.key,a.props,null,f.mode,d),d.ref=hn(f,null,a),d.return=f,d;case Ot:return a=Wl(a,f.mode,d),a.return=f,a;case Je:var v=a._init;return m(f,v(a._payload),d)}if(wn(a)||cn(a))return a=xt(a,f.mode,d,null),a.return=f,a;pr(f,a)}return null}function p(f,a,d,v){var E=a!==null?a.key:null;if(typeof d=="string"&&d!==""||typeof d=="number")return E!==null?null:i(f,a,""+d,v);if(typeof d=="object"&&d!==null){switch(d.$$typeof){case nr:return d.key===E?s(f,a,d,v):null;case Ot:return d.key===E?c(f,a,d,v):null;case Je:return E=d._init,p(f,a,E(d._payload),v)}if(wn(d)||cn(d))return E!==null?null:h(f,a,d,v,null);pr(f,d)}return null}function g(f,a,d,v,E){if(typeof v=="string"&&v!==""||typeof v=="number")return f=f.get(d)||null,i(a,f,""+v,E);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case nr:return f=f.get(v.key===null?d:v.key)||null,s(a,f,v,E);case Ot:return f=f.get(v.key===null?d:v.key)||null,c(a,f,v,E);case Je:var N=v._init;return g(f,a,d,N(v._payload),E)}if(wn(v)||cn(v))return f=f.get(d)||null,h(a,f,v,E,null);pr(a,v)}return null}function w(f,a,d,v){for(var E=null,N=null,k=a,x=a=0,R=null;k!==null&&x<d.length;x++){k.index>x?(R=k,k=null):R=k.sibling;var P=p(f,k,d[x],v);if(P===null){k===null&&(k=R);break}e&&k&&P.alternate===null&&t(f,k),a=u(P,a,x),N===null?E=P:N.sibling=P,N=P,k=R}if(x===d.length)return n(f,k),A&&gt(f,x),E;if(k===null){for(;x<d.length;x++)k=m(f,d[x],v),k!==null&&(a=u(k,a,x),N===null?E=k:N.sibling=k,N=k);return A&&gt(f,x),E}for(k=r(f,k);x<d.length;x++)R=g(k,f,x,d[x],v),R!==null&&(e&&R.alternate!==null&&k.delete(R.key===null?x:R.key),a=u(R,a,x),N===null?E=R:N.sibling=R,N=R);return e&&k.forEach(function(Pe){return t(f,Pe)}),A&&gt(f,x),E}function S(f,a,d,v){var E=cn(d);if(typeof E!="function")throw Error(y(150));if(d=E.call(d),d==null)throw Error(y(151));for(var N=E=null,k=a,x=a=0,R=null,P=d.next();k!==null&&!P.done;x++,P=d.next()){k.index>x?(R=k,k=null):R=k.sibling;var Pe=p(f,k,P.value,v);if(Pe===null){k===null&&(k=R);break}e&&k&&Pe.alternate===null&&t(f,k),a=u(Pe,a,x),N===null?E=Pe:N.sibling=Pe,N=Pe,k=R}if(P.done)return n(f,k),A&&gt(f,x),E;if(k===null){for(;!P.done;x++,P=d.next())P=m(f,P.value,v),P!==null&&(a=u(P,a,x),N===null?E=P:N.sibling=P,N=P);return A&&gt(f,x),E}for(k=r(f,k);!P.done;x++,P=d.next())P=g(k,f,x,P.value,v),P!==null&&(e&&P.alternate!==null&&k.delete(P.key===null?x:P.key),a=u(P,a,x),N===null?E=P:N.sibling=P,N=P);return e&&k.forEach(function(sn){return t(f,sn)}),A&&gt(f,x),E}function D(f,a,d,v){if(typeof d=="object"&&d!==null&&d.type===Mt&&d.key===null&&(d=d.props.children),typeof d=="object"&&d!==null){switch(d.$$typeof){case nr:e:{for(var E=d.key,N=a;N!==null;){if(N.key===E){if(E=d.type,E===Mt){if(N.tag===7){n(f,N.sibling),a=l(N,d.props.children),a.return=f,f=a;break e}}else if(N.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===Je&&yi(E)===N.type){n(f,N.sibling),a=l(N,d.props),a.ref=hn(f,N,d),a.return=f,f=a;break e}n(f,N);break}else t(f,N);N=N.sibling}d.type===Mt?(a=xt(d.props.children,f.mode,v,d.key),a.return=f,f=a):(v=Tr(d.type,d.key,d.props,null,f.mode,v),v.ref=hn(f,a,d),v.return=f,f=v)}return o(f);case Ot:e:{for(N=d.key;a!==null;){if(a.key===N)if(a.tag===4&&a.stateNode.containerInfo===d.containerInfo&&a.stateNode.implementation===d.implementation){n(f,a.sibling),a=l(a,d.children||[]),a.return=f,f=a;break e}else{n(f,a);break}else t(f,a);a=a.sibling}a=Wl(d,f.mode,v),a.return=f,f=a}return o(f);case Je:return N=d._init,D(f,a,N(d._payload),v)}if(wn(d))return w(f,a,d,v);if(cn(d))return S(f,a,d,v);pr(f,d)}return typeof d=="string"&&d!==""||typeof d=="number"?(d=""+d,a!==null&&a.tag===6?(n(f,a.sibling),a=l(a,d),a.return=f,f=a):(n(f,a),a=Hl(d,f.mode,v),a.return=f,f=a),o(f)):n(f,a)}return D}var en=na(!0),ra=na(!1),Hr=mt(null),Wr=null,$t=null,io=null;function so(){io=$t=Wr=null}function ao(e){var t=Hr.current;U(Hr),e._currentValue=t}function ku(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Gt(e,t){Wr=e,io=$t=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(fe=!0),e.firstContext=null)}function _e(e){var t=e._currentValue;if(io!==e)if(e={context:e,memoizedValue:t,next:null},$t===null){if(Wr===null)throw Error(y(308));$t=e,Wr.dependencies={lanes:0,firstContext:e}}else $t=$t.next=e;return t}var kt=null;function co(e){kt===null?kt=[e]:kt.push(e)}function la(e,t,n,r){var l=t.interleaved;return l===null?(n.next=n,co(t)):(n.next=l.next,l.next=n),t.interleaved=n,Ye(e,r)}function Ye(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var qe=!1;function fo(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function ua(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function We(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function it(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,j&2){var l=r.pending;return l===null?t.next=t:(t.next=l.next,l.next=t),r.pending=t,Ye(e,n)}return l=r.interleaved,l===null?(t.next=t,co(r)):(t.next=l.next,l.next=t),r.interleaved=t,Ye(e,n)}function Cr(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Zu(e,n)}}function gi(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var l=null,u=null;if(n=n.firstBaseUpdate,n!==null){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};u===null?l=u=o:u=u.next=o,n=n.next}while(n!==null);u===null?l=u=t:u=u.next=t}else l=u=t;n={baseState:r.baseState,firstBaseUpdate:l,lastBaseUpdate:u,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Qr(e,t,n,r){var l=e.updateQueue;qe=!1;var u=l.firstBaseUpdate,o=l.lastBaseUpdate,i=l.shared.pending;if(i!==null){l.shared.pending=null;var s=i,c=s.next;s.next=null,o===null?u=c:o.next=c,o=s;var h=e.alternate;h!==null&&(h=h.updateQueue,i=h.lastBaseUpdate,i!==o&&(i===null?h.firstBaseUpdate=c:i.next=c,h.lastBaseUpdate=s))}if(u!==null){var m=l.baseState;o=0,h=c=s=null,i=u;do{var p=i.lane,g=i.eventTime;if((r&p)===p){h!==null&&(h=h.next={eventTime:g,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var w=e,S=i;switch(p=t,g=n,S.tag){case 1:if(w=S.payload,typeof w=="function"){m=w.call(g,m,p);break e}m=w;break e;case 3:w.flags=w.flags&-65537|128;case 0:if(w=S.payload,p=typeof w=="function"?w.call(g,m,p):w,p==null)break e;m=$({},m,p);break e;case 2:qe=!0}}i.callback!==null&&i.lane!==0&&(e.flags|=64,p=l.effects,p===null?l.effects=[i]:p.push(i))}else g={eventTime:g,lane:p,tag:i.tag,payload:i.payload,callback:i.callback,next:null},h===null?(c=h=g,s=m):h=h.next=g,o|=p;if(i=i.next,i===null){if(i=l.shared.pending,i===null)break;p=i,i=p.next,p.next=null,l.lastBaseUpdate=p,l.shared.pending=null}}while(!0);if(h===null&&(s=m),l.baseState=s,l.firstBaseUpdate=c,l.lastBaseUpdate=h,t=l.shared.interleaved,t!==null){l=t;do o|=l.lane,l=l.next;while(l!==t)}else u===null&&(l.shared.lanes=0);zt|=o,e.lanes=o,e.memoizedState=m}}function wi(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],l=r.callback;if(l!==null){if(r.callback=null,r=n,typeof l!="function")throw Error(y(191,l));l.call(r)}}}var qn={},Ae=mt(qn),$n=mt(qn),Hn=mt(qn);function Et(e){if(e===qn)throw Error(y(174));return e}function po(e,t){switch(I(Hn,t),I($n,e),I(Ae,qn),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:tu(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=tu(t,e)}U(Ae),I(Ae,t)}function tn(){U(Ae),U($n),U(Hn)}function oa(e){Et(Hn.current);var t=Et(Ae.current),n=tu(t,e.type);t!==n&&(I($n,e),I(Ae,n))}function mo(e){$n.current===e&&(U(Ae),U($n))}var V=mt(0);function Kr(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Fl=[];function ho(){for(var e=0;e<Fl.length;e++)Fl[e]._workInProgressVersionPrimary=null;Fl.length=0}var xr=Ge.ReactCurrentDispatcher,Ul=Ge.ReactCurrentBatchConfig,Pt=0,B=null,X=null,J=null,Yr=!1,Pn=!1,Wn=0,qf=0;function ne(){throw Error(y(321))}function vo(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Me(e[n],t[n]))return!1;return!0}function yo(e,t,n,r,l,u){if(Pt=u,B=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,xr.current=e===null||e.memoizedState===null?nd:rd,e=n(r,l),Pn){u=0;do{if(Pn=!1,Wn=0,25<=u)throw Error(y(301));u+=1,J=X=null,t.updateQueue=null,xr.current=ld,e=n(r,l)}while(Pn)}if(xr.current=Xr,t=X!==null&&X.next!==null,Pt=0,J=X=B=null,Yr=!1,t)throw Error(y(300));return e}function go(){var e=Wn!==0;return Wn=0,e}function Ie(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return J===null?B.memoizedState=J=e:J=J.next=e,J}function Ne(){if(X===null){var e=B.alternate;e=e!==null?e.memoizedState:null}else e=X.next;var t=J===null?B.memoizedState:J.next;if(t!==null)J=t,X=e;else{if(e===null)throw Error(y(310));X=e,e={memoizedState:X.memoizedState,baseState:X.baseState,baseQueue:X.baseQueue,queue:X.queue,next:null},J===null?B.memoizedState=J=e:J=J.next=e}return J}function Qn(e,t){return typeof t=="function"?t(e):t}function Al(e){var t=Ne(),n=t.queue;if(n===null)throw Error(y(311));n.lastRenderedReducer=e;var r=X,l=r.baseQueue,u=n.pending;if(u!==null){if(l!==null){var o=l.next;l.next=u.next,u.next=o}r.baseQueue=l=u,n.pending=null}if(l!==null){u=l.next,r=r.baseState;var i=o=null,s=null,c=u;do{var h=c.lane;if((Pt&h)===h)s!==null&&(s=s.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var m={lane:h,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};s===null?(i=s=m,o=r):s=s.next=m,B.lanes|=h,zt|=h}c=c.next}while(c!==null&&c!==u);s===null?o=r:s.next=i,Me(r,t.memoizedState)||(fe=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=s,n.lastRenderedState=r}if(e=n.interleaved,e!==null){l=e;do u=l.lane,B.lanes|=u,zt|=u,l=l.next;while(l!==e)}else l===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Vl(e){var t=Ne(),n=t.queue;if(n===null)throw Error(y(311));n.lastRenderedReducer=e;var r=n.dispatch,l=n.pending,u=t.memoizedState;if(l!==null){n.pending=null;var o=l=l.next;do u=e(u,o.action),o=o.next;while(o!==l);Me(u,t.memoizedState)||(fe=!0),t.memoizedState=u,t.baseQueue===null&&(t.baseState=u),n.lastRenderedState=u}return[u,r]}function ia(){}function sa(e,t){var n=B,r=Ne(),l=t(),u=!Me(r.memoizedState,l);if(u&&(r.memoizedState=l,fe=!0),r=r.queue,wo(fa.bind(null,n,r,e),[e]),r.getSnapshot!==t||u||J!==null&&J.memoizedState.tag&1){if(n.flags|=2048,Kn(9,ca.bind(null,n,r,l,t),void 0,null),q===null)throw Error(y(349));Pt&30||aa(n,t,l)}return l}function aa(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=B.updateQueue,t===null?(t={lastEffect:null,stores:null},B.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function ca(e,t,n,r){t.value=n,t.getSnapshot=r,da(t)&&pa(e)}function fa(e,t,n){return n(function(){da(t)&&pa(e)})}function da(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Me(e,n)}catch{return!0}}function pa(e){var t=Ye(e,1);t!==null&&Oe(t,e,1,-1)}function Si(e){var t=Ie();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Qn,lastRenderedState:e},t.queue=e,e=e.dispatch=td.bind(null,B,e),[t.memoizedState,e]}function Kn(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=B.updateQueue,t===null?(t={lastEffect:null,stores:null},B.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function ma(){return Ne().memoizedState}function _r(e,t,n,r){var l=Ie();B.flags|=e,l.memoizedState=Kn(1|t,n,void 0,r===void 0?null:r)}function il(e,t,n,r){var l=Ne();r=r===void 0?null:r;var u=void 0;if(X!==null){var o=X.memoizedState;if(u=o.destroy,r!==null&&vo(r,o.deps)){l.memoizedState=Kn(t,n,u,r);return}}B.flags|=e,l.memoizedState=Kn(1|t,n,u,r)}function ki(e,t){return _r(8390656,8,e,t)}function wo(e,t){return il(2048,8,e,t)}function ha(e,t){return il(4,2,e,t)}function va(e,t){return il(4,4,e,t)}function ya(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function ga(e,t,n){return n=n!=null?n.concat([e]):null,il(4,4,ya.bind(null,t,e),n)}function So(){}function wa(e,t){var n=Ne();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&vo(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Sa(e,t){var n=Ne();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&vo(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function ka(e,t,n){return Pt&21?(Me(n,t)||(n=Ns(),B.lanes|=n,zt|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,fe=!0),e.memoizedState=n)}function bf(e,t){var n=M;M=n!==0&&4>n?n:4,e(!0);var r=Ul.transition;Ul.transition={};try{e(!1),t()}finally{M=n,Ul.transition=r}}function Ea(){return Ne().memoizedState}function ed(e,t,n){var r=at(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ca(e))xa(t,n);else if(n=la(e,t,n,r),n!==null){var l=ie();Oe(n,e,r,l),_a(n,t,r)}}function td(e,t,n){var r=at(e),l={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ca(e))xa(t,l);else{var u=e.alternate;if(e.lanes===0&&(u===null||u.lanes===0)&&(u=t.lastRenderedReducer,u!==null))try{var o=t.lastRenderedState,i=u(o,n);if(l.hasEagerState=!0,l.eagerState=i,Me(i,o)){var s=t.interleaved;s===null?(l.next=l,co(t)):(l.next=s.next,s.next=l),t.interleaved=l;return}}catch{}finally{}n=la(e,t,l,r),n!==null&&(l=ie(),Oe(n,e,r,l),_a(n,t,r))}}function Ca(e){var t=e.alternate;return e===B||t!==null&&t===B}function xa(e,t){Pn=Yr=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function _a(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Zu(e,n)}}var Xr={readContext:_e,useCallback:ne,useContext:ne,useEffect:ne,useImperativeHandle:ne,useInsertionEffect:ne,useLayoutEffect:ne,useMemo:ne,useReducer:ne,useRef:ne,useState:ne,useDebugValue:ne,useDeferredValue:ne,useTransition:ne,useMutableSource:ne,useSyncExternalStore:ne,useId:ne,unstable_isNewReconciler:!1},nd={readContext:_e,useCallback:function(e,t){return Ie().memoizedState=[e,t===void 0?null:t],e},useContext:_e,useEffect:ki,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,_r(4194308,4,ya.bind(null,t,e),n)},useLayoutEffect:function(e,t){return _r(4194308,4,e,t)},useInsertionEffect:function(e,t){return _r(4,2,e,t)},useMemo:function(e,t){var n=Ie();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Ie();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=ed.bind(null,B,e),[r.memoizedState,e]},useRef:function(e){var t=Ie();return e={current:e},t.memoizedState=e},useState:Si,useDebugValue:So,useDeferredValue:function(e){return Ie().memoizedState=e},useTransition:function(){var e=Si(!1),t=e[0];return e=bf.bind(null,e[1]),Ie().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=B,l=Ie();if(A){if(n===void 0)throw Error(y(407));n=n()}else{if(n=t(),q===null)throw Error(y(349));Pt&30||aa(r,t,n)}l.memoizedState=n;var u={value:n,getSnapshot:t};return l.queue=u,ki(fa.bind(null,r,u,e),[e]),r.flags|=2048,Kn(9,ca.bind(null,r,u,n,t),void 0,null),n},useId:function(){var e=Ie(),t=q.identifierPrefix;if(A){var n=He,r=$e;n=(r&~(1<<32-je(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=Wn++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=qf++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},rd={readContext:_e,useCallback:wa,useContext:_e,useEffect:wo,useImperativeHandle:ga,useInsertionEffect:ha,useLayoutEffect:va,useMemo:Sa,useReducer:Al,useRef:ma,useState:function(){return Al(Qn)},useDebugValue:So,useDeferredValue:function(e){var t=Ne();return ka(t,X.memoizedState,e)},useTransition:function(){var e=Al(Qn)[0],t=Ne().memoizedState;return[e,t]},useMutableSource:ia,useSyncExternalStore:sa,useId:Ea,unstable_isNewReconciler:!1},ld={readContext:_e,useCallback:wa,useContext:_e,useEffect:wo,useImperativeHandle:ga,useInsertionEffect:ha,useLayoutEffect:va,useMemo:Sa,useReducer:Vl,useRef:ma,useState:function(){return Vl(Qn)},useDebugValue:So,useDeferredValue:function(e){var t=Ne();return X===null?t.memoizedState=e:ka(t,X.memoizedState,e)},useTransition:function(){var e=Vl(Qn)[0],t=Ne().memoizedState;return[e,t]},useMutableSource:ia,useSyncExternalStore:sa,useId:Ea,unstable_isNewReconciler:!1};function Te(e,t){if(e&&e.defaultProps){t=$({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function Eu(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:$({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var sl={isMounted:function(e){return(e=e._reactInternals)?Rt(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=ie(),l=at(e),u=We(r,l);u.payload=t,n!=null&&(u.callback=n),t=it(e,u,l),t!==null&&(Oe(t,e,l,r),Cr(t,e,l))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=ie(),l=at(e),u=We(r,l);u.tag=1,u.payload=t,n!=null&&(u.callback=n),t=it(e,u,l),t!==null&&(Oe(t,e,l,r),Cr(t,e,l))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ie(),r=at(e),l=We(n,r);l.tag=2,t!=null&&(l.callback=t),t=it(e,l,r),t!==null&&(Oe(t,e,r,n),Cr(t,e,r))}};function Ei(e,t,n,r,l,u,o){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,u,o):t.prototype&&t.prototype.isPureReactComponent?!Un(n,r)||!Un(l,u):!0}function Na(e,t,n){var r=!1,l=dt,u=t.contextType;return typeof u=="object"&&u!==null?u=_e(u):(l=pe(t)?_t:ue.current,r=t.contextTypes,u=(r=r!=null)?qt(e,l):dt),t=new t(n,u),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=sl,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=l,e.__reactInternalMemoizedMaskedChildContext=u),t}function Ci(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&sl.enqueueReplaceState(t,t.state,null)}function Cu(e,t,n,r){var l=e.stateNode;l.props=n,l.state=e.memoizedState,l.refs={},fo(e);var u=t.contextType;typeof u=="object"&&u!==null?l.context=_e(u):(u=pe(t)?_t:ue.current,l.context=qt(e,u)),l.state=e.memoizedState,u=t.getDerivedStateFromProps,typeof u=="function"&&(Eu(e,t,u,n),l.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof l.getSnapshotBeforeUpdate=="function"||typeof l.UNSAFE_componentWillMount!="function"&&typeof l.componentWillMount!="function"||(t=l.state,typeof l.componentWillMount=="function"&&l.componentWillMount(),typeof l.UNSAFE_componentWillMount=="function"&&l.UNSAFE_componentWillMount(),t!==l.state&&sl.enqueueReplaceState(l,l.state,null),Qr(e,n,l,r),l.state=e.memoizedState),typeof l.componentDidMount=="function"&&(e.flags|=4194308)}function nn(e,t){try{var n="",r=t;do n+=Rc(r),r=r.return;while(r);var l=n}catch(u){l=`[m
[32m+[m[32mError generating stack: `+u.message+`[m
[32m+[m[32m`+u.stack}return{value:e,source:t,stack:l,digest:null}}function Bl(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function xu(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var ud=typeof WeakMap=="function"?WeakMap:Map;function Pa(e,t,n){n=We(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Zr||(Zr=!0,Mu=r),xu(e,t)},n}function za(e,t,n){n=We(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var l=t.value;n.payload=function(){return r(l)},n.callback=function(){xu(e,t)}}var u=e.stateNode;return u!==null&&typeof u.componentDidCatch=="function"&&(n.callback=function(){xu(e,t),typeof r!="function"&&(st===null?st=new Set([this]):st.add(this));var o=t.stack;this.componentDidCatch(t.value,{componentStack:o!==null?o:""})}),n}function xi(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new ud;var l=new Set;r.set(t,l)}else l=r.get(t),l===void 0&&(l=new Set,r.set(t,l));l.has(n)||(l.add(n),e=wd.bind(null,e,t,n),t.then(e,e))}function _i(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function Ni(e,t,n,r,l){return e.mode&1?(e.flags|=65536,e.lanes=l,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=We(-1,1),t.tag=2,it(n,t,1))),n.lanes|=1),e)}var od=Ge.ReactCurrentOwner,fe=!1;function oe(e,t,n,r){t.child=e===null?ra(t,null,n,r):en(t,e.child,n,r)}function Pi(e,t,n,r,l){n=n.render;var u=t.ref;return Gt(t,l),r=yo(e,t,n,r,u,l),n=go(),e!==null&&!fe?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~l,Xe(e,t,l)):(A&&n&&lo(t),t.flags|=1,oe(e,t,r,l),t.child)}function zi(e,t,n,r,l){if(e===null){var u=n.type;return typeof u=="function"&&!zo(u)&&u.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=u,Ta(e,t,u,r,l)):(e=Tr(n.type,null,r,t,t.mode,l),e.ref=t.ref,e.return=t,t.child=e)}if(u=e.child,!(e.lanes&l)){var o=u.memoizedProps;if(n=n.compare,n=n!==null?n:Un,n(o,r)&&e.ref===t.ref)return Xe(e,t,l)}return t.flags|=1,e=ct(u,r),e.ref=t.ref,e.return=t,t.child=e}function Ta(e,t,n,r,l){if(e!==null){var u=e.memoizedProps;if(Un(u,r)&&e.ref===t.ref)if(fe=!1,t.pendingProps=r=u,(e.lanes&l)!==0)e.flags&131072&&(fe=!0);else return t.lanes=e.lanes,Xe(e,t,l)}return _u(e,t,n,r,l)}function La(e,t,n){var r=t.pendingProps,l=r.children,u=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},I(Wt,he),he|=n;else{if(!(n&1073741824))return e=u!==null?u.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,I(Wt,he),he|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=u!==null?u.baseLanes:n,I(Wt,he),he|=r}else u!==null?(r=u.baseLanes|n,t.memoizedState=null):r=n,I(Wt,he),he|=r;return oe(e,t,l,n),t.child}function Ra(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function _u(e,t,n,r,l){var u=pe(n)?_t:ue.current;return u=qt(t,u),Gt(t,l),n=yo(e,t,n,r,u,l),r=go(),e!==null&&!fe?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~l,Xe(e,t,l)):(A&&r&&lo(t),t.flags|=1,oe(e,t,n,l),t.child)}function Ti(e,t,n,r,l){if(pe(n)){var u=!0;Vr(t)}else u=!1;if(Gt(t,l),t.stateNode===null)Nr(e,t),Na(t,n,r),Cu(t,n,r,l),r=!0;else if(e===null){var o=t.stateNode,i=t.memoizedProps;o.props=i;var s=o.context,c=n.contextType;typeof c=="object"&&c!==null?c=_e(c):(c=pe(n)?_t:ue.current,c=qt(t,c));var h=n.getDerivedStateFromProps,m=typeof h=="function"||typeof o.getSnapshotBeforeUpdate=="function";m||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(i!==r||s!==c)&&Ci(t,o,r,c),qe=!1;var p=t.memoizedState;o.state=p,Qr(t,r,o,l),s=t.memoizedState,i!==r||p!==s||de.current||qe?(typeof h=="function"&&(Eu(t,n,h,r),s=t.memoizedState),(i=qe||Ei(t,n,i,r,p,s,c))?(m||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(t.flags|=4194308)):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=s),o.props=r,o.state=s,o.context=c,r=i):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{o=t.stateNode,ua(e,t),i=t.memoizedProps,c=t.type===t.elementType?i:Te(t.type,i),o.props=c,m=t.pendingProps,p=o.context,s=n.contextType,typeof s=="object"&&s!==null?s=_e(s):(s=pe(n)?_t:ue.current,s=qt(t,s));var g=n.getDerivedStateFromProps;(h=typeof g=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(i!==m||p!==s)&&Ci(t,o,r,s),qe=!1,p=t.memoizedState,o.state=p,Qr(t,r,o,l);var w=t.memoizedState;i!==m||p!==w||de.current||qe?(typeof g=="function"&&(Eu(t,n,g,r),w=t.memoizedState),(c=qe||Ei(t,n,c,r,p,w,s)||!1)?(h||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(r,w,s),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(r,w,s)),typeof o.componentDidUpdate=="function"&&(t.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof o.componentDidUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=w),o.props=r,o.state=w,o.context=s,r=c):(typeof o.componentDidUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),r=!1)}return Nu(e,t,n,r,u,l)}function Nu(e,t,n,r,l,u){Ra(e,t);var o=(t.flags&128)!==0;if(!r&&!o)return l&&mi(t,n,!1),Xe(e,t,u);r=t.stateNode,od.current=t;var i=o&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&o?(t.child=en(t,e.child,null,u),t.child=en(t,null,i,u)):oe(e,t,i,u),t.memoizedState=r.state,l&&mi(t,n,!0),t.child}function ja(e){var t=e.stateNode;t.pendingContext?pi(e,t.pendingContext,t.pendingContext!==t.context):t.context&&pi(e,t.context,!1),po(e,t.containerInfo)}function Li(e,t,n,r,l){return bt(),oo(l),t.flags|=256,oe(e,t,n,r),t.child}var Pu={dehydrated:null,treeContext:null,retryLane:0};function zu(e){return{baseLanes:e,cachePool:null,transitions:null}}function Oa(e,t,n){var r=t.pendingProps,l=V.current,u=!1,o=(t.flags&128)!==0,i;if((i=o)||(i=e!==null&&e.memoizedState===null?!1:(l&2)!==0),i?(u=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(l|=1),I(V,l&1),e===null)return Su(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(o=r.children,e=r.fallback,u?(r=t.mode,u=t.child,o={mode:"hidden",children:o},!(r&1)&&u!==null?(u.childLanes=0,u.pendingProps=o):u=fl(o,r,0,null),e=xt(e,r,n,null),u.return=t,e.return=t,u.sibling=e,t.child=u,t.child.memoizedState=zu(n),t.memoizedState=Pu,e):ko(t,o));if(l=e.memoizedState,l!==null&&(i=l.dehydrated,i!==null))return id(e,t,o,r,i,l,n);if(u){u=r.fallback,o=t.mode,l=e.child,i=l.sibling;var s={mode:"hidden",children:r.children};return!(o&1)&&t.child!==l?(r=t.child,r.childLanes=0,r.pendingProps=s,t.deletions=null):(r=ct(l,s),r.subtreeFlags=l.subtreeFlags&14680064),i!==null?u=ct(i,u):(u=xt(u,o,n,null),u.flags|=2),u.return=t,r.return=t,r.sibling=u,t.child=r,r=u,u=t.child,o=e.child.memoizedState,o=o===null?zu(n):{baseLanes:o.baseLanes|n,cachePool:null,transitions:o.transitions},u.memoizedState=o,u.childLanes=e.childLanes&~n,t.memoizedState=Pu,r}return u=e.child,e=u.sibling,r=ct(u,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function ko(e,t){return t=fl({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function mr(e,t,n,r){return r!==null&&oo(r),en(t,e.child,null,n),e=ko(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function id(e,t,n,r,l,u,o){if(n)return t.flags&256?(t.flags&=-257,r=Bl(Error(y(422))),mr(e,t,o,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(u=r.fallback,l=t.mode,r=fl({mode:"visible",children:r.children},l,0,null),u=xt(u,l,o,null),u.flags|=2,r.return=t,u.return=t,r.sibling=u,t.child=r,t.mode&1&&en(t,e.child,null,o),t.child.memoizedState=zu(o),t.memoizedState=Pu,u);if(!(t.mode&1))return mr(e,t,o,null);if(l.data==="$!"){if(r=l.nextSibling&&l.nextSibling.dataset,r)var i=r.dgst;return r=i,u=Error(y(419)),r=Bl(u,r,void 0),mr(e,t,o,r)}if(i=(o&e.childLanes)!==0,fe||i){if(r=q,r!==null){switch(o&-o){case 4:l=2;break;case 16:l=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:l=32;break;case 536870912:l=268435456;break;default:l=0}l=l&(r.suspendedLanes|o)?0:l,l!==0&&l!==u.retryLane&&(u.retryLane=l,Ye(e,l),Oe(r,e,l,-1))}return Po(),r=Bl(Error(y(421))),mr(e,t,o,r)}return l.data==="$?"?(t.flags|=128,t.child=e.child,t=Sd.bind(null,e),l._reactRetry=t,null):(e=u.treeContext,ve=ot(l.nextSibling),ye=t,A=!0,Re=null,e!==null&&(ke[Ee++]=$e,ke[Ee++]=He,ke[Ee++]=Nt,$e=e.id,He=e.overflow,Nt=t),t=ko(t,r.children),t.flags|=4096,t)}function Ri(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),ku(e.return,t,n)}function $l(e,t,n,r,l){var u=e.memoizedState;u===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:l}:(u.isBackwards=t,u.rendering=null,u.renderingStartTime=0,u.last=r,u.tail=n,u.tailMode=l)}function Ma(e,t,n){var r=t.pendingProps,l=r.revealOrder,u=r.tail;if(oe(e,t,r.children,n),r=V.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Ri(e,n,t);else if(e.tag===19)Ri(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(I(V,r),!(t.mode&1))t.memoizedState=null;else switch(l){case"forwards":for(n=t.child,l=null;n!==null;)e=n.alternate,e!==null&&Kr(e)===null&&(l=n),n=n.sibling;n=l,n===null?(l=t.child,t.child=null):(l=n.sibling,n.sibling=null),$l(t,!1,l,n,u);break;case"backwards":for(n=null,l=t.child,t.child=null;l!==null;){if(e=l.alternate,e!==null&&Kr(e)===null){t.child=l;break}e=l.sibling,l.sibling=n,n=l,l=e}$l(t,!0,n,null,u);break;case"together":$l(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Nr(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Xe(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),zt|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(y(153));if(t.child!==null){for(e=t.child,n=ct(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=ct(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function sd(e,t,n){switch(t.tag){case 3:ja(t),bt();break;case 5:oa(t);break;case 1:pe(t.type)&&Vr(t);break;case 4:po(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,l=t.memoizedProps.value;I(Hr,r._currentValue),r._currentValue=l;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(I(V,V.current&1),t.flags|=128,null):n&t.child.childLanes?Oa(e,t,n):(I(V,V.current&1),e=Xe(e,t,n),e!==null?e.sibling:null);I(V,V.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return Ma(e,t,n);t.flags|=128}if(l=t.memoizedState,l!==null&&(l.rendering=null,l.tail=null,l.lastEffect=null),I(V,V.current),r)break;return null;case 22:case 23:return t.lanes=0,La(e,t,n)}return Xe(e,t,n)}var Da,Tu,Ia,Fa;Da=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};Tu=function(){};Ia=function(e,t,n,r){var l=e.memoizedProps;if(l!==r){e=t.stateNode,Et(Ae.current);var u=null;switch(n){case"input":l=Jl(e,l),r=Jl(e,r),u=[];break;case"select":l=$({},l,{value:void 0}),r=$({},r,{value:void 0}),u=[];break;case"textarea":l=eu(e,l),r=eu(e,r),u=[];break;default:typeof l.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=Ur)}nu(n,r);var o;n=null;for(c in l)if(!r.hasOwnProperty(c)&&l.hasOwnProperty(c)&&l[c]!=null)if(c==="style"){var i=l[c];for(o in i)i.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(Rn.hasOwnProperty(c)?u||(u=[]):(u=u||[]).push(c,null));for(c in r){var s=r[c];if(i=l!=null?l[c]:void 0,r.hasOwnProperty(c)&&s!==i&&(s!=null||i!=null))if(c==="style")if(i){for(o in i)!i.hasOwnProperty(o)||s&&s.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in s)s.hasOwnProperty(o)&&i[o]!==s[o]&&(n||(n={}),n[o]=s[o])}else n||(u||(u=[]),u.push(c,n)),n=s;else c==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,i=i?i.__html:void 0,s!=null&&i!==s&&(u=u||[]).push(c,s)):c==="children"?typeof s!="string"&&typeof s!="number"||(u=u||[]).push(c,""+s):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(Rn.hasOwnProperty(c)?(s!=null&&c==="onScroll"&&F("scroll",e),u||i===s||(u=[])):(u=u||[]).push(c,s))}n&&(u=u||[]).push("style",n);var c=u;(t.updateQueue=c)&&(t.flags|=4)}};Fa=function(e,t,n,r){n!==r&&(t.flags|=4)};function vn(e,t){if(!A)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function re(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var l=e.child;l!==null;)n|=l.lanes|l.childLanes,r|=l.subtreeFlags&14680064,r|=l.flags&14680064,l.return=e,l=l.sibling;else for(l=e.child;l!==null;)n|=l.lanes|l.childLanes,r|=l.subtreeFlags,r|=l.flags,l.return=e,l=l.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function ad(e,t,n){var r=t.pendingProps;switch(uo(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return re(t),null;case 1:return pe(t.type)&&Ar(),re(t),null;case 3:return r=t.stateNode,tn(),U(de),U(ue),ho(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(dr(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Re!==null&&(Fu(Re),Re=null))),Tu(e,t),re(t),null;case 5:mo(t);var l=Et(Hn.current);if(n=t.type,e!==null&&t.stateNode!=null)Ia(e,t,n,r,l),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(y(166));return re(t),null}if(e=Et(Ae.current),dr(t)){r=t.stateNode,n=t.type;var u=t.memoizedProps;switch(r[Fe]=t,r[Bn]=u,e=(t.mode&1)!==0,n){case"dialog":F("cancel",r),F("close",r);break;case"iframe":case"object":case"embed":F("load",r);break;case"video":case"audio":for(l=0;l<kn.length;l++)F(kn[l],r);break;case"source":F("error",r);break;case"img":case"image":case"link":F("error",r),F("load",r);break;case"details":F("toggle",r);break;case"input":Vo(r,u),F("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!u.multiple},F("invalid",r);break;case"textarea":$o(r,u),F("invalid",r)}nu(n,u),l=null;for(var o in u)if(u.hasOwnProperty(o)){var i=u[o];o==="children"?typeof i=="string"?r.textContent!==i&&(u.suppressHydrationWarning!==!0&&fr(r.textContent,i,e),l=["children",i]):typeof i=="number"&&r.textContent!==""+i&&(u.suppressHydrationWarning!==!0&&fr(r.textContent,i,e),l=["children",""+i]):Rn.hasOwnProperty(o)&&i!=null&&o==="onScroll"&&F("scroll",r)}switch(n){case"input":rr(r),Bo(r,u,!0);break;case"textarea":rr(r),Ho(r);break;case"select":case"option":break;default:typeof u.onClick=="function"&&(r.onclick=Ur)}r=l,t.updateQueue=r,r!==null&&(t.flags|=4)}else{o=l.nodeType===9?l:l.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=fs(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=o.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=o.createElement(n,{is:r.is}):(e=o.createElement(n),n==="select"&&(o=e,r.multiple?o.multiple=!0:r.size&&(o.size=r.size))):e=o.createElementNS(e,n),e[Fe]=t,e[Bn]=r,Da(e,t,!1,!1),t.stateNode=e;e:{switch(o=ru(n,r),n){case"dialog":F("cancel",e),F("close",e),l=r;break;case"iframe":case"object":case"embed":F("load",e),l=r;break;case"video":case"audio":for(l=0;l<kn.length;l++)F(kn[l],e);l=r;break;case"source":F("error",e),l=r;break;case"img":case"image":case"link":F("error",e),F("load",e),l=r;break;case"details":F("toggle",e),l=r;break;case"input":Vo(e,r),l=Jl(e,r),F("invalid",e);break;case"option":l=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},l=$({},r,{value:void 0}),F("invalid",e);break;case"textarea":$o(e,r),l=eu(e,r),F("invalid",e);break;default:l=r}nu(n,l),i=l;for(u in i)if(i.hasOwnProperty(u)){var s=i[u];u==="style"?ms(e,s):u==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,s!=null&&ds(e,s)):u==="children"?typeof s=="string"?(n!=="textarea"||s!=="")&&jn(e,s):typeof s=="number"&&jn(e,""+s):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Rn.hasOwnProperty(u)?s!=null&&u==="onScroll"&&F("scroll",e):s!=null&&Wu(e,u,s,o))}switch(n){case"input":rr(e),Bo(e,r,!1);break;case"textarea":rr(e),Ho(e);break;case"option":r.value!=null&&e.setAttribute("value",""+ft(r.value));break;case"select":e.multiple=!!r.multiple,u=r.value,u!=null?Qt(e,!!r.multiple,u,!1):r.defaultValue!=null&&Qt(e,!!r.multiple,r.defaultValue,!0);break;default:typeof l.onClick=="function"&&(e.onclick=Ur)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return re(t),null;case 6:if(e&&t.stateNode!=null)Fa(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(y(166));if(n=Et(Hn.current),Et(Ae.current),dr(t)){if(r=t.stateNode,n=t.memoizedProps,r[Fe]=t,(u=r.nodeValue!==n)&&(e=ye,e!==null))switch(e.tag){case 3:fr(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&fr(r.nodeValue,n,(e.mode&1)!==0)}u&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[Fe]=t,t.stateNode=r}return re(t),null;case 13:if(U(V),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(A&&ve!==null&&t.mode&1&&!(t.flags&128))ta(),bt(),t.flags|=98560,u=!1;else if(u=dr(t),r!==null&&r.dehydrated!==null){if(e===null){if(!u)throw Error(y(318));if(u=t.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(y(317));u[Fe]=t}else bt(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;re(t),u=!1}else Re!==null&&(Fu(Re),Re=null),u=!0;if(!u)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||V.current&1?G===0&&(G=3):Po())),t.updateQueue!==null&&(t.flags|=4),re(t),null);case 4:return tn(),Tu(e,t),e===null&&An(t.stateNode.containerInfo),re(t),null;case 10:return ao(t.type._context),re(t),null;case 17:return pe(t.type)&&Ar(),re(t),null;case 19:if(U(V),u=t.memoizedState,u===null)return re(t),null;if(r=(t.flags&128)!==0,o=u.rendering,o===null)if(r)vn(u,!1);else{if(G!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(o=Kr(e),o!==null){for(t.flags|=128,vn(u,!1),r=o.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)u=n,e=r,u.flags&=14680066,o=u.alternate,o===null?(u.childLanes=0,u.lanes=e,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=o.childLanes,u.lanes=o.lanes,u.child=o.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=o.memoizedProps,u.memoizedState=o.memoizedState,u.updateQueue=o.updateQueue,u.type=o.type,e=o.dependencies,u.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return I(V,V.current&1|2),t.child}e=e.sibling}u.tail!==null&&Q()>rn&&(t.flags|=128,r=!0,vn(u,!1),t.lanes=4194304)}else{if(!r)if(e=Kr(o),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),vn(u,!0),u.tail===null&&u.tailMode==="hidden"&&!o.alternate&&!A)return re(t),null}else 2*Q()-u.renderingStartTime>rn&&n!==1073741824&&(t.flags|=128,r=!0,vn(u,!1),t.lanes=4194304);u.isBackwards?(o.sibling=t.child,t.child=o):(n=u.last,n!==null?n.sibling=o:t.child=o,u.last=o)}return u.tail!==null?(t=u.tail,u.rendering=t,u.tail=t.sibling,u.renderingStartTime=Q(),t.sibling=null,n=V.current,I(V,r?n&1|2:n&1),t):(re(t),null);case 22:case 23:return No(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?he&1073741824&&(re(t),t.subtreeFlags&6&&(t.flags|=8192)):re(t),null;case 24:return null;case 25:return null}throw Error(y(156,t.tag))}function cd(e,t){switch(uo(t),t.tag){case 1:return pe(t.type)&&Ar(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return tn(),U(de),U(ue),ho(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return mo(t),null;case 13:if(U(V),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(y(340));bt()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return U(V),null;case 4:return tn(),null;case 10:return ao(t.type._context),null;case 22:case 23:return No(),null;case 24:return null;default:return null}}var hr=!1,le=!1,fd=typeof WeakSet=="function"?WeakSet:Set,C=null;function Ht(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){H(e,t,r)}else n.current=null}function Lu(e,t,n){try{n()}catch(r){H(e,t,r)}}var ji=!1;function dd(e,t){if(pu=Dr,e=$s(),ro(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var l=r.anchorOffset,u=r.focusNode;r=r.focusOffset;try{n.nodeType,u.nodeType}catch{n=null;break e}var o=0,i=-1,s=-1,c=0,h=0,m=e,p=null;t:for(;;){for(var g;m!==n||l!==0&&m.nodeType!==3||(i=o+l),m!==u||r!==0&&m.nodeType!==3||(s=o+r),m.nodeType===3&&(o+=m.nodeValue.length),(g=m.firstChild)!==null;)p=m,m=g;for(;;){if(m===e)break t;if(p===n&&++c===l&&(i=o),p===u&&++h===r&&(s=o),(g=m.nextSibling)!==null)break;m=p,p=m.parentNode}m=g}n=i===-1||s===-1?null:{start:i,end:s}}else n=null}n=n||{start:0,end:0}}else n=null;for(mu={focusedElem:e,selectionRange:n},Dr=!1,C=t;C!==null;)if(t=C,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,C=e;else for(;C!==null;){t=C;try{var w=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(w!==null){var S=w.memoizedProps,D=w.memoizedState,f=t.stateNode,a=f.getSnapshotBeforeUpdate(t.elementType===t.type?S:Te(t.type,S),D);f.__reactInternalSnapshotBeforeUpdate=a}break;case 3:var d=t.stateNode.containerInfo;d.nodeType===1?d.textContent="":d.nodeType===9&&d.documentElement&&d.removeChild(d.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(y(163))}}catch(v){H(t,t.return,v)}if(e=t.sibling,e!==null){e.return=t.return,C=e;break}C=t.return}return w=ji,ji=!1,w}function zn(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var l=r=r.next;do{if((l.tag&e)===e){var u=l.destroy;l.destroy=void 0,u!==void 0&&Lu(t,n,u)}l=l.next}while(l!==r)}}function al(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function Ru(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function Ua(e){var t=e.alternate;t!==null&&(e.alternate=null,Ua(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Fe],delete t[Bn],delete t[yu],delete t[Xf],delete t[Gf])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Aa(e){return e.tag===5||e.tag===3||e.tag===4}function Oi(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Aa(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ju(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Ur));else if(r!==4&&(e=e.child,e!==null))for(ju(e,t,n),e=e.sibling;e!==null;)ju(e,t,n),e=e.sibling}function Ou(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(Ou(e,t,n),e=e.sibling;e!==null;)Ou(e,t,n),e=e.sibling}var b=null,Le=!1;function Ze(e,t,n){for(n=n.child;n!==null;)Va(e,t,n),n=n.sibling}function Va(e,t,n){if(Ue&&typeof Ue.onCommitFiberUnmount=="function")try{Ue.onCommitFiberUnmount(tl,n)}catch{}switch(n.tag){case 5:le||Ht(n,t);case 6:var r=b,l=Le;b=null,Ze(e,t,n),b=r,Le=l,b!==null&&(Le?(e=b,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):b.removeChild(n.stateNode));break;case 18:b!==null&&(Le?(e=b,n=n.stateNode,e.nodeType===8?Dl(e.parentNode,n):e.nodeType===1&&Dl(e,n),In(e)):Dl(b,n.stateNode));break;case 4:r=b,l=Le,b=n.stateNode.containerInfo,Le=!0,Ze(e,t,n),b=r,Le=l;break;case 0:case 11:case 14:case 15:if(!le&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){l=r=r.next;do{var u=l,o=u.destroy;u=u.tag,o!==void 0&&(u&2||u&4)&&Lu(n,t,o),l=l.next}while(l!==r)}Ze(e,t,n);break;case 1:if(!le&&(Ht(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(i){H(n,t,i)}Ze(e,t,n);break;case 21:Ze(e,t,n);break;case 22:n.mode&1?(le=(r=le)||n.memoizedState!==null,Ze(e,t,n),le=r):Ze(e,t,n);break;default:Ze(e,t,n)}}function Mi(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new fd),t.forEach(function(r){var l=kd.bind(null,e,r);n.has(r)||(n.add(r),r.then(l,l))})}}function ze(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var l=n[r];try{var u=e,o=t,i=o;e:for(;i!==null;){switch(i.tag){case 5:b=i.stateNode,Le=!1;break e;case 3:b=i.stateNode.containerInfo,Le=!0;break e;case 4:b=i.stateNode.containerInfo,Le=!0;break e}i=i.return}if(b===null)throw Error(y(160));Va(u,o,l),b=null,Le=!1;var s=l.alternate;s!==null&&(s.return=null),l.return=null}catch(c){H(l,t,c)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Ba(t,e),t=t.sibling}function Ba(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ze(t,e),De(e),r&4){try{zn(3,e,e.return),al(3,e)}catch(S){H(e,e.return,S)}try{zn(5,e,e.return)}catch(S){H(e,e.return,S)}}break;case 1:ze(t,e),De(e),r&512&&n!==null&&Ht(n,n.return);break;case 5:if(ze(t,e),De(e),r&512&&n!==null&&Ht(n,n.return),e.flags&32){var l=e.stateNode;try{jn(l,"")}catch(S){H(e,e.return,S)}}if(r&4&&(l=e.stateNode,l!=null)){var u=e.memoizedProps,o=n!==null?n.memoizedProps:u,i=e.type,s=e.updateQueue;if(e.updateQueue=null,s!==null)try{i==="input"&&u.type==="radio"&&u.name!=null&&as(l,u),ru(i,o);var c=ru(i,u);for(o=0;o<s.length;o+=2){var h=s[o],m=s[o+1];h==="style"?ms(l,m):h==="dangerouslySetInnerHTML"?ds(l,m):h==="children"?jn(l,m):Wu(l,h,m,c)}switch(i){case"input":ql(l,u);break;case"textarea":cs(l,u);break;case"select":var p=l._wrapperState.wasMultiple;l._wrapperState.wasMultiple=!!u.multiple;var g=u.value;g!=null?Qt(l,!!u.multiple,g,!1):p!==!!u.multiple&&(u.defaultValue!=null?Qt(l,!!u.multiple,u.defaultValue,!0):Qt(l,!!u.multiple,u.multiple?[]:"",!1))}l[Bn]=u}catch(S){H(e,e.return,S)}}break;case 6:if(ze(t,e),De(e),r&4){if(e.stateNode===null)throw Error(y(162));l=e.stateNode,u=e.memoizedProps;try{l.nodeValue=u}catch(S){H(e,e.return,S)}}break;case 3:if(ze(t,e),De(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{In(t.containerInfo)}catch(S){H(e,e.return,S)}break;case 4:ze(t,e),De(e);break;case 13:ze(t,e),De(e),l=e.child,l.flags&8192&&(u=l.memoizedState!==null,l.stateNode.isHidden=u,!u||l.alternate!==null&&l.alternate.memoizedState!==null||(xo=Q())),r&4&&Mi(e);break;case 22:if(h=n!==null&&n.memoizedState!==null,e.mode&1?(le=(c=le)||h,ze(t,e),le=c):ze(t,e),De(e),r&8192){if(c=e.memoizedState!==null,(e.stateNode.isHidden=c)&&!h&&e.mode&1)for(C=e,h=e.child;h!==null;){for(m=C=h;C!==null;){switch(p=C,g=p.child,p.tag){case 0:case 11:case 14:case 15:zn(4,p,p.return);break;case 1:Ht(p,p.return);var w=p.stateNode;if(typeof w.componentWillUnmount=="function"){r=p,n=p.return;try{t=r,w.props=t.memoizedProps,w.state=t.memoizedState,w.componentWillUnmount()}catch(S){H(r,n,S)}}break;case 5:Ht(p,p.return);break;case 22:if(p.memoizedState!==null){Ii(m);continue}}g!==null?(g.return=p,C=g):Ii(m)}h=h.sibling}e:for(h=null,m=e;;){if(m.tag===5){if(h===null){h=m;try{l=m.stateNode,c?(u=l.style,typeof u.setProperty=="function"?u.setProperty("display","none","important"):u.display="none"):(i=m.stateNode,s=m.memoizedProps.style,o=s!=null&&s.hasOwnProperty("display")?s.display:null,i.style.display=ps("display",o))}catch(S){H(e,e.return,S)}}}else if(m.tag===6){if(h===null)try{m.stateNode.nodeValue=c?"":m.memoizedProps}catch(S){H(e,e.return,S)}}else if((m.tag!==22&&m.tag!==23||m.memoizedState===null||m===e)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===e)break e;for(;m.sibling===null;){if(m.return===null||m.return===e)break e;h===m&&(h=null),m=m.return}h===m&&(h=null),m.sibling.return=m.return,m=m.sibling}}break;case 19:ze(t,e),De(e),r&4&&Mi(e);break;case 21:break;default:ze(t,e),De(e)}}function De(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(Aa(n)){var r=n;break e}n=n.return}throw Error(y(160))}switch(r.tag){case 5:var l=r.stateNode;r.flags&32&&(jn(l,""),r.flags&=-33);var u=Oi(e);Ou(e,u,l);break;case 3:case 4:var o=r.stateNode.containerInfo,i=Oi(e);ju(e,i,o);break;default:throw Error(y(161))}}catch(s){H(e,e.return,s)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function pd(e,t,n){C=e,$a(e)}function $a(e,t,n){for(var r=(e.mode&1)!==0;C!==null;){var l=C,u=l.child;if(l.tag===22&&r){var o=l.memoizedState!==null||hr;if(!o){var i=l.alternate,s=i!==null&&i.memoizedState!==null||le;i=hr;var c=le;if(hr=o,(le=s)&&!c)for(C=l;C!==null;)o=C,s=o.child,o.tag===22&&o.memoizedState!==null?Fi(l):s!==null?(s.return=o,C=s):Fi(l);for(;u!==null;)C=u,$a(u),u=u.sibling;C=l,hr=i,le=c}Di(e)}else l.subtreeFlags&8772&&u!==null?(u.return=l,C=u):Di(e)}}function Di(e){for(;C!==null;){var t=C;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:le||al(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!le)if(n===null)r.componentDidMount();else{var l=t.elementType===t.type?n.memoizedProps:Te(t.type,n.memoizedProps);r.componentDidUpdate(l,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var u=t.updateQueue;u!==null&&wi(t,u,r);break;case 3:var o=t.updateQueue;if(o!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}wi(t,o,n)}break;case 5:var i=t.stateNode;if(n===null&&t.flags&4){n=i;var s=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&n.focus();break;case"img":s.src&&(n.src=s.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var c=t.alternate;if(c!==null){var h=c.memoizedState;if(h!==null){var m=h.dehydrated;m!==null&&In(m)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(y(163))}le||t.flags&512&&Ru(t)}catch(p){H(t,t.return,p)}}if(t===e){C=null;break}if(n=t.sibling,n!==null){n.return=t.return,C=n;break}C=t.return}}function Ii(e){for(;C!==null;){var t=C;if(t===e){C=null;break}var n=t.sibling;if(n!==null){n.return=t.return,C=n;break}C=t.return}}function Fi(e){for(;C!==null;){var t=C;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{al(4,t)}catch(s){H(t,n,s)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var l=t.return;try{r.componentDidMount()}catch(s){H(t,l,s)}}var u=t.return;try{Ru(t)}catch(s){H(t,u,s)}break;case 5:var o=t.return;try{Ru(t)}catch(s){H(t,o,s)}}}catch(s){H(t,t.return,s)}if(t===e){C=null;break}var i=t.sibling;if(i!==null){i.return=t.return,C=i;break}C=t.return}}var md=Math.ceil,Gr=Ge.ReactCurrentDispatcher,Eo=Ge.ReactCurrentOwner,xe=Ge.ReactCurrentBatchConfig,j=0,q=null,K=null,ee=0,he=0,Wt=mt(0),G=0,Yn=null,zt=0,cl=0,Co=0,Tn=null,ce=null,xo=0,rn=1/0,Ve=null,Zr=!1,Mu=null,st=null,vr=!1,nt=null,Jr=0,Ln=0,Du=null,Pr=-1,zr=0;function ie(){return j&6?Q():Pr!==-1?Pr:Pr=Q()}function at(e){return e.mode&1?j&2&&ee!==0?ee&-ee:Jf.transition!==null?(zr===0&&(zr=Ns()),zr):(e=M,e!==0||(e=window.event,e=e===void 0?16:Os(e.type)),e):1}function Oe(e,t,n,r){if(50<Ln)throw Ln=0,Du=null,Error(y(185));Gn(e,n,r),(!(j&2)||e!==q)&&(e===q&&(!(j&2)&&(cl|=n),G===4&&et(e,ee)),me(e,r),n===1&&j===0&&!(t.mode&1)&&(rn=Q()+500,ol&&ht()))}function me(e,t){var n=e.callbackNode;Zc(e,t);var r=Mr(e,e===q?ee:0);if(r===0)n!==null&&Ko(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&Ko(n),t===1)e.tag===0?Zf(Ui.bind(null,e)):qs(Ui.bind(null,e)),Kf(function(){!(j&6)&&ht()}),n=null;else{switch(Ps(r)){case 1:n=Gu;break;case 4:n=xs;break;case 16:n=Or;break;case 536870912:n=_s;break;default:n=Or}n=Za(n,Ha.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function Ha(e,t){if(Pr=-1,zr=0,j&6)throw Error(y(327));var n=e.callbackNode;if(Zt()&&e.callbackNode!==n)return null;var r=Mr(e,e===q?ee:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=qr(e,r);else{t=r;var l=j;j|=2;var u=Qa();(q!==e||ee!==t)&&(Ve=null,rn=Q()+500,Ct(e,t));do try{yd();break}catch(i){Wa(e,i)}while(!0);so(),Gr.current=u,j=l,K!==null?t=0:(q=null,ee=0,t=G)}if(t!==0){if(t===2&&(l=su(e),l!==0&&(r=l,t=Iu(e,l))),t===1)throw n=Yn,Ct(e,0),et(e,r),me(e,Q()),n;if(t===6)et(e,r);else{if(l=e.current.alternate,!(r&30)&&!hd(l)&&(t=qr(e,r),t===2&&(u=su(e),u!==0&&(r=u,t=Iu(e,u))),t===1))throw n=Yn,Ct(e,0),et(e,r),me(e,Q()),n;switch(e.finishedWork=l,e.finishedLanes=r,t){case 0:case 1:throw Error(y(345));case 2:wt(e,ce,Ve);break;case 3:if(et(e,r),(r&130023424)===r&&(t=xo+500-Q(),10<t)){if(Mr(e,0)!==0)break;if(l=e.suspendedLanes,(l&r)!==r){ie(),e.pingedLanes|=e.suspendedLanes&l;break}e.timeoutHandle=vu(wt.bind(null,e,ce,Ve),t);break}wt(e,ce,Ve);break;case 4:if(et(e,r),(r&4194240)===r)break;for(t=e.eventTimes,l=-1;0<r;){var o=31-je(r);u=1<<o,o=t[o],o>l&&(l=o),r&=~u}if(r=l,r=Q()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*md(r/1960))-r,10<r){e.timeoutHandle=vu(wt.bind(null,e,ce,Ve),r);break}wt(e,ce,Ve);break;case 5:wt(e,ce,Ve);break;default:throw Error(y(329))}}}return me(e,Q()),e.callbackNode===n?Ha.bind(null,e):null}function Iu(e,t){var n=Tn;return e.current.memoizedState.isDehydrated&&(Ct(e,t).flags|=256),e=qr(e,t),e!==2&&(t=ce,ce=n,t!==null&&Fu(t)),e}function Fu(e){ce===null?ce=e:ce.push.apply(ce,e)}function hd(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var l=n[r],u=l.getSnapshot;l=l.value;try{if(!Me(u(),l))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function et(e,t){for(t&=~Co,t&=~cl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-je(t),r=1<<n;e[n]=-1,t&=~r}}function Ui(e){if(j&6)throw Error(y(327));Zt();var t=Mr(e,0);if(!(t&1))return me(e,Q()),null;var n=qr(e,t);if(e.tag!==0&&n===2){var r=su(e);r!==0&&(t=r,n=Iu(e,r))}if(n===1)throw n=Yn,Ct(e,0),et(e,t),me(e,Q()),n;if(n===6)throw Error(y(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wt(e,ce,Ve),me(e,Q()),null}function _o(e,t){var n=j;j|=1;try{return e(t)}finally{j=n,j===0&&(rn=Q()+500,ol&&ht())}}function Tt(e){nt!==null&&nt.tag===0&&!(j&6)&&Zt();var t=j;j|=1;var n=xe.transition,r=M;try{if(xe.transition=null,M=1,e)return e()}finally{M=r,xe.transition=n,j=t,!(j&6)&&ht()}}function No(){he=Wt.current,U(Wt)}function Ct(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Qf(n)),K!==null)for(n=K.return;n!==null;){var r=n;switch(uo(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&Ar();break;case 3:tn(),U(de),U(ue),ho();break;case 5:mo(r);break;case 4:tn();break;case 13:U(V);break;case 19:U(V);break;case 10:ao(r.type._context);break;case 22:case 23:No()}n=n.return}if(q=e,K=e=ct(e.current,null),ee=he=t,G=0,Yn=null,Co=cl=zt=0,ce=Tn=null,kt!==null){for(t=0;t<kt.length;t++)if(n=kt[t],r=n.interleaved,r!==null){n.interleaved=null;var l=r.next,u=n.pending;if(u!==null){var o=u.next;u.next=l,r.next=o}n.pending=r}kt=null}return e}function Wa(e,t){do{var n=K;try{if(so(),xr.current=Xr,Yr){for(var r=B.memoizedState;r!==null;){var l=r.queue;l!==null&&(l.pending=null),r=r.next}Yr=!1}if(Pt=0,J=X=B=null,Pn=!1,Wn=0,Eo.current=null,n===null||n.return===null){G=1,Yn=t,K=null;break}e:{var u=e,o=n.return,i=n,s=t;if(t=ee,i.flags|=32768,s!==null&&typeof s=="object"&&typeof s.then=="function"){var c=s,h=i,m=h.tag;if(!(h.mode&1)&&(m===0||m===11||m===15)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var g=_i(o);if(g!==null){g.flags&=-257,Ni(g,o,i,u,t),g.mode&1&&xi(u,c,t),t=g,s=c;var w=t.updateQueue;if(w===null){var S=new Set;S.add(s),t.updateQueue=S}else w.add(s);break e}else{if(!(t&1)){xi(u,c,t),Po();break e}s=Error(y(426))}}else if(A&&i.mode&1){var D=_i(o);if(D!==null){!(D.flags&65536)&&(D.flags|=256),Ni(D,o,i,u,t),oo(nn(s,i));break e}}u=s=nn(s,i),G!==4&&(G=2),Tn===null?Tn=[u]:Tn.push(u),u=o;do{switch(u.tag){case 3:u.flags|=65536,t&=-t,u.lanes|=t;var f=Pa(u,s,t);gi(u,f);break e;case 1:i=s;var a=u.type,d=u.stateNode;if(!(u.flags&128)&&(typeof a.getDerivedStateFromError=="function"||d!==null&&typeof d.componentDidCatch=="function"&&(st===null||!st.has(d)))){u.flags|=65536,t&=-t,u.lanes|=t;var v=za(u,i,t);gi(u,v);break e}}u=u.return}while(u!==null)}Ya(n)}catch(E){t=E,K===n&&n!==null&&(K=n=n.return);continue}break}while(!0)}function Qa(){var e=Gr.current;return Gr.current=Xr,e===null?Xr:e}function Po(){(G===0||G===3||G===2)&&(G=4),q===null||!(zt&268435455)&&!(cl&268435455)||et(q,ee)}function qr(e,t){var n=j;j|=2;var r=Qa();(q!==e||ee!==t)&&(Ve=null,Ct(e,t));do try{vd();break}catch(l){Wa(e,l)}while(!0);if(so(),j=n,Gr.current=r,K!==null)throw Error(y(261));return q=null,ee=0,G}function vd(){for(;K!==null;)Ka(K)}function yd(){for(;K!==null&&!Bc();)Ka(K)}function Ka(e){var t=Ga(e.alternate,e,he);e.memoizedProps=e.pendingProps,t===null?Ya(e):K=t,Eo.current=null}function Ya(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=cd(n,t),n!==null){n.flags&=32767,K=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{G=6,K=null;return}}else if(n=ad(n,t,he),n!==null){K=n;return}if(t=t.sibling,t!==null){K=t;return}K=t=e}while(t!==null);G===0&&(G=5)}function wt(e,t,n){var r=M,l=xe.transition;try{xe.transition=null,M=1,gd(e,t,n,r)}finally{xe.transition=l,M=r}return null}function gd(e,t,n,r){do Zt();while(nt!==null);if(j&6)throw Error(y(327));n=e.finishedWork;var l=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(y(177));e.callbackNode=null,e.callbackPriority=0;var u=n.lanes|n.childLanes;if(Jc(e,u),e===q&&(K=q=null,ee=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||vr||(vr=!0,Za(Or,function(){return Zt(),null})),u=(n.flags&15990)!==0,n.subtreeFlags&15990||u){u=xe.transition,xe.transition=null;var o=M;M=1;var i=j;j|=4,Eo.current=null,dd(e,n),Ba(n,e),Uf(mu),Dr=!!pu,mu=pu=null,e.current=n,pd(n),$c(),j=i,M=o,xe.transition=u}else e.current=n;if(vr&&(vr=!1,nt=e,Jr=l),u=e.pendingLanes,u===0&&(st=null),Qc(n.stateNode),me(e,Q()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)l=t[n],r(l.value,{componentStack:l.stack,digest:l.digest});if(Zr)throw Zr=!1,e=Mu,Mu=null,e;return Jr&1&&e.tag!==0&&Zt(),u=e.pendingLanes,u&1?e===Du?Ln++:(Ln=0,Du=e):Ln=0,ht(),null}function Zt(){if(nt!==null){var e=Ps(Jr),t=xe.transition,n=M;try{if(xe.transition=null,M=16>e?16:e,nt===null)var r=!1;else{if(e=nt,nt=null,Jr=0,j&6)throw Error(y(331));var l=j;for(j|=4,C=e.current;C!==null;){var u=C,o=u.child;if(C.flags&16){var i=u.deletions;if(i!==null){for(var s=0;s<i.length;s++){var c=i[s];for(C=c;C!==null;){var h=C;switch(h.tag){case 0:case 11:case 15:zn(8,h,u)}var m=h.child;if(m!==null)m.return=h,C=m;else for(;C!==null;){h=C;var p=h.sibling,g=h.return;if(Ua(h),h===c){C=null;break}if(p!==null){p.return=g,C=p;break}C=g}}}var w=u.alternate;if(w!==null){var S=w.child;if(S!==null){w.child=null;do{var D=S.sibling;S.sibling=null,S=D}while(S!==null)}}C=u}}if(u.subtreeFlags&2064&&o!==null)o.return=u,C=o;else e:for(;C!==null;){if(u=C,u.flags&2048)switch(u.tag){case 0:case 11:case 15:zn(9,u,u.return)}var f=u.sibling;if(f!==null){f.return=u.return,C=f;break e}C=u.return}}var a=e.current;for(C=a;C!==null;){o=C;var d=o.child;if(o.subtreeFlags&2064&&d!==null)d.return=o,C=d;else e:for(o=a;C!==null;){if(i=C,i.flags&2048)try{switch(i.tag){case 0:case 11:case 15:al(9,i)}}catch(E){H(i,i.return,E)}if(i===o){C=null;break e}var v=i.sibling;if(v!==null){v.return=i.return,C=v;break e}C=i.return}}if(j=l,ht(),Ue&&typeof Ue.onPostCommitFiberRoot=="function")try{Ue.onPostCommitFiberRoot(tl,e)}catch{}r=!0}return r}finally{M=n,xe.transition=t}}return!1}function Ai(e,t,n){t=nn(n,t),t=Pa(e,t,1),e=it(e,t,1),t=ie(),e!==null&&(Gn(e,1,t),me(e,t))}function H(e,t,n){if(e.tag===3)Ai(e,e,n);else for(;t!==null;){if(t.tag===3){Ai(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(st===null||!st.has(r))){e=nn(n,e),e=za(t,e,1),t=it(t,e,1),e=ie(),t!==null&&(Gn(t,1,e),me(t,e));break}}t=t.return}}function wd(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=ie(),e.pingedLanes|=e.suspendedLanes&n,q===e&&(ee&n)===n&&(G===4||G===3&&(ee&130023424)===ee&&500>Q()-xo?Ct(e,0):Co|=n),me(e,t)}function Xa(e,t){t===0&&(e.mode&1?(t=or,or<<=1,!(or&130023424)&&(or=4194304)):t=1);var n=ie();e=Ye(e,t),e!==null&&(Gn(e,t,n),me(e,n))}function Sd(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),Xa(e,n)}function kd(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,l=e.memoizedState;l!==null&&(n=l.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(y(314))}r!==null&&r.delete(t),Xa(e,n)}var Ga;Ga=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||de.current)fe=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return fe=!1,sd(e,t,n);fe=!!(e.flags&131072)}else fe=!1,A&&t.flags&1048576&&bs(t,$r,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Nr(e,t),e=t.pendingProps;var l=qt(t,ue.current);Gt(t,n),l=yo(null,t,r,e,l,n);var u=go();return t.flags|=1,typeof l=="object"&&l!==null&&typeof l.render=="function"&&l.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,pe(r)?(u=!0,Vr(t)):u=!1,t.memoizedState=l.state!==null&&l.state!==void 0?l.state:null,fo(t),l.updater=sl,t.stateNode=l,l._reactInternals=t,Cu(t,r,e,n),t=Nu(null,t,r,!0,u,n)):(t.tag=0,A&&u&&lo(t),oe(null,t,l,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Nr(e,t),e=t.pendingProps,l=r._init,r=l(r._payload),t.type=r,l=t.tag=Cd(r),e=Te(r,e),l){case 0:t=_u(null,t,r,e,n);break e;case 1:t=Ti(null,t,r,e,n);break e;case 11:t=Pi(null,t,r,e,n);break e;case 14:t=zi(null,t,r,Te(r.type,e),n);break e}throw Error(y(306,r,""))}return t;case 0:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),_u(e,t,r,l,n);case 1:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Ti(e,t,r,l,n);case 3:e:{if(ja(t),e===null)throw Error(y(387));r=t.pendingProps,u=t.memoizedState,l=u.element,ua(e,t),Qr(t,r,null,n);var o=t.memoizedState;if(r=o.element,u.isDehydrated)if(u={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=u,t.memoizedState=u,t.flags&256){l=nn(Error(y(423)),t),t=Li(e,t,r,n,l);break e}else if(r!==l){l=nn(Error(y(424)),t),t=Li(e,t,r,n,l);break e}else for(ve=ot(t.stateNode.containerInfo.firstChild),ye=t,A=!0,Re=null,n=ra(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(bt(),r===l){t=Xe(e,t,n);break e}oe(e,t,r,n)}t=t.child}return t;case 5:return oa(t),e===null&&Su(t),r=t.type,l=t.pendingProps,u=e!==null?e.memoizedProps:null,o=l.children,hu(r,l)?o=null:u!==null&&hu(r,u)&&(t.flags|=32),Ra(e,t),oe(e,t,o,n),t.child;case 6:return e===null&&Su(t),null;case 13:return Oa(e,t,n);case 4:return po(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=en(t,null,r,n):oe(e,t,r,n),t.child;case 11:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Pi(e,t,r,l,n);case 7:return oe(e,t,t.pendingProps,n),t.child;case 8:return oe(e,t,t.pendingProps.children,n),t.child;case 12:return oe(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,l=t.pendingProps,u=t.memoizedProps,o=l.value,I(Hr,r._currentValue),r._currentValue=o,u!==null)if(Me(u.value,o)){if(u.children===l.children&&!de.current){t=Xe(e,t,n);break e}}else for(u=t.child,u!==null&&(u.return=t);u!==null;){var i=u.dependencies;if(i!==null){o=u.child;for(var s=i.firstContext;s!==null;){if(s.context===r){if(u.tag===1){s=We(-1,n&-n),s.tag=2;var c=u.updateQueue;if(c!==null){c=c.shared;var h=c.pending;h===null?s.next=s:(s.next=h.next,h.next=s),c.pending=s}}u.lanes|=n,s=u.alternate,s!==null&&(s.lanes|=n),ku(u.return,n,t),i.lanes|=n;break}s=s.next}}else if(u.tag===10)o=u.type===t.type?null:u.child;else if(u.tag===18){if(o=u.return,o===null)throw Error(y(341));o.lanes|=n,i=o.alternate,i!==null&&(i.lanes|=n),ku(o,n,t),o=u.sibling}else o=u.child;if(o!==null)o.return=u;else for(o=u;o!==null;){if(o===t){o=null;break}if(u=o.sibling,u!==null){u.return=o.return,o=u;break}o=o.return}u=o}oe(e,t,l.children,n),t=t.child}return t;case 9:return l=t.type,r=t.pendingProps.children,Gt(t,n),l=_e(l),r=r(l),t.flags|=1,oe(e,t,r,n),t.child;case 14:return r=t.type,l=Te(r,t.pendingProps),l=Te(r.type,l),zi(e,t,r,l,n);case 15:return Ta(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Nr(e,t),t.tag=1,pe(r)?(e=!0,Vr(t)):e=!1,Gt(t,n),Na(t,r,l),Cu(t,r,l,n),Nu(null,t,r,!0,e,n);case 19:return Ma(e,t,n);case 22:return La(e,t,n)}throw Error(y(156,t.tag))};function Za(e,t){return Cs(e,t)}function Ed(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ce(e,t,n,r){return new Ed(e,t,n,r)}function zo(e){return e=e.prototype,!(!e||!e.isReactComponent)}function Cd(e){if(typeof e=="function")return zo(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Ku)return 11;if(e===Yu)return 14}return 2}function ct(e,t){var n=e.alternate;return n===null?(n=Ce(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Tr(e,t,n,r,l,u){var o=2;if(r=e,typeof e=="function")zo(e)&&(o=1);else if(typeof e=="string")o=5;else e:switch(e){case Mt:return xt(n.children,l,u,t);case Qu:o=8,l|=8;break;case Yl:return e=Ce(12,n,t,l|2),e.elementType=Yl,e.lanes=u,e;case Xl:return e=Ce(13,n,t,l),e.elementType=Xl,e.lanes=u,e;case Gl:return e=Ce(19,n,t,l),e.elementType=Gl,e.lanes=u,e;case os:return fl(n,l,u,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case ls:o=10;break e;case us:o=9;break e;case Ku:o=11;break e;case Yu:o=14;break e;case Je:o=16,r=null;break e}throw Error(y(130,e==null?e:typeof e,""))}return t=Ce(o,n,t,l),t.elementType=e,t.type=r,t.lanes=u,t}function xt(e,t,n,r){return e=Ce(7,e,r,t),e.lanes=n,e}function fl(e,t,n,r){return e=Ce(22,e,r,t),e.elementType=os,e.lanes=n,e.stateNode={isHidden:!1},e}function Hl(e,t,n){return e=Ce(6,e,null,t),e.lanes=n,e}function Wl(e,t,n){return t=Ce(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function xd(e,t,n,r,l){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=xl(0),this.expirationTimes=xl(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=xl(0),this.identifierPrefix=r,this.onRecoverableError=l,this.mutableSourceEagerHydrationData=null}function To(e,t,n,r,l,u,o,i,s){return e=new xd(e,t,n,i,s),t===1?(t=1,u===!0&&(t|=8)):t=0,u=Ce(3,null,null,t),e.current=u,u.stateNode=e,u.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},fo(u),e}function _d(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Ot,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function Ja(e){if(!e)return dt;e=e._reactInternals;e:{if(Rt(e)!==e||e.tag!==1)throw Error(y(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(pe(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(y(171))}if(e.tag===1){var n=e.type;if(pe(n))return Js(e,n,t)}return t}function qa(e,t,n,r,l,u,o,i,s){return e=To(n,r,!0,e,l,u,o,i,s),e.context=Ja(null),n=e.current,r=ie(),l=at(n),u=We(r,l),u.callback=t??null,it(n,u,l),e.current.lanes=l,Gn(e,l,r),me(e,r),e}function dl(e,t,n,r){var l=t.current,u=ie(),o=at(l);return n=Ja(n),t.context===null?t.context=n:t.pendingContext=n,t=We(u,o),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=it(l,t,o),e!==null&&(Oe(e,l,o,u),Cr(e,l,o)),o}function br(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Vi(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function Lo(e,t){Vi(e,t),(e=e.alternate)&&Vi(e,t)}function Nd(){return null}var ba=typeof reportError=="function"?reportError:function(e){console.error(e)};function Ro(e){this._internalRoot=e}pl.prototype.render=Ro.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(y(409));dl(e,t,null,null)};pl.prototype.unmount=Ro.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Tt(function(){dl(null,e,null,null)}),t[Ke]=null}};function pl(e){this._internalRoot=e}pl.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ls();e={blockedOn:null,target:e,priority:t};for(var n=0;n<be.length&&t!==0&&t<be[n].priority;n++);be.splice(n,0,e),n===0&&js(e)}};function jo(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function ml(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function Bi(){}function Pd(e,t,n,r,l){if(l){if(typeof r=="function"){var u=r;r=function(){var c=br(o);u.call(c)}}var o=qa(t,r,e,0,null,!1,!1,"",Bi);return e._reactRootContainer=o,e[Ke]=o.current,An(e.nodeType===8?e.parentNode:e),Tt(),o}for(;l=e.lastChild;)e.removeChild(l);if(typeof r=="function"){var i=r;r=function(){var c=br(s);i.call(c)}}var s=To(e,0,!1,null,null,!1,!1,"",Bi);return e._reactRootContainer=s,e[Ke]=s.current,An(e.nodeType===8?e.parentNode:e),Tt(function(){dl(t,s,n,r)}),s}function hl(e,t,n,r,l){var u=n._reactRootContainer;if(u){var o=u;if(typeof l=="function"){var i=l;l=function(){var s=br(o);i.call(s)}}dl(t,o,e,l)}else o=Pd(n,t,e,l,r);return br(o)}zs=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=Sn(t.pendingLanes);n!==0&&(Zu(t,n|1),me(t,Q()),!(j&6)&&(rn=Q()+500,ht()))}break;case 13:Tt(function(){var r=Ye(e,1);if(r!==null){var l=ie();Oe(r,e,1,l)}}),Lo(e,1)}};Ju=function(e){if(e.tag===13){var t=Ye(e,134217728);if(t!==null){var n=ie();Oe(t,e,134217728,n)}Lo(e,134217728)}};Ts=function(e){if(e.tag===13){var t=at(e),n=Ye(e,t);if(n!==null){var r=ie();Oe(n,e,t,r)}Lo(e,t)}};Ls=function(){return M};Rs=function(e,t){var n=M;try{return M=e,t()}finally{M=n}};uu=function(e,t,n){switch(t){case"input":if(ql(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var l=ul(r);if(!l)throw Error(y(90));ss(r),ql(r,l)}}}break;case"textarea":cs(e,n);break;case"select":t=n.value,t!=null&&Qt(e,!!n.multiple,t,!1)}};ys=_o;gs=Tt;var zd={usingClientEntryPoint:!1,Events:[Jn,Ut,ul,hs,vs,_o]},yn={findFiberByHostInstance:St,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},Td={bundleType:yn.bundleType,version:yn.version,rendererPackageName:yn.rendererPackageName,rendererConfig:yn.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Ge.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=ks(e),e===null?null:e.stateNode},findFiberByHostInstance:yn.findFiberByHostInstance||Nd,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var yr=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yr.isDisabled&&yr.supportsFiber)try{tl=yr.inject(Td),Ue=yr}catch{}}we.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=zd;we.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!jo(t))throw Error(y(200));return _d(e,t,null,n)};we.createRoot=function(e,t){if(!jo(e))throw Error(y(299));var n=!1,r="",l=ba;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(l=t.onRecoverableError)),t=To(e,1,!1,null,null,n,!1,r,l),e[Ke]=t.current,An(e.nodeType===8?e.parentNode:e),new Ro(t)};we.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(y(188)):(e=Object.keys(e).join(","),Error(y(268,e)));return e=ks(t),e=e===null?null:e.stateNode,e};we.flushSync=function(e){return Tt(e)};we.hydrate=function(e,t,n){if(!ml(t))throw Error(y(200));return hl(null,e,t,!0,n)};we.hydrateRoot=function(e,t,n){if(!jo(e))throw Error(y(405));var r=n!=null&&n.hydratedSources||null,l=!1,u="",o=ba;if(n!=null&&(n.unstable_strictMode===!0&&(l=!0),n.identifierPrefix!==void 0&&(u=n.identifierPrefix),n.onRecoverableError!==void 0&&(o=n.onRecoverableError)),t=qa(t,null,e,1,n??null,l,!1,u,o),e[Ke]=t.current,An(e),r)for(e=0;e<r.length;e++)n=r[e],l=n._getVersion,l=l(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,l]:t.mutableSourceEagerHydrationData.push(n,l);return new pl(t)};we.render=function(e,t,n){if(!ml(t))throw Error(y(200));return hl(null,e,t,!1,n)};we.unmountComponentAtNode=function(e){if(!ml(e))throw Error(y(40));return e._reactRootContainer?(Tt(function(){hl(null,null,e,!1,function(){e._reactRootContainer=null,e[Ke]=null})}),!0):!1};we.unstable_batchedUpdates=_o;we.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!ml(n))throw Error(y(200));if(e==null||e._reactInternals===void 0)throw Error(y(38));return hl(e,t,n,!1,r)};we.version="18.3.1-next-f1338f8080-20240426";function ec(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ec)}catch(e){console.error(e)}}ec(),es.exports=we;var Ld=es.exports,$i=Ld;Ql.createRoot=$i.createRoot,Ql.hydrateRoot=$i.hydrateRoot;const Rd=2e3;function jd(){const[e,t]=Y.useState(!1),[n,r]=Y.useState(null),[l,u]=Y.useState("idle"),[o,i]=Y.useState(""),[s,c]=Y.useState(""),[h,m]=Y.useState(0),p=Y.useRef(null),g=Y.useRef(null),w=Y.useRef(null),S=Y.useRef(!1),D=Y.useRef(null);Y.useEffect(()=>()=>v(),[]);const f=Y.useCallback(async k=>{u("saving"),i("");try{const R=await(await fetch("./api/save.php",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({qr_text:k})})).json();R.success?(u("saved"),m(P=>P+1)):(u("error"),i(R.error||"Nieznany b≈ÇƒÖd serwera"))}catch{u("error"),i("Brak po≈ÇƒÖczenia z serwerem")}},[]),a=Y.useCallback(k=>{S.current||(S.current=!0,r(k),f(k),setTimeout(()=>{S.current=!1},Rd))},[f]),d=Y.useCallback(async()=>{var k;if(c(""),!("BarcodeDetector"in window)){c("Twoja przeglƒÖdarka nie obs≈Çuguje skanowania QR. U≈ºyj Chrome na Androidzie.");return}try{D.current=new BarcodeDetector({formats:["qr_code"]});const x=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:"environment"},width:{ideal:1920},height:{ideal:1080}},audio:!1});g.current=x;const R=p.current;R.srcObject=x,R.setAttribute("playsinline","true"),await R.play(),t(!0),w.current=setInterval(async()=>{if(!(!p.current||p.current.readyState<2))try{const P=await D.current.detect(p.current);P.length>0&&a(P[0].rawValue)}catch{}},150)}catch(x){const R=((k=x==null?void 0:x.toString)==null?void 0:k.call(x))||"Nie uda≈Ço siƒô uruchomiƒá kamery";R.includes("NotAllowedError")||R.includes("Permission")?c("Brak zgody na dostƒôp do kamery. Sprawd≈∫ ustawienia przeglƒÖdarki."):R.includes("NotFoundError")?c("Nie znaleziono kamery na tym urzƒÖdzeniu."):c(R)}},[a]),v=Y.useCallback(()=>{w.current&&(clearInterval(w.current),w.current=null),g.current&&(g.current.getTracks().forEach(k=>k.stop()),g.current=null),p.current&&(p.current.srcObject=null),D.current=null,t(!1)},[]),E=()=>{switch(l){case"saving":return"‚è≥";case"saved":return"‚úÖ";case"error":return"‚ùå";default:return"‚Äî"}},N=()=>{switch(l){case"saving":return"Zapisywanie‚Ä¶";case"saved":return"Zapisano pomy≈õlnie";case"error":return o||"WystƒÖpi≈Ç b≈ÇƒÖd";default:return"Oczekiwanie na skan"}};return O.jsxs("div",{className:"app",children:[O.jsxs("main",{className:"main",children:[O.jsxs("section",{className:"card scanner-card",children:[O.jsx("h2",{className:"scanner-title",children:"Skanuj kod QR"}),!e&&!s&&O.jsxs("div",{className:"scanner-placeholder-wrapper",children:[O.jsx("span",{className:"scanner-placeholder-icon",children:"üì∏"}),O.jsxs("span",{children:["Naci≈õnij przycisk poni≈ºej,",O.jsx("br",{}),"aby uruchomiƒá kamerƒô"]})]}),O.jsx("div",{className:"scanner-video-wrapper",style:{display:e?"block":"none"},children:O.jsx("video",{ref:p,className:"scanner-video",playsInline:!0,muted:!0})}),s&&O.jsxs("div",{className:"camera-error",children:[O.jsx("span",{className:"camera-error-icon",children:"‚ö†Ô∏è"}),O.jsx("span",{children:s})]}),O.jsx("div",{className:"scanner-controls",children:e?O.jsxs("button",{className:"btn btn-stop",onClick:v,children:[O.jsx("span",{className:"btn-icon",children:"‚èπ"}),"Zatrzymaj"]}):O.jsxs("button",{className:"btn btn-start",onClick:d,children:[O.jsx("span",{className:"btn-icon",children:"‚ñ∂"}),"Uruchom skaner"]})})]}),O.jsxs("section",{className:"card result-card",children:[O.jsx("h2",{className:"card-label",children:"Ostatni skan"}),O.jsx("div",{className:`scan-result ${n?"has-value":""}`,children:n||"Brak skan√≥w"})]}),O.jsxs("section",{className:`card status-card status-${l}`,children:[O.jsx("h2",{className:"card-label",children:"Status zapisu"}),O.jsxs("div",{className:"status-row",children:[O.jsx("span",{className:"status-icon",children:E()}),O.jsx("span",{className:"status-text",children:N()})]})]}),h>0&&O.jsxs("div",{className:"counter",children:["Zapisano dzisiaj: ",O.jsx("strong",{children:h})," ",h===1?"skan":h<5?"skany":"skan√≥w"]})]}),O.jsx("footer",{className:"footer",children:"Krawcowa App ¬∑ Skaner etykiet"})]})}Ql.createRoot(document.getElementById("root")).render(O.jsx(gc.StrictMode,{children:O.jsx(jd,{})}));[m
[1mdiff --git a/deploy/index.html b/deploy/index.html[m
[1mindex d4f67c2..47f356b 100644[m
[1m--- a/deploy/index.html[m
[1m+++ b/deploy/index.html[m
[36m@@ -9,7 +9,7 @@[m
     <link rel="preconnect" href="https://fonts.googleapis.com" />[m
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />[m
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />[m
[31m-    <script type="module" crossorigin src="./assets/index-D9s3s2jp.js"></script>[m
[32m+[m[32m    <script type="module" crossorigin src="./assets/index-CL4UxkMi.js"></script>[m
     <link rel="stylesheet" crossorigin href="./assets/index-BjN-r06w.css">[m
   </head>[m
   <body>[m
[1mdiff --git a/frontend/dist/assets/index-BjN-r06w.css b/frontend/dist/assets/index-BjN-r06w.css[m
[1mnew file mode 100644[m
[1mindex 0000000..b5c0920[m
[1m--- /dev/null[m
[1m+++ b/frontend/dist/assets/index-BjN-r06w.css[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32m*,*:before,*:after{box-sizing:border-box;margin:0;padding:0}:root{--color-bg: #0f172a;--color-bg-card: rgba(30, 41, 59, .7);--color-surface: #1e293b;--color-border: rgba(148, 163, 184, .15);--color-text: #f1f5f9;--color-text-muted: #94a3b8;--color-text-dim: #64748b;--color-accent: #6366f1;--color-accent-glow: rgba(99, 102, 241, .3);--color-success: #22c55e;--color-success-bg: rgba(34, 197, 94, .1);--color-error: #ef4444;--color-error-bg: rgba(239, 68, 68, .1);--color-warning: #f59e0b;--color-warning-bg: rgba(245, 158, 11, .1);--radius: 16px;--radius-sm: 10px;--shadow: 0 4px 24px rgba(0, 0, 0, .3);--transition: .25s cubic-bezier(.4, 0, .2, 1);--font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif}html{font-size:16px;-webkit-text-size-adjust:100%}body{font-family:var(--font);background:var(--color-bg);color:var(--color-text);line-height:1.6;min-height:100dvh;-webkit-font-smoothing:antialiased}body:before{content:"";position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(ellipse at 20% 0%,rgba(99,102,241,.12) 0%,transparent 60%),radial-gradient(ellipse at 80% 100%,rgba(139,92,246,.08) 0%,transparent 60%);pointer-events:none;z-index:0}.app{position:relative;z-index:1;display:flex;flex-direction:column;min-height:100dvh;max-width:480px;margin:0 auto;padding:0 16px}.main{flex:1;display:flex;flex-direction:column;gap:16px;padding-top:24px;padding-bottom:24px}.card{background:var(--color-bg-card);border:1px solid var(--color-border);border-radius:var(--radius);padding:20px;backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);box-shadow:var(--shadow)}.card-label{font-size:.75rem;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--color-text-muted);margin-bottom:10px}.scanner-card{padding:16px}.scanner-title{font-size:1.25rem;font-weight:700;text-align:center;margin-bottom:16px;color:var(--color-text);background:linear-gradient(135deg,#e2e8f0,#6366f1);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.scanner-placeholder-wrapper{width:100%;min-height:280px;border-radius:var(--radius-sm);background:var(--color-surface);border:2px dashed var(--color-border);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;color:var(--color-text-dim);font-size:.875rem;text-align:center;line-height:1.5}.scanner-placeholder-icon{font-size:3rem;opacity:.5}.scanner-video-wrapper{position:relative;border-radius:var(--radius-sm);overflow:hidden;border:2px solid var(--color-accent);box-shadow:0 0 20px var(--color-accent-glow)}.scanner-video{width:100%;display:block;background:#000}.focus-indicator{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70px;height:70px;border:3px solid #fff;border-radius:50%;animation:focus-pulse .6s ease-out forwards;pointer-events:none}@keyframes focus-pulse{0%{transform:translate(-50%,-50%) scale(1.3);opacity:1}to{transform:translate(-50%,-50%) scale(.9);opacity:0}}.tap-hint{position:absolute;bottom:8px;left:0;right:0;text-align:center;font-size:.7rem;color:#fff9;text-shadow:0 1px 3px rgba(0,0,0,.8);pointer-events:none}.zoom-control{display:flex;align-items:center;gap:10px;margin-top:12px;padding:8px 12px;background:var(--color-surface);border-radius:var(--radius-sm);border:1px solid var(--color-border)}.zoom-label{font-size:1.2rem;flex-shrink:0}.zoom-slider{flex:1;height:6px;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:var(--color-border);border-radius:3px;outline:none}.zoom-slider::-webkit-slider-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:24px;height:24px;border-radius:50%;background:var(--color-accent);cursor:pointer;box-shadow:0 0 8px var(--color-accent-glow)}.zoom-value{font-size:.85rem;font-weight:600;color:var(--color-accent);min-width:36px;text-align:right}.scanner-controls{margin-top:16px;display:flex;justify-content:center}.btn{display:inline-flex;align-items:center;gap:8px;padding:14px 28px;border:none;border-radius:var(--radius-sm);font-family:var(--font);font-size:1rem;font-weight:600;cursor:pointer;transition:all var(--transition);-webkit-tap-highlight-color:transparent;-webkit-user-select:none;user-select:none}.btn:active{transform:scale(.97)}.btn-icon{font-size:.875rem}.btn-start{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;box-shadow:0 4px 16px var(--color-accent-glow)}.btn-start:hover{box-shadow:0 6px 24px #6366f173}.btn-stop{background:#ef444426;color:var(--color-error);border:1px solid rgba(239,68,68,.3)}.btn-stop:hover{background:#ef444440}.camera-error{display:flex;align-items:flex-start;gap:10px;margin-top:12px;padding:12px 16px;background:var(--color-warning-bg);border:1px solid rgba(245,158,11,.25);border-radius:var(--radius-sm);font-size:.85rem;color:var(--color-warning);line-height:1.5}.camera-error-icon{flex-shrink:0;font-size:1.1rem}.scan-result{font-size:1rem;color:var(--color-text-dim);padding:12px 16px;background:var(--color-surface);border-radius:var(--radius-sm);border:1px solid var(--color-border);word-break:break-all;font-family:SF Mono,Fira Code,Consolas,monospace;min-height:44px;display:flex;align-items:center;transition:all var(--transition)}.scan-result.has-value{color:var(--color-text);border-color:#6366f14d;background:#6366f10f;animation:flash-in .3s ease-out}@keyframes flash-in{0%{background:#6366f133}to{background:#6366f10f}}.status-row{display:flex;align-items:center;gap:10px;padding:12px 16px;border-radius:var(--radius-sm);background:var(--color-surface);border:1px solid var(--color-border);transition:all var(--transition)}.status-icon{font-size:1.25rem;flex-shrink:0}.status-text{font-size:.9rem;font-weight:500}.status-saving .status-row{border-color:#6366f14d}.status-saving .status-icon{animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.status-saved .status-row{border-color:#22c55e4d;background:var(--color-success-bg)}.status-saved .status-text{color:var(--color-success)}.status-error .status-row{border-color:#ef44444d;background:var(--color-error-bg)}.status-error .status-text{color:var(--color-error)}.counter{text-align:center;font-size:.85rem;color:var(--color-text-muted);padding:12px;background:var(--color-bg-card);border-radius:var(--radius-sm);border:1px solid var(--color-border)}.counter strong{color:var(--color-accent);font-weight:700;font-size:1.1rem}.footer{text-align:center;padding:20px 0;font-size:.75rem;color:var(--color-text-dim);letter-spacing:.02em}@media (max-width: 360px){.btn{padding:12px 24px;font-size:.9rem}.scanner-placeholder-wrapper{min-height:240px}}@media (min-width: 481px){.app{padding:0 24px}}[m
[1mdiff --git a/frontend/dist/assets/index-CL4UxkMi.js b/frontend/dist/assets/index-CL4UxkMi.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d336c8e[m
[1m--- /dev/null[m
[1m+++ b/frontend/dist/assets/index-CL4UxkMi.js[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32m(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const l of document.querySelectorAll('link[rel="modulepreload"]'))r(l);new MutationObserver(l=>{for(const u of l)if(u.type==="childList")for(const o of u.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(l){const u={};return l.integrity&&(u.integrity=l.integrity),l.referrerPolicy&&(u.referrerPolicy=l.referrerPolicy),l.crossOrigin==="use-credentials"?u.credentials="include":l.crossOrigin==="anonymous"?u.credentials="omit":u.credentials="same-origin",u}function r(l){if(l.ep)return;l.ep=!0;const u=n(l);fetch(l.href,u)}})();function nc(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Hi={exports:{}},el={},Wi={exports:{}},L={};/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var Xn=Symbol.for("react.element"),rc=Symbol.for("react.portal"),lc=Symbol.for("react.fragment"),uc=Symbol.for("react.strict_mode"),oc=Symbol.for("react.profiler"),ic=Symbol.for("react.provider"),sc=Symbol.for("react.context"),ac=Symbol.for("react.forward_ref"),cc=Symbol.for("react.suspense"),fc=Symbol.for("react.memo"),dc=Symbol.for("react.lazy"),Mo=Symbol.iterator;function pc(e){return e===null||typeof e!="object"?null:(e=Mo&&e[Mo]||e["@@iterator"],typeof e=="function"?e:null)}var Qi={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Ki=Object.assign,Yi={};function ln(e,t,n){this.props=e,this.context=t,this.refs=Yi,this.updater=n||Qi}ln.prototype.isReactComponent={};ln.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};ln.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function Xi(){}Xi.prototype=ln.prototype;function Uu(e,t,n){this.props=e,this.context=t,this.refs=Yi,this.updater=n||Qi}var Au=Uu.prototype=new Xi;Au.constructor=Uu;Ki(Au,ln.prototype);Au.isPureReactComponent=!0;var Do=Array.isArray,Gi=Object.prototype.hasOwnProperty,Vu={current:null},Zi={key:!0,ref:!0,__self:!0,__source:!0};function Ji(e,t,n){var r,l={},u=null,o=null;if(t!=null)for(r in t.ref!==void 0&&(o=t.ref),t.key!==void 0&&(u=""+t.key),t)Gi.call(t,r)&&!Zi.hasOwnProperty(r)&&(l[r]=t[r]);var i=arguments.length-2;if(i===1)l.children=n;else if(1<i){for(var s=Array(i),c=0;c<i;c++)s[c]=arguments[c+2];l.children=s}if(e&&e.defaultProps)for(r in i=e.defaultProps,i)l[r]===void 0&&(l[r]=i[r]);return{$$typeof:Xn,type:e,key:u,ref:o,props:l,_owner:Vu.current}}function mc(e,t){return{$$typeof:Xn,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function Bu(e){return typeof e=="object"&&e!==null&&e.$$typeof===Xn}function hc(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var Io=/\/+/g;function wl(e,t){return typeof e=="object"&&e!==null&&e.key!=null?hc(""+e.key):t.toString(36)}function gr(e,t,n,r,l){var u=typeof e;(u==="undefined"||u==="boolean")&&(e=null);var o=!1;if(e===null)o=!0;else switch(u){case"string":case"number":o=!0;break;case"object":switch(e.$$typeof){case Xn:case rc:o=!0}}if(o)return o=e,l=l(o),e=r===""?"."+wl(o,0):r,Do(l)?(n="",e!=null&&(n=e.replace(Io,"$&/")+"/"),gr(l,t,n,"",function(c){return c})):l!=null&&(Bu(l)&&(l=mc(l,n+(!l.key||o&&o.key===l.key?"":(""+l.key).replace(Io,"$&/")+"/")+e)),t.push(l)),1;if(o=0,r=r===""?".":r+":",Do(e))for(var i=0;i<e.length;i++){u=e[i];var s=r+wl(u,i);o+=gr(u,t,n,s,l)}else if(s=pc(e),typeof s=="function")for(e=s.call(e),i=0;!(u=e.next()).done;)u=u.value,s=r+wl(u,i++),o+=gr(u,t,n,s,l);else if(u==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return o}function tr(e,t,n){if(e==null)return e;var r=[],l=0;return gr(e,r,"","",function(u){return t.call(n,u,l++)}),r}function vc(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var se={current:null},wr={transition:null},yc={ReactCurrentDispatcher:se,ReactCurrentBatchConfig:wr,ReactCurrentOwner:Vu};function qi(){throw Error("act(...) is not supported in production builds of React.")}L.Children={map:tr,forEach:function(e,t,n){tr(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return tr(e,function(){t++}),t},toArray:function(e){return tr(e,function(t){return t})||[]},only:function(e){if(!Bu(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};L.Component=ln;L.Fragment=lc;L.Profiler=oc;L.PureComponent=Uu;L.StrictMode=uc;L.Suspense=cc;L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=yc;L.act=qi;L.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=Ki({},e.props),l=e.key,u=e.ref,o=e._owner;if(t!=null){if(t.ref!==void 0&&(u=t.ref,o=Vu.current),t.key!==void 0&&(l=""+t.key),e.type&&e.type.defaultProps)var i=e.type.defaultProps;for(s in t)Gi.call(t,s)&&!Zi.hasOwnProperty(s)&&(r[s]=t[s]===void 0&&i!==void 0?i[s]:t[s])}var s=arguments.length-2;if(s===1)r.children=n;else if(1<s){i=Array(s);for(var c=0;c<s;c++)i[c]=arguments[c+2];r.children=i}return{$$typeof:Xn,type:e.type,key:l,ref:u,props:r,_owner:o}};L.createContext=function(e){return e={$$typeof:sc,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:ic,_context:e},e.Consumer=e};L.createElement=Ji;L.createFactory=function(e){var t=Ji.bind(null,e);return t.type=e,t};L.createRef=function(){return{current:null}};L.forwardRef=function(e){return{$$typeof:ac,render:e}};L.isValidElement=Bu;L.lazy=function(e){return{$$typeof:dc,_payload:{_status:-1,_result:e},_init:vc}};L.memo=function(e,t){return{$$typeof:fc,type:e,compare:t===void 0?null:t}};L.startTransition=function(e){var t=wr.transition;wr.transition={};try{e()}finally{wr.transition=t}};L.unstable_act=qi;L.useCallback=function(e,t){return se.current.useCallback(e,t)};L.useContext=function(e){return se.current.useContext(e)};L.useDebugValue=function(){};L.useDeferredValue=function(e){return se.current.useDeferredValue(e)};L.useEffect=function(e,t){return se.current.useEffect(e,t)};L.useId=function(){return se.current.useId()};L.useImperativeHandle=function(e,t,n){return se.current.useImperativeHandle(e,t,n)};L.useInsertionEffect=function(e,t){return se.current.useInsertionEffect(e,t)};L.useLayoutEffect=function(e,t){return se.current.useLayoutEffect(e,t)};L.useMemo=function(e,t){return se.current.useMemo(e,t)};L.useReducer=function(e,t,n){return se.current.useReducer(e,t,n)};L.useRef=function(e){return se.current.useRef(e)};L.useState=function(e){return se.current.useState(e)};L.useSyncExternalStore=function(e,t,n){return se.current.useSyncExternalStore(e,t,n)};L.useTransition=function(){return se.current.useTransition()};L.version="18.3.1";Wi.exports=L;var Y=Wi.exports;const gc=nc(Y);/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react-jsx-runtime.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var wc=Y,Sc=Symbol.for("react.element"),kc=Symbol.for("react.fragment"),Ec=Object.prototype.hasOwnProperty,Cc=wc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,xc={key:!0,ref:!0,__self:!0,__source:!0};function bi(e,t,n){var r,l={},u=null,o=null;n!==void 0&&(u=""+n),t.key!==void 0&&(u=""+t.key),t.ref!==void 0&&(o=t.ref);for(r in t)Ec.call(t,r)&&!xc.hasOwnProperty(r)&&(l[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)l[r]===void 0&&(l[r]=t[r]);return{$$typeof:Sc,type:e,key:u,ref:o,props:l,_owner:Cc.current}}el.Fragment=kc;el.jsx=bi;el.jsxs=bi;Hi.exports=el;var O=Hi.exports,Ql={},es={exports:{}},we={},ts={exports:{}},ns={};/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * scheduler.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */(function(e){function t(_,z){var T=_.length;_.push(z);e:for(;0<T;){var W=T-1>>>1,Z=_[W];if(0<l(Z,z))_[W]=z,_[T]=Z,T=W;else break e}}function n(_){return _.length===0?null:_[0]}function r(_){if(_.length===0)return null;var z=_[0],T=_.pop();if(T!==z){_[0]=T;e:for(var W=0,Z=_.length,bn=Z>>>1;W<bn;){var vt=2*(W+1)-1,gl=_[vt],yt=vt+1,er=_[yt];if(0>l(gl,T))yt<Z&&0>l(er,gl)?(_[W]=er,_[yt]=T,W=yt):(_[W]=gl,_[vt]=T,W=vt);else if(yt<Z&&0>l(er,T))_[W]=er,_[yt]=T,W=yt;else break e}}return z}function l(_,z){var T=_.sortIndex-z.sortIndex;return T!==0?T:_.id-z.id}if(typeof performance=="object"&&typeof performance.now=="function"){var u=performance;e.unstable_now=function(){return u.now()}}else{var o=Date,i=o.now();e.unstable_now=function(){return o.now()-i}}var s=[],c=[],h=1,m=null,p=3,g=!1,w=!1,S=!1,D=typeof setTimeout=="function"?setTimeout:null,f=typeof clearTimeout=="function"?clearTimeout:null,a=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function d(_){for(var z=n(c);z!==null;){if(z.callback===null)r(c);else if(z.startTime<=_)r(c),z.sortIndex=z.expirationTime,t(s,z);else break;z=n(c)}}function v(_){if(S=!1,d(_),!w)if(n(s)!==null)w=!0,vl(E);else{var z=n(c);z!==null&&yl(v,z.startTime-_)}}function E(_,z){w=!1,S&&(S=!1,f(x),x=-1),g=!0;var T=p;try{for(d(z),m=n(s);m!==null&&(!(m.expirationTime>z)||_&&!Pe());){var W=m.callback;if(typeof W=="function"){m.callback=null,p=m.priorityLevel;var Z=W(m.expirationTime<=z);z=e.unstable_now(),typeof Z=="function"?m.callback=Z:m===n(s)&&r(s),d(z)}else r(s);m=n(s)}if(m!==null)var bn=!0;else{var vt=n(c);vt!==null&&yl(v,vt.startTime-z),bn=!1}return bn}finally{m=null,p=T,g=!1}}var N=!1,k=null,x=-1,R=5,P=-1;function Pe(){return!(e.unstable_now()-P<R)}function sn(){if(k!==null){var _=e.unstable_now();P=_;var z=!0;try{z=k(!0,_)}finally{z?an():(N=!1,k=null)}}else N=!1}var an;if(typeof a=="function")an=function(){a(sn)};else if(typeof MessageChannel<"u"){var Oo=new MessageChannel,tc=Oo.port2;Oo.port1.onmessage=sn,an=function(){tc.postMessage(null)}}else an=function(){D(sn,0)};function vl(_){k=_,N||(N=!0,an())}function yl(_,z){x=D(function(){_(e.unstable_now())},z)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(_){_.callback=null},e.unstable_continueExecution=function(){w||g||(w=!0,vl(E))},e.unstable_forceFrameRate=function(_){0>_||125<_?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<_?Math.floor(1e3/_):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(s)},e.unstable_next=function(_){switch(p){case 1:case 2:case 3:var z=3;break;default:z=p}var T=p;p=z;try{return _()}finally{p=T}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(_,z){switch(_){case 1:case 2:case 3:case 4:case 5:break;default:_=3}var T=p;p=_;try{return z()}finally{p=T}},e.unstable_scheduleCallback=function(_,z,T){var W=e.unstable_now();switch(typeof T=="object"&&T!==null?(T=T.delay,T=typeof T=="number"&&0<T?W+T:W):T=W,_){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=T+Z,_={id:h++,callback:z,priorityLevel:_,startTime:T,expirationTime:Z,sortIndex:-1},T>W?(_.sortIndex=T,t(c,_),n(s)===null&&_===n(c)&&(S?(f(x),x=-1):S=!0,yl(v,T-W))):(_.sortIndex=Z,t(s,_),w||g||(w=!0,vl(E))),_},e.unstable_shouldYield=Pe,e.unstable_wrapCallback=function(_){var z=p;return function(){var T=p;p=z;try{return _.apply(this,arguments)}finally{p=T}}}})(ns);ts.exports=ns;var _c=ts.exports;/**[m
[32m+[m[32m * @license React[m
[32m+[m[32m * react-dom.production.min.js[m
[32m+[m[32m *[m
[32m+[m[32m * Copyright (c) Facebook, Inc. and its affiliates.[m
[32m+[m[32m *[m
[32m+[m[32m * This source code is licensed under the MIT license found in the[m
[32m+[m[32m * LICENSE file in the root directory of this source tree.[m
[32m+[m[32m */var Nc=Y,ge=_c;function y(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var rs=new Set,Rn={};function Lt(e,t){Jt(e,t),Jt(e+"Capture",t)}function Jt(e,t){for(Rn[e]=t,e=0;e<t.length;e++)rs.add(t[e])}var Qe=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Kl=Object.prototype.hasOwnProperty,Pc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Fo={},Uo={};function zc(e){return Kl.call(Uo,e)?!0:Kl.call(Fo,e)?!1:Pc.test(e)?Uo[e]=!0:(Fo[e]=!0,!1)}function Tc(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Lc(e,t,n,r){if(t===null||typeof t>"u"||Tc(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function ae(e,t,n,r,l,u,o){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=l,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=u,this.removeEmptyString=o}var te={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){te[e]=new ae(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];te[t]=new ae(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){te[e]=new ae(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){te[e]=new ae(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){te[e]=new ae(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){te[e]=new ae(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){te[e]=new ae(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){te[e]=new ae(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){te[e]=new ae(e,5,!1,e.toLowerCase(),null,!1,!1)});var $u=/[\-:]([a-z])/g;function Hu(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace($u,Hu);te[t]=new ae(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){te[e]=new ae(e,1,!1,e.toLowerCase(),null,!1,!1)});te.xlinkHref=new ae("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){te[e]=new ae(e,1,!1,e.toLowerCase(),null,!0,!0)});function Wu(e,t,n,r){var l=te.hasOwnProperty(t)?te[t]:null;(l!==null?l.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Lc(t,n,l,r)&&(n=null),r||l===null?zc(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):l.mustUseProperty?e[l.propertyName]=n===null?l.type===3?!1:"":n:(t=l.attributeName,r=l.attributeNamespace,n===null?e.removeAttribute(t):(l=l.type,n=l===3||l===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var Ge=Nc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,nr=Symbol.for("react.element"),Ot=Symbol.for("react.portal"),Mt=Symbol.for("react.fragment"),Qu=Symbol.for("react.strict_mode"),Yl=Symbol.for("react.profiler"),ls=Symbol.for("react.provider"),us=Symbol.for("react.context"),Ku=Symbol.for("react.forward_ref"),Xl=Symbol.for("react.suspense"),Gl=Symbol.for("react.suspense_list"),Yu=Symbol.for("react.memo"),Je=Symbol.for("react.lazy"),os=Symbol.for("react.offscreen"),Ao=Symbol.iterator;function cn(e){return e===null||typeof e!="object"?null:(e=Ao&&e[Ao]||e["@@iterator"],typeof e=="function"?e:null)}var $=Object.assign,Sl;function gn(e){if(Sl===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Sl=t&&t[1]||""}return`[m
[32m+[m[32m`+Sl+e}var kl=!1;function El(e,t){if(!e||kl)return"";kl=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(c){var r=c}Reflect.construct(e,[],t)}else{try{t.call()}catch(c){r=c}e.call(t.prototype)}else{try{throw Error()}catch(c){r=c}e()}}catch(c){if(c&&r&&typeof c.stack=="string"){for(var l=c.stack.split(`[m
[32m+[m[32m`),u=r.stack.split(`[m
[32m+[m[32m`),o=l.length-1,i=u.length-1;1<=o&&0<=i&&l[o]!==u[i];)i--;for(;1<=o&&0<=i;o--,i--)if(l[o]!==u[i]){if(o!==1||i!==1)do if(o--,i--,0>i||l[o]!==u[i]){var s=`[m
[32m+[m[32m`+l[o].replace(" at new "," at ");return e.displayName&&s.includes("<anonymous>")&&(s=s.replace("<anonymous>",e.displayName)),s}while(1<=o&&0<=i);break}}}finally{kl=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?gn(e):""}function Rc(e){switch(e.tag){case 5:return gn(e.type);case 16:return gn("Lazy");case 13:return gn("Suspense");case 19:return gn("SuspenseList");case 0:case 2:case 15:return e=El(e.type,!1),e;case 11:return e=El(e.type.render,!1),e;case 1:return e=El(e.type,!0),e;default:return""}}function Zl(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Mt:return"Fragment";case Ot:return"Portal";case Yl:return"Profiler";case Qu:return"StrictMode";case Xl:return"Suspense";case Gl:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case us:return(e.displayName||"Context")+".Consumer";case ls:return(e._context.displayName||"Context")+".Provider";case Ku:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Yu:return t=e.displayName||null,t!==null?t:Zl(e.type)||"Memo";case Je:t=e._payload,e=e._init;try{return Zl(e(t))}catch{}}return null}function jc(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Zl(t);case 8:return t===Qu?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function ft(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function is(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Oc(e){var t=is(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var l=n.get,u=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return l.call(this)},set:function(o){r=""+o,u.call(this,o)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(o){r=""+o},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function rr(e){e._valueTracker||(e._valueTracker=Oc(e))}function ss(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=is(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function Lr(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Jl(e,t){var n=t.checked;return $({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function Vo(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=ft(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function as(e,t){t=t.checked,t!=null&&Wu(e,"checked",t,!1)}function ql(e,t){as(e,t);var n=ft(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?bl(e,t.type,n):t.hasOwnProperty("defaultValue")&&bl(e,t.type,ft(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function Bo(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function bl(e,t,n){(t!=="number"||Lr(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var wn=Array.isArray;function Qt(e,t,n,r){if(e=e.options,t){t={};for(var l=0;l<n.length;l++)t["$"+n[l]]=!0;for(n=0;n<e.length;n++)l=t.hasOwnProperty("$"+e[n].value),e[n].selected!==l&&(e[n].selected=l),l&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ft(n),t=null,l=0;l<e.length;l++){if(e[l].value===n){e[l].selected=!0,r&&(e[l].defaultSelected=!0);return}t!==null||e[l].disabled||(t=e[l])}t!==null&&(t.selected=!0)}}function eu(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(y(91));return $({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function $o(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(y(92));if(wn(n)){if(1<n.length)throw Error(y(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:ft(n)}}function cs(e,t){var n=ft(t.value),r=ft(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function Ho(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function fs(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function tu(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?fs(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var lr,ds=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,l){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,l)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(lr=lr||document.createElement("div"),lr.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=lr.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function jn(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var En={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Mc=["Webkit","ms","Moz","O"];Object.keys(En).forEach(function(e){Mc.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),En[t]=En[e]})});function ps(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||En.hasOwnProperty(e)&&En[e]?(""+t).trim():t+"px"}function ms(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,l=ps(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,l):e[n]=l}}var Dc=$({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function nu(e,t){if(t){if(Dc[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(y(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(y(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(y(61))}if(t.style!=null&&typeof t.style!="object")throw Error(y(62))}}function ru(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var lu=null;function Xu(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var uu=null,Kt=null,Yt=null;function Wo(e){if(e=Jn(e)){if(typeof uu!="function")throw Error(y(280));var t=e.stateNode;t&&(t=ul(t),uu(e.stateNode,e.type,t))}}function hs(e){Kt?Yt?Yt.push(e):Yt=[e]:Kt=e}function vs(){if(Kt){var e=Kt,t=Yt;if(Yt=Kt=null,Wo(e),t)for(e=0;e<t.length;e++)Wo(t[e])}}function ys(e,t){return e(t)}function gs(){}var Cl=!1;function ws(e,t,n){if(Cl)return e(t,n);Cl=!0;try{return ys(e,t,n)}finally{Cl=!1,(Kt!==null||Yt!==null)&&(gs(),vs())}}function On(e,t){var n=e.stateNode;if(n===null)return null;var r=ul(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(y(231,t,typeof n));return n}var ou=!1;if(Qe)try{var fn={};Object.defineProperty(fn,"passive",{get:function(){ou=!0}}),window.addEventListener("test",fn,fn),window.removeEventListener("test",fn,fn)}catch{ou=!1}function Ic(e,t,n,r,l,u,o,i,s){var c=Array.prototype.slice.call(arguments,3);try{t.apply(n,c)}catch(h){this.onError(h)}}var Cn=!1,Rr=null,jr=!1,iu=null,Fc={onError:function(e){Cn=!0,Rr=e}};function Uc(e,t,n,r,l,u,o,i,s){Cn=!1,Rr=null,Ic.apply(Fc,arguments)}function Ac(e,t,n,r,l,u,o,i,s){if(Uc.apply(this,arguments),Cn){if(Cn){var c=Rr;Cn=!1,Rr=null}else throw Error(y(198));jr||(jr=!0,iu=c)}}function Rt(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function Ss(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function Qo(e){if(Rt(e)!==e)throw Error(y(188))}function Vc(e){var t=e.alternate;if(!t){if(t=Rt(e),t===null)throw Error(y(188));return t!==e?null:e}for(var n=e,r=t;;){var l=n.return;if(l===null)break;var u=l.alternate;if(u===null){if(r=l.return,r!==null){n=r;continue}break}if(l.child===u.child){for(u=l.child;u;){if(u===n)return Qo(l),e;if(u===r)return Qo(l),t;u=u.sibling}throw Error(y(188))}if(n.return!==r.return)n=l,r=u;else{for(var o=!1,i=l.child;i;){if(i===n){o=!0,n=l,r=u;break}if(i===r){o=!0,r=l,n=u;break}i=i.sibling}if(!o){for(i=u.child;i;){if(i===n){o=!0,n=u,r=l;break}if(i===r){o=!0,r=u,n=l;break}i=i.sibling}if(!o)throw Error(y(189))}}if(n.alternate!==r)throw Error(y(190))}if(n.tag!==3)throw Error(y(188));return n.stateNode.current===n?e:t}function ks(e){return e=Vc(e),e!==null?Es(e):null}function Es(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=Es(e);if(t!==null)return t;e=e.sibling}return null}var Cs=ge.unstable_scheduleCallback,Ko=ge.unstable_cancelCallback,Bc=ge.unstable_shouldYield,$c=ge.unstable_requestPaint,Q=ge.unstable_now,Hc=ge.unstable_getCurrentPriorityLevel,Gu=ge.unstable_ImmediatePriority,xs=ge.unstable_UserBlockingPriority,Or=ge.unstable_NormalPriority,Wc=ge.unstable_LowPriority,_s=ge.unstable_IdlePriority,tl=null,Ue=null;function Qc(e){if(Ue&&typeof Ue.onCommitFiberRoot=="function")try{Ue.onCommitFiberRoot(tl,e,void 0,(e.current.flags&128)===128)}catch{}}var je=Math.clz32?Math.clz32:Xc,Kc=Math.log,Yc=Math.LN2;function Xc(e){return e>>>=0,e===0?32:31-(Kc(e)/Yc|0)|0}var ur=64,or=4194304;function Sn(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Mr(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,l=e.suspendedLanes,u=e.pingedLanes,o=n&268435455;if(o!==0){var i=o&~l;i!==0?r=Sn(i):(u&=o,u!==0&&(r=Sn(u)))}else o=n&~l,o!==0?r=Sn(o):u!==0&&(r=Sn(u));if(r===0)return 0;if(t!==0&&t!==r&&!(t&l)&&(l=r&-r,u=t&-t,l>=u||l===16&&(u&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-je(t),l=1<<n,r|=e[n],t&=~l;return r}function Gc(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Zc(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,l=e.expirationTimes,u=e.pendingLanes;0<u;){var o=31-je(u),i=1<<o,s=l[o];s===-1?(!(i&n)||i&r)&&(l[o]=Gc(i,t)):s<=t&&(e.expiredLanes|=i),u&=~i}}function su(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Ns(){var e=ur;return ur<<=1,!(ur&4194240)&&(ur=64),e}function xl(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Gn(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-je(t),e[t]=n}function Jc(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var l=31-je(n),u=1<<l;t[l]=0,r[l]=-1,e[l]=-1,n&=~u}}function Zu(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-je(n),l=1<<r;l&t|e[r]&t&&(e[r]|=t),n&=~l}}var M=0;function Ps(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var zs,Ju,Ts,Ls,Rs,au=!1,ir=[],rt=null,lt=null,ut=null,Mn=new Map,Dn=new Map,be=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Yo(e,t){switch(e){case"focusin":case"focusout":rt=null;break;case"dragenter":case"dragleave":lt=null;break;case"mouseover":case"mouseout":ut=null;break;case"pointerover":case"pointerout":Mn.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Dn.delete(t.pointerId)}}function dn(e,t,n,r,l,u){return e===null||e.nativeEvent!==u?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:u,targetContainers:[l]},t!==null&&(t=Jn(t),t!==null&&Ju(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,l!==null&&t.indexOf(l)===-1&&t.push(l),e)}function bc(e,t,n,r,l){switch(t){case"focusin":return rt=dn(rt,e,t,n,r,l),!0;case"dragenter":return lt=dn(lt,e,t,n,r,l),!0;case"mouseover":return ut=dn(ut,e,t,n,r,l),!0;case"pointerover":var u=l.pointerId;return Mn.set(u,dn(Mn.get(u)||null,e,t,n,r,l)),!0;case"gotpointercapture":return u=l.pointerId,Dn.set(u,dn(Dn.get(u)||null,e,t,n,r,l)),!0}return!1}function js(e){var t=St(e.target);if(t!==null){var n=Rt(t);if(n!==null){if(t=n.tag,t===13){if(t=Ss(n),t!==null){e.blockedOn=t,Rs(e.priority,function(){Ts(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Sr(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=cu(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);lu=r,n.target.dispatchEvent(r),lu=null}else return t=Jn(n),t!==null&&Ju(t),e.blockedOn=n,!1;t.shift()}return!0}function Xo(e,t,n){Sr(e)&&n.delete(t)}function ef(){au=!1,rt!==null&&Sr(rt)&&(rt=null),lt!==null&&Sr(lt)&&(lt=null),ut!==null&&Sr(ut)&&(ut=null),Mn.forEach(Xo),Dn.forEach(Xo)}function pn(e,t){e.blockedOn===t&&(e.blockedOn=null,au||(au=!0,ge.unstable_scheduleCallback(ge.unstable_NormalPriority,ef)))}function In(e){function t(l){return pn(l,e)}if(0<ir.length){pn(ir[0],e);for(var n=1;n<ir.length;n++){var r=ir[n];r.blockedOn===e&&(r.blockedOn=null)}}for(rt!==null&&pn(rt,e),lt!==null&&pn(lt,e),ut!==null&&pn(ut,e),Mn.forEach(t),Dn.forEach(t),n=0;n<be.length;n++)r=be[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<be.length&&(n=be[0],n.blockedOn===null);)js(n),n.blockedOn===null&&be.shift()}var Xt=Ge.ReactCurrentBatchConfig,Dr=!0;function tf(e,t,n,r){var l=M,u=Xt.transition;Xt.transition=null;try{M=1,qu(e,t,n,r)}finally{M=l,Xt.transition=u}}function nf(e,t,n,r){var l=M,u=Xt.transition;Xt.transition=null;try{M=4,qu(e,t,n,r)}finally{M=l,Xt.transition=u}}function qu(e,t,n,r){if(Dr){var l=cu(e,t,n,r);if(l===null)Ml(e,t,r,Ir,n),Yo(e,r);else if(bc(l,e,t,n,r))r.stopPropagation();else if(Yo(e,r),t&4&&-1<qc.indexOf(e)){for(;l!==null;){var u=Jn(l);if(u!==null&&zs(u),u=cu(e,t,n,r),u===null&&Ml(e,t,r,Ir,n),u===l)break;l=u}l!==null&&r.stopPropagation()}else Ml(e,t,r,null,n)}}var Ir=null;function cu(e,t,n,r){if(Ir=null,e=Xu(r),e=St(e),e!==null)if(t=Rt(e),t===null)e=null;else if(n=t.tag,n===13){if(e=Ss(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Ir=e,null}function Os(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Hc()){case Gu:return 1;case xs:return 4;case Or:case Wc:return 16;case _s:return 536870912;default:return 16}default:return 16}}var tt=null,bu=null,kr=null;function Ms(){if(kr)return kr;var e,t=bu,n=t.length,r,l="value"in tt?tt.value:tt.textContent,u=l.length;for(e=0;e<n&&t[e]===l[e];e++);var o=n-e;for(r=1;r<=o&&t[n-r]===l[u-r];r++);return kr=l.slice(e,1<r?1-r:void 0)}function Er(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function sr(){return!0}function Go(){return!1}function Se(e){function t(n,r,l,u,o){this._reactName=n,this._targetInst=l,this.type=r,this.nativeEvent=u,this.target=o,this.currentTarget=null;for(var i in e)e.hasOwnProperty(i)&&(n=e[i],this[i]=n?n(u):u[i]);return this.isDefaultPrevented=(u.defaultPrevented!=null?u.defaultPrevented:u.returnValue===!1)?sr:Go,this.isPropagationStopped=Go,this}return $(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=sr)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=sr)},persist:function(){},isPersistent:sr}),t}var un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},eo=Se(un),Zn=$({},un,{view:0,detail:0}),rf=Se(Zn),_l,Nl,mn,nl=$({},Zn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:to,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==mn&&(mn&&e.type==="mousemove"?(_l=e.screenX-mn.screenX,Nl=e.screenY-mn.screenY):Nl=_l=0,mn=e),_l)},movementY:function(e){return"movementY"in e?e.movementY:Nl}}),Zo=Se(nl),lf=$({},nl,{dataTransfer:0}),uf=Se(lf),of=$({},Zn,{relatedTarget:0}),Pl=Se(of),sf=$({},un,{animationName:0,elapsedTime:0,pseudoElement:0}),af=Se(sf),cf=$({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),ff=Se(cf),df=$({},un,{data:0}),Jo=Se(df),pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},mf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},hf={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function vf(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=hf[e])?!!t[e]:!1}function to(){return vf}var yf=$({},Zn,{key:function(e){if(e.key){var t=pf[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Er(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?mf[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:to,charCode:function(e){return e.type==="keypress"?Er(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Er(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),gf=Se(yf),wf=$({},nl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),qo=Se(wf),Sf=$({},Zn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:to}),kf=Se(Sf),Ef=$({},un,{propertyName:0,elapsedTime:0,pseudoElement:0}),Cf=Se(Ef),xf=$({},nl,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),_f=Se(xf),Nf=[9,13,27,32],no=Qe&&"CompositionEvent"in window,xn=null;Qe&&"documentMode"in document&&(xn=document.documentMode);var Pf=Qe&&"TextEvent"in window&&!xn,Ds=Qe&&(!no||xn&&8<xn&&11>=xn),bo=" ",ei=!1;function Is(e,t){switch(e){case"keyup":return Nf.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Fs(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Dt=!1;function zf(e,t){switch(e){case"compositionend":return Fs(t);case"keypress":return t.which!==32?null:(ei=!0,bo);case"textInput":return e=t.data,e===bo&&ei?null:e;default:return null}}function Tf(e,t){if(Dt)return e==="compositionend"||!no&&Is(e,t)?(e=Ms(),kr=bu=tt=null,Dt=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ds&&t.locale!=="ko"?null:t.data;default:return null}}var Lf={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function ti(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!Lf[e.type]:t==="textarea"}function Us(e,t,n,r){hs(r),t=Fr(t,"onChange"),0<t.length&&(n=new eo("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var _n=null,Fn=null;function Rf(e){Gs(e,0)}function rl(e){var t=Ut(e);if(ss(t))return e}function jf(e,t){if(e==="change")return t}var As=!1;if(Qe){var zl;if(Qe){var Tl="oninput"in document;if(!Tl){var ni=document.createElement("div");ni.setAttribute("oninput","return;"),Tl=typeof ni.oninput=="function"}zl=Tl}else zl=!1;As=zl&&(!document.documentMode||9<document.documentMode)}function ri(){_n&&(_n.detachEvent("onpropertychange",Vs),Fn=_n=null)}function Vs(e){if(e.propertyName==="value"&&rl(Fn)){var t=[];Us(t,Fn,e,Xu(e)),ws(Rf,t)}}function Of(e,t,n){e==="focusin"?(ri(),_n=t,Fn=n,_n.attachEvent("onpropertychange",Vs)):e==="focusout"&&ri()}function Mf(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return rl(Fn)}function Df(e,t){if(e==="click")return rl(t)}function If(e,t){if(e==="input"||e==="change")return rl(t)}function Ff(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Me=typeof Object.is=="function"?Object.is:Ff;function Un(e,t){if(Me(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var l=n[r];if(!Kl.call(t,l)||!Me(e[l],t[l]))return!1}return!0}function li(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ui(e,t){var n=li(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=li(n)}}function Bs(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?Bs(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function $s(){for(var e=window,t=Lr();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=Lr(e.document)}return t}function ro(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function Uf(e){var t=$s(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&Bs(n.ownerDocument.documentElement,n)){if(r!==null&&ro(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var l=n.textContent.length,u=Math.min(r.start,l);r=r.end===void 0?u:Math.min(r.end,l),!e.extend&&u>r&&(l=r,r=u,u=l),l=ui(n,u);var o=ui(n,r);l&&o&&(e.rangeCount!==1||e.anchorNode!==l.node||e.anchorOffset!==l.offset||e.focusNode!==o.node||e.focusOffset!==o.offset)&&(t=t.createRange(),t.setStart(l.node,l.offset),e.removeAllRanges(),u>r?(e.addRange(t),e.extend(o.node,o.offset)):(t.setEnd(o.node,o.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Af=Qe&&"documentMode"in document&&11>=document.documentMode,It=null,fu=null,Nn=null,du=!1;function oi(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;du||It==null||It!==Lr(r)||(r=It,"selectionStart"in r&&ro(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Nn&&Un(Nn,r)||(Nn=r,r=Fr(fu,"onSelect"),0<r.length&&(t=new eo("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=It)))}function ar(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Ft={animationend:ar("Animation","AnimationEnd"),animationiteration:ar("Animation","AnimationIteration"),animationstart:ar("Animation","AnimationStart"),transitionend:ar("Transition","TransitionEnd")},Ll={},Hs={};Qe&&(Hs=document.createElement("div").style,"AnimationEvent"in window||(delete Ft.animationend.animation,delete Ft.animationiteration.animation,delete Ft.animationstart.animation),"TransitionEvent"in window||delete Ft.transitionend.transition);function ll(e){if(Ll[e])return Ll[e];if(!Ft[e])return e;var t=Ft[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in Hs)return Ll[e]=t[n];return e}var Ws=ll("animationend"),Qs=ll("animationiteration"),Ks=ll("animationstart"),Ys=ll("transitionend"),Xs=new Map,ii="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function pt(e,t){Xs.set(e,t),Lt(t,[e])}for(var Rl=0;Rl<ii.length;Rl++){var jl=ii[Rl],Vf=jl.toLowerCase(),Bf=jl[0].toUpperCase()+jl.slice(1);pt(Vf,"on"+Bf)}pt(Ws,"onAnimationEnd");pt(Qs,"onAnimationIteration");pt(Ks,"onAnimationStart");pt("dblclick","onDoubleClick");pt("focusin","onFocus");pt("focusout","onBlur");pt(Ys,"onTransitionEnd");Jt("onMouseEnter",["mouseout","mouseover"]);Jt("onMouseLeave",["mouseout","mouseover"]);Jt("onPointerEnter",["pointerout","pointerover"]);Jt("onPointerLeave",["pointerout","pointerover"]);Lt("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Lt("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Lt("onBeforeInput",["compositionend","keypress","textInput","paste"]);Lt("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Lt("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var kn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),$f=new Set("cancel close invalid load scroll toggle".split(" ").concat(kn));function si(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,Ac(r,t,void 0,e),e.currentTarget=null}function Gs(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],l=r.event;r=r.listeners;e:{var u=void 0;if(t)for(var o=r.length-1;0<=o;o--){var i=r[o],s=i.instance,c=i.currentTarget;if(i=i.listener,s!==u&&l.isPropagationStopped())break e;si(l,i,c),u=s}else for(o=0;o<r.length;o++){if(i=r[o],s=i.instance,c=i.currentTarget,i=i.listener,s!==u&&l.isPropagationStopped())break e;si(l,i,c),u=s}}}if(jr)throw e=iu,jr=!1,iu=null,e}function F(e,t){var n=t[yu];n===void 0&&(n=t[yu]=new Set);var r=e+"__bubble";n.has(r)||(Zs(t,e,2,!1),n.add(r))}function Ol(e,t,n){var r=0;t&&(r|=4),Zs(n,e,r,t)}var cr="_reactListening"+Math.random().toString(36).slice(2);function An(e){if(!e[cr]){e[cr]=!0,rs.forEach(function(n){n!=="selectionchange"&&($f.has(n)||Ol(n,!1,e),Ol(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[cr]||(t[cr]=!0,Ol("selectionchange",!1,t))}}function Zs(e,t,n,r){switch(Os(t)){case 1:var l=tf;break;case 4:l=nf;break;default:l=qu}n=l.bind(null,t,n,e),l=void 0,!ou||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(l=!0),r?l!==void 0?e.addEventListener(t,n,{capture:!0,passive:l}):e.addEventListener(t,n,!0):l!==void 0?e.addEventListener(t,n,{passive:l}):e.addEventListener(t,n,!1)}function Ml(e,t,n,r,l){var u=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var o=r.tag;if(o===3||o===4){var i=r.stateNode.containerInfo;if(i===l||i.nodeType===8&&i.parentNode===l)break;if(o===4)for(o=r.return;o!==null;){var s=o.tag;if((s===3||s===4)&&(s=o.stateNode.containerInfo,s===l||s.nodeType===8&&s.parentNode===l))return;o=o.return}for(;i!==null;){if(o=St(i),o===null)return;if(s=o.tag,s===5||s===6){r=u=o;continue e}i=i.parentNode}}r=r.return}ws(function(){var c=u,h=Xu(n),m=[];e:{var p=Xs.get(e);if(p!==void 0){var g=eo,w=e;switch(e){case"keypress":if(Er(n)===0)break e;case"keydown":case"keyup":g=gf;break;case"focusin":w="focus",g=Pl;break;case"focusout":w="blur",g=Pl;break;case"beforeblur":case"afterblur":g=Pl;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":g=Zo;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":g=uf;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":g=kf;break;case Ws:case Qs:case Ks:g=af;break;case Ys:g=Cf;break;case"scroll":g=rf;break;case"wheel":g=_f;break;case"copy":case"cut":case"paste":g=ff;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":g=qo}var S=(t&4)!==0,D=!S&&e==="scroll",f=S?p!==null?p+"Capture":null:p;S=[];for(var a=c,d;a!==null;){d=a;var v=d.stateNode;if(d.tag===5&&v!==null&&(d=v,f!==null&&(v=On(a,f),v!=null&&S.push(Vn(a,v,d)))),D)break;a=a.return}0<S.length&&(p=new g(p,w,null,n,h),m.push({event:p,listeners:S}))}}if(!(t&7)){e:{if(p=e==="mouseover"||e==="pointerover",g=e==="mouseout"||e==="pointerout",p&&n!==lu&&(w=n.relatedTarget||n.fromElement)&&(St(w)||w[Ke]))break e;if((g||p)&&(p=h.window===h?h:(p=h.ownerDocument)?p.defaultView||p.parentWindow:window,g?(w=n.relatedTarget||n.toElement,g=c,w=w?St(w):null,w!==null&&(D=Rt(w),w!==D||w.tag!==5&&w.tag!==6)&&(w=null)):(g=null,w=c),g!==w)){if(S=Zo,v="onMouseLeave",f="onMouseEnter",a="mouse",(e==="pointerout"||e==="pointerover")&&(S=qo,v="onPointerLeave",f="onPointerEnter",a="pointer"),D=g==null?p:Ut(g),d=w==null?p:Ut(w),p=new S(v,a+"leave",g,n,h),p.target=D,p.relatedTarget=d,v=null,St(h)===c&&(S=new S(f,a+"enter",w,n,h),S.target=d,S.relatedTarget=D,v=S),D=v,g&&w)t:{for(S=g,f=w,a=0,d=S;d;d=jt(d))a++;for(d=0,v=f;v;v=jt(v))d++;for(;0<a-d;)S=jt(S),a--;for(;0<d-a;)f=jt(f),d--;for(;a--;){if(S===f||f!==null&&S===f.alternate)break t;S=jt(S),f=jt(f)}S=null}else S=null;g!==null&&ai(m,p,g,S,!1),w!==null&&D!==null&&ai(m,D,w,S,!0)}}e:{if(p=c?Ut(c):window,g=p.nodeName&&p.nodeName.toLowerCase(),g==="select"||g==="input"&&p.type==="file")var E=jf;else if(ti(p))if(As)E=If;else{E=Mf;var N=Of}else(g=p.nodeName)&&g.toLowerCase()==="input"&&(p.type==="checkbox"||p.type==="radio")&&(E=Df);if(E&&(E=E(e,c))){Us(m,E,n,h);break e}N&&N(e,p,c),e==="focusout"&&(N=p._wrapperState)&&N.controlled&&p.type==="number"&&bl(p,"number",p.value)}switch(N=c?Ut(c):window,e){case"focusin":(ti(N)||N.contentEditable==="true")&&(It=N,fu=c,Nn=null);break;case"focusout":Nn=fu=It=null;break;case"mousedown":du=!0;break;case"contextmenu":case"mouseup":case"dragend":du=!1,oi(m,n,h);break;case"selectionchange":if(Af)break;case"keydown":case"keyup":oi(m,n,h)}var k;if(no)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Dt?Is(e,n)&&(x="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(x="onCompositionStart");x&&(Ds&&n.locale!=="ko"&&(Dt||x!=="onCompositionStart"?x==="onCompositionEnd"&&Dt&&(k=Ms()):(tt=h,bu="value"in tt?tt.value:tt.textContent,Dt=!0)),N=Fr(c,x),0<N.length&&(x=new Jo(x,e,null,n,h),m.push({event:x,listeners:N}),k?x.data=k:(k=Fs(n),k!==null&&(x.data=k)))),(k=Pf?zf(e,n):Tf(e,n))&&(c=Fr(c,"onBeforeInput"),0<c.length&&(h=new Jo("onBeforeInput","beforeinput",null,n,h),m.push({event:h,listeners:c}),h.data=k))}Gs(m,t)})}function Vn(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Fr(e,t){for(var n=t+"Capture",r=[];e!==null;){var l=e,u=l.stateNode;l.tag===5&&u!==null&&(l=u,u=On(e,n),u!=null&&r.unshift(Vn(e,u,l)),u=On(e,t),u!=null&&r.push(Vn(e,u,l))),e=e.return}return r}function jt(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function ai(e,t,n,r,l){for(var u=t._reactName,o=[];n!==null&&n!==r;){var i=n,s=i.alternate,c=i.stateNode;if(s!==null&&s===r)break;i.tag===5&&c!==null&&(i=c,l?(s=On(n,u),s!=null&&o.unshift(Vn(n,s,i))):l||(s=On(n,u),s!=null&&o.push(Vn(n,s,i)))),n=n.return}o.length!==0&&e.push({event:t,listeners:o})}var Hf=/\r\n?/g,Wf=/\u0000|\uFFFD/g;function ci(e){return(typeof e=="string"?e:""+e).replace(Hf,`[m
[32m+[m[32m`).replace(Wf,"")}function fr(e,t,n){if(t=ci(t),ci(e)!==t&&n)throw Error(y(425))}function Ur(){}var pu=null,mu=null;function hu(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var vu=typeof setTimeout=="function"?setTimeout:void 0,Qf=typeof clearTimeout=="function"?clearTimeout:void 0,fi=typeof Promise=="function"?Promise:void 0,Kf=typeof queueMicrotask=="function"?queueMicrotask:typeof fi<"u"?function(e){return fi.resolve(null).then(e).catch(Yf)}:vu;function Yf(e){setTimeout(function(){throw e})}function Dl(e,t){var n=t,r=0;do{var l=n.nextSibling;if(e.removeChild(n),l&&l.nodeType===8)if(n=l.data,n==="/$"){if(r===0){e.removeChild(l),In(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=l}while(n);In(t)}function ot(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function di(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var on=Math.random().toString(36).slice(2),Fe="__reactFiber$"+on,Bn="__reactProps$"+on,Ke="__reactContainer$"+on,yu="__reactEvents$"+on,Xf="__reactListeners$"+on,Gf="__reactHandles$"+on;function St(e){var t=e[Fe];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Ke]||n[Fe]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=di(e);e!==null;){if(n=e[Fe])return n;e=di(e)}return t}e=n,n=e.parentNode}return null}function Jn(e){return e=e[Fe]||e[Ke],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Ut(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(y(33))}function ul(e){return e[Bn]||null}var gu=[],At=-1;function mt(e){return{current:e}}function U(e){0>At||(e.current=gu[At],gu[At]=null,At--)}function I(e,t){At++,gu[At]=e.current,e.current=t}var dt={},ue=mt(dt),de=mt(!1),_t=dt;function qt(e,t){var n=e.type.contextTypes;if(!n)return dt;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var l={},u;for(u in n)l[u]=t[u];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=l),l}function pe(e){return e=e.childContextTypes,e!=null}function Ar(){U(de),U(ue)}function pi(e,t,n){if(ue.current!==dt)throw Error(y(168));I(ue,t),I(de,n)}function Js(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var l in r)if(!(l in t))throw Error(y(108,jc(e)||"Unknown",l));return $({},n,r)}function Vr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||dt,_t=ue.current,I(ue,e),I(de,de.current),!0}function mi(e,t,n){var r=e.stateNode;if(!r)throw Error(y(169));n?(e=Js(e,t,_t),r.__reactInternalMemoizedMergedChildContext=e,U(de),U(ue),I(ue,e)):U(de),I(de,n)}var Be=null,ol=!1,Il=!1;function qs(e){Be===null?Be=[e]:Be.push(e)}function Zf(e){ol=!0,qs(e)}function ht(){if(!Il&&Be!==null){Il=!0;var e=0,t=M;try{var n=Be;for(M=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}Be=null,ol=!1}catch(l){throw Be!==null&&(Be=Be.slice(e+1)),Cs(Gu,ht),l}finally{M=t,Il=!1}}return null}var Vt=[],Bt=0,Br=null,$r=0,ke=[],Ee=0,Nt=null,$e=1,He="";function gt(e,t){Vt[Bt++]=$r,Vt[Bt++]=Br,Br=e,$r=t}function bs(e,t,n){ke[Ee++]=$e,ke[Ee++]=He,ke[Ee++]=Nt,Nt=e;var r=$e;e=He;var l=32-je(r)-1;r&=~(1<<l),n+=1;var u=32-je(t)+l;if(30<u){var o=l-l%5;u=(r&(1<<o)-1).toString(32),r>>=o,l-=o,$e=1<<32-je(t)+l|n<<l|r,He=u+e}else $e=1<<u|n<<l|r,He=e}function lo(e){e.return!==null&&(gt(e,1),bs(e,1,0))}function uo(e){for(;e===Br;)Br=Vt[--Bt],Vt[Bt]=null,$r=Vt[--Bt],Vt[Bt]=null;for(;e===Nt;)Nt=ke[--Ee],ke[Ee]=null,He=ke[--Ee],ke[Ee]=null,$e=ke[--Ee],ke[Ee]=null}var ye=null,ve=null,A=!1,Re=null;function ea(e,t){var n=Ce(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function hi(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,ye=e,ve=ot(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,ye=e,ve=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Nt!==null?{id:$e,overflow:He}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Ce(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,ye=e,ve=null,!0):!1;default:return!1}}function wu(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Su(e){if(A){var t=ve;if(t){var n=t;if(!hi(e,t)){if(wu(e))throw Error(y(418));t=ot(n.nextSibling);var r=ye;t&&hi(e,t)?ea(r,n):(e.flags=e.flags&-4097|2,A=!1,ye=e)}}else{if(wu(e))throw Error(y(418));e.flags=e.flags&-4097|2,A=!1,ye=e}}}function vi(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;ye=e}function dr(e){if(e!==ye)return!1;if(!A)return vi(e),A=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!hu(e.type,e.memoizedProps)),t&&(t=ve)){if(wu(e))throw ta(),Error(y(418));for(;t;)ea(e,t),t=ot(t.nextSibling)}if(vi(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(y(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){ve=ot(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}ve=null}}else ve=ye?ot(e.stateNode.nextSibling):null;return!0}function ta(){for(var e=ve;e;)e=ot(e.nextSibling)}function bt(){ve=ye=null,A=!1}function oo(e){Re===null?Re=[e]:Re.push(e)}var Jf=Ge.ReactCurrentBatchConfig;function hn(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(y(309));var r=n.stateNode}if(!r)throw Error(y(147,e));var l=r,u=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===u?t.ref:(t=function(o){var i=l.refs;o===null?delete i[u]:i[u]=o},t._stringRef=u,t)}if(typeof e!="string")throw Error(y(284));if(!n._owner)throw Error(y(290,e))}return e}function pr(e,t){throw e=Object.prototype.toString.call(t),Error(y(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function yi(e){var t=e._init;return t(e._payload)}function na(e){function t(f,a){if(e){var d=f.deletions;d===null?(f.deletions=[a],f.flags|=16):d.push(a)}}function n(f,a){if(!e)return null;for(;a!==null;)t(f,a),a=a.sibling;return null}function r(f,a){for(f=new Map;a!==null;)a.key!==null?f.set(a.key,a):f.set(a.index,a),a=a.sibling;return f}function l(f,a){return f=ct(f,a),f.index=0,f.sibling=null,f}function u(f,a,d){return f.index=d,e?(d=f.alternate,d!==null?(d=d.index,d<a?(f.flags|=2,a):d):(f.flags|=2,a)):(f.flags|=1048576,a)}function o(f){return e&&f.alternate===null&&(f.flags|=2),f}function i(f,a,d,v){return a===null||a.tag!==6?(a=Hl(d,f.mode,v),a.return=f,a):(a=l(a,d),a.return=f,a)}function s(f,a,d,v){var E=d.type;return E===Mt?h(f,a,d.props.children,v,d.key):a!==null&&(a.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===Je&&yi(E)===a.type)?(v=l(a,d.props),v.ref=hn(f,a,d),v.return=f,v):(v=Tr(d.type,d.key,d.props,null,f.mode,v),v.ref=hn(f,a,d),v.return=f,v)}function c(f,a,d,v){return a===null||a.tag!==4||a.stateNode.containerInfo!==d.containerInfo||a.stateNode.implementation!==d.implementation?(a=Wl(d,f.mode,v),a.return=f,a):(a=l(a,d.children||[]),a.return=f,a)}function h(f,a,d,v,E){return a===null||a.tag!==7?(a=xt(d,f.mode,v,E),a.return=f,a):(a=l(a,d),a.return=f,a)}function m(f,a,d){if(typeof a=="string"&&a!==""||typeof a=="number")return a=Hl(""+a,f.mode,d),a.return=f,a;if(typeof a=="object"&&a!==null){switch(a.$$typeof){case nr:return d=Tr(a.type,a.key,a.props,null,f.mode,d),d.ref=hn(f,null,a),d.return=f,d;case Ot:return a=Wl(a,f.mode,d),a.return=f,a;case Je:var v=a._init;return m(f,v(a._payload),d)}if(wn(a)||cn(a))return a=xt(a,f.mode,d,null),a.return=f,a;pr(f,a)}return null}function p(f,a,d,v){var E=a!==null?a.key:null;if(typeof d=="string"&&d!==""||typeof d=="number")return E!==null?null:i(f,a,""+d,v);if(typeof d=="object"&&d!==null){switch(d.$$typeof){case nr:return d.key===E?s(f,a,d,v):null;case Ot:return d.key===E?c(f,a,d,v):null;case Je:return E=d._init,p(f,a,E(d._payload),v)}if(wn(d)||cn(d))return E!==null?null:h(f,a,d,v,null);pr(f,d)}return null}function g(f,a,d,v,E){if(typeof v=="string"&&v!==""||typeof v=="number")return f=f.get(d)||null,i(a,f,""+v,E);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case nr:return f=f.get(v.key===null?d:v.key)||null,s(a,f,v,E);case Ot:return f=f.get(v.key===null?d:v.key)||null,c(a,f,v,E);case Je:var N=v._init;return g(f,a,d,N(v._payload),E)}if(wn(v)||cn(v))return f=f.get(d)||null,h(a,f,v,E,null);pr(a,v)}return null}function w(f,a,d,v){for(var E=null,N=null,k=a,x=a=0,R=null;k!==null&&x<d.length;x++){k.index>x?(R=k,k=null):R=k.sibling;var P=p(f,k,d[x],v);if(P===null){k===null&&(k=R);break}e&&k&&P.alternate===null&&t(f,k),a=u(P,a,x),N===null?E=P:N.sibling=P,N=P,k=R}if(x===d.length)return n(f,k),A&&gt(f,x),E;if(k===null){for(;x<d.length;x++)k=m(f,d[x],v),k!==null&&(a=u(k,a,x),N===null?E=k:N.sibling=k,N=k);return A&&gt(f,x),E}for(k=r(f,k);x<d.length;x++)R=g(k,f,x,d[x],v),R!==null&&(e&&R.alternate!==null&&k.delete(R.key===null?x:R.key),a=u(R,a,x),N===null?E=R:N.sibling=R,N=R);return e&&k.forEach(function(Pe){return t(f,Pe)}),A&&gt(f,x),E}function S(f,a,d,v){var E=cn(d);if(typeof E!="function")throw Error(y(150));if(d=E.call(d),d==null)throw Error(y(151));for(var N=E=null,k=a,x=a=0,R=null,P=d.next();k!==null&&!P.done;x++,P=d.next()){k.index>x?(R=k,k=null):R=k.sibling;var Pe=p(f,k,P.value,v);if(Pe===null){k===null&&(k=R);break}e&&k&&Pe.alternate===null&&t(f,k),a=u(Pe,a,x),N===null?E=Pe:N.sibling=Pe,N=Pe,k=R}if(P.done)return n(f,k),A&&gt(f,x),E;if(k===null){for(;!P.done;x++,P=d.next())P=m(f,P.value,v),P!==null&&(a=u(P,a,x),N===null?E=P:N.sibling=P,N=P);return A&&gt(f,x),E}for(k=r(f,k);!P.done;x++,P=d.next())P=g(k,f,x,P.value,v),P!==null&&(e&&P.alternate!==null&&k.delete(P.key===null?x:P.key),a=u(P,a,x),N===null?E=P:N.sibling=P,N=P);return e&&k.forEach(function(sn){return t(f,sn)}),A&&gt(f,x),E}function D(f,a,d,v){if(typeof d=="object"&&d!==null&&d.type===Mt&&d.key===null&&(d=d.props.children),typeof d=="object"&&d!==null){switch(d.$$typeof){case nr:e:{for(var E=d.key,N=a;N!==null;){if(N.key===E){if(E=d.type,E===Mt){if(N.tag===7){n(f,N.sibling),a=l(N,d.props.children),a.return=f,f=a;break e}}else if(N.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===Je&&yi(E)===N.type){n(f,N.sibling),a=l(N,d.props),a.ref=hn(f,N,d),a.return=f,f=a;break e}n(f,N);break}else t(f,N);N=N.sibling}d.type===Mt?(a=xt(d.props.children,f.mode,v,d.key),a.return=f,f=a):(v=Tr(d.type,d.key,d.props,null,f.mode,v),v.ref=hn(f,a,d),v.return=f,f=v)}return o(f);case Ot:e:{for(N=d.key;a!==null;){if(a.key===N)if(a.tag===4&&a.stateNode.containerInfo===d.containerInfo&&a.stateNode.implementation===d.implementation){n(f,a.sibling),a=l(a,d.children||[]),a.return=f,f=a;break e}else{n(f,a);break}else t(f,a);a=a.sibling}a=Wl(d,f.mode,v),a.return=f,f=a}return o(f);case Je:return N=d._init,D(f,a,N(d._payload),v)}if(wn(d))return w(f,a,d,v);if(cn(d))return S(f,a,d,v);pr(f,d)}return typeof d=="string"&&d!==""||typeof d=="number"?(d=""+d,a!==null&&a.tag===6?(n(f,a.sibling),a=l(a,d),a.return=f,f=a):(n(f,a),a=Hl(d,f.mode,v),a.return=f,f=a),o(f)):n(f,a)}return D}var en=na(!0),ra=na(!1),Hr=mt(null),Wr=null,$t=null,io=null;function so(){io=$t=Wr=null}function ao(e){var t=Hr.current;U(Hr),e._currentValue=t}function ku(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Gt(e,t){Wr=e,io=$t=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(fe=!0),e.firstContext=null)}function _e(e){var t=e._currentValue;if(io!==e)if(e={context:e,memoizedValue:t,next:null},$t===null){if(Wr===null)throw Error(y(308));$t=e,Wr.dependencies={lanes:0,firstContext:e}}else $t=$t.next=e;return t}var kt=null;function co(e){kt===null?kt=[e]:kt.push(e)}function la(e,t,n,r){var l=t.interleaved;return l===null?(n.next=n,co(t)):(n.next=l.next,l.next=n),t.interleaved=n,Ye(e,r)}function Ye(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var qe=!1;function fo(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function ua(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function We(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function it(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,j&2){var l=r.pending;return l===null?t.next=t:(t.next=l.next,l.next=t),r.pending=t,Ye(e,n)}return l=r.interleaved,l===null?(t.next=t,co(r)):(t.next=l.next,l.next=t),r.interleaved=t,Ye(e,n)}function Cr(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Zu(e,n)}}function gi(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var l=null,u=null;if(n=n.firstBaseUpdate,n!==null){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};u===null?l=u=o:u=u.next=o,n=n.next}while(n!==null);u===null?l=u=t:u=u.next=t}else l=u=t;n={baseState:r.baseState,firstBaseUpdate:l,lastBaseUpdate:u,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Qr(e,t,n,r){var l=e.updateQueue;qe=!1;var u=l.firstBaseUpdate,o=l.lastBaseUpdate,i=l.shared.pending;if(i!==null){l.shared.pending=null;var s=i,c=s.next;s.next=null,o===null?u=c:o.next=c,o=s;var h=e.alternate;h!==null&&(h=h.updateQueue,i=h.lastBaseUpdate,i!==o&&(i===null?h.firstBaseUpdate=c:i.next=c,h.lastBaseUpdate=s))}if(u!==null){var m=l.baseState;o=0,h=c=s=null,i=u;do{var p=i.lane,g=i.eventTime;if((r&p)===p){h!==null&&(h=h.next={eventTime:g,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var w=e,S=i;switch(p=t,g=n,S.tag){case 1:if(w=S.payload,typeof w=="function"){m=w.call(g,m,p);break e}m=w;break e;case 3:w.flags=w.flags&-65537|128;case 0:if(w=S.payload,p=typeof w=="function"?w.call(g,m,p):w,p==null)break e;m=$({},m,p);break e;case 2:qe=!0}}i.callback!==null&&i.lane!==0&&(e.flags|=64,p=l.effects,p===null?l.effects=[i]:p.push(i))}else g={eventTime:g,lane:p,tag:i.tag,payload:i.payload,callback:i.callback,next:null},h===null?(c=h=g,s=m):h=h.next=g,o|=p;if(i=i.next,i===null){if(i=l.shared.pending,i===null)break;p=i,i=p.next,p.next=null,l.lastBaseUpdate=p,l.shared.pending=null}}while(!0);if(h===null&&(s=m),l.baseState=s,l.firstBaseUpdate=c,l.lastBaseUpdate=h,t=l.shared.interleaved,t!==null){l=t;do o|=l.lane,l=l.next;while(l!==t)}else u===null&&(l.shared.lanes=0);zt|=o,e.lanes=o,e.memoizedState=m}}function wi(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],l=r.callback;if(l!==null){if(r.callback=null,r=n,typeof l!="function")throw Error(y(191,l));l.call(r)}}}var qn={},Ae=mt(qn),$n=mt(qn),Hn=mt(qn);function Et(e){if(e===qn)throw Error(y(174));return e}function po(e,t){switch(I(Hn,t),I($n,e),I(Ae,qn),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:tu(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=tu(t,e)}U(Ae),I(Ae,t)}function tn(){U(Ae),U($n),U(Hn)}function oa(e){Et(Hn.current);var t=Et(Ae.current),n=tu(t,e.type);t!==n&&(I($n,e),I(Ae,n))}function mo(e){$n.current===e&&(U(Ae),U($n))}var V=mt(0);function Kr(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Fl=[];function ho(){for(var e=0;e<Fl.length;e++)Fl[e]._workInProgressVersionPrimary=null;Fl.length=0}var xr=Ge.ReactCurrentDispatcher,Ul=Ge.ReactCurrentBatchConfig,Pt=0,B=null,X=null,J=null,Yr=!1,Pn=!1,Wn=0,qf=0;function ne(){throw Error(y(321))}function vo(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Me(e[n],t[n]))return!1;return!0}function yo(e,t,n,r,l,u){if(Pt=u,B=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,xr.current=e===null||e.memoizedState===null?nd:rd,e=n(r,l),Pn){u=0;do{if(Pn=!1,Wn=0,25<=u)throw Error(y(301));u+=1,J=X=null,t.updateQueue=null,xr.current=ld,e=n(r,l)}while(Pn)}if(xr.current=Xr,t=X!==null&&X.next!==null,Pt=0,J=X=B=null,Yr=!1,t)throw Error(y(300));return e}function go(){var e=Wn!==0;return Wn=0,e}function Ie(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return J===null?B.memoizedState=J=e:J=J.next=e,J}function Ne(){if(X===null){var e=B.alternate;e=e!==null?e.memoizedState:null}else e=X.next;var t=J===null?B.memoizedState:J.next;if(t!==null)J=t,X=e;else{if(e===null)throw Error(y(310));X=e,e={memoizedState:X.memoizedState,baseState:X.baseState,baseQueue:X.baseQueue,queue:X.queue,next:null},J===null?B.memoizedState=J=e:J=J.next=e}return J}function Qn(e,t){return typeof t=="function"?t(e):t}function Al(e){var t=Ne(),n=t.queue;if(n===null)throw Error(y(311));n.lastRenderedReducer=e;var r=X,l=r.baseQueue,u=n.pending;if(u!==null){if(l!==null){var o=l.next;l.next=u.next,u.next=o}r.baseQueue=l=u,n.pending=null}if(l!==null){u=l.next,r=r.baseState;var i=o=null,s=null,c=u;do{var h=c.lane;if((Pt&h)===h)s!==null&&(s=s.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var m={lane:h,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};s===null?(i=s=m,o=r):s=s.next=m,B.lanes|=h,zt|=h}c=c.next}while(c!==null&&c!==u);s===null?o=r:s.next=i,Me(r,t.memoizedState)||(fe=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=s,n.lastRenderedState=r}if(e=n.interleaved,e!==null){l=e;do u=l.lane,B.lanes|=u,zt|=u,l=l.next;while(l!==e)}else l===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Vl(e){var t=Ne(),n=t.queue;if(n===null)throw Error(y(311));n.lastRenderedReducer=e;var r=n.dispatch,l=n.pending,u=t.memoizedState;if(l!==null){n.pending=null;var o=l=l.next;do u=e(u,o.action),o=o.next;while(o!==l);Me(u,t.memoizedState)||(fe=!0),t.memoizedState=u,t.baseQueue===null&&(t.baseState=u),n.lastRenderedState=u}return[u,r]}function ia(){}function sa(e,t){var n=B,r=Ne(),l=t(),u=!Me(r.memoizedState,l);if(u&&(r.memoizedState=l,fe=!0),r=r.queue,wo(fa.bind(null,n,r,e),[e]),r.getSnapshot!==t||u||J!==null&&J.memoizedState.tag&1){if(n.flags|=2048,Kn(9,ca.bind(null,n,r,l,t),void 0,null),q===null)throw Error(y(349));Pt&30||aa(n,t,l)}return l}function aa(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=B.updateQueue,t===null?(t={lastEffect:null,stores:null},B.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function ca(e,t,n,r){t.value=n,t.getSnapshot=r,da(t)&&pa(e)}function fa(e,t,n){return n(function(){da(t)&&pa(e)})}function da(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Me(e,n)}catch{return!0}}function pa(e){var t=Ye(e,1);t!==null&&Oe(t,e,1,-1)}function Si(e){var t=Ie();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Qn,lastRenderedState:e},t.queue=e,e=e.dispatch=td.bind(null,B,e),[t.memoizedState,e]}function Kn(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=B.updateQueue,t===null?(t={lastEffect:null,stores:null},B.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function ma(){return Ne().memoizedState}function _r(e,t,n,r){var l=Ie();B.flags|=e,l.memoizedState=Kn(1|t,n,void 0,r===void 0?null:r)}function il(e,t,n,r){var l=Ne();r=r===void 0?null:r;var u=void 0;if(X!==null){var o=X.memoizedState;if(u=o.destroy,r!==null&&vo(r,o.deps)){l.memoizedState=Kn(t,n,u,r);return}}B.flags|=e,l.memoizedState=Kn(1|t,n,u,r)}function ki(e,t){return _r(8390656,8,e,t)}function wo(e,t){return il(2048,8,e,t)}function ha(e,t){return il(4,2,e,t)}function va(e,t){return il(4,4,e,t)}function ya(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function ga(e,t,n){return n=n!=null?n.concat([e]):null,il(4,4,ya.bind(null,t,e),n)}function So(){}function wa(e,t){var n=Ne();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&vo(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Sa(e,t){var n=Ne();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&vo(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function ka(e,t,n){return Pt&21?(Me(n,t)||(n=Ns(),B.lanes|=n,zt|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,fe=!0),e.memoizedState=n)}function bf(e,t){var n=M;M=n!==0&&4>n?n:4,e(!0);var r=Ul.transition;Ul.transition={};try{e(!1),t()}finally{M=n,Ul.transition=r}}function Ea(){return Ne().memoizedState}function ed(e,t,n){var r=at(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ca(e))xa(t,n);else if(n=la(e,t,n,r),n!==null){var l=ie();Oe(n,e,r,l),_a(n,t,r)}}function td(e,t,n){var r=at(e),l={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ca(e))xa(t,l);else{var u=e.alternate;if(e.lanes===0&&(u===null||u.lanes===0)&&(u=t.lastRenderedReducer,u!==null))try{var o=t.lastRenderedState,i=u(o,n);if(l.hasEagerState=!0,l.eagerState=i,Me(i,o)){var s=t.interleaved;s===null?(l.next=l,co(t)):(l.next=s.next,s.next=l),t.interleaved=l;return}}catch{}finally{}n=la(e,t,l,r),n!==null&&(l=ie(),Oe(n,e,r,l),_a(n,t,r))}}function Ca(e){var t=e.alternate;return e===B||t!==null&&t===B}function xa(e,t){Pn=Yr=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function _a(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Zu(e,n)}}var Xr={readContext:_e,useCallback:ne,useContext:ne,useEffect:ne,useImperativeHandle:ne,useInsertionEffect:ne,useLayoutEffect:ne,useMemo:ne,useReducer:ne,useRef:ne,useState:ne,useDebugValue:ne,useDeferredValue:ne,useTransition:ne,useMutableSource:ne,useSyncExternalStore:ne,useId:ne,unstable_isNewReconciler:!1},nd={readContext:_e,useCallback:function(e,t){return Ie().memoizedState=[e,t===void 0?null:t],e},useContext:_e,useEffect:ki,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,_r(4194308,4,ya.bind(null,t,e),n)},useLayoutEffect:function(e,t){return _r(4194308,4,e,t)},useInsertionEffect:function(e,t){return _r(4,2,e,t)},useMemo:function(e,t){var n=Ie();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Ie();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=ed.bind(null,B,e),[r.memoizedState,e]},useRef:function(e){var t=Ie();return e={current:e},t.memoizedState=e},useState:Si,useDebugValue:So,useDeferredValue:function(e){return Ie().memoizedState=e},useTransition:function(){var e=Si(!1),t=e[0];return e=bf.bind(null,e[1]),Ie().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=B,l=Ie();if(A){if(n===void 0)throw Error(y(407));n=n()}else{if(n=t(),q===null)throw Error(y(349));Pt&30||aa(r,t,n)}l.memoizedState=n;var u={value:n,getSnapshot:t};return l.queue=u,ki(fa.bind(null,r,u,e),[e]),r.flags|=2048,Kn(9,ca.bind(null,r,u,n,t),void 0,null),n},useId:function(){var e=Ie(),t=q.identifierPrefix;if(A){var n=He,r=$e;n=(r&~(1<<32-je(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=Wn++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=qf++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},rd={readContext:_e,useCallback:wa,useContext:_e,useEffect:wo,useImperativeHandle:ga,useInsertionEffect:ha,useLayoutEffect:va,useMemo:Sa,useReducer:Al,useRef:ma,useState:function(){return Al(Qn)},useDebugValue:So,useDeferredValue:function(e){var t=Ne();return ka(t,X.memoizedState,e)},useTransition:function(){var e=Al(Qn)[0],t=Ne().memoizedState;return[e,t]},useMutableSource:ia,useSyncExternalStore:sa,useId:Ea,unstable_isNewReconciler:!1},ld={readContext:_e,useCallback:wa,useContext:_e,useEffect:wo,useImperativeHandle:ga,useInsertionEffect:ha,useLayoutEffect:va,useMemo:Sa,useReducer:Vl,useRef:ma,useState:function(){return Vl(Qn)},useDebugValue:So,useDeferredValue:function(e){var t=Ne();return X===null?t.memoizedState=e:ka(t,X.memoizedState,e)},useTransition:function(){var e=Vl(Qn)[0],t=Ne().memoizedState;return[e,t]},useMutableSource:ia,useSyncExternalStore:sa,useId:Ea,unstable_isNewReconciler:!1};function Te(e,t){if(e&&e.defaultProps){t=$({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function Eu(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:$({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var sl={isMounted:function(e){return(e=e._reactInternals)?Rt(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=ie(),l=at(e),u=We(r,l);u.payload=t,n!=null&&(u.callback=n),t=it(e,u,l),t!==null&&(Oe(t,e,l,r),Cr(t,e,l))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=ie(),l=at(e),u=We(r,l);u.tag=1,u.payload=t,n!=null&&(u.callback=n),t=it(e,u,l),t!==null&&(Oe(t,e,l,r),Cr(t,e,l))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ie(),r=at(e),l=We(n,r);l.tag=2,t!=null&&(l.callback=t),t=it(e,l,r),t!==null&&(Oe(t,e,r,n),Cr(t,e,r))}};function Ei(e,t,n,r,l,u,o){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,u,o):t.prototype&&t.prototype.isPureReactComponent?!Un(n,r)||!Un(l,u):!0}function Na(e,t,n){var r=!1,l=dt,u=t.contextType;return typeof u=="object"&&u!==null?u=_e(u):(l=pe(t)?_t:ue.current,r=t.contextTypes,u=(r=r!=null)?qt(e,l):dt),t=new t(n,u),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=sl,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=l,e.__reactInternalMemoizedMaskedChildContext=u),t}function Ci(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&sl.enqueueReplaceState(t,t.state,null)}function Cu(e,t,n,r){var l=e.stateNode;l.props=n,l.state=e.memoizedState,l.refs={},fo(e);var u=t.contextType;typeof u=="object"&&u!==null?l.context=_e(u):(u=pe(t)?_t:ue.current,l.context=qt(e,u)),l.state=e.memoizedState,u=t.getDerivedStateFromProps,typeof u=="function"&&(Eu(e,t,u,n),l.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof l.getSnapshotBeforeUpdate=="function"||typeof l.UNSAFE_componentWillMount!="function"&&typeof l.componentWillMount!="function"||(t=l.state,typeof l.componentWillMount=="function"&&l.componentWillMount(),typeof l.UNSAFE_componentWillMount=="function"&&l.UNSAFE_componentWillMount(),t!==l.state&&sl.enqueueReplaceState(l,l.state,null),Qr(e,n,l,r),l.state=e.memoizedState),typeof l.componentDidMount=="function"&&(e.flags|=4194308)}function nn(e,t){try{var n="",r=t;do n+=Rc(r),r=r.return;while(r);var l=n}catch(u){l=`[m
[32m+[m[32mError generating stack: `+u.message+`[m
[32m+[m[32m`+u.stack}return{value:e,source:t,stack:l,digest:null}}function Bl(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function xu(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var ud=typeof WeakMap=="function"?WeakMap:Map;function Pa(e,t,n){n=We(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Zr||(Zr=!0,Mu=r),xu(e,t)},n}function za(e,t,n){n=We(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var l=t.value;n.payload=function(){return r(l)},n.callback=function(){xu(e,t)}}var u=e.stateNode;return u!==null&&typeof u.componentDidCatch=="function"&&(n.callback=function(){xu(e,t),typeof r!="function"&&(st===null?st=new Set([this]):st.add(this));var o=t.stack;this.componentDidCatch(t.value,{componentStack:o!==null?o:""})}),n}function xi(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new ud;var l=new Set;r.set(t,l)}else l=r.get(t),l===void 0&&(l=new Set,r.set(t,l));l.has(n)||(l.add(n),e=wd.bind(null,e,t,n),t.then(e,e))}function _i(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function Ni(e,t,n,r,l){return e.mode&1?(e.flags|=65536,e.lanes=l,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=We(-1,1),t.tag=2,it(n,t,1))),n.lanes|=1),e)}var od=Ge.ReactCurrentOwner,fe=!1;function oe(e,t,n,r){t.child=e===null?ra(t,null,n,r):en(t,e.child,n,r)}function Pi(e,t,n,r,l){n=n.render;var u=t.ref;return Gt(t,l),r=yo(e,t,n,r,u,l),n=go(),e!==null&&!fe?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~l,Xe(e,t,l)):(A&&n&&lo(t),t.flags|=1,oe(e,t,r,l),t.child)}function zi(e,t,n,r,l){if(e===null){var u=n.type;return typeof u=="function"&&!zo(u)&&u.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=u,Ta(e,t,u,r,l)):(e=Tr(n.type,null,r,t,t.mode,l),e.ref=t.ref,e.return=t,t.child=e)}if(u=e.child,!(e.lanes&l)){var o=u.memoizedProps;if(n=n.compare,n=n!==null?n:Un,n(o,r)&&e.ref===t.ref)return Xe(e,t,l)}return t.flags|=1,e=ct(u,r),e.ref=t.ref,e.return=t,t.child=e}function Ta(e,t,n,r,l){if(e!==null){var u=e.memoizedProps;if(Un(u,r)&&e.ref===t.ref)if(fe=!1,t.pendingProps=r=u,(e.lanes&l)!==0)e.flags&131072&&(fe=!0);else return t.lanes=e.lanes,Xe(e,t,l)}return _u(e,t,n,r,l)}function La(e,t,n){var r=t.pendingProps,l=r.children,u=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},I(Wt,he),he|=n;else{if(!(n&1073741824))return e=u!==null?u.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,I(Wt,he),he|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=u!==null?u.baseLanes:n,I(Wt,he),he|=r}else u!==null?(r=u.baseLanes|n,t.memoizedState=null):r=n,I(Wt,he),he|=r;return oe(e,t,l,n),t.child}function Ra(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function _u(e,t,n,r,l){var u=pe(n)?_t:ue.current;return u=qt(t,u),Gt(t,l),n=yo(e,t,n,r,u,l),r=go(),e!==null&&!fe?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~l,Xe(e,t,l)):(A&&r&&lo(t),t.flags|=1,oe(e,t,n,l),t.child)}function Ti(e,t,n,r,l){if(pe(n)){var u=!0;Vr(t)}else u=!1;if(Gt(t,l),t.stateNode===null)Nr(e,t),Na(t,n,r),Cu(t,n,r,l),r=!0;else if(e===null){var o=t.stateNode,i=t.memoizedProps;o.props=i;var s=o.context,c=n.contextType;typeof c=="object"&&c!==null?c=_e(c):(c=pe(n)?_t:ue.current,c=qt(t,c));var h=n.getDerivedStateFromProps,m=typeof h=="function"||typeof o.getSnapshotBeforeUpdate=="function";m||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(i!==r||s!==c)&&Ci(t,o,r,c),qe=!1;var p=t.memoizedState;o.state=p,Qr(t,r,o,l),s=t.memoizedState,i!==r||p!==s||de.current||qe?(typeof h=="function"&&(Eu(t,n,h,r),s=t.memoizedState),(i=qe||Ei(t,n,i,r,p,s,c))?(m||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(t.flags|=4194308)):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=s),o.props=r,o.state=s,o.context=c,r=i):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{o=t.stateNode,ua(e,t),i=t.memoizedProps,c=t.type===t.elementType?i:Te(t.type,i),o.props=c,m=t.pendingProps,p=o.context,s=n.contextType,typeof s=="object"&&s!==null?s=_e(s):(s=pe(n)?_t:ue.current,s=qt(t,s));var g=n.getDerivedStateFromProps;(h=typeof g=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(i!==m||p!==s)&&Ci(t,o,r,s),qe=!1,p=t.memoizedState,o.state=p,Qr(t,r,o,l);var w=t.memoizedState;i!==m||p!==w||de.current||qe?(typeof g=="function"&&(Eu(t,n,g,r),w=t.memoizedState),(c=qe||Ei(t,n,c,r,p,w,s)||!1)?(h||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(r,w,s),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(r,w,s)),typeof o.componentDidUpdate=="function"&&(t.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof o.componentDidUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=w),o.props=r,o.state=w,o.context=s,r=c):(typeof o.componentDidUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),r=!1)}return Nu(e,t,n,r,u,l)}function Nu(e,t,n,r,l,u){Ra(e,t);var o=(t.flags&128)!==0;if(!r&&!o)return l&&mi(t,n,!1),Xe(e,t,u);r=t.stateNode,od.current=t;var i=o&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&o?(t.child=en(t,e.child,null,u),t.child=en(t,null,i,u)):oe(e,t,i,u),t.memoizedState=r.state,l&&mi(t,n,!0),t.child}function ja(e){var t=e.stateNode;t.pendingContext?pi(e,t.pendingContext,t.pendingContext!==t.context):t.context&&pi(e,t.context,!1),po(e,t.containerInfo)}function Li(e,t,n,r,l){return bt(),oo(l),t.flags|=256,oe(e,t,n,r),t.child}var Pu={dehydrated:null,treeContext:null,retryLane:0};function zu(e){return{baseLanes:e,cachePool:null,transitions:null}}function Oa(e,t,n){var r=t.pendingProps,l=V.current,u=!1,o=(t.flags&128)!==0,i;if((i=o)||(i=e!==null&&e.memoizedState===null?!1:(l&2)!==0),i?(u=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(l|=1),I(V,l&1),e===null)return Su(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(o=r.children,e=r.fallback,u?(r=t.mode,u=t.child,o={mode:"hidden",children:o},!(r&1)&&u!==null?(u.childLanes=0,u.pendingProps=o):u=fl(o,r,0,null),e=xt(e,r,n,null),u.return=t,e.return=t,u.sibling=e,t.child=u,t.child.memoizedState=zu(n),t.memoizedState=Pu,e):ko(t,o));if(l=e.memoizedState,l!==null&&(i=l.dehydrated,i!==null))return id(e,t,o,r,i,l,n);if(u){u=r.fallback,o=t.mode,l=e.child,i=l.sibling;var s={mode:"hidden",children:r.children};return!(o&1)&&t.child!==l?(r=t.child,r.childLanes=0,r.pendingProps=s,t.deletions=null):(r=ct(l,s),r.subtreeFlags=l.subtreeFlags&14680064),i!==null?u=ct(i,u):(u=xt(u,o,n,null),u.flags|=2),u.return=t,r.return=t,r.sibling=u,t.child=r,r=u,u=t.child,o=e.child.memoizedState,o=o===null?zu(n):{baseLanes:o.baseLanes|n,cachePool:null,transitions:o.transitions},u.memoizedState=o,u.childLanes=e.childLanes&~n,t.memoizedState=Pu,r}return u=e.child,e=u.sibling,r=ct(u,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function ko(e,t){return t=fl({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function mr(e,t,n,r){return r!==null&&oo(r),en(t,e.child,null,n),e=ko(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function id(e,t,n,r,l,u,o){if(n)return t.flags&256?(t.flags&=-257,r=Bl(Error(y(422))),mr(e,t,o,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(u=r.fallback,l=t.mode,r=fl({mode:"visible",children:r.children},l,0,null),u=xt(u,l,o,null),u.flags|=2,r.return=t,u.return=t,r.sibling=u,t.child=r,t.mode&1&&en(t,e.child,null,o),t.child.memoizedState=zu(o),t.memoizedState=Pu,u);if(!(t.mode&1))return mr(e,t,o,null);if(l.data==="$!"){if(r=l.nextSibling&&l.nextSibling.dataset,r)var i=r.dgst;return r=i,u=Error(y(419)),r=Bl(u,r,void 0),mr(e,t,o,r)}if(i=(o&e.childLanes)!==0,fe||i){if(r=q,r!==null){switch(o&-o){case 4:l=2;break;case 16:l=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:l=32;break;case 536870912:l=268435456;break;default:l=0}l=l&(r.suspendedLanes|o)?0:l,l!==0&&l!==u.retryLane&&(u.retryLane=l,Ye(e,l),Oe(r,e,l,-1))}return Po(),r=Bl(Error(y(421))),mr(e,t,o,r)}return l.data==="$?"?(t.flags|=128,t.child=e.child,t=Sd.bind(null,e),l._reactRetry=t,null):(e=u.treeContext,ve=ot(l.nextSibling),ye=t,A=!0,Re=null,e!==null&&(ke[Ee++]=$e,ke[Ee++]=He,ke[Ee++]=Nt,$e=e.id,He=e.overflow,Nt=t),t=ko(t,r.children),t.flags|=4096,t)}function Ri(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),ku(e.return,t,n)}function $l(e,t,n,r,l){var u=e.memoizedState;u===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:l}:(u.isBackwards=t,u.rendering=null,u.renderingStartTime=0,u.last=r,u.tail=n,u.tailMode=l)}function Ma(e,t,n){var r=t.pendingProps,l=r.revealOrder,u=r.tail;if(oe(e,t,r.children,n),r=V.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Ri(e,n,t);else if(e.tag===19)Ri(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(I(V,r),!(t.mode&1))t.memoizedState=null;else switch(l){case"forwards":for(n=t.child,l=null;n!==null;)e=n.alternate,e!==null&&Kr(e)===null&&(l=n),n=n.sibling;n=l,n===null?(l=t.child,t.child=null):(l=n.sibling,n.sibling=null),$l(t,!1,l,n,u);break;case"backwards":for(n=null,l=t.child,t.child=null;l!==null;){if(e=l.alternate,e!==null&&Kr(e)===null){t.child=l;break}e=l.sibling,l.sibling=n,n=l,l=e}$l(t,!0,n,null,u);break;case"together":$l(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Nr(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Xe(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),zt|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(y(153));if(t.child!==null){for(e=t.child,n=ct(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=ct(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function sd(e,t,n){switch(t.tag){case 3:ja(t),bt();break;case 5:oa(t);break;case 1:pe(t.type)&&Vr(t);break;case 4:po(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,l=t.memoizedProps.value;I(Hr,r._currentValue),r._currentValue=l;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(I(V,V.current&1),t.flags|=128,null):n&t.child.childLanes?Oa(e,t,n):(I(V,V.current&1),e=Xe(e,t,n),e!==null?e.sibling:null);I(V,V.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return Ma(e,t,n);t.flags|=128}if(l=t.memoizedState,l!==null&&(l.rendering=null,l.tail=null,l.lastEffect=null),I(V,V.current),r)break;return null;case 22:case 23:return t.lanes=0,La(e,t,n)}return Xe(e,t,n)}var Da,Tu,Ia,Fa;Da=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};Tu=function(){};Ia=function(e,t,n,r){var l=e.memoizedProps;if(l!==r){e=t.stateNode,Et(Ae.current);var u=null;switch(n){case"input":l=Jl(e,l),r=Jl(e,r),u=[];break;case"select":l=$({},l,{value:void 0}),r=$({},r,{value:void 0}),u=[];break;case"textarea":l=eu(e,l),r=eu(e,r),u=[];break;default:typeof l.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=Ur)}nu(n,r);var o;n=null;for(c in l)if(!r.hasOwnProperty(c)&&l.hasOwnProperty(c)&&l[c]!=null)if(c==="style"){var i=l[c];for(o in i)i.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(Rn.hasOwnProperty(c)?u||(u=[]):(u=u||[]).push(c,null));for(c in r){var s=r[c];if(i=l!=null?l[c]:void 0,r.hasOwnProperty(c)&&s!==i&&(s!=null||i!=null))if(c==="style")if(i){for(o in i)!i.hasOwnProperty(o)||s&&s.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in s)s.hasOwnProperty(o)&&i[o]!==s[o]&&(n||(n={}),n[o]=s[o])}else n||(u||(u=[]),u.push(c,n)),n=s;else c==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,i=i?i.__html:void 0,s!=null&&i!==s&&(u=u||[]).push(c,s)):c==="children"?typeof s!="string"&&typeof s!="number"||(u=u||[]).push(c,""+s):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(Rn.hasOwnProperty(c)?(s!=null&&c==="onScroll"&&F("scroll",e),u||i===s||(u=[])):(u=u||[]).push(c,s))}n&&(u=u||[]).push("style",n);var c=u;(t.updateQueue=c)&&(t.flags|=4)}};Fa=function(e,t,n,r){n!==r&&(t.flags|=4)};function vn(e,t){if(!A)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function re(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var l=e.child;l!==null;)n|=l.lanes|l.childLanes,r|=l.subtreeFlags&14680064,r|=l.flags&14680064,l.return=e,l=l.sibling;else for(l=e.child;l!==null;)n|=l.lanes|l.childLanes,r|=l.subtreeFlags,r|=l.flags,l.return=e,l=l.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function ad(e,t,n){var r=t.pendingProps;switch(uo(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return re(t),null;case 1:return pe(t.type)&&Ar(),re(t),null;case 3:return r=t.stateNode,tn(),U(de),U(ue),ho(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(dr(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Re!==null&&(Fu(Re),Re=null))),Tu(e,t),re(t),null;case 5:mo(t);var l=Et(Hn.current);if(n=t.type,e!==null&&t.stateNode!=null)Ia(e,t,n,r,l),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(y(166));return re(t),null}if(e=Et(Ae.current),dr(t)){r=t.stateNode,n=t.type;var u=t.memoizedProps;switch(r[Fe]=t,r[Bn]=u,e=(t.mode&1)!==0,n){case"dialog":F("cancel",r),F("close",r);break;case"iframe":case"object":case"embed":F("load",r);break;case"video":case"audio":for(l=0;l<kn.length;l++)F(kn[l],r);break;case"source":F("error",r);break;case"img":case"image":case"link":F("error",r),F("load",r);break;case"details":F("toggle",r);break;case"input":Vo(r,u),F("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!u.multiple},F("invalid",r);break;case"textarea":$o(r,u),F("invalid",r)}nu(n,u),l=null;for(var o in u)if(u.hasOwnProperty(o)){var i=u[o];o==="children"?typeof i=="string"?r.textContent!==i&&(u.suppressHydrationWarning!==!0&&fr(r.textContent,i,e),l=["children",i]):typeof i=="number"&&r.textContent!==""+i&&(u.suppressHydrationWarning!==!0&&fr(r.textContent,i,e),l=["children",""+i]):Rn.hasOwnProperty(o)&&i!=null&&o==="onScroll"&&F("scroll",r)}switch(n){case"input":rr(r),Bo(r,u,!0);break;case"textarea":rr(r),Ho(r);break;case"select":case"option":break;default:typeof u.onClick=="function"&&(r.onclick=Ur)}r=l,t.updateQueue=r,r!==null&&(t.flags|=4)}else{o=l.nodeType===9?l:l.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=fs(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=o.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=o.createElement(n,{is:r.is}):(e=o.createElement(n),n==="select"&&(o=e,r.multiple?o.multiple=!0:r.size&&(o.size=r.size))):e=o.createElementNS(e,n),e[Fe]=t,e[Bn]=r,Da(e,t,!1,!1),t.stateNode=e;e:{switch(o=ru(n,r),n){case"dialog":F("cancel",e),F("close",e),l=r;break;case"iframe":case"object":case"embed":F("load",e),l=r;break;case"video":case"audio":for(l=0;l<kn.length;l++)F(kn[l],e);l=r;break;case"source":F("error",e),l=r;break;case"img":case"image":case"link":F("error",e),F("load",e),l=r;break;case"details":F("toggle",e),l=r;break;case"input":Vo(e,r),l=Jl(e,r),F("invalid",e);break;case"option":l=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},l=$({},r,{value:void 0}),F("invalid",e);break;case"textarea":$o(e,r),l=eu(e,r),F("invalid",e);break;default:l=r}nu(n,l),i=l;for(u in i)if(i.hasOwnProperty(u)){var s=i[u];u==="style"?ms(e,s):u==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,s!=null&&ds(e,s)):u==="children"?typeof s=="string"?(n!=="textarea"||s!=="")&&jn(e,s):typeof s=="number"&&jn(e,""+s):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Rn.hasOwnProperty(u)?s!=null&&u==="onScroll"&&F("scroll",e):s!=null&&Wu(e,u,s,o))}switch(n){case"input":rr(e),Bo(e,r,!1);break;case"textarea":rr(e),Ho(e);break;case"option":r.value!=null&&e.setAttribute("value",""+ft(r.value));break;case"select":e.multiple=!!r.multiple,u=r.value,u!=null?Qt(e,!!r.multiple,u,!1):r.defaultValue!=null&&Qt(e,!!r.multiple,r.defaultValue,!0);break;default:typeof l.onClick=="function"&&(e.onclick=Ur)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return re(t),null;case 6:if(e&&t.stateNode!=null)Fa(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(y(166));if(n=Et(Hn.current),Et(Ae.current),dr(t)){if(r=t.stateNode,n=t.memoizedProps,r[Fe]=t,(u=r.nodeValue!==n)&&(e=ye,e!==null))switch(e.tag){case 3:fr(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&fr(r.nodeValue,n,(e.mode&1)!==0)}u&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[Fe]=t,t.stateNode=r}return re(t),null;case 13:if(U(V),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(A&&ve!==null&&t.mode&1&&!(t.flags&128))ta(),bt(),t.flags|=98560,u=!1;else if(u=dr(t),r!==null&&r.dehydrated!==null){if(e===null){if(!u)throw Error(y(318));if(u=t.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(y(317));u[Fe]=t}else bt(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;re(t),u=!1}else Re!==null&&(Fu(Re),Re=null),u=!0;if(!u)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||V.current&1?G===0&&(G=3):Po())),t.updateQueue!==null&&(t.flags|=4),re(t),null);case 4:return tn(),Tu(e,t),e===null&&An(t.stateNode.containerInfo),re(t),null;case 10:return ao(t.type._context),re(t),null;case 17:return pe(t.type)&&Ar(),re(t),null;case 19:if(U(V),u=t.memoizedState,u===null)return re(t),null;if(r=(t.flags&128)!==0,o=u.rendering,o===null)if(r)vn(u,!1);else{if(G!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(o=Kr(e),o!==null){for(t.flags|=128,vn(u,!1),r=o.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)u=n,e=r,u.flags&=14680066,o=u.alternate,o===null?(u.childLanes=0,u.lanes=e,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=o.childLanes,u.lanes=o.lanes,u.child=o.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=o.memoizedProps,u.memoizedState=o.memoizedState,u.updateQueue=o.updateQueue,u.type=o.type,e=o.dependencies,u.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return I(V,V.current&1|2),t.child}e=e.sibling}u.tail!==null&&Q()>rn&&(t.flags|=128,r=!0,vn(u,!1),t.lanes=4194304)}else{if(!r)if(e=Kr(o),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),vn(u,!0),u.tail===null&&u.tailMode==="hidden"&&!o.alternate&&!A)return re(t),null}else 2*Q()-u.renderingStartTime>rn&&n!==1073741824&&(t.flags|=128,r=!0,vn(u,!1),t.lanes=4194304);u.isBackwards?(o.sibling=t.child,t.child=o):(n=u.last,n!==null?n.sibling=o:t.child=o,u.last=o)}return u.tail!==null?(t=u.tail,u.rendering=t,u.tail=t.sibling,u.renderingStartTime=Q(),t.sibling=null,n=V.current,I(V,r?n&1|2:n&1),t):(re(t),null);case 22:case 23:return No(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?he&1073741824&&(re(t),t.subtreeFlags&6&&(t.flags|=8192)):re(t),null;case 24:return null;case 25:return null}throw Error(y(156,t.tag))}function cd(e,t){switch(uo(t),t.tag){case 1:return pe(t.type)&&Ar(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return tn(),U(de),U(ue),ho(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return mo(t),null;case 13:if(U(V),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(y(340));bt()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return U(V),null;case 4:return tn(),null;case 10:return ao(t.type._context),null;case 22:case 23:return No(),null;case 24:return null;default:return null}}var hr=!1,le=!1,fd=typeof WeakSet=="function"?WeakSet:Set,C=null;function Ht(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){H(e,t,r)}else n.current=null}function Lu(e,t,n){try{n()}catch(r){H(e,t,r)}}var ji=!1;function dd(e,t){if(pu=Dr,e=$s(),ro(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var l=r.anchorOffset,u=r.focusNode;r=r.focusOffset;try{n.nodeType,u.nodeType}catch{n=null;break e}var o=0,i=-1,s=-1,c=0,h=0,m=e,p=null;t:for(;;){for(var g;m!==n||l!==0&&m.nodeType!==3||(i=o+l),m!==u||r!==0&&m.nodeType!==3||(s=o+r),m.nodeType===3&&(o+=m.nodeValue.length),(g=m.firstChild)!==null;)p=m,m=g;for(;;){if(m===e)break t;if(p===n&&++c===l&&(i=o),p===u&&++h===r&&(s=o),(g=m.nextSibling)!==null)break;m=p,p=m.parentNode}m=g}n=i===-1||s===-1?null:{start:i,end:s}}else n=null}n=n||{start:0,end:0}}else n=null;for(mu={focusedElem:e,selectionRange:n},Dr=!1,C=t;C!==null;)if(t=C,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,C=e;else for(;C!==null;){t=C;try{var w=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(w!==null){var S=w.memoizedProps,D=w.memoizedState,f=t.stateNode,a=f.getSnapshotBeforeUpdate(t.elementType===t.type?S:Te(t.type,S),D);f.__reactInternalSnapshotBeforeUpdate=a}break;case 3:var d=t.stateNode.containerInfo;d.nodeType===1?d.textContent="":d.nodeType===9&&d.documentElement&&d.removeChild(d.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(y(163))}}catch(v){H(t,t.return,v)}if(e=t.sibling,e!==null){e.return=t.return,C=e;break}C=t.return}return w=ji,ji=!1,w}function zn(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var l=r=r.next;do{if((l.tag&e)===e){var u=l.destroy;l.destroy=void 0,u!==void 0&&Lu(t,n,u)}l=l.next}while(l!==r)}}function al(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function Ru(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function Ua(e){var t=e.alternate;t!==null&&(e.alternate=null,Ua(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Fe],delete t[Bn],delete t[yu],delete t[Xf],delete t[Gf])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Aa(e){return e.tag===5||e.tag===3||e.tag===4}function Oi(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Aa(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ju(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Ur));else if(r!==4&&(e=e.child,e!==null))for(ju(e,t,n),e=e.sibling;e!==null;)ju(e,t,n),e=e.sibling}function Ou(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(Ou(e,t,n),e=e.sibling;e!==null;)Ou(e,t,n),e=e.sibling}var b=null,Le=!1;function Ze(e,t,n){for(n=n.child;n!==null;)Va(e,t,n),n=n.sibling}function Va(e,t,n){if(Ue&&typeof Ue.onCommitFiberUnmount=="function")try{Ue.onCommitFiberUnmount(tl,n)}catch{}switch(n.tag){case 5:le||Ht(n,t);case 6:var r=b,l=Le;b=null,Ze(e,t,n),b=r,Le=l,b!==null&&(Le?(e=b,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):b.removeChild(n.stateNode));break;case 18:b!==null&&(Le?(e=b,n=n.stateNode,e.nodeType===8?Dl(e.parentNode,n):e.nodeType===1&&Dl(e,n),In(e)):Dl(b,n.stateNode));break;case 4:r=b,l=Le,b=n.stateNode.containerInfo,Le=!0,Ze(e,t,n),b=r,Le=l;break;case 0:case 11:case 14:case 15:if(!le&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){l=r=r.next;do{var u=l,o=u.destroy;u=u.tag,o!==void 0&&(u&2||u&4)&&Lu(n,t,o),l=l.next}while(l!==r)}Ze(e,t,n);break;case 1:if(!le&&(Ht(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(i){H(n,t,i)}Ze(e,t,n);break;case 21:Ze(e,t,n);break;case 22:n.mode&1?(le=(r=le)||n.memoizedState!==null,Ze(e,t,n),le=r):Ze(e,t,n);break;default:Ze(e,t,n)}}function Mi(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new fd),t.forEach(function(r){var l=kd.bind(null,e,r);n.has(r)||(n.add(r),r.then(l,l))})}}function ze(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var l=n[r];try{var u=e,o=t,i=o;e:for(;i!==null;){switch(i.tag){case 5:b=i.stateNode,Le=!1;break e;case 3:b=i.stateNode.containerInfo,Le=!0;break e;case 4:b=i.stateNode.containerInfo,Le=!0;break e}i=i.return}if(b===null)throw Error(y(160));Va(u,o,l),b=null,Le=!1;var s=l.alternate;s!==null&&(s.return=null),l.return=null}catch(c){H(l,t,c)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Ba(t,e),t=t.sibling}function Ba(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ze(t,e),De(e),r&4){try{zn(3,e,e.return),al(3,e)}catch(S){H(e,e.return,S)}try{zn(5,e,e.return)}catch(S){H(e,e.return,S)}}break;case 1:ze(t,e),De(e),r&512&&n!==null&&Ht(n,n.return);break;case 5:if(ze(t,e),De(e),r&512&&n!==null&&Ht(n,n.return),e.flags&32){var l=e.stateNode;try{jn(l,"")}catch(S){H(e,e.return,S)}}if(r&4&&(l=e.stateNode,l!=null)){var u=e.memoizedProps,o=n!==null?n.memoizedProps:u,i=e.type,s=e.updateQueue;if(e.updateQueue=null,s!==null)try{i==="input"&&u.type==="radio"&&u.name!=null&&as(l,u),ru(i,o);var c=ru(i,u);for(o=0;o<s.length;o+=2){var h=s[o],m=s[o+1];h==="style"?ms(l,m):h==="dangerouslySetInnerHTML"?ds(l,m):h==="children"?jn(l,m):Wu(l,h,m,c)}switch(i){case"input":ql(l,u);break;case"textarea":cs(l,u);break;case"select":var p=l._wrapperState.wasMultiple;l._wrapperState.wasMultiple=!!u.multiple;var g=u.value;g!=null?Qt(l,!!u.multiple,g,!1):p!==!!u.multiple&&(u.defaultValue!=null?Qt(l,!!u.multiple,u.defaultValue,!0):Qt(l,!!u.multiple,u.multiple?[]:"",!1))}l[Bn]=u}catch(S){H(e,e.return,S)}}break;case 6:if(ze(t,e),De(e),r&4){if(e.stateNode===null)throw Error(y(162));l=e.stateNode,u=e.memoizedProps;try{l.nodeValue=u}catch(S){H(e,e.return,S)}}break;case 3:if(ze(t,e),De(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{In(t.containerInfo)}catch(S){H(e,e.return,S)}break;case 4:ze(t,e),De(e);break;case 13:ze(t,e),De(e),l=e.child,l.flags&8192&&(u=l.memoizedState!==null,l.stateNode.isHidden=u,!u||l.alternate!==null&&l.alternate.memoizedState!==null||(xo=Q())),r&4&&Mi(e);break;case 22:if(h=n!==null&&n.memoizedState!==null,e.mode&1?(le=(c=le)||h,ze(t,e),le=c):ze(t,e),De(e),r&8192){if(c=e.memoizedState!==null,(e.stateNode.isHidden=c)&&!h&&e.mode&1)for(C=e,h=e.child;h!==null;){for(m=C=h;C!==null;){switch(p=C,g=p.child,p.tag){case 0:case 11:case 14:case 15:zn(4,p,p.return);break;case 1:Ht(p,p.return);var w=p.stateNode;if(typeof w.componentWillUnmount=="function"){r=p,n=p.return;try{t=r,w.props=t.memoizedProps,w.state=t.memoizedState,w.componentWillUnmount()}catch(S){H(r,n,S)}}break;case 5:Ht(p,p.return);break;case 22:if(p.memoizedState!==null){Ii(m);continue}}g!==null?(g.return=p,C=g):Ii(m)}h=h.sibling}e:for(h=null,m=e;;){if(m.tag===5){if(h===null){h=m;try{l=m.stateNode,c?(u=l.style,typeof u.setProperty=="function"?u.setProperty("display","none","important"):u.display="none"):(i=m.stateNode,s=m.memoizedProps.style,o=s!=null&&s.hasOwnProperty("display")?s.display:null,i.style.display=ps("display",o))}catch(S){H(e,e.return,S)}}}else if(m.tag===6){if(h===null)try{m.stateNode.nodeValue=c?"":m.memoizedProps}catch(S){H(e,e.return,S)}}else if((m.tag!==22&&m.tag!==23||m.memoizedState===null||m===e)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===e)break e;for(;m.sibling===null;){if(m.return===null||m.return===e)break e;h===m&&(h=null),m=m.return}h===m&&(h=null),m.sibling.return=m.return,m=m.sibling}}break;case 19:ze(t,e),De(e),r&4&&Mi(e);break;case 21:break;default:ze(t,e),De(e)}}function De(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(Aa(n)){var r=n;break e}n=n.return}throw Error(y(160))}switch(r.tag){case 5:var l=r.stateNode;r.flags&32&&(jn(l,""),r.flags&=-33);var u=Oi(e);Ou(e,u,l);break;case 3:case 4:var o=r.stateNode.containerInfo,i=Oi(e);ju(e,i,o);break;default:throw Error(y(161))}}catch(s){H(e,e.return,s)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function pd(e,t,n){C=e,$a(e)}function $a(e,t,n){for(var r=(e.mode&1)!==0;C!==null;){var l=C,u=l.child;if(l.tag===22&&r){var o=l.memoizedState!==null||hr;if(!o){var i=l.alternate,s=i!==null&&i.memoizedState!==null||le;i=hr;var c=le;if(hr=o,(le=s)&&!c)for(C=l;C!==null;)o=C,s=o.child,o.tag===22&&o.memoizedState!==null?Fi(l):s!==null?(s.return=o,C=s):Fi(l);for(;u!==null;)C=u,$a(u),u=u.sibling;C=l,hr=i,le=c}Di(e)}else l.subtreeFlags&8772&&u!==null?(u.return=l,C=u):Di(e)}}function Di(e){for(;C!==null;){var t=C;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:le||al(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!le)if(n===null)r.componentDidMount();else{var l=t.elementType===t.type?n.memoizedProps:Te(t.type,n.memoizedProps);r.componentDidUpdate(l,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var u=t.updateQueue;u!==null&&wi(t,u,r);break;case 3:var o=t.updateQueue;if(o!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}wi(t,o,n)}break;case 5:var i=t.stateNode;if(n===null&&t.flags&4){n=i;var s=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&n.focus();break;case"img":s.src&&(n.src=s.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var c=t.alternate;if(c!==null){var h=c.memoizedState;if(h!==null){var m=h.dehydrated;m!==null&&In(m)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(y(163))}le||t.flags&512&&Ru(t)}catch(p){H(t,t.return,p)}}if(t===e){C=null;break}if(n=t.sibling,n!==null){n.return=t.return,C=n;break}C=t.return}}function Ii(e){for(;C!==null;){var t=C;if(t===e){C=null;break}var n=t.sibling;if(n!==null){n.return=t.return,C=n;break}C=t.return}}function Fi(e){for(;C!==null;){var t=C;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{al(4,t)}catch(s){H(t,n,s)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var l=t.return;try{r.componentDidMount()}catch(s){H(t,l,s)}}var u=t.return;try{Ru(t)}catch(s){H(t,u,s)}break;case 5:var o=t.return;try{Ru(t)}catch(s){H(t,o,s)}}}catch(s){H(t,t.return,s)}if(t===e){C=null;break}var i=t.sibling;if(i!==null){i.return=t.return,C=i;break}C=t.return}}var md=Math.ceil,Gr=Ge.ReactCurrentDispatcher,Eo=Ge.ReactCurrentOwner,xe=Ge.ReactCurrentBatchConfig,j=0,q=null,K=null,ee=0,he=0,Wt=mt(0),G=0,Yn=null,zt=0,cl=0,Co=0,Tn=null,ce=null,xo=0,rn=1/0,Ve=null,Zr=!1,Mu=null,st=null,vr=!1,nt=null,Jr=0,Ln=0,Du=null,Pr=-1,zr=0;function ie(){return j&6?Q():Pr!==-1?Pr:Pr=Q()}function at(e){return e.mode&1?j&2&&ee!==0?ee&-ee:Jf.transition!==null?(zr===0&&(zr=Ns()),zr):(e=M,e!==0||(e=window.event,e=e===void 0?16:Os(e.type)),e):1}function Oe(e,t,n,r){if(50<Ln)throw Ln=0,Du=null,Error(y(185));Gn(e,n,r),(!(j&2)||e!==q)&&(e===q&&(!(j&2)&&(cl|=n),G===4&&et(e,ee)),me(e,r),n===1&&j===0&&!(t.mode&1)&&(rn=Q()+500,ol&&ht()))}function me(e,t){var n=e.callbackNode;Zc(e,t);var r=Mr(e,e===q?ee:0);if(r===0)n!==null&&Ko(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&Ko(n),t===1)e.tag===0?Zf(Ui.bind(null,e)):qs(Ui.bind(null,e)),Kf(function(){!(j&6)&&ht()}),n=null;else{switch(Ps(r)){case 1:n=Gu;break;case 4:n=xs;break;case 16:n=Or;break;case 536870912:n=_s;break;default:n=Or}n=Za(n,Ha.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function Ha(e,t){if(Pr=-1,zr=0,j&6)throw Error(y(327));var n=e.callbackNode;if(Zt()&&e.callbackNode!==n)return null;var r=Mr(e,e===q?ee:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=qr(e,r);else{t=r;var l=j;j|=2;var u=Qa();(q!==e||ee!==t)&&(Ve=null,rn=Q()+500,Ct(e,t));do try{yd();break}catch(i){Wa(e,i)}while(!0);so(),Gr.current=u,j=l,K!==null?t=0:(q=null,ee=0,t=G)}if(t!==0){if(t===2&&(l=su(e),l!==0&&(r=l,t=Iu(e,l))),t===1)throw n=Yn,Ct(e,0),et(e,r),me(e,Q()),n;if(t===6)et(e,r);else{if(l=e.current.alternate,!(r&30)&&!hd(l)&&(t=qr(e,r),t===2&&(u=su(e),u!==0&&(r=u,t=Iu(e,u))),t===1))throw n=Yn,Ct(e,0),et(e,r),me(e,Q()),n;switch(e.finishedWork=l,e.finishedLanes=r,t){case 0:case 1:throw Error(y(345));case 2:wt(e,ce,Ve);break;case 3:if(et(e,r),(r&130023424)===r&&(t=xo+500-Q(),10<t)){if(Mr(e,0)!==0)break;if(l=e.suspendedLanes,(l&r)!==r){ie(),e.pingedLanes|=e.suspendedLanes&l;break}e.timeoutHandle=vu(wt.bind(null,e,ce,Ve),t);break}wt(e,ce,Ve);break;case 4:if(et(e,r),(r&4194240)===r)break;for(t=e.eventTimes,l=-1;0<r;){var o=31-je(r);u=1<<o,o=t[o],o>l&&(l=o),r&=~u}if(r=l,r=Q()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*md(r/1960))-r,10<r){e.timeoutHandle=vu(wt.bind(null,e,ce,Ve),r);break}wt(e,ce,Ve);break;case 5:wt(e,ce,Ve);break;default:throw Error(y(329))}}}return me(e,Q()),e.callbackNode===n?Ha.bind(null,e):null}function Iu(e,t){var n=Tn;return e.current.memoizedState.isDehydrated&&(Ct(e,t).flags|=256),e=qr(e,t),e!==2&&(t=ce,ce=n,t!==null&&Fu(t)),e}function Fu(e){ce===null?ce=e:ce.push.apply(ce,e)}function hd(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var l=n[r],u=l.getSnapshot;l=l.value;try{if(!Me(u(),l))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function et(e,t){for(t&=~Co,t&=~cl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-je(t),r=1<<n;e[n]=-1,t&=~r}}function Ui(e){if(j&6)throw Error(y(327));Zt();var t=Mr(e,0);if(!(t&1))return me(e,Q()),null;var n=qr(e,t);if(e.tag!==0&&n===2){var r=su(e);r!==0&&(t=r,n=Iu(e,r))}if(n===1)throw n=Yn,Ct(e,0),et(e,t),me(e,Q()),n;if(n===6)throw Error(y(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wt(e,ce,Ve),me(e,Q()),null}function _o(e,t){var n=j;j|=1;try{return e(t)}finally{j=n,j===0&&(rn=Q()+500,ol&&ht())}}function Tt(e){nt!==null&&nt.tag===0&&!(j&6)&&Zt();var t=j;j|=1;var n=xe.transition,r=M;try{if(xe.transition=null,M=1,e)return e()}finally{M=r,xe.transition=n,j=t,!(j&6)&&ht()}}function No(){he=Wt.current,U(Wt)}function Ct(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Qf(n)),K!==null)for(n=K.return;n!==null;){var r=n;switch(uo(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&Ar();break;case 3:tn(),U(de),U(ue),ho();break;case 5:mo(r);break;case 4:tn();break;case 13:U(V);break;case 19:U(V);break;case 10:ao(r.type._context);break;case 22:case 23:No()}n=n.return}if(q=e,K=e=ct(e.current,null),ee=he=t,G=0,Yn=null,Co=cl=zt=0,ce=Tn=null,kt!==null){for(t=0;t<kt.length;t++)if(n=kt[t],r=n.interleaved,r!==null){n.interleaved=null;var l=r.next,u=n.pending;if(u!==null){var o=u.next;u.next=l,r.next=o}n.pending=r}kt=null}return e}function Wa(e,t){do{var n=K;try{if(so(),xr.current=Xr,Yr){for(var r=B.memoizedState;r!==null;){var l=r.queue;l!==null&&(l.pending=null),r=r.next}Yr=!1}if(Pt=0,J=X=B=null,Pn=!1,Wn=0,Eo.current=null,n===null||n.return===null){G=1,Yn=t,K=null;break}e:{var u=e,o=n.return,i=n,s=t;if(t=ee,i.flags|=32768,s!==null&&typeof s=="object"&&typeof s.then=="function"){var c=s,h=i,m=h.tag;if(!(h.mode&1)&&(m===0||m===11||m===15)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var g=_i(o);if(g!==null){g.flags&=-257,Ni(g,o,i,u,t),g.mode&1&&xi(u,c,t),t=g,s=c;var w=t.updateQueue;if(w===null){var S=new Set;S.add(s),t.updateQueue=S}else w.add(s);break e}else{if(!(t&1)){xi(u,c,t),Po();break e}s=Error(y(426))}}else if(A&&i.mode&1){var D=_i(o);if(D!==null){!(D.flags&65536)&&(D.flags|=256),Ni(D,o,i,u,t),oo(nn(s,i));break e}}u=s=nn(s,i),G!==4&&(G=2),Tn===null?Tn=[u]:Tn.push(u),u=o;do{switch(u.tag){case 3:u.flags|=65536,t&=-t,u.lanes|=t;var f=Pa(u,s,t);gi(u,f);break e;case 1:i=s;var a=u.type,d=u.stateNode;if(!(u.flags&128)&&(typeof a.getDerivedStateFromError=="function"||d!==null&&typeof d.componentDidCatch=="function"&&(st===null||!st.has(d)))){u.flags|=65536,t&=-t,u.lanes|=t;var v=za(u,i,t);gi(u,v);break e}}u=u.return}while(u!==null)}Ya(n)}catch(E){t=E,K===n&&n!==null&&(K=n=n.return);continue}break}while(!0)}function Qa(){var e=Gr.current;return Gr.current=Xr,e===null?Xr:e}function Po(){(G===0||G===3||G===2)&&(G=4),q===null||!(zt&268435455)&&!(cl&268435455)||et(q,ee)}function qr(e,t){var n=j;j|=2;var r=Qa();(q!==e||ee!==t)&&(Ve=null,Ct(e,t));do try{vd();break}catch(l){Wa(e,l)}while(!0);if(so(),j=n,Gr.current=r,K!==null)throw Error(y(261));return q=null,ee=0,G}function vd(){for(;K!==null;)Ka(K)}function yd(){for(;K!==null&&!Bc();)Ka(K)}function Ka(e){var t=Ga(e.alternate,e,he);e.memoizedProps=e.pendingProps,t===null?Ya(e):K=t,Eo.current=null}function Ya(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=cd(n,t),n!==null){n.flags&=32767,K=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{G=6,K=null;return}}else if(n=ad(n,t,he),n!==null){K=n;return}if(t=t.sibling,t!==null){K=t;return}K=t=e}while(t!==null);G===0&&(G=5)}function wt(e,t,n){var r=M,l=xe.transition;try{xe.transition=null,M=1,gd(e,t,n,r)}finally{xe.transition=l,M=r}return null}function gd(e,t,n,r){do Zt();while(nt!==null);if(j&6)throw Error(y(327));n=e.finishedWork;var l=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(y(177));e.callbackNode=null,e.callbackPriority=0;var u=n.lanes|n.childLanes;if(Jc(e,u),e===q&&(K=q=null,ee=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||vr||(vr=!0,Za(Or,function(){return Zt(),null})),u=(n.flags&15990)!==0,n.subtreeFlags&15990||u){u=xe.transition,xe.transition=null;var o=M;M=1;var i=j;j|=4,Eo.current=null,dd(e,n),Ba(n,e),Uf(mu),Dr=!!pu,mu=pu=null,e.current=n,pd(n),$c(),j=i,M=o,xe.transition=u}else e.current=n;if(vr&&(vr=!1,nt=e,Jr=l),u=e.pendingLanes,u===0&&(st=null),Qc(n.stateNode),me(e,Q()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)l=t[n],r(l.value,{componentStack:l.stack,digest:l.digest});if(Zr)throw Zr=!1,e=Mu,Mu=null,e;return Jr&1&&e.tag!==0&&Zt(),u=e.pendingLanes,u&1?e===Du?Ln++:(Ln=0,Du=e):Ln=0,ht(),null}function Zt(){if(nt!==null){var e=Ps(Jr),t=xe.transition,n=M;try{if(xe.transition=null,M=16>e?16:e,nt===null)var r=!1;else{if(e=nt,nt=null,Jr=0,j&6)throw Error(y(331));var l=j;for(j|=4,C=e.current;C!==null;){var u=C,o=u.child;if(C.flags&16){var i=u.deletions;if(i!==null){for(var s=0;s<i.length;s++){var c=i[s];for(C=c;C!==null;){var h=C;switch(h.tag){case 0:case 11:case 15:zn(8,h,u)}var m=h.child;if(m!==null)m.return=h,C=m;else for(;C!==null;){h=C;var p=h.sibling,g=h.return;if(Ua(h),h===c){C=null;break}if(p!==null){p.return=g,C=p;break}C=g}}}var w=u.alternate;if(w!==null){var S=w.child;if(S!==null){w.child=null;do{var D=S.sibling;S.sibling=null,S=D}while(S!==null)}}C=u}}if(u.subtreeFlags&2064&&o!==null)o.return=u,C=o;else e:for(;C!==null;){if(u=C,u.flags&2048)switch(u.tag){case 0:case 11:case 15:zn(9,u,u.return)}var f=u.sibling;if(f!==null){f.return=u.return,C=f;break e}C=u.return}}var a=e.current;for(C=a;C!==null;){o=C;var d=o.child;if(o.subtreeFlags&2064&&d!==null)d.return=o,C=d;else e:for(o=a;C!==null;){if(i=C,i.flags&2048)try{switch(i.tag){case 0:case 11:case 15:al(9,i)}}catch(E){H(i,i.return,E)}if(i===o){C=null;break e}var v=i.sibling;if(v!==null){v.return=i.return,C=v;break e}C=i.return}}if(j=l,ht(),Ue&&typeof Ue.onPostCommitFiberRoot=="function")try{Ue.onPostCommitFiberRoot(tl,e)}catch{}r=!0}return r}finally{M=n,xe.transition=t}}return!1}function Ai(e,t,n){t=nn(n,t),t=Pa(e,t,1),e=it(e,t,1),t=ie(),e!==null&&(Gn(e,1,t),me(e,t))}function H(e,t,n){if(e.tag===3)Ai(e,e,n);else for(;t!==null;){if(t.tag===3){Ai(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(st===null||!st.has(r))){e=nn(n,e),e=za(t,e,1),t=it(t,e,1),e=ie(),t!==null&&(Gn(t,1,e),me(t,e));break}}t=t.return}}function wd(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=ie(),e.pingedLanes|=e.suspendedLanes&n,q===e&&(ee&n)===n&&(G===4||G===3&&(ee&130023424)===ee&&500>Q()-xo?Ct(e,0):Co|=n),me(e,t)}function Xa(e,t){t===0&&(e.mode&1?(t=or,or<<=1,!(or&130023424)&&(or=4194304)):t=1);var n=ie();e=Ye(e,t),e!==null&&(Gn(e,t,n),me(e,n))}function Sd(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),Xa(e,n)}function kd(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,l=e.memoizedState;l!==null&&(n=l.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(y(314))}r!==null&&r.delete(t),Xa(e,n)}var Ga;Ga=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||de.current)fe=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return fe=!1,sd(e,t,n);fe=!!(e.flags&131072)}else fe=!1,A&&t.flags&1048576&&bs(t,$r,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Nr(e,t),e=t.pendingProps;var l=qt(t,ue.current);Gt(t,n),l=yo(null,t,r,e,l,n);var u=go();return t.flags|=1,typeof l=="object"&&l!==null&&typeof l.render=="function"&&l.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,pe(r)?(u=!0,Vr(t)):u=!1,t.memoizedState=l.state!==null&&l.state!==void 0?l.state:null,fo(t),l.updater=sl,t.stateNode=l,l._reactInternals=t,Cu(t,r,e,n),t=Nu(null,t,r,!0,u,n)):(t.tag=0,A&&u&&lo(t),oe(null,t,l,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Nr(e,t),e=t.pendingProps,l=r._init,r=l(r._payload),t.type=r,l=t.tag=Cd(r),e=Te(r,e),l){case 0:t=_u(null,t,r,e,n);break e;case 1:t=Ti(null,t,r,e,n);break e;case 11:t=Pi(null,t,r,e,n);break e;case 14:t=zi(null,t,r,Te(r.type,e),n);break e}throw Error(y(306,r,""))}return t;case 0:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),_u(e,t,r,l,n);case 1:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Ti(e,t,r,l,n);case 3:e:{if(ja(t),e===null)throw Error(y(387));r=t.pendingProps,u=t.memoizedState,l=u.element,ua(e,t),Qr(t,r,null,n);var o=t.memoizedState;if(r=o.element,u.isDehydrated)if(u={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=u,t.memoizedState=u,t.flags&256){l=nn(Error(y(423)),t),t=Li(e,t,r,n,l);break e}else if(r!==l){l=nn(Error(y(424)),t),t=Li(e,t,r,n,l);break e}else for(ve=ot(t.stateNode.containerInfo.firstChild),ye=t,A=!0,Re=null,n=ra(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(bt(),r===l){t=Xe(e,t,n);break e}oe(e,t,r,n)}t=t.child}return t;case 5:return oa(t),e===null&&Su(t),r=t.type,l=t.pendingProps,u=e!==null?e.memoizedProps:null,o=l.children,hu(r,l)?o=null:u!==null&&hu(r,u)&&(t.flags|=32),Ra(e,t),oe(e,t,o,n),t.child;case 6:return e===null&&Su(t),null;case 13:return Oa(e,t,n);case 4:return po(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=en(t,null,r,n):oe(e,t,r,n),t.child;case 11:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Pi(e,t,r,l,n);case 7:return oe(e,t,t.pendingProps,n),t.child;case 8:return oe(e,t,t.pendingProps.children,n),t.child;case 12:return oe(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,l=t.pendingProps,u=t.memoizedProps,o=l.value,I(Hr,r._currentValue),r._currentValue=o,u!==null)if(Me(u.value,o)){if(u.children===l.children&&!de.current){t=Xe(e,t,n);break e}}else for(u=t.child,u!==null&&(u.return=t);u!==null;){var i=u.dependencies;if(i!==null){o=u.child;for(var s=i.firstContext;s!==null;){if(s.context===r){if(u.tag===1){s=We(-1,n&-n),s.tag=2;var c=u.updateQueue;if(c!==null){c=c.shared;var h=c.pending;h===null?s.next=s:(s.next=h.next,h.next=s),c.pending=s}}u.lanes|=n,s=u.alternate,s!==null&&(s.lanes|=n),ku(u.return,n,t),i.lanes|=n;break}s=s.next}}else if(u.tag===10)o=u.type===t.type?null:u.child;else if(u.tag===18){if(o=u.return,o===null)throw Error(y(341));o.lanes|=n,i=o.alternate,i!==null&&(i.lanes|=n),ku(o,n,t),o=u.sibling}else o=u.child;if(o!==null)o.return=u;else for(o=u;o!==null;){if(o===t){o=null;break}if(u=o.sibling,u!==null){u.return=o.return,o=u;break}o=o.return}u=o}oe(e,t,l.children,n),t=t.child}return t;case 9:return l=t.type,r=t.pendingProps.children,Gt(t,n),l=_e(l),r=r(l),t.flags|=1,oe(e,t,r,n),t.child;case 14:return r=t.type,l=Te(r,t.pendingProps),l=Te(r.type,l),zi(e,t,r,l,n);case 15:return Ta(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,l=t.pendingProps,l=t.elementType===r?l:Te(r,l),Nr(e,t),t.tag=1,pe(r)?(e=!0,Vr(t)):e=!1,Gt(t,n),Na(t,r,l),Cu(t,r,l,n),Nu(null,t,r,!0,e,n);case 19:return Ma(e,t,n);case 22:return La(e,t,n)}throw Error(y(156,t.tag))};function Za(e,t){return Cs(e,t)}function Ed(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ce(e,t,n,r){return new Ed(e,t,n,r)}function zo(e){return e=e.prototype,!(!e||!e.isReactComponent)}function Cd(e){if(typeof e=="function")return zo(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Ku)return 11;if(e===Yu)return 14}return 2}function ct(e,t){var n=e.alternate;return n===null?(n=Ce(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Tr(e,t,n,r,l,u){var o=2;if(r=e,typeof e=="function")zo(e)&&(o=1);else if(typeof e=="string")o=5;else e:switch(e){case Mt:return xt(n.children,l,u,t);case Qu:o=8,l|=8;break;case Yl:return e=Ce(12,n,t,l|2),e.elementType=Yl,e.lanes=u,e;case Xl:return e=Ce(13,n,t,l),e.elementType=Xl,e.lanes=u,e;case Gl:return e=Ce(19,n,t,l),e.elementType=Gl,e.lanes=u,e;case os:return fl(n,l,u,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case ls:o=10;break e;case us:o=9;break e;case Ku:o=11;break e;case Yu:o=14;break e;case Je:o=16,r=null;break e}throw Error(y(130,e==null?e:typeof e,""))}return t=Ce(o,n,t,l),t.elementType=e,t.type=r,t.lanes=u,t}function xt(e,t,n,r){return e=Ce(7,e,r,t),e.lanes=n,e}function fl(e,t,n,r){return e=Ce(22,e,r,t),e.elementType=os,e.lanes=n,e.stateNode={isHidden:!1},e}function Hl(e,t,n){return e=Ce(6,e,null,t),e.lanes=n,e}function Wl(e,t,n){return t=Ce(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function xd(e,t,n,r,l){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=xl(0),this.expirationTimes=xl(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=xl(0),this.identifierPrefix=r,this.onRecoverableError=l,this.mutableSourceEagerHydrationData=null}function To(e,t,n,r,l,u,o,i,s){return e=new xd(e,t,n,i,s),t===1?(t=1,u===!0&&(t|=8)):t=0,u=Ce(3,null,null,t),e.current=u,u.stateNode=e,u.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},fo(u),e}function _d(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Ot,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function Ja(e){if(!e)return dt;e=e._reactInternals;e:{if(Rt(e)!==e||e.tag!==1)throw Error(y(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(pe(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(y(171))}if(e.tag===1){var n=e.type;if(pe(n))return Js(e,n,t)}return t}function qa(e,t,n,r,l,u,o,i,s){return e=To(n,r,!0,e,l,u,o,i,s),e.context=Ja(null),n=e.current,r=ie(),l=at(n),u=We(r,l),u.callback=t??null,it(n,u,l),e.current.lanes=l,Gn(e,l,r),me(e,r),e}function dl(e,t,n,r){var l=t.current,u=ie(),o=at(l);return n=Ja(n),t.context===null?t.context=n:t.pendingContext=n,t=We(u,o),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=it(l,t,o),e!==null&&(Oe(e,l,o,u),Cr(e,l,o)),o}function br(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Vi(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function Lo(e,t){Vi(e,t),(e=e.alternate)&&Vi(e,t)}function Nd(){return null}var ba=typeof reportError=="function"?reportError:function(e){console.error(e)};function Ro(e){this._internalRoot=e}pl.prototype.render=Ro.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(y(409));dl(e,t,null,null)};pl.prototype.unmount=Ro.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Tt(function(){dl(null,e,null,null)}),t[Ke]=null}};function pl(e){this._internalRoot=e}pl.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ls();e={blockedOn:null,target:e,priority:t};for(var n=0;n<be.length&&t!==0&&t<be[n].priority;n++);be.splice(n,0,e),n===0&&js(e)}};function jo(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function ml(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function Bi(){}function Pd(e,t,n,r,l){if(l){if(typeof r=="function"){var u=r;r=function(){var c=br(o);u.call(c)}}var o=qa(t,r,e,0,null,!1,!1,"",Bi);return e._reactRootContainer=o,e[Ke]=o.current,An(e.nodeType===8?e.parentNode:e),Tt(),o}for(;l=e.lastChild;)e.removeChild(l);if(typeof r=="function"){var i=r;r=function(){var c=br(s);i.call(c)}}var s=To(e,0,!1,null,null,!1,!1,"",Bi);return e._reactRootContainer=s,e[Ke]=s.current,An(e.nodeType===8?e.parentNode:e),Tt(function(){dl(t,s,n,r)}),s}function hl(e,t,n,r,l){var u=n._reactRootContainer;if(u){var o=u;if(typeof l=="function"){var i=l;l=function(){var s=br(o);i.call(s)}}dl(t,o,e,l)}else o=Pd(n,t,e,l,r);return br(o)}zs=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=Sn(t.pendingLanes);n!==0&&(Zu(t,n|1),me(t,Q()),!(j&6)&&(rn=Q()+500,ht()))}break;case 13:Tt(function(){var r=Ye(e,1);if(r!==null){var l=ie();Oe(r,e,1,l)}}),Lo(e,1)}};Ju=function(e){if(e.tag===13){var t=Ye(e,134217728);if(t!==null){var n=ie();Oe(t,e,134217728,n)}Lo(e,134217728)}};Ts=function(e){if(e.tag===13){var t=at(e),n=Ye(e,t);if(n!==null){var r=ie();Oe(n,e,t,r)}Lo(e,t)}};Ls=function(){return M};Rs=function(e,t){var n=M;try{return M=e,t()}finally{M=n}};uu=function(e,t,n){switch(t){case"input":if(ql(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var l=ul(r);if(!l)throw Error(y(90));ss(r),ql(r,l)}}}break;case"textarea":cs(e,n);break;case"select":t=n.value,t!=null&&Qt(e,!!n.multiple,t,!1)}};ys=_o;gs=Tt;var zd={usingClientEntryPoint:!1,Events:[Jn,Ut,ul,hs,vs,_o]},yn={findFiberByHostInstance:St,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},Td={bundleType:yn.bundleType,version:yn.version,rendererPackageName:yn.rendererPackageName,rendererConfig:yn.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Ge.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=ks(e),e===null?null:e.stateNode},findFiberByHostInstance:yn.findFiberByHostInstance||Nd,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var yr=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yr.isDisabled&&yr.supportsFiber)try{tl=yr.inject(Td),Ue=yr}catch{}}we.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=zd;we.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!jo(t))throw Error(y(200));return _d(e,t,null,n)};we.createRoot=function(e,t){if(!jo(e))throw Error(y(299));var n=!1,r="",l=ba;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(l=t.onRecoverableError)),t=To(e,1,!1,null,null,n,!1,r,l),e[Ke]=t.current,An(e.nodeType===8?e.parentNode:e),new Ro(t)};we.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(y(188)):(e=Object.keys(e).join(","),Error(y(268,e)));return e=ks(t),e=e===null?null:e.stateNode,e};we.flushSync=function(e){return Tt(e)};we.hydrate=function(e,t,n){if(!ml(t))throw Error(y(200));return hl(null,e,t,!0,n)};we.hydrateRoot=function(e,t,n){if(!jo(e))throw Error(y(405));var r=n!=null&&n.hydratedSources||null,l=!1,u="",o=ba;if(n!=null&&(n.unstable_strictMode===!0&&(l=!0),n.identifierPrefix!==void 0&&(u=n.identifierPrefix),n.onRecoverableError!==void 0&&(o=n.onRecoverableError)),t=qa(t,null,e,1,n??null,l,!1,u,o),e[Ke]=t.current,An(e),r)for(e=0;e<r.length;e++)n=r[e],l=n._getVersion,l=l(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,l]:t.mutableSourceEagerHydrationData.push(n,l);return new pl(t)};we.render=function(e,t,n){if(!ml(t))throw Error(y(200));return hl(null,e,t,!1,n)};we.unmountComponentAtNode=function(e){if(!ml(e))throw Error(y(40));return e._reactRootContainer?(Tt(function(){hl(null,null,e,!1,function(){e._reactRootContainer=null,e[Ke]=null})}),!0):!1};we.unstable_batchedUpdates=_o;we.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!ml(n))throw Error(y(200));if(e==null||e._reactInternals===void 0)throw Error(y(38));return hl(e,t,n,!1,r)};we.version="18.3.1-next-f1338f8080-20240426";function ec(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ec)}catch(e){console.error(e)}}ec(),es.exports=we;var Ld=es.exports,$i=Ld;Ql.createRoot=$i.createRoot,Ql.hydrateRoot=$i.hydrateRoot;const Rd=2e3;function jd(){const[e,t]=Y.useState(!1),[n,r]=Y.useState(null),[l,u]=Y.useState("idle"),[o,i]=Y.useState(""),[s,c]=Y.useState(""),[h,m]=Y.useState(0),p=Y.useRef(null),g=Y.useRef(null),w=Y.useRef(null),S=Y.useRef(!1),D=Y.useRef(null);Y.useEffect(()=>()=>v(),[]);const f=Y.useCallback(async k=>{u("saving"),i("");try{const R=await(await fetch("./api/save.php",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({qr_text:k})})).json();R.success?(u("saved"),m(P=>P+1)):(u("error"),i(R.error||"Nieznany b≈ÇƒÖd serwera"))}catch{u("error"),i("Brak po≈ÇƒÖczenia z serwerem")}},[]),a=Y.useCallback(k=>{S.current||(S.current=!0,r(k),f(k),setTimeout(()=>{S.current=!1},Rd))},[f]),d=Y.useCallback(async()=>{var k;if(c(""),!("BarcodeDetector"in window)){c("Twoja przeglƒÖdarka nie obs≈Çuguje skanowania QR. U≈ºyj Chrome na Androidzie.");return}try{D.current=new BarcodeDetector({formats:["qr_code"]});const x=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:"environment"},width:{ideal:1920},height:{ideal:1080}},audio:!1});g.current=x;const R=p.current;R.srcObject=x,R.setAttribute("playsinline","true"),await R.play(),t(!0),w.current=setInterval(async()=>{if(!(!p.current||p.current.readyState<2))try{const P=await D.current.detect(p.current);P.length>0&&a(P[0].rawValue)}catch{}},150)}catch(x){const R=((k=x==null?void 0:x.toString)==null?void 0:k.call(x))||"Nie uda≈Ço siƒô uruchomiƒá kamery";R.includes("NotAllowedError")||R.includes("Permission")?c("Brak zgody na dostƒôp do kamery. Sprawd≈∫ ustawienia przeglƒÖdarki."):R.includes("NotFoundError")?c("Nie znaleziono kamery na tym urzƒÖdzeniu."):c(R)}},[a]),v=Y.useCallback(()=>{w.current&&(clearInterval(w.current),w.current=null),g.current&&(g.current.getTracks().forEach(k=>k.stop()),g.current=null),p.current&&(p.current.srcObject=null),D.current=null,t(!1)},[]),E=()=>{switch(l){case"saving":return"‚è≥";case"saved":return"‚úÖ";case"error":return"‚ùå";default:return"‚Äî"}},N=()=>{switch(l){case"saving":return"Zapisywanie‚Ä¶";case"saved":return"Zapisano pomy≈õlnie";case"error":return o||"WystƒÖpi≈Ç b≈ÇƒÖd";default:return"Oczekiwanie na skan"}};return O.jsxs("div",{className:"app",children:[O.jsxs("main",{className:"main",children:[O.jsxs("section",{className:"card scanner-card",children:[O.jsx("h2",{className:"scanner-title",children:"Skanuj kod QR"}),!e&&!s&&O.jsxs("div",{className:"scanner-placeholder-wrapper",children:[O.jsx("span",{className:"scanner-placeholder-icon",children:"üì∏"}),O.jsxs("span",{children:["Naci≈õnij przycisk poni≈ºej,",O.jsx("br",{}),"aby uruchomiƒá kamerƒô"]})]}),O.jsx("div",{className:"scanner-video-wrapper",style:{display:e?"block":"none"},children:O.jsx("video",{ref:p,className:"scanner-video",playsInline:!0,muted:!0})}),s&&O.jsxs("div",{className:"camera-error",children:[O.jsx("span",{className:"camera-error-icon",children:"‚ö†Ô∏è"}),O.jsx("span",{children:s})]}),O.jsx("div",{className:"scanner-controls",children:e?O.jsxs("button",{className:"btn btn-stop",onClick:v,children:[O.jsx("span",{className:"btn-icon",children:"‚èπ"}),"Zatrzymaj"]}):O.jsxs("button",{className:"btn btn-start",onClick:d,children:[O.jsx("span",{className:"btn-icon",children:"‚ñ∂"}),"Uruchom skaner"]})})]}),O.jsxs("section",{className:"card result-card",children:[O.jsx("h2",{className:"card-label",children:"Ostatni skan"}),O.jsx("div",{className:`scan-result ${n?"has-value":""}`,children:n||"Brak skan√≥w"})]}),O.jsxs("section",{className:`card status-card status-${l}`,children:[O.jsx("h2",{className:"card-label",children:"Status zapisu"}),O.jsxs("div",{className:"status-row",children:[O.jsx("span",{className:"status-icon",children:E()}),O.jsx("span",{className:"status-text",children:N()})]})]}),h>0&&O.jsxs("div",{className:"counter",children:["Zapisano dzisiaj: ",O.jsx("strong",{children:h})," ",h===1?"skan":h<5?"skany":"skan√≥w"]})]}),O.jsx("footer",{className:"footer",children:"Krawcowa App ¬∑ Skaner etykiet"})]})}Ql.createRoot(document.getElementById("root")).render(O.jsx(gc.StrictMode,{children:O.jsx(jd,{})}));[m
[1mdiff --git a/frontend/dist/index.html b/frontend/dist/index.html[m
[1mindex d4f67c2..47f356b 100644[m
[1m--- a/frontend/dist/index.html[m
[1m+++ b/frontend/dist/index.html[m
[36m@@ -9,7 +9,7 @@[m
     <link rel="preconnect" href="https://fonts.googleapis.com" />[m
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />[m
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />[m
[31m-    <script type="module" crossorigin src="./assets/index-D9s3s2jp.js"></script>[m
[32m+[m[32m    <script type="module" crossorigin src="./assets/index-CL4UxkMi.js"></script>[m
     <link rel="stylesheet" crossorigin href="./assets/index-BjN-r06w.css">[m
   </head>[m
   <body>[m
[1mdiff --git a/frontend/node_modules/.package-lock.json b/frontend/node_modules/.package-lock.json[m
[1mindex 7b1b73d..933a30f 100644[m
[1m--- a/frontend/node_modules/.package-lock.json[m
[1m+++ b/frontend/node_modules/.package-lock.json[m
[36m@@ -461,6 +461,28 @@[m
         "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"[m
       }[m
     },[m
[32m+[m[32m    "node_modules/@zxing/library": {[m
[32m+[m[32m      "version": "0.21.3",[m
[32m+[m[32m      "resolved": "https://registry.npmjs.org/@zxing/library/-/library-0.21.3.tgz",[m
[32m+[m[32m      "integrity": "sha512-hZHqFe2JyH/ZxviJZosZjV+2s6EDSY0O24R+FQmlWZBZXP9IqMo7S3nb3+2LBWxodJQkSurdQGnqE7KXqrYgow==",[m
[32m+[m[32m      "license": "MIT",[m
[32m+[m[32m      "dependencies": {[m
[32m+[m[32m        "ts-custom-error": "^3.2.1"[m
[32m+[m[32m      },[m
[32m+[m[32m      "engines": {[m
[32m+[m[32m        "node": ">= 10.4.0"[m
[32m+[m[32m      },[m
[32m+[m[32m      "optionalDependencies": {[m
[32m+[m[32m        "@zxing/text-encoding": "~0.9.0"[m
[32m+[m[32m      }[m
[32m+[m[32m    },[m
[32m+[m[32m    "node_modules/@zxing/text-encoding": {[m
[32m+[m[32m      "version": "0.9.0",[m
[32m+[m[32m      "resolved": "https://registry.npmjs.org/@zxing/text-encoding/-/text-encoding-0.9.0.tgz",[m
[32m+[m[32m      "integrity": "sha512-U/4aVJ2mxI0aDNI8Uq0wEhMgY+u4CNtEb0om3+y3+niDAsoTCOB33UF0sxpzqzdqXLqmvc+vZyAt4O8pPdfkwA==",[m
[32m+[m[32m      "license": "(Unlicense OR Apache-2.0)",[m
[32m+[m[32m      "optional": true[m
[32m+[m[32m    },[m
     "node_modules/baseline-browser-mapping": {[m
       "version": "2.9.19",[m
       "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.9.19.tgz",[m
[36m@@ -855,6 +877,15 @@[m
         "node": ">=0.10.0"[m
       }[m
     },[m
[32m+[m[32m    "node_modules/ts-custom-error": {[m
[32m+[m[32m      "version": "3.3.1",[m
[32m+[m[32m      "resolved": "https://registry.npmjs.org/ts-custom-error/-/ts-custom-error-3.3.1.tgz",[m
[32m+[m[32m      "integrity": "sha512-5OX1tzOjxWEgsr/YEUWSuPrQ00deKLh6D7OTWcvNHm12/7QPyRh8SYpyWvA4IZv8H/+GQWQEh/kwo95Q9OVW1A==",[m
[32m+[m[32m      "license": "MIT",[m
[32m+[m[32m      "engines": {[m
[32m+[m[32m        "node": ">=14.0.0"[m
[32m+[m[32m      }[m
[32m+[m[32m    },[m
     "node_modules/update-browserslist-db": {[m
       "version": "1.2.3",[m
       "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",[m
[1mdiff --git a/frontend/node_modules/@zxing/library/LICENSE b/frontend/node_modules/@zxing/library/LICENSE[m
[1mnew file mode 100644[m
[1mindex 0000000..4bcbdae[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/LICENSE[m
[36m@@ -0,0 +1,245 @@[m
[32m+[m[32m                                 Apache License[m
[32m+[m[32m                           Version 2.0, January 2004[m
[32m+[m[32m                        http://www.apache.org/licenses/[m
[32m+[m
[32m+[m[32m   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION[m
[32m+[m
[32m+[m[32m   1. Definitions.[m
[32m+[m
[32m+[m[32m      "License" shall mean the terms and conditions for use, reproduction,[m
[32m+[m[32m      and distribution as defined by Sections 1 through 9 of this document.[m
[32m+[m
[32m+[m[32m      "Licensor" shall mean the copyright owner or entity authorized by[m
[32m+[m[32m      the copyright owner that is granting the License.[m
[32m+[m
[32m+[m[32m      "Legal Entity" shall mean the union of the acting entity and all[m
[32m+[m[32m      other entities that control, are controlled by, or are under common[m
[32m+[m[32m      control with that entity. For the purposes of this definition,[m
[32m+[m[32m      "control" means (i) the power, direct or indirect, to cause the[m
[32m+[m[32m      direction or management of such entity, whether by contract or[m
[32m+[m[32m      otherwise, or (ii) ownership of fifty percent (50%) or more of the[m
[32m+[m[32m      outstanding shares, or (iii) beneficial ownership of such entity.[m
[32m+[m
[32m+[m[32m      "You" (or "Your") shall mean an individual or Legal Entity[m
[32m+[m[32m      exercising permissions granted by this License.[m
[32m+[m
[32m+[m[32m      "Source" form shall mean the preferred form for making modifications,[m
[32m+[m[32m      including but not limited to software source code, documentation[m
[32m+[m[32m      source, and configuration files.[m
[32m+[m
[32m+[m[32m      "Object" form shall mean any form resulting from mechanical[m
[32m+[m[32m      transformation or translation of a Source form, including but[m
[32m+[m[32m      not limited to compiled object code, generated documentation,[m
[32m+[m[32m      and conversions to other media types.[m
[32m+[m
[32m+[m[32m      "Work" shall mean the work of authorship, whether in Source or[m
[32m+[m[32m      Object form, made available under the License, as indicated by a[m
[32m+[m[32m      copyright notice that is included in or attached to the work[m
[32m+[m[32m      (an example is provided in the Appendix below).[m
[32m+[m
[32m+[m[32m      "Derivative Works" shall mean any work, whether in Source or Object[m
[32m+[m[32m      form, that is based on (or derived from) the Work and for which the[m
[32m+[m[32m      editorial revisions, annotations, elaborations, or other modifications[m
[32m+[m[32m      represent, as a whole, an original work of authorship. For the purposes[m
[32m+[m[32m      of this License, Derivative Works shall not include works that remain[m
[32m+[m[32m      separable from, or merely link (or bind by name) to the interfaces of,[m
[32m+[m[32m      the Work and Derivative Works thereof.[m
[32m+[m
[32m+[m[32m      "Contribution" shall mean any work of authorship, including[m
[32m+[m[32m      the original version of the Work and any modifications or additions[m
[32m+[m[32m      to that Work or Derivative Works thereof, that is intentionally[m
[32m+[m[32m      submitted to Licensor for inclusion in the Work by the copyright owner[m
[32m+[m[32m      or by an individual or Legal Entity authorized to submit on behalf of[m
[32m+[m[32m      the copyright owner. For the purposes of this definition, "submitted"[m
[32m+[m[32m      means any form of electronic, verbal, or written communication sent[m
[32m+[m[32m      to the Licensor or its representatives, including but not limited to[m
[32m+[m[32m      communication on electronic mailing lists, source code control systems,[m
[32m+[m[32m      and issue tracking systems that are managed by, or on behalf of, the[m
[32m+[m[32m      Licensor for the purpose of discussing and improving the Work, but[m
[32m+[m[32m      excluding communication that is conspicuously marked or otherwise[m
[32m+[m[32m      designated in writing by the copyright owner as "Not a Contribution."[m
[32m+[m
[32m+[m[32m      "Contributor" shall mean Licensor and any individual or Legal Entity[m
[32m+[m[32m      on behalf of whom a Contribution has been received by Licensor and[m
[32m+[m[32m      subsequently incorporated within the Work.[m
[32m+[m
[32m+[m[32m   2. Grant of Copyright License. Subject to the terms and conditions of[m
[32m+[m[32m      this License, each Contributor hereby grants to You a perpetual,[m
[32m+[m[32m      worldwide, non-exclusive, no-charge, royalty-free, irrevocable[m
[32m+[m[32m      copyright license to reproduce, prepare Derivative Works of,[m
[32m+[m[32m      publicly display, publicly perform, sublicense, and distribute the[m
[32m+[m[32m      Work and such Derivative Works in Source or Object form.[m
[32m+[m
[32m+[m[32m   3. Grant of Patent License. Subject to the terms and conditions of[m
[32m+[m[32m      this License, each Contributor hereby grants to You a perpetual,[m
[32m+[m[32m      worldwide, non-exclusive, no-charge, royalty-free, irrevocable[m
[32m+[m[32m      (except as stated in this section) patent license to make, have made,[m
[32m+[m[32m      use, offer to sell, sell, import, and otherwise transfer the Work,[m
[32m+[m[32m      where such license applies only to those patent claims licensable[m
[32m+[m[32m      by such Contributor that are necessarily infringed by their[m
[32m+[m[32m      Contribution(s) alone or by combination of their Contribution(s)[m
[32m+[m[32m      with the Work to which such Contribution(s) was submitted. If You[m
[32m+[m[32m      institute patent litigation against any entity (including a[m
[32m+[m[32m      cross-claim or counterclaim in a lawsuit) alleging that the Work[m
[32m+[m[32m      or a Contribution incorporated within the Work constitutes direct[m
[32m+[m[32m      or contributory patent infringement, then any patent licenses[m
[32m+[m[32m      granted to You under this License for that Work shall terminate[m
[32m+[m[32m      as of the date such litigation is filed.[m
[32m+[m
[32m+[m[32m   4. Redistribution. You may reproduce and distribute copies of the[m
[32m+[m[32m      Work or Derivative Works thereof in any medium, with or without[m
[32m+[m[32m      modifications, and in Source or Object form, provided that You[m
[32m+[m[32m      meet the following conditions:[m
[32m+[m
[32m+[m[32m      (a) You must give any other recipients of the Work or[m
[32m+[m[32m          Derivative Works a copy of this License; and[m
[32m+[m
[32m+[m[32m      (b) You must cause any modified files to carry prominent notices[m
[32m+[m[32m          stating that You changed the files; and[m
[32m+[m
[32m+[m[32m      (c) You must retain, in the Source form of any Derivative Works[m
[32m+[m[32m          that You distribute, all copyright, patent, trademark, and[m
[32m+[m[32m          attribution notices from the Source form of the Work,[m
[32m+[m[32m          excluding those notices that do not pertain to any part of[m
[32m+[m[32m          the Derivative Works; and[m
[32m+[m
[32m+[m[32m      (d) If the Work includes a "NOTICE" text file as part of its[m
[32m+[m[32m          distribution, then any Derivative Works that You distribute must[m
[32m+[m[32m          include a readable copy of the attribution notices contained[m
[32m+[m[32m          within such NOTICE file, excluding those notices that do not[m
[32m+[m[32m          pertain to any part of the Derivative Works, in at least one[m
[32m+[m[32m          of the following places: within a NOTICE text file distributed[m
[32m+[m[32m          as part of the Derivative Works; within the Source form or[m
[32m+[m[32m          documentation, if provided along with the Derivative Works; or,[m
[32m+[m[32m          within a display generated by the Derivative Works, if and[m
[32m+[m[32m          wherever such third-party notices normally appear. The contents[m
[32m+[m[32m          of the NOTICE file are for informational purposes only and[m
[32m+[m[32m          do not modify the License. You may add Your own attribution[m
[32m+[m[32m          notices within Derivative Works that You distribute, alongside[m
[32m+[m[32m          or as an addendum to the NOTICE text from the Work, provided[m
[32m+[m[32m          that such additional attribution notices cannot be construed[m
[32m+[m[32m          as modifying the License.[m
[32m+[m
[32m+[m[32m      You may add Your own copyright statement to Your modifications and[m
[32m+[m[32m      may provide additional or different license terms and conditions[m
[32m+[m[32m      for use, reproduction, or distribution of Your modifications, or[m
[32m+[m[32m      for any such Derivative Works as a whole, provided Your use,[m
[32m+[m[32m      reproduction, and distribution of the Work otherwise complies with[m
[32m+[m[32m      the conditions stated in this License.[m
[32m+[m
[32m+[m[32m   5. Submission of Contributions. Unless You explicitly state otherwise,[m
[32m+[m[32m      any Contribution intentionally submitted for inclusion in the Work[m
[32m+[m[32m      by You to the Licensor shall be under the terms and conditions of[m
[32m+[m[32m      this License, without any additional terms or conditions.[m
[32m+[m[32m      Notwithstanding the above, nothing herein shall supersede or modify[m
[32m+[m[32m      the terms of any separate license agreement you may have executed[m
[32m+[m[32m      with Licensor regarding such Contributions.[m
[32m+[m
[32m+[m[32m   6. Trademarks. This License does not grant permission to use the trade[m
[32m+[m[32m      names, trademarks, service marks, or product names of the Licensor,[m
[32m+[m[32m      except as required for reasonable and customary use in describing the[m
[32m+[m[32m      origin of the Work and reproducing the content of the NOTICE file.[m
[32m+[m
[32m+[m[32m   7. Disclaimer of Warranty. Unless required by applicable law or[m
[32m+[m[32m      agreed to in writing, Licensor provides the Work (and each[m
[32m+[m[32m      Contributor provides its Contributions) on an "AS IS" BASIS,[m
[32m+[m[32m      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or[m
[32m+[m[32m      implied, including, without limitation, any warranties or conditions[m
[32m+[m[32m      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A[m
[32m+[m[32m      PARTICULAR PURPOSE. You are solely responsible for determining the[m
[32m+[m[32m      appropriateness of using or redistributing the Work and assume any[m
[32m+[m[32m      risks associated with Your exercise of permissions under this License.[m
[32m+[m
[32m+[m[32m   8. Limitation of Liability. In no event and under no legal theory,[m
[32m+[m[32m      whether in tort (including negligence), contract, or otherwise,[m
[32m+[m[32m      unless required by applicable law (such as deliberate and grossly[m
[32m+[m[32m      negligent acts) or agreed to in writing, shall any Contributor be[m
[32m+[m[32m      liable to You for damages, including any direct, indirect, special,[m
[32m+[m[32m      incidental, or consequential damages of any character arising as a[m
[32m+[m[32m      result of this License or out of the use or inability to use the[m
[32m+[m[32m      Work (including but not limited to damages for loss of goodwill,[m
[32m+[m[32m      work stoppage, computer failure or malfunction, or any and all[m
[32m+[m[32m      other commercial damages or losses), even if such Contributor[m
[32m+[m[32m      has been advised of the possibility of such damages.[m
[32m+[m
[32m+[m[32m   9. Accepting Warranty or Additional Liability. While redistributing[m
[32m+[m[32m      the Work or Derivative Works thereof, You may choose to offer,[m
[32m+[m[32m      and charge a fee for, acceptance of support, warranty, indemnity,[m
[32m+[m[32m      or other liability obligations and/or rights consistent with this[m
[32m+[m[32m      License. However, in accepting such obligations, You may act only[m
[32m+[m[32m      on Your own behalf and on Your sole responsibility, not on behalf[m
[32m+[m[32m      of any other Contributor, and only if You agree to indemnify,[m
[32m+[m[32m      defend, and hold each Contributor harmless for any liability[m
[32m+[m[32m      incurred by, or claims asserted against, such Contributor by reason[m
[32m+[m[32m      of your accepting any such warranty or additional liability.[m
[32m+[m
[32m+[m[32m   END OF TERMS AND CONDITIONS[m
[32m+[m
[32m+[m[32m   APPENDIX: How to apply the Apache License to your work.[m
[32m+[m
[32m+[m[32m      To apply the Apache License to your work, attach the following[m
[32m+[m[32m      boilerplate notice, with the fields enclosed by brackets "[]"[m
[32m+[m[32m      replaced with your own identifying information. (Don't include[m
[32m+[m[32m      the brackets!)  The text should be enclosed in the appropriate[m
[32m+[m[32m      comment syntax for the file format. We also recommend that a[m
[32m+[m[32m      file or class name and description of purpose be included on the[m
[32m+[m[32m      same "printed page" as the copyright notice for easier[m
[32m+[m[32m      identification within third-party archives.[m
[32m+[m
[32m+[m[32m   Copyright [yyyy] [name of copyright owner][m
[32m+[m
[32m+[m[32m   Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m   you may not use this file except in compliance with the License.[m
[32m+[m[32m   You may obtain a copy of the License at[m
[32m+[m
[32m+[m[32m       http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m
[32m+[m[32m   Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m   distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m   See the License for the specific language governing permissions and[m
[32m+[m[32m   limitations under the License.[m
[32m+[m
[32m+[m[32m========================================================================[m
[32m+[m[32mjai-imageio[m
[32m+[m[32m========================================================================[m
[32m+[m
[32m+[m[32mCopyright (c) 2005 Sun Microsystems, Inc.[m
[32m+[m[32mCopyright ¬© 2010-2014 University of Manchester[m
[32m+[m[32mCopyright ¬© 2010-2015 Stian Soiland-Reyes[m
[32m+[m[32mCopyright ¬© 2015 Peter Hull[m
[32m+[m[32mAll Rights Reserved.[m
[32m+[m
[32m+[m[32mRedistribution and use in source and binary forms, with or without[m
[32m+[m[32mmodification, are permitted provided that the following conditions[m
[32m+[m[32mare met:[m
[32m+[m
[32m+[m[32m- Redistribution of source code must retain the above copyright[m
[32m+[m[32m  notice, this list of conditions and the following disclaimer.[m
[32m+[m
[32m+[m[32m- Redistribution in binary form must reproduce the above copyright[m
[32m+[m[32m  notice, this list of conditions and the following disclaimer in[m
[32m+[m[32m  the documentation and/or other materials provided with the[m
[32m+[m[32m  distribution.[m
[32m+[m
[32m+[m[32mNeither the name of Sun Microsystems, Inc. or the names of[m
[32m+[m[32mcontributors may be used to endorse or promote products derived[m
[32m+[m[32mfrom this software without specific prior written permission.[m
[32m+[m
[32m+[m[32mThis software is provided "AS IS," without a warranty of any[m
[32m+[m[32mkind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND[m
[32m+[m[32mWARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,[m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY[m
[32m+[m[32mEXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL[m
[32m+[m[32mNOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF[m
[32m+[m[32mUSING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS[m
[32m+[m[32mDERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR[m
[32m+[m[32mANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,[m
[32m+[m[32mCONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND[m
[32m+[m[32mREGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR[m
[32m+[m[32mINABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE[m
[32m+[m[32mPOSSIBILITY OF SUCH DAMAGES.[m
[32m+[m
[32m+[m[32mYou acknowledge that this software is not designed or intended for[m
[32m+[m[32muse in the design, construction, operation or maintenance of any[m
[32m+[m[32mnuclear facility.[m
[1mdiff --git a/frontend/node_modules/@zxing/library/README.md b/frontend/node_modules/@zxing/library/README.md[m
[1mnew file mode 100644[m
[1mindex 0000000..6a66cdc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/README.md[m
[36m@@ -0,0 +1,126 @@[m
[32m+[m[32m[<img align="right" src="https://raw.github.com/wiki/zxing/zxing/zxing-logo.png"/>][1][m
[32m+[m
[32m+[m[32m# ZXing[m
[32m+[m
[32m+[m[32m## Project in Maintenance Mode Only[m
[32m+[m
[32m+[m[32mThe project is in maintenance mode, meaning, changes are driven by contributed patches.[m
[32m+[m[32mOnly bug fixes and minor enhancements will be considered. The Barcode Scanner app can[m
[32m+[m[32mno longer be published, so it's unlikely any changes will be accepted for it.[m
[32m+[m[32mThere is otherwise no active development or roadmap for this project. It is "DIY".[m
[32m+[m
[32m+[m[32m### Runs on your favorite ECMAScript ecosystem[m
[32m+[m
[32m+[m[32m> If it doesn't, we gonna make it.[m
[32m+[m
[32m+[m[32m## What is ZXing?[m
[32m+[m
[32m+[m[32m> [ZXing][1] ("zebra crossing") is an open-source, multi-format 1D/2D barcode image processing library implemented in Java, with ports to other languages.[m
[32m+[m
[32m+[m[32m## Supported Formats[m
[32m+[m
[32m+[m[32m> See [Projects](https://github.com/zxing-js/library/projects) and [Milestones](https://github.com/zxing-js/library/milestones) for what is currently done and what's planned next. üëÄ[m
[32m+[m
[32m+[m[32m| 1D product | 1D industrial                        | 2D           |[m
[32m+[m[32m| ---------- |--------------------------------------|--------------|[m
[32m+[m[32m| UPC-A      | Code 39                              | QR Code      |[m
[32m+[m[32m| UPC-E      | Code 93                              | Data Matrix  |[m
[32m+[m[32m| EAN-8      | Code 128                             | Aztec        |[m
[32m+[m[32m| EAN-13     | Codabar                              | PDF 417      |[m
[32m+[m[32m|            | ITF                                  | ~~MaxiCode~~ |[m
[32m+[m[32m|            | RSS-14                               |              |[m
[32m+[m[32m|            | RSS-Expanded (not production ready!) |              |[m
[32m+[m
[32m+[m
[32m+[m[32m## Status[m
[32m+[m
[32m+[m[32m[![Maintainer wanted](https://img.shields.io/badge/maintained-help%20wanted-red)](https://npmjs.org/package/@zxing/ngx-scanner)[m
[32m+[m[32m[![Greenkeeper badge](https://badges.greenkeeper.io/zxing-js/library.svg)](https://greenkeeper.io/)[m
[32m+[m
[32m+[m[32m[![NPM version](https://img.shields.io/npm/v/@zxing/library.svg?&label=npm)][0][m
[32m+[m[32m[![npm](https://img.shields.io/npm/dm/localeval.svg)][0][m
[32m+[m[32m[![Contributors](https://img.shields.io/github/contributors/zxing-js/library.svg)](https://github.com/zxing-js/library/graphs/contributors)[m
[32m+[m[32m[![Commits to deploy](https://img.shields.io/github/commits-since/zxing-js/library/master.svg?label=commits%20to%20deploy)](https://github.com/zxing-js/library/compare/master...develop)[m
[32m+[m
[32m+[m[32m[![Maintainability](https://api.codeclimate.com/v1/badges/2b9c6ae92412ee8e15a9/maintainability)](https://codeclimate.com/github/zxing-js/library/maintainability)[m
[32m+[m[32m[![Test Coverage](https://api.codeclimate.com/v1/badges/2b9c6ae92412ee8e15a9/test_coverage)](https://codeclimate.com/github/zxing-js/library/test_coverage)[m
[32m+[m
[32m+[m[32m### Attention[m
[32m+[m
[32m+[m[32m>NOTE: While we do not have the time to actively maintain zxing-js anymore, we are open to new maintainers taking the lead.[m
[32m+[m
[32m+[m[32m## Demo[m
[32m+[m
[32m+[m[32mSee [Live Preview](https://zxing-js.github.io/library/) in browser.[m
[32m+[m
[32m+[m[32m**Note:** All the examples are using ES6, be sure is supported in your browser or modify as needed, Chrome recommended.[m
[32m+[m
[32m+[m[32m## Installation[m
[32m+[m
[32m+[m[32m`npm i @zxing/library --save`[m
[32m+[m
[32m+[m[32mor[m
[32m+[m
[32m+[m[32m`yarn add @zxing/library`[m
[32m+[m
[32m+[m[32m## Limitations[m
[32m+[m
[32m+[m[32mOn iOS-Devices **with iOS < 14.3** camera access works only in native Safari and not in other Browsers (Chrome,...) or Apps that use an UIWebView or WKWebView. This is not a restriction of this library but of the limited WebRTC support by Apple. The behavior might change in iOS 11.3 (Apr 2018?, not tested) as stated [here](https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_11_1.html#//apple_ref/doc/uid/TP40014305-CH14-SW1)[m
[32m+[m
[32m+[m[32m> iOS 14.3 (released in december 2020) now supports WebRTC in 3rd party browsers as well üéâ[m[41m [m
[32m+[m
[32m+[m[32m### Browser Support[m
[32m+[m
[32m+[m[32mThe browser layer is using the [MediaDevices](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices) web API which is not supported by older browsers.[m
[32m+[m
[32m+[m[32m_You can use external polyfills like [WebRTC adapter](https://github.com/webrtc/adapter) to increase browser compatibility._[m
[32m+[m
[32m+[m[32mAlso, note that the library is using the [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) (`Int32Array`, `Uint8ClampedArray`, etc.) which are not available in older browsers (e.g. Android 4 default browser).[m
[32m+[m
[32m+[m[32m_You can use [core-js](https://github.com/zloirock/core-js) to add support to these browsers._[m
[32m+[m
[32m+[m[32mIn the PDF 417 decoder recent addition, the library now makes use of the new `BigInt` type, which [is not supported by all browsers][2] as well. There's no way to polyfill that and ponyfill libraries are **way to big**, but even if PDF 417 decoding relies on `BigInt` the rest of the library shall work ok in browsers that doesn't support it.[m
[32m+[m
[32m+[m[32m_There's no polyfills for `BigInt` in the way it's coded in here._[m
[32m+[m
[32m+[m[32m## Usage[m
[32m+[m
[32m+[m[32m```javascript[m
[32m+[m[32m// use with commonJS[m
[32m+[m[32mconst { MultiFormatReader, BarcodeFormat } = require('@zxing/library');[m
[32m+[m[32m// or with ES6 modules[m
[32m+[m[32mimport { MultiFormatReader, BarcodeFormat } from '@zxing/library';[m
[32m+[m
[32m+[m[32mconst hints = new Map();[m
[32m+[m[32mconst formats = [BarcodeFormat.QR_CODE, BarcodeFormat.DATA_MATRIX/*, ...*/];[m
[32m+[m
[32m+[m[32mhints.set(DecodeHintType.POSSIBLE_FORMATS, formats);[m
[32m+[m
[32m+[m[32mconst reader = new MultiFormatReader();[m
[32m+[m
[32m+[m[32mconst luminanceSource = new RGBLuminanceSource(imgByteArray, imgWidth, imgHeight);[m
[32m+[m[32mconst binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));[m
[32m+[m
[32m+[m[32mreader.decode(binaryBitmap, hints);[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## Contributing[m
[32m+[m
[32m+[m[32mSee [Contributing Guide](https://github.com/zxing-js/library/blob/master/CONTRIBUTING.md) for information regarding porting approach and reasoning behind some of the approaches taken.[m
[32m+[m
[32m+[m[32m## Contributors[m
[32m+[m
[32m+[m[32mSpecial thanks to all the contributors who have contributed for this project. We heartly thankful to you all.[m
[32m+[m
[32m+[m[32m[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/0)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/0)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/1)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/1)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/2)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/2)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/3)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/3)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/4)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/4)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/5)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/5)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/6)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/6)[![](https://sourcerer.io/fame/odahcam/zxing-js/library/images/7)](https://sourcerer.io/fame/odahcam/zxing-js/library/links/7)[m
[32m+[m
[32m+[m[32mAnd a special thanks to [@aleris][3] who created the project itself and made available the initial QR code port.[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m[![Bless](https://cdn.rawgit.com/LunaGao/BlessYourCodeTag/master/tags/alpaca.svg)](http://lunagao.github.io/BlessYourCodeTag/)[m
[32m+[m
[32m+[m[32m[0]: https://www.npmjs.com/package/@zxing/library[m
[32m+[m[32m[1]: https://github.com/zxing/zxing[m
[32m+[m[32m[2]: https://caniuse.com/#feat=bigint[m
[32m+[m[32m[3]: https://github.com/aleris[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser.d.ts b/frontend/node_modules/@zxing/library/cjs/browser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..00687da[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser.d.ts[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32mexport * from './browser/BrowserAztecCodeReader';[m
[32m+[m[32mexport * from './browser/BrowserBarcodeReader';[m
[32m+[m[32mexport * from './browser/BrowserCodeReader';[m
[32m+[m[32mexport * from './browser/BrowserDatamatrixCodeReader';[m
[32m+[m[32mexport * from './browser/BrowserMultiFormatReader';[m
[32m+[m[32mexport * from './browser/BrowserPDF417Reader';[m
[32m+[m[32mexport * from './browser/BrowserQRCodeReader';[m
[32m+[m[32mexport * from './browser/BrowserQRCodeSvgWriter';[m
[32m+[m[32mexport * from './browser/DecodeContinuouslyCallback';[m
[32m+[m[32mexport * from './browser/HTMLCanvasElementLuminanceSource';[m
[32m+[m[32mexport * from './browser/HTMLVisualMediaElement';[m
[32m+[m[32mexport * from './browser/VideoInputDevice';[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser.js b/frontend/node_modules/@zxing/library/cjs/browser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..acda175[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser.js[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {[m
[32m+[m[32m    if (k2 === undefined) k2 = k;[m
[32m+[m[32m    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });[m
[32m+[m[32m}) : (function(o, m, k, k2) {[m
[32m+[m[32m    if (k2 === undefined) k2 = k;[m
[32m+[m[32m    o[k2] = m[k];[m
[32m+[m[32m}));[m
[32m+[m[32mvar __exportStar = (this && this.__exportStar) || function(m, exports) {[m
[32m+[m[32m    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// browser[m
[32m+[m[32m__exportStar(require("./browser/BrowserAztecCodeReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserBarcodeReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserCodeReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserDatamatrixCodeReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserMultiFormatReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserPDF417Reader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserQRCodeReader"), exports);[m
[32m+[m[32m__exportStar(require("./browser/BrowserQRCodeSvgWriter"), exports);[m
[32m+[m[32m__exportStar(require("./browser/DecodeContinuouslyCallback"), exports);[m
[32m+[m[32m__exportStar(require("./browser/HTMLCanvasElementLuminanceSource"), exports);[m
[32m+[m[32m__exportStar(require("./browser/HTMLVisualMediaElement"), exports);[m
[32m+[m[32m__exportStar(require("./browser/VideoInputDevice"), exports);[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2a1f678[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.d.ts[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * Aztec Code reader to use from browser.[m
[32m+[m[32m *[m
[32m+[m[32m * @class BrowserAztecCodeReader[m
[32m+[m[32m * @extends {BrowserCodeReader}[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserAztecCodeReader extends BrowserCodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserAztecCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserAztecCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(timeBetweenScansMillis?: number);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..23d8092[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserAztecCodeReader.js[m
[36m@@ -0,0 +1,39 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserAztecCodeReader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar AztecReader_1 = require("../core/aztec/AztecReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * Aztec Code reader to use from browser.[m
[32m+[m[32m *[m
[32m+[m[32m * @class BrowserAztecCodeReader[m
[32m+[m[32m * @extends {BrowserCodeReader}[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserAztecCodeReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserAztecCodeReader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserAztecCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserAztecCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserAztecCodeReader(timeBetweenScansMillis) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        return _super.call(this, new AztecReader_1.default(), timeBetweenScansMillis) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return BrowserAztecCodeReader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserAztecCodeReader = BrowserAztecCodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..91f75f8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.d.ts[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32mimport DecodeHintType from '../core/DecodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Barcode reader reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserBarcodeReader extends BrowserCodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserBarcodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     * @param {Map<DecodeHintType, any>} hints[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(timeBetweenScansMillis?: number, hints?: Map<DecodeHintType, any>);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8562757[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserBarcodeReader.js[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserBarcodeReader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar MultiFormatOneDReader_1 = require("../core/oned/MultiFormatOneDReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Barcode reader reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserBarcodeReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserBarcodeReader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserBarcodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     * @param {Map<DecodeHintType, any>} hints[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserBarcodeReader(timeBetweenScansMillis, hints) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        return _super.call(this, new MultiFormatOneDReader_1.default(hints), timeBetweenScansMillis, hints) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return BrowserBarcodeReader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserBarcodeReader = BrowserBarcodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0204a4c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.d.ts[m
[36m@@ -0,0 +1,411 @@[m
[32m+[m[32mimport BinaryBitmap from '../core/BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../core/DecodeHintType';[m
[32m+[m[32mimport Reader from '../core/Reader';[m
[32m+[m[32mimport Result from '../core/Result';[m
[32m+[m[32mimport { DecodeContinuouslyCallback } from './DecodeContinuouslyCallback';[m
[32m+[m[32mimport { HTMLVisualMediaElement } from './HTMLVisualMediaElement';[m
[32m+[m[32mimport { VideoInputDevice } from './VideoInputDevice';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Base class for browser code reader.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserCodeReader {[m
[32m+[m[32m    protected readonly reader: Reader;[m
[32m+[m[32m    protected timeBetweenScansMillis: number;[m
[32m+[m[32m    protected _hints?: Map<DecodeHintType, any>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If navigator is present.[m
[32m+[m[32m     */[m
[32m+[m[32m    get hasNavigator(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If mediaDevices under navigator is supported.[m
[32m+[m[32m     */[m
[32m+[m[32m    get isMediaDevicesSuported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If enumerateDevices under navigator is supported.[m
[32m+[m[32m     */[m
[32m+[m[32m    get canEnumerateDevices(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This will break the loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    private _stopContinuousDecode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This will break the loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    private _stopAsyncDecode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Delay time between decode attempts made by the scanner.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected _timeBetweenDecodingAttempts: number;[m
[32m+[m[32m    /** Time between two decoding tries in milli seconds. */[m
[32m+[m[32m    get timeBetweenDecodingAttempts(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Change the time span the decoder waits between two decoding tries.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {number} millis Time between two decoding tries in milli seconds.[m
[32m+[m[32m     */[m
[32m+[m[32m    set timeBetweenDecodingAttempts(millis: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The HTML canvas element, used to draw the video or image's frame for decoding.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected captureCanvas: HTMLCanvasElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The HTML canvas element context.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected captureCanvasContext: CanvasRenderingContext2D;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The HTML image element, used as a fallback for the video element when decoding.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected imageElement: HTMLImageElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Should contain the current registered listener for image loading,[m
[32m+[m[32m     * used to unregister that listener when needed.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected imageLoadedListener: EventListener;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The stream output from camera.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected stream: MediaStream;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The HTML video element, used to display the camera stream.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected videoElement: HTMLVideoElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Should contain the current registered listener for video loaded-metadata,[m
[32m+[m[32m     * used to unregister that listener when needed.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected videoCanPlayListener: EventListener;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Should contain the current registered listener for video play-ended,[m
[32m+[m[32m     * used to unregister that listener when needed.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected videoEndedListener: EventListener;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Should contain the current registered listener for video playing,[m
[32m+[m[32m     * used to unregister that listener when needed.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected videoPlayingEventListener: EventListener;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the hints.[m
[32m+[m[32m     */[m
[32m+[m[32m    set hints(hints: Map<DecodeHintType, any>);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the hints.[m
[32m+[m[32m     */[m
[32m+[m[32m    get hints(): Map<DecodeHintType, any>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserCodeReader.[m
[32m+[m[32m     * @param {Reader} reader The reader instance to decode the barcode[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(reader: Reader, timeBetweenScansMillis?: number, _hints?: Map<DecodeHintType, any>);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Lists all the available video input devices.[m
[32m+[m[32m     */[m
[32m+[m[32m    listVideoInputDevices(): Promise<MediaDeviceInfo[]>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Obtain the list of available devices with type 'videoinput'.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @returns {Promise<VideoInputDevice[]>} an array of available video input devices[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `listVideoInputDevices` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    getVideoInputDevices(): Promise<VideoInputDevice[]>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Let's you find a device using it's Id.[m
[32m+[m[32m     */[m
[32m+[m[32m    findDeviceById(deviceId: string): Promise<MediaDeviceInfo>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `decodeOnceFromVideoDevice` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromInputVideoDevice(deviceId?: string, videoSource?: string | HTMLVideoElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeOnceFromVideoDevice(deviceId?: string, videoSource?: string | HTMLVideoElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param constraints the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeOnceFromConstraints(constraints: MediaStreamConstraints, videoSource?: string | HTMLVideoElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeOnceFromStream(stream: MediaStream, videoSource?: string | HTMLVideoElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<void>}[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `decodeFromVideoDevice` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromInputVideoDeviceContinuously(deviceId: string | null, videoSource: string | HTMLVideoElement | null, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<void>}[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoDevice(deviceId: string | null, videoSource: string | HTMLVideoElement | null, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromConstraints(constraints: MediaStreamConstraints, videoSource: string | HTMLVideoElement, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromStream(stream: MediaStream, videoSource: string | HTMLVideoElement, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Breaks the decoding loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    stopAsyncDecode(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Breaks the decoding loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    stopContinuousDecode(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the new stream and request a new decoding-with-delay.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stream The stream to be shown in the video element.[m
[32m+[m[32m     * @param decodeFn A callback for the decode method.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected attachStreamToVideo(stream: MediaStream, videoSource: string | HTMLVideoElement): Promise<HTMLVideoElement>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     */[m
[32m+[m[32m    protected playVideoOnLoadAsync(videoElement: HTMLVideoElement): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Binds listeners and callbacks to the videoElement.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param element[m
[32m+[m[32m     * @param callbackFn[m
[32m+[m[32m     */[m
[32m+[m[32m    protected playVideoOnLoad(element: HTMLVideoElement, callbackFn: EventListener): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Checks if the given video element is currently playing.[m
[32m+[m[32m     */[m
[32m+[m[32m    isVideoPlaying(video: HTMLVideoElement): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Just tries to play the video and logs any errors.[m
[32m+[m[32m     * The play call is only made is the video is not already playing.[m
[32m+[m[32m     */[m
[32m+[m[32m    tryPlayVideo(videoElement: HTMLVideoElement): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Searches and validates a media element.[m
[32m+[m[32m     */[m
[32m+[m[32m    getMediaElement(mediaElementId: string, type: string): HTMLVisualMediaElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromImage(source?: string | HTMLImageElement, url?: string): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from a video.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideo(source?: string | HTMLVideoElement, url?: string): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes continuously the barcode from a video.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @experimental[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoContinuously(source: string | HTMLVideoElement | null, url: string | null, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromImageElement(source: string | HTMLImageElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoElement(source: string | HTMLVideoElement): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoElementContinuously(source: string | HTMLVideoElement, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets up the video source so it can be decoded when loaded.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param source The video source element.[m
[32m+[m[32m     */[m
[32m+[m[32m    private _decodeFromVideoElementSetup;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromImageUrl(url?: string): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoUrl(url: string): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @experimental[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeFromVideoUrlContinuously(url: string, callbackFn: DecodeContinuouslyCallback): Promise<void>;[m
[32m+[m[32m    private _decodeOnLoadImage;[m
[32m+[m[32m    private _decodeOnLoadVideo;[m
[32m+[m[32m    private _decodeOnLoadVideoContinuously;[m
[32m+[m[32m    isImageLoaded(img: HTMLImageElement): boolean;[m
[32m+[m[32m    prepareImageElement(imageSource?: HTMLImageElement | string): HTMLImageElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a HTMLVideoElement for scanning or creates a new one.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoSource The HTMLVideoElement to be set.[m
[32m+[m[32m     */[m
[32m+[m[32m    prepareVideoElement(videoSource?: HTMLVideoElement | string): HTMLVideoElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Tries to decode from the video input until it finds some value.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeOnce(element: HTMLVisualMediaElement, retryIfNotFound?: boolean, retryIfChecksumOrFormatError?: boolean): Promise<Result>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously decodes from video input.[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeContinuously(element: HTMLVideoElement, callbackFn: DecodeContinuouslyCallback): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the BinaryBitmap for ya! (and decodes it)[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(element: HTMLVisualMediaElement): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a binaryBitmap based in some image source.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mediaElement HTML element containing drawable image source.[m
[32m+[m[32m     */[m
[32m+[m[32m    createBinaryBitmap(mediaElement: HTMLVisualMediaElement): BinaryBitmap;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    protected getCaptureCanvasContext(mediaElement?: HTMLVisualMediaElement): CanvasRenderingContext2D;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    protected getCaptureCanvas(mediaElement?: HTMLVisualMediaElement): HTMLCanvasElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Overwriting this allows you to manipulate the next frame in anyway you want before decode.[m
[32m+[m[32m     */[m
[32m+[m[32m    drawFrameOnCanvas(srcElement: HTMLVideoElement, dimensions?: {[m
[32m+[m[32m        sx: number;[m
[32m+[m[32m        sy: number;[m
[32m+[m[32m        sWidth: number;[m
[32m+[m[32m        sHeight: number;[m
[32m+[m[32m        dx: number;[m
[32m+[m[32m        dy: number;[m
[32m+[m[32m        dWidth: number;[m
[32m+[m[32m        dHeight: number;[m
[32m+[m[32m    }, canvasElementContext?: CanvasRenderingContext2D): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Ovewriting this allows you to manipulate the snapshot image in anyway you want before decode.[m
[32m+[m[32m     */[m
[32m+[m[32m    drawImageOnCanvas(srcElement: HTMLImageElement, dimensions?: {[m
[32m+[m[32m        sx: number;[m
[32m+[m[32m        sy: number;[m
[32m+[m[32m        sWidth: number;[m
[32m+[m[32m        sHeight: number;[m
[32m+[m[32m        dx: number;[m
[32m+[m[32m        dy: number;[m
[32m+[m[32m        dWidth: number;[m
[32m+[m[32m        dHeight: number;[m
[32m+[m[32m    }, canvasElementContext?: CanvasRenderingContext2D): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Call the encapsulated readers decode[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeBitmap(binaryBitmap: BinaryBitmap): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * üñå Prepares the canvas for capture and scan frames.[m
[32m+[m[32m     */[m
[32m+[m[32m    createCaptureCanvas(mediaElement?: HTMLVisualMediaElement): HTMLCanvasElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Stops the continuous scan and cleans the stream.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected stopStreams(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    private _destroyVideoElement;[m
[32m+[m[32m    private _destroyImageElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Cleans canvas references üñå[m
[32m+[m[32m     */[m
[32m+[m[32m    private _destroyCaptureCanvas;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Defines what the videoElement src will be.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     * @param stream[m
[32m+[m[32m     */[m
[32m+[m[32m    addVideoSource(videoElement: HTMLVideoElement, stream: MediaStream): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unbinds a HTML video src property.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     */[m
[32m+[m[32m    private cleanVideoSource;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ea96864[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserCodeReader.js[m
[36m@@ -0,0 +1,1080 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {[m
[32m+[m[32m    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }[m
[32m+[m[32m    return new (P || (P = Promise))(function (resolve, reject) {[m
[32m+[m[32m        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }[m
[32m+[m[32m        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }[m
[32m+[m[32m        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }[m
[32m+[m[32m        step((generator = generator.apply(thisArg, _arguments || [])).next());[m
[32m+[m[32m    });[m
[32m+[m[32m};[m
[32m+[m[32mvar __generator = (this && this.__generator) || function (thisArg, body) {[m
[32m+[m[32m    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;[m
[32m+[m[32m    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;[m
[32m+[m[32m    function verb(n) { return function (v) { return step([n, v]); }; }[m
[32m+[m[32m    function step(op) {[m
[32m+[m[32m        if (f) throw new TypeError("Generator is already executing.");[m
[32m+[m[32m        while (_) try {[m
[32m+[m[32m            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;[m
[32m+[m[32m            if (y = 0, t) op = [op[0] & 2, t.value];[m
[32m+[m[32m            switch (op[0]) {[m
[32m+[m[32m                case 0: case 1: t = op; break;[m
[32m+[m[32m                case 4: _.label++; return { value: op[1], done: false };[m
[32m+[m[32m                case 5: _.label++; y = op[1]; op = [0]; continue;[m
[32m+[m[32m                case 7: op = _.ops.pop(); _.trys.pop(); continue;[m
[32m+[m[32m                default:[m
[32m+[m[32m                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }[m
[32m+[m[32m                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }[m
[32m+[m[32m                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }[m
[32m+[m[32m                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }[m
[32m+[m[32m                    if (t[2]) _.ops.pop();[m
[32m+[m[32m                    _.trys.pop(); continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            op = body.call(thisArg, _);[m
[32m+[m[32m        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }[m
[32m+[m[32m        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserCodeReader = void 0;[m
[32m+[m[32mvar ArgumentException_1 = require("../core/ArgumentException");[m
[32m+[m[32mvar BinaryBitmap_1 = require("../core/BinaryBitmap");[m
[32m+[m[32mvar ChecksumException_1 = require("../core/ChecksumException");[m
[32m+[m[32mvar HybridBinarizer_1 = require("../core/common/HybridBinarizer");[m
[32m+[m[32mvar FormatException_1 = require("../core/FormatException");[m
[32m+[m[32mvar NotFoundException_1 = require("../core/NotFoundException");[m
[32m+[m[32mvar HTMLCanvasElementLuminanceSource_1 = require("./HTMLCanvasElementLuminanceSource");[m
[32m+[m[32mvar VideoInputDevice_1 = require("./VideoInputDevice");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Base class for browser code reader.[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserCodeReader = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserCodeReader.[m
[32m+[m[32m     * @param {Reader} reader The reader instance to decode the barcode[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserCodeReader(reader, timeBetweenScansMillis, _hints) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        this.reader = reader;[m
[32m+[m[32m        this.timeBetweenScansMillis = timeBetweenScansMillis;[m
[32m+[m[32m        this._hints = _hints;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * This will break the loop.[m
[32m+[m[32m         */[m
[32m+[m[32m        this._stopContinuousDecode = false;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * This will break the loop.[m
[32m+[m[32m         */[m
[32m+[m[32m        this._stopAsyncDecode = false;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Delay time between decode attempts made by the scanner.[m
[32m+[m[32m         */[m
[32m+[m[32m        this._timeBetweenDecodingAttempts = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    Object.defineProperty(BrowserCodeReader.prototype, "hasNavigator", {[m
[32m+[m[32m        /**[m
[32m+[m[32m         * If navigator is present.[m
[32m+[m[32m         */[m
[32m+[m[32m        get: function () {[m
[32m+[m[32m            return typeof navigator !== 'undefined';[m
[32m+[m[32m        },[m
[32m+[m[32m        enumerable: false,[m
[32m+[m[32m        configurable: true[m
[32m+[m[32m    });[m
[32m+[m[32m    Object.defineProperty(BrowserCodeReader.prototype, "isMediaDevicesSuported", {[m
[32m+[m[32m        /**[m
[32m+[m[32m         * If mediaDevices under navigator is supported.[m
[32m+[m[32m         */[m
[32m+[m[32m        get: function () {[m
[32m+[m[32m            return this.hasNavigator && !!navigator.mediaDevices;[m
[32m+[m[32m        },[m
[32m+[m[32m        enumerable: false,[m
[32m+[m[32m        configurable: true[m
[32m+[m[32m    });[m
[32m+[m[32m    Object.defineProperty(BrowserCodeReader.prototype, "canEnumerateDevices", {[m
[32m+[m[32m        /**[m
[32m+[m[32m         * If enumerateDevices under navigator is supported.[m
[32m+[m[32m         */[m
[32m+[m[32m        get: function () {[m
[32m+[m[32m            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);[m
[32m+[m[32m        },[m
[32m+[m[32m        enumerable: false,[m
[32m+[m[32m        configurable: true[m
[32m+[m[32m    });[m
[32m+[m[32m    Object.defineProperty(BrowserCodeReader.prototype, "timeBetweenDecodingAttempts", {[m
[32m+[m[32m        /** Time between two decoding tries in milli seconds. */[m
[32m+[m[32m        get: function () {[m
[32m+[m[32m            return this._timeBetweenDecodingAttempts;[m
[32m+[m[32m        },[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Change the time span the decoder waits between two decoding tries.[m
[32m+[m[32m         *[m
[32m+[m[32m         * @param {number} millis Time between two decoding tries in milli seconds.[m
[32m+[m[32m         */[m
[32m+[m[32m        set: function (millis) {[m
[32m+[m[32m            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;[m
[32m+[m[32m        },[m
[32m+[m[32m        enumerable: false,[m
[32m+[m[32m        configurable: true[m
[32m+[m[32m    });[m
[32m+[m[32m    Object.defineProperty(BrowserCodeReader.prototype, "hints", {[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Sets the hints.[m
[32m+[m[32m         */[m
[32m+[m[32m        get: function () {[m
[32m+[m[32m            return this._hints;[m
[32m+[m[32m        },[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Sets the hints.[m
[32m+[m[32m         */[m
[32m+[m[32m        set: function (hints) {[m
[32m+[m[32m            this._hints = hints || null;[m
[32m+[m[32m        },[m
[32m+[m[32m        enumerable: false,[m
[32m+[m[32m        configurable: true[m
[32m+[m[32m    });[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Lists all the available video input devices.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.listVideoInputDevices = function () {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;[m
[32m+[m[32m            var e_1, _a;[m
[32m+[m[32m            return __generator(this, function (_b) {[m
[32m+[m[32m                switch (_b.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        if (!this.hasNavigator) {[m
[32m+[m[32m                            throw new Error("Can't enumerate devices, navigator is not present.");[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (!this.canEnumerateDevices) {[m
[32m+[m[32m                            throw new Error("Can't enumerate devices, method not supported.");[m
[32m+[m[32m                        }[m
[32m+[m[32m                        return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        devices = _b.sent();[m
[32m+[m[32m                        videoDevices = [];[m
[32m+[m[32m                        try {[m
[32m+[m[32m                            for (devices_1 = __values(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {[m
[32m+[m[32m                                device = devices_1_1.value;[m
[32m+[m[32m                                kind = device.kind === 'video' ? 'videoinput' : device.kind;[m
[32m+[m[32m                                if (kind !== 'videoinput') {[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                deviceId = device.deviceId || device.id;[m
[32m+[m[32m                                label = device.label || "Video device " + (videoDevices.length + 1);[m
[32m+[m[32m                                groupId = device.groupId;[m
[32m+[m[32m                                videoDevice = { deviceId: deviceId, label: label, kind: kind, groupId: groupId };[m
[32m+[m[32m                                videoDevices.push(videoDevice);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m                        finally {[m
[32m+[m[32m                            try {[m
[32m+[m[32m                                if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return)) _a.call(devices_1);[m
[32m+[m[32m                            }[m
[32m+[m[32m                            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        return [2 /*return*/, videoDevices];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Obtain the list of available devices with type 'videoinput'.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @returns {Promise<VideoInputDevice[]>} an array of available video input devices[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `listVideoInputDevices` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.getVideoInputDevices = function () {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var devices;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        devices = _a.sent();[m
[32m+[m[32m                        return [2 /*return*/, devices.map(function (d) { return new VideoInputDevice_1.VideoInputDevice(d.deviceId, d.label); })];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Let's you find a device using it's Id.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.findDeviceById = function (deviceId) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var devices;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        devices = _a.sent();[m
[32m+[m[32m                        if (!devices) {[m
[32m+[m[32m                            return [2 /*return*/, null];[m
[32m+[m[32m                        }[m
[32m+[m[32m                        return [2 /*return*/, devices.find(function (x) { return x.deviceId === deviceId; })];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `decodeOnceFromVideoDevice` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromInputVideoDevice = function (deviceId, videoSource) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, this.decodeOnceFromVideoDevice(deviceId, videoSource)];[m
[32m+[m[32m                    case 1: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeOnceFromVideoDevice = function (deviceId, videoSource) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var videoConstraints, constraints;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        this.reset();[m
[32m+[m[32m                        if (!deviceId) {[m
[32m+[m[32m                            videoConstraints = { facingMode: 'environment' };[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            videoConstraints = { deviceId: { exact: deviceId } };[m
[32m+[m[32m                        }[m
[32m+[m[32m                        constraints = { video: videoConstraints };[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeOnceFromConstraints(constraints, videoSource)];[m
[32m+[m[32m                    case 1: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param constraints the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeOnceFromConstraints = function (constraints, videoSource) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var stream;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        stream = _a.sent();[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeOnceFromStream(stream, videoSource)];[m
[32m+[m[32m                    case 2: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeOnceFromStream = function (stream, videoSource) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var video, result;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        this.reset();[m
[32m+[m[32m                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        video = _a.sent();[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeOnce(video)];[m
[32m+[m[32m                    case 2:[m
[32m+[m[32m                        result = _a.sent();[m
[32m+[m[32m                        return [2 /*return*/, result];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<void>}[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated Use `decodeFromVideoDevice` instead.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromInputVideoDeviceContinuously = function (deviceId, videoSource, callbackFn) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, this.decodeFromVideoDevice(deviceId, videoSource, callbackFn)];[m
[32m+[m[32m                    case 1: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.[m
[32m+[m[32m     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<void>}[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoDevice = function (deviceId, videoSource, callbackFn) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var videoConstraints, constraints;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        if (!deviceId) {[m
[32m+[m[32m                            videoConstraints = { facingMode: 'environment' };[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            videoConstraints = { deviceId: { exact: deviceId } };[m
[32m+[m[32m                        }[m
[32m+[m[32m                        constraints = { video: videoConstraints };[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeFromConstraints(constraints, videoSource, callbackFn)];[m
[32m+[m[32m                    case 1: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromConstraints = function (constraints, videoSource, callbackFn) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var stream;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        stream = _a.sent();[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeFromStream(stream, videoSource, callbackFn)];[m
[32m+[m[32m                    case 2: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from[m
[32m+[m[32m     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.[m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromStream = function (stream, videoSource, callbackFn) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var video;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        this.reset();[m
[32m+[m[32m                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        video = _a.sent();[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeContinuously(video, callbackFn)];[m
[32m+[m[32m                    case 2: return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Breaks the decoding loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.stopAsyncDecode = function () {[m
[32m+[m[32m        this._stopAsyncDecode = true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Breaks the decoding loop.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.stopContinuousDecode = function () {[m
[32m+[m[32m        this._stopContinuousDecode = true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the new stream and request a new decoding-with-delay.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stream The stream to be shown in the video element.[m
[32m+[m[32m     * @param decodeFn A callback for the decode method.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.attachStreamToVideo = function (stream, videoSource) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var videoElement;[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        videoElement = this.prepareVideoElement(videoSource);[m
[32m+[m[32m                        this.addVideoSource(videoElement, stream);[m
[32m+[m[32m                        this.videoElement = videoElement;[m
[32m+[m[32m                        this.stream = stream;[m
[32m+[m[32m                        return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        _a.sent();[m
[32m+[m[32m                        return [2 /*return*/, videoElement];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.playVideoOnLoadAsync = function (videoElement) {[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        return new Promise(function (resolve, reject) {[m
[32m+[m[32m            return _this.playVideoOnLoad(videoElement, function () { return resolve(); });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Binds listeners and callbacks to the videoElement.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param element[m
[32m+[m[32m     * @param callbackFn[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.playVideoOnLoad = function (element, callbackFn) {[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        this.videoEndedListener = function () { return _this.stopStreams(); };[m
[32m+[m[32m        this.videoCanPlayListener = function () { return _this.tryPlayVideo(element); };[m
[32m+[m[32m        element.addEventListener('ended', this.videoEndedListener);[m
[32m+[m[32m        element.addEventListener('canplay', this.videoCanPlayListener);[m
[32m+[m[32m        element.addEventListener('playing', callbackFn);[m
[32m+[m[32m        // if canplay was already fired, we won't know when to play, so just give it a try[m
[32m+[m[32m        this.tryPlayVideo(element);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Checks if the given video element is currently playing.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.isVideoPlaying = function (video) {[m
[32m+[m[32m        return (video.currentTime > 0 &&[m
[32m+[m[32m            !video.paused &&[m
[32m+[m[32m            !video.ended &&[m
[32m+[m[32m            video.readyState > 2);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Just tries to play the video and logs any errors.[m
[32m+[m[32m     * The play call is only made is the video is not already playing.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.tryPlayVideo = function (videoElement) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            var _a;[m
[32m+[m[32m            return __generator(this, function (_b) {[m
[32m+[m[32m                switch (_b.label) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        if (this.isVideoPlaying(videoElement)) {[m
[32m+[m[32m                            console.warn('Trying to play video that is already playing.');[m
[32m+[m[32m                            return [2 /*return*/];[m
[32m+[m[32m                        }[m
[32m+[m[32m                        _b.label = 1;[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        _b.trys.push([1, 3, , 4]);[m
[32m+[m[32m                        return [4 /*yield*/, videoElement.play()];[m
[32m+[m[32m                    case 2:[m
[32m+[m[32m                        _b.sent();[m
[32m+[m[32m                        return [3 /*break*/, 4];[m
[32m+[m[32m                    case 3:[m
[32m+[m[32m                        _a = _b.sent();[m
[32m+[m[32m                        console.warn('It was not possible to play the video.');[m
[32m+[m[32m                        return [3 /*break*/, 4];[m
[32m+[m[32m                    case 4: return [2 /*return*/];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Searches and validates a media element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.getMediaElement = function (mediaElementId, type) {[m
[32m+[m[32m        var mediaElement = document.getElementById(mediaElementId);[m
[32m+[m[32m        if (!mediaElement) {[m
[32m+[m[32m            throw new ArgumentException_1.default("element with id '" + mediaElementId + "' not found");[m
[32m+[m[32m        }[m
[32m+[m[32m        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {[m
[32m+[m[32m            throw new ArgumentException_1.default("element with id '" + mediaElementId + "' must be an " + type + " element");[m
[32m+[m[32m        }[m
[32m+[m[32m        return mediaElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromImage = function (source, url) {[m
[32m+[m[32m        if (!source && !url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('either imageElement with a src set or an url must be provided');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (url && !source) {[m
[32m+[m[32m            return this.decodeFromImageUrl(url);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.decodeFromImageElement(source);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes the barcode from a video.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideo = function (source, url) {[m
[32m+[m[32m        if (!source && !url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (url && !source) {[m
[32m+[m[32m            return this.decodeFromVideoUrl(url);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.decodeFromVideoElement(source);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes continuously the barcode from a video.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.[m
[32m+[m[32m     * @param {string} [url][m
[32m+[m[32m     * @returns {Promise<Result>} The decoding result.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     *[m
[32m+[m[32m     * @experimental[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoContinuously = function (source, url, callbackFn) {[m
[32m+[m[32m        if (undefined === source && undefined === url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (url && !source) {[m
[32m+[m[32m            return this.decodeFromVideoUrlContinuously(url, callbackFn);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.decodeFromVideoElementContinuously(source, callbackFn);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromImageElement = function (source) {[m
[32m+[m[32m        if (!source) {[m
[32m+[m[32m            throw new ArgumentException_1.default('An image element must be provided.');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.reset();[m
[32m+[m[32m        var element = this.prepareImageElement(source);[m
[32m+[m[32m        this.imageElement = element;[m
[32m+[m[32m        var task;[m
[32m+[m[32m        if (this.isImageLoaded(element)) {[m
[32m+[m[32m            task = this.decodeOnce(element, false, true);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            task = this._decodeOnLoadImage(element);[m
[32m+[m[32m        }[m
[32m+[m[32m        return task;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoElement = function (source) {[m
[32m+[m[32m        var element = this._decodeFromVideoElementSetup(source);[m
[32m+[m[32m        return this._decodeOnLoadVideo(element);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes something from an image HTML element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoElementContinuously = function (source, callbackFn) {[m
[32m+[m[32m        var element = this._decodeFromVideoElementSetup(source);[m
[32m+[m[32m        return this._decodeOnLoadVideoContinuously(element, callbackFn);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets up the video source so it can be decoded when loaded.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param source The video source element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype._decodeFromVideoElementSetup = function (source) {[m
[32m+[m[32m        if (!source) {[m
[32m+[m[32m            throw new ArgumentException_1.default('A video element must be provided.');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.reset();[m
[32m+[m[32m        var element = this.prepareVideoElement(source);[m
[32m+[m[32m        // defines the video element before starts decoding[m
[32m+[m[32m        this.videoElement = element;[m
[32m+[m[32m        return element;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromImageUrl = function (url) {[m
[32m+[m[32m        if (!url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('An URL must be provided.');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.reset();[m
[32m+[m[32m        var element = this.prepareImageElement();[m
[32m+[m[32m        this.imageElement = element;[m
[32m+[m[32m        var decodeTask = this._decodeOnLoadImage(element);[m
[32m+[m[32m        element.src = url;[m
[32m+[m[32m        return decodeTask;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoUrl = function (url) {[m
[32m+[m[32m        if (!url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('An URL must be provided.');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.reset();[m
[32m+[m[32m        // creates a new element[m
[32m+[m[32m        var element = this.prepareVideoElement();[m
[32m+[m[32m        var decodeTask = this.decodeFromVideoElement(element);[m
[32m+[m[32m        element.src = url;[m
[32m+[m[32m        return decodeTask;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decodes an image from a URL.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @experimental[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeFromVideoUrlContinuously = function (url, callbackFn) {[m
[32m+[m[32m        if (!url) {[m
[32m+[m[32m            throw new ArgumentException_1.default('An URL must be provided.');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.reset();[m
[32m+[m[32m        // creates a new element[m
[32m+[m[32m        var element = this.prepareVideoElement();[m
[32m+[m[32m        var decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);[m
[32m+[m[32m        element.src = url;[m
[32m+[m[32m        return decodeTask;[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype._decodeOnLoadImage = function (element) {[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        return new Promise(function (resolve, reject) {[m
[32m+[m[32m            _this.imageLoadedListener = function () {[m
[32m+[m[32m                return _this.decodeOnce(element, false, true).then(resolve, reject);[m
[32m+[m[32m            };[m
[32m+[m[32m            element.addEventListener('load', _this.imageLoadedListener);[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype._decodeOnLoadVideo = function (videoElement) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m[41m [m
[32m+[m[32m                    // plays the video[m
[32m+[m[32m                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        // plays the video[m
[32m+[m[32m                        _a.sent();[m
[32m+[m[32m                        return [4 /*yield*/, this.decodeOnce(videoElement)];[m
[32m+[m[32m                    case 2:[m[41m [m
[32m+[m[32m                    // starts decoding after played the video[m
[32m+[m[32m                    return [2 /*return*/, _a.sent()];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype._decodeOnLoadVideoContinuously = function (videoElement, callbackFn) {[m
[32m+[m[32m        return __awaiter(this, void 0, void 0, function () {[m
[32m+[m[32m            return __generator(this, function (_a) {[m
[32m+[m[32m                switch (_a.label) {[m
[32m+[m[32m                    case 0:[m[41m [m
[32m+[m[32m                    // plays the video[m
[32m+[m[32m                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        // plays the video[m
[32m+[m[32m                        _a.sent();[m
[32m+[m[32m                        // starts decoding after played the video[m
[32m+[m[32m                        this.decodeContinuously(videoElement, callbackFn);[m
[32m+[m[32m                        return [2 /*return*/];[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype.isImageLoaded = function (img) {[m
[32m+[m[32m        // During the onload event, IE correctly identifies any images that[m
[32m+[m[32m        // weren‚Äôt downloaded as not complete. Others should too. Gecko-based[m
[32m+[m[32m        // browsers act like NS4 in that they report this incorrectly.[m
[32m+[m[32m        if (!img.complete) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // However, they do have two very useful properties: naturalWidth and[m
[32m+[m[32m        // naturalHeight. These give the true size of the image. If it failed[m
[32m+[m[32m        // to load, either of these should be zero.[m
[32m+[m[32m        if (img.naturalWidth === 0) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // No other way of checking: assume it‚Äôs ok.[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype.prepareImageElement = function (imageSource) {[m
[32m+[m[32m        var imageElement;[m
[32m+[m[32m        if (typeof imageSource === 'undefined') {[m
[32m+[m[32m            imageElement = document.createElement('img');[m
[32m+[m[32m            imageElement.width = 200;[m
[32m+[m[32m            imageElement.height = 200;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (typeof imageSource === 'string') {[m
[32m+[m[32m            imageElement = this.getMediaElement(imageSource, 'img');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (imageSource instanceof HTMLImageElement) {[m
[32m+[m[32m            imageElement = imageSource;[m
[32m+[m[32m        }[m
[32m+[m[32m        return imageElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a HTMLVideoElement for scanning or creates a new one.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoSource The HTMLVideoElement to be set.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.prepareVideoElement = function (videoSource) {[m
[32m+[m[32m        var videoElement;[m
[32m+[m[32m        if (!videoSource && typeof document !== 'undefined') {[m
[32m+[m[32m            videoElement = document.createElement('video');[m
[32m+[m[32m            videoElement.width = 200;[m
[32m+[m[32m            videoElement.height = 200;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (typeof videoSource === 'string') {[m
[32m+[m[32m            videoElement = (this.getMediaElement(videoSource, 'video'));[m
[32m+[m[32m        }[m
[32m+[m[32m        if (videoSource instanceof HTMLVideoElement) {[m
[32m+[m[32m            videoElement = videoSource;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Needed for iOS 11[m
[32m+[m[32m        videoElement.setAttribute('autoplay', 'true');[m
[32m+[m[32m        videoElement.setAttribute('muted', 'true');[m
[32m+[m[32m        videoElement.setAttribute('playsinline', 'true');[m
[32m+[m[32m        return videoElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Tries to decode from the video input until it finds some value.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeOnce = function (element, retryIfNotFound, retryIfChecksumOrFormatError) {[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        if (retryIfNotFound === void 0) { retryIfNotFound = true; }[m
[32m+[m[32m        if (retryIfChecksumOrFormatError === void 0) { retryIfChecksumOrFormatError = true; }[m
[32m+[m[32m        this._stopAsyncDecode = false;[m
[32m+[m[32m        var loop = function (resolve, reject) {[m
[32m+[m[32m            if (_this._stopAsyncDecode) {[m
[32m+[m[32m                reject(new NotFoundException_1.default('Video stream has ended before any code could be detected.'));[m
[32m+[m[32m                _this._stopAsyncDecode = undefined;[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            try {[m
[32m+[m[32m                var result = _this.decode(element);[m
[32m+[m[32m                resolve(result);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e) {[m
[32m+[m[32m                var ifNotFound = retryIfNotFound && e instanceof NotFoundException_1.default;[m
[32m+[m[32m                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;[m
[32m+[m[32m                var ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;[m
[32m+[m[32m                if (ifNotFound || ifChecksumOrFormat) {[m
[32m+[m[32m                    // trying again[m
[32m+[m[32m                    return setTimeout(loop, _this._timeBetweenDecodingAttempts, resolve, reject);[m
[32m+[m[32m                }[m
[32m+[m[32m                reject(e);[m
[32m+[m[32m            }[m
[32m+[m[32m        };[m
[32m+[m[32m        return new Promise(function (resolve, reject) { return loop(resolve, reject); });[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Continuously decodes from video input.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeContinuously = function (element, callbackFn) {[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        this._stopContinuousDecode = false;[m
[32m+[m[32m        var loop = function () {[m
[32m+[m[32m            if (_this._stopContinuousDecode) {[m
[32m+[m[32m                _this._stopContinuousDecode = undefined;[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            try {[m
[32m+[m[32m                var result = _this.decode(element);[m
[32m+[m[32m                callbackFn(result, null);[m
[32m+[m[32m                setTimeout(loop, _this.timeBetweenScansMillis);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e) {[m
[32m+[m[32m                callbackFn(null, e);[m
[32m+[m[32m                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;[m
[32m+[m[32m                var isNotFound = e instanceof NotFoundException_1.default;[m
[32m+[m[32m                if (isChecksumOrFormatError || isNotFound) {[m
[32m+[m[32m                    // trying again[m
[32m+[m[32m                    setTimeout(loop, _this._timeBetweenDecodingAttempts);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        };[m
[32m+[m[32m        loop();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the BinaryBitmap for ya! (and decodes it)[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decode = function (element) {[m
[32m+[m[32m        // get binary bitmap for decode function[m
[32m+[m[32m        var binaryBitmap = this.createBinaryBitmap(element);[m
[32m+[m[32m        return this.decodeBitmap(binaryBitmap);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a binaryBitmap based in some image source.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mediaElement HTML element containing drawable image source.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.createBinaryBitmap = function (mediaElement) {[m
[32m+[m[32m        var ctx = this.getCaptureCanvasContext(mediaElement);[m
[32m+[m[32m        // doing a scan with inverted colors on the second scan should only happen for video elements[m
[32m+[m[32m        var doAutoInvert = false;[m
[32m+[m[32m        if (mediaElement instanceof HTMLVideoElement) {[m
[32m+[m[32m            this.drawFrameOnCanvas(mediaElement);[m
[32m+[m[32m            doAutoInvert = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.drawImageOnCanvas(mediaElement);[m
[32m+[m[32m        }[m
[32m+[m[32m        var canvas = this.getCaptureCanvas(mediaElement);[m
[32m+[m[32m        var luminanceSource = new HTMLCanvasElementLuminanceSource_1.HTMLCanvasElementLuminanceSource(canvas, doAutoInvert);[m
[32m+[m[32m        var hybridBinarizer = new HybridBinarizer_1.default(luminanceSource);[m
[32m+[m[32m        return new BinaryBitmap_1.default(hybridBinarizer);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.getCaptureCanvasContext = function (mediaElement) {[m
[32m+[m[32m        if (!this.captureCanvasContext) {[m
[32m+[m[32m            var elem = this.getCaptureCanvas(mediaElement);[m
[32m+[m[32m            var ctx = void 0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                ctx = elem.getContext('2d', { willReadFrequently: true });[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e) {[m
[32m+[m[32m                ctx = elem.getContext('2d');[m
[32m+[m[32m            }[m
[32m+[m[32m            this.captureCanvasContext = ctx;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.captureCanvasContext;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.getCaptureCanvas = function (mediaElement) {[m
[32m+[m[32m        if (!this.captureCanvas) {[m
[32m+[m[32m            var elem = this.createCaptureCanvas(mediaElement);[m
[32m+[m[32m            this.captureCanvas = elem;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.captureCanvas;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Overwriting this allows you to manipulate the next frame in anyway you want before decode.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.drawFrameOnCanvas = function (srcElement, dimensions, canvasElementContext) {[m
[32m+[m[32m        if (dimensions === void 0) { dimensions = {[m
[32m+[m[32m            sx: 0,[m
[32m+[m[32m            sy: 0,[m
[32m+[m[32m            sWidth: srcElement.videoWidth,[m
[32m+[m[32m            sHeight: srcElement.videoHeight,[m
[32m+[m[32m            dx: 0,[m
[32m+[m[32m            dy: 0,[m
[32m+[m[32m            dWidth: srcElement.videoWidth,[m
[32m+[m[32m            dHeight: srcElement.videoHeight,[m
[32m+[m[32m        }; }[m
[32m+[m[32m        if (canvasElementContext === void 0) { canvasElementContext = this.captureCanvasContext; }[m
[32m+[m[32m        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Ovewriting this allows you to manipulate the snapshot image in anyway you want before decode.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.drawImageOnCanvas = function (srcElement, dimensions, canvasElementContext) {[m
[32m+[m[32m        if (dimensions === void 0) { dimensions = {[m
[32m+[m[32m            sx: 0,[m
[32m+[m[32m            sy: 0,[m
[32m+[m[32m            sWidth: srcElement.naturalWidth,[m
[32m+[m[32m            sHeight: srcElement.naturalHeight,[m
[32m+[m[32m            dx: 0,[m
[32m+[m[32m            dy: 0,[m
[32m+[m[32m            dWidth: srcElement.naturalWidth,[m
[32m+[m[32m            dHeight: srcElement.naturalHeight,[m
[32m+[m[32m        }; }[m
[32m+[m[32m        if (canvasElementContext === void 0) { canvasElementContext = this.captureCanvasContext; }[m
[32m+[m[32m        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Call the encapsulated readers decode[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.decodeBitmap = function (binaryBitmap) {[m
[32m+[m[32m        return this.reader.decode(binaryBitmap, this._hints);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * üñå Prepares the canvas for capture and scan frames.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.createCaptureCanvas = function (mediaElement) {[m
[32m+[m[32m        if (typeof document === 'undefined') {[m
[32m+[m[32m            this._destroyCaptureCanvas();[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var canvasElement = document.createElement('canvas');[m
[32m+[m[32m        var width;[m
[32m+[m[32m        var height;[m
[32m+[m[32m        if (typeof mediaElement !== 'undefined') {[m
[32m+[m[32m            if (mediaElement instanceof HTMLVideoElement) {[m
[32m+[m[32m                width = mediaElement.videoWidth;[m
[32m+[m[32m                height = mediaElement.videoHeight;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (mediaElement instanceof HTMLImageElement) {[m
[32m+[m[32m                width = mediaElement.naturalWidth || mediaElement.width;[m
[32m+[m[32m                height = mediaElement.naturalHeight || mediaElement.height;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        canvasElement.style.width = width + 'px';[m
[32m+[m[32m        canvasElement.style.height = height + 'px';[m
[32m+[m[32m        canvasElement.width = width;[m
[32m+[m[32m        canvasElement.height = height;[m
[32m+[m[32m        return canvasElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Stops the continuous scan and cleans the stream.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.stopStreams = function () {[m
[32m+[m[32m        if (this.stream) {[m
[32m+[m[32m            this.stream.getVideoTracks().forEach(function (t) { return t.stop(); });[m
[32m+[m[32m            this.stream = undefined;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this._stopAsyncDecode === false) {[m
[32m+[m[32m            this.stopAsyncDecode();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this._stopContinuousDecode === false) {[m
[32m+[m[32m            this.stopContinuousDecode();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @memberOf BrowserCodeReader[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.reset = function () {[m
[32m+[m[32m        // stops the camera, preview and scan üî¥[m
[32m+[m[32m        this.stopStreams();[m
[32m+[m[32m        // clean and forget about HTML elements[m
[32m+[m[32m        this._destroyVideoElement();[m
[32m+[m[32m        this._destroyImageElement();[m
[32m+[m[32m        this._destroyCaptureCanvas();[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype._destroyVideoElement = function () {[m
[32m+[m[32m        if (!this.videoElement) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        // first gives freedon to the element üïä[m
[32m+[m[32m        if (typeof this.videoEndedListener !== 'undefined') {[m
[32m+[m[32m            this.videoElement.removeEventListener('ended', this.videoEndedListener);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (typeof this.videoPlayingEventListener !== 'undefined') {[m
[32m+[m[32m            this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (typeof this.videoCanPlayListener !== 'undefined') {[m
[32m+[m[32m            this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);[m
[32m+[m[32m        }[m
[32m+[m[32m        // then forgets about that element üò¢[m
[32m+[m[32m        this.cleanVideoSource(this.videoElement);[m
[32m+[m[32m        this.videoElement = undefined;[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserCodeReader.prototype._destroyImageElement = function () {[m
[32m+[m[32m        if (!this.imageElement) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        // first gives freedon to the element üïä[m
[32m+[m[32m        if (undefined !== this.imageLoadedListener) {[m
[32m+[m[32m            this.imageElement.removeEventListener('load', this.imageLoadedListener);[m
[32m+[m[32m        }[m
[32m+[m[32m        // then forget about that element üò¢[m
[32m+[m[32m        this.imageElement.src = undefined;[m
[32m+[m[32m        this.imageElement.removeAttribute('src');[m
[32m+[m[32m        this.imageElement = undefined;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Cleans canvas references üñå[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype._destroyCaptureCanvas = function () {[m
[32m+[m[32m        // then forget about that element üò¢[m
[32m+[m[32m        this.captureCanvasContext = undefined;[m
[32m+[m[32m        this.captureCanvas = undefined;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Defines what the videoElement src will be.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     * @param stream[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.addVideoSource = function (videoElement, stream) {[m
[32m+[m[32m        // Older browsers may not have `srcObject`[m
[32m+[m[32m        try {[m
[32m+[m[32m            // @note Throws Exception if interrupted by a new loaded request[m
[32m+[m[32m            videoElement.srcObject = stream;[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (err) {[m
[32m+[m[32m            // @note Avoid using this in new browsers, as it is going away.[m
[32m+[m[32m            // @ts-ignore[m
[32m+[m[32m            videoElement.src = URL.createObjectURL(stream);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unbinds a HTML video src property.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param videoElement[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserCodeReader.prototype.cleanVideoSource = function (videoElement) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            videoElement.srcObject = null;[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (err) {[m
[32m+[m[32m            videoElement.src = '';[m
[32m+[m[32m        }[m
[32m+[m[32m        this.videoElement.removeAttribute('src');[m
[32m+[m[32m    };[m
[32m+[m[32m    return BrowserCodeReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.BrowserCodeReader = BrowserCodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5ae9ca3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserDatamatrixCodeReader extends BrowserCodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserQRCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(timeBetweenScansMillis?: number);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..4396160[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserDatamatrixCodeReader.js[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserDatamatrixCodeReader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar DataMatrixReader_1 = require("../core/datamatrix/DataMatrixReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserDatamatrixCodeReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserDatamatrixCodeReader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserQRCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserDatamatrixCodeReader(timeBetweenScansMillis) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        return _super.call(this, new DataMatrixReader_1.default(), timeBetweenScansMillis) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return BrowserDatamatrixCodeReader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d99bc46[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.d.ts[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32mimport MultiFormatReader from '../core/MultiFormatReader';[m
[32m+[m[32mimport BinaryBitmap from '../core/BinaryBitmap';[m
[32m+[m[32mimport Result from '../core/Result';[m
[32m+[m[32mimport DecodeHintType from '../core/DecodeHintType';[m
[32m+[m[32mexport declare class BrowserMultiFormatReader extends BrowserCodeReader {[m
[32m+[m[32m    protected readonly reader: MultiFormatReader;[m
[32m+[m[32m    constructor(hints?: Map<DecodeHintType, any>, timeBetweenScansMillis?: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Overwrite decodeBitmap to call decodeWithState, which will pay[m
[32m+[m[32m     * attention to the hints set in the constructor function[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeBitmap(binaryBitmap: BinaryBitmap): Result;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f3ab06b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserMultiFormatReader.js[m
[36m@@ -0,0 +1,39 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserMultiFormatReader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar MultiFormatReader_1 = require("../core/MultiFormatReader");[m
[32m+[m[32mvar BrowserMultiFormatReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserMultiFormatReader, _super);[m
[32m+[m[32m    function BrowserMultiFormatReader(hints, timeBetweenScansMillis) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        var _this = this;[m
[32m+[m[32m        var reader = new MultiFormatReader_1.default();[m
[32m+[m[32m        reader.setHints(hints);[m
[32m+[m[32m        _this = _super.call(this, reader, timeBetweenScansMillis) || this;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Overwrite decodeBitmap to call decodeWithState, which will pay[m
[32m+[m[32m     * attention to the hints set in the constructor function[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserMultiFormatReader.prototype.decodeBitmap = function (binaryBitmap) {[m
[32m+[m[32m        return this.reader.decodeWithState(binaryBitmap);[m
[32m+[m[32m    };[m
[32m+[m[32m    return BrowserMultiFormatReader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserMultiFormatReader = BrowserMultiFormatReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a5b7874[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserPDF417Reader extends BrowserCodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserPDF417Reader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(timeBetweenScansMillis?: number);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..4e774c7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserPDF417Reader.js[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserPDF417Reader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar PDF417Reader_1 = require("../core/pdf417/PDF417Reader");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserPDF417Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserPDF417Reader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserPDF417Reader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserPDF417Reader(timeBetweenScansMillis) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        return _super.call(this, new PDF417Reader_1.default(), timeBetweenScansMillis) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return BrowserPDF417Reader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserPDF417Reader = BrowserPDF417Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a8626da[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport { BrowserCodeReader } from './BrowserCodeReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class BrowserQRCodeReader extends BrowserCodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserQRCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(timeBetweenScansMillis?: number);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..abf7c1d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeReader.js[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserQRCodeReader = void 0;[m
[32m+[m[32mvar BrowserCodeReader_1 = require("./BrowserCodeReader");[m
[32m+[m[32mvar QRCodeReader_1 = require("../core/qrcode/QRCodeReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * QR Code reader to use from browser.[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserQRCodeReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BrowserQRCodeReader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of BrowserQRCodeReader.[m
[32m+[m[32m     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserQRCodeReader(timeBetweenScansMillis) {[m
[32m+[m[32m        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }[m
[32m+[m[32m        return _super.call(this, new QRCodeReader_1.default(), timeBetweenScansMillis) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return BrowserQRCodeReader;[m
[32m+[m[32m}(BrowserCodeReader_1.BrowserCodeReader));[m
[32m+[m[32mexports.BrowserQRCodeReader = BrowserQRCodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..228a02b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.d.ts[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32mimport EncodeHintType from '../core/EncodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mdeclare class BrowserQRCodeSvgWriter {[m
[32m+[m[32m    private static readonly QUIET_ZONE_SIZE;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * SVG markup NameSpace[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readonly SVG_NS;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes and renders a QRCode SVG element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param contents[m
[32m+[m[32m     * @param width[m
[32m+[m[32m     * @param height[m
[32m+[m[32m     * @param hints[m
[32m+[m[32m     */[m
[32m+[m[32m    write(contents: string, width: number, height: number, hints?: Map<EncodeHintType, any>): SVGSVGElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Renders the result and then appends it to the DOM.[m
[32m+[m[32m     */[m
[32m+[m[32m    writeToDom(containerElement: string | HTMLElement, contents: string, width: number, height: number, hints?: Map<EncodeHintType, any>): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Note that the input matrix uses 0 == white, 1 == black.[m
[32m+[m[32m     * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).[m
[32m+[m[32m     */[m
[32m+[m[32m    private renderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param w SVG's width attribute[m
[32m+[m[32m     * @param h SVG's height attribute[m
[32m+[m[32m     */[m
[32m+[m[32m    private createSVGElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x Element's x coordinate[m
[32m+[m[32m     * @param y Element's y coordinate[m
[32m+[m[32m     * @param w Element's width attribute[m
[32m+[m[32m     * @param h Element's height attribute[m
[32m+[m[32m     */[m
[32m+[m[32m    private createSvgRectElement;[m
[32m+[m[32m}[m
[32m+[m[32mexport { BrowserQRCodeSvgWriter };[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d395d62[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserQRCodeSvgWriter.js[m
[36m@@ -0,0 +1,129 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserQRCodeSvgWriter = void 0;[m
[32m+[m[32mvar EncodeHintType_1 = require("../core/EncodeHintType");[m
[32m+[m[32mvar Encoder_1 = require("../core/qrcode/encoder/Encoder");[m
[32m+[m[32mvar ErrorCorrectionLevel_1 = require("../core/qrcode/decoder/ErrorCorrectionLevel");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../core/IllegalArgumentException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../core/IllegalStateException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserQRCodeSvgWriter = /** @class */ (function () {[m
[32m+[m[32m    function BrowserQRCodeSvgWriter() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes and renders a QRCode SVG element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param contents[m
[32m+[m[32m     * @param width[m
[32m+[m[32m     * @param height[m
[32m+[m[32m     * @param hints[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.prototype.write = function (contents, width, height, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        if (contents.length === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Found empty contents');[m
[32m+[m[32m        }[m
[32m+[m[32m        // if (format != BarcodeFormat.QR_CODE) {[m
[32m+[m[32m        //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)[m
[32m+[m[32m        // }[m
[32m+[m[32m        if (width < 0 || height < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Requested dimensions are too small: ' + width + 'x' + height);[m
[32m+[m[32m        }[m
[32m+[m[32m        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;[m
[32m+[m[32m        var quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;[m
[32m+[m[32m        if (hints !== null) {[m
[32m+[m[32m            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {[m
[32m+[m[32m                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {[m
[32m+[m[32m                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);[m
[32m+[m[32m        return this.renderResult(code, width, height, quietZone);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Renders the result and then appends it to the DOM.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.prototype.writeToDom = function (containerElement, contents, width, height, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        if (typeof containerElement === 'string') {[m
[32m+[m[32m            containerElement = document.querySelector(containerElement);[m
[32m+[m[32m        }[m
[32m+[m[32m        var svgElement = this.write(contents, width, height, hints);[m
[32m+[m[32m        if (containerElement)[m
[32m+[m[32m            containerElement.appendChild(svgElement);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Note that the input matrix uses 0 == white, 1 == black.[m
[32m+[m[32m     * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.prototype.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {[m
[32m+[m[32m        var input = code.getMatrix();[m
[32m+[m[32m        if (input === null) {[m
[32m+[m[32m            throw new IllegalStateException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var inputWidth = input.getWidth();[m
[32m+[m[32m        var inputHeight = input.getHeight();[m
[32m+[m[32m        var qrWidth = inputWidth + (quietZone * 2);[m
[32m+[m[32m        var qrHeight = inputHeight + (quietZone * 2);[m
[32m+[m[32m        var outputWidth = Math.max(width, qrWidth);[m
[32m+[m[32m        var outputHeight = Math.max(height, qrHeight);[m
[32m+[m[32m        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));[m
[32m+[m[32m        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested[m
[32m+[m[32m        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.[m
[32m+[m[32m        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will[m
[32m+[m[32m        // handle all the padding from 100x100 (the actual QR) up to 200x160.[m
[32m+[m[32m        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);[m
[32m+[m[32m        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);[m
[32m+[m[32m        var svgElement = this.createSVGElement(outputWidth, outputHeight);[m
[32m+[m[32m        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {[m
[32m+[m[32m            // Write the contents of this row of the barcode[m
[32m+[m[32m            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {[m
[32m+[m[32m                if (input.get(inputX, inputY) === 1) {[m
[32m+[m[32m                    var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);[m
[32m+[m[32m                    svgElement.appendChild(svgRectElement);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return svgElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param w SVG's width attribute[m
[32m+[m[32m     * @param h SVG's height attribute[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.prototype.createSVGElement = function (w, h) {[m
[32m+[m[32m        var svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');[m
[32m+[m[32m        svgElement.setAttributeNS(null, 'height', w.toString());[m
[32m+[m[32m        svgElement.setAttributeNS(null, 'width', h.toString());[m
[32m+[m[32m        return svgElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect element.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x Element's x coordinate[m
[32m+[m[32m     * @param y Element's y coordinate[m
[32m+[m[32m     * @param w Element's width attribute[m
[32m+[m[32m     * @param h Element's height attribute[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.prototype.createSvgRectElement = function (x, y, w, h) {[m
[32m+[m[32m        var rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');[m
[32m+[m[32m        rect.setAttributeNS(null, 'x', x.toString());[m
[32m+[m[32m        rect.setAttributeNS(null, 'y', y.toString());[m
[32m+[m[32m        rect.setAttributeNS(null, 'height', w.toString());[m
[32m+[m[32m        rect.setAttributeNS(null, 'width', h.toString());[m
[32m+[m[32m        rect.setAttributeNS(null, 'fill', '#000000');[m
[32m+[m[32m        return rect;[m
[32m+[m[32m    };[m
[32m+[m[32m    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * SVG markup NameSpace[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';[m
[32m+[m[32m    return BrowserQRCodeSvgWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5cd32ae[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.d.ts[m
[36m@@ -0,0 +1,49 @@[m
[32m+[m[32mimport EncodeHintType from '../core/EncodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mdeclare abstract class BrowserSvgCodeWriter {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Default quiet zone in pixels.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readonly QUIET_ZONE_SIZE;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * SVG markup NameSpace[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readonly SVG_NS;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A HTML container element for the image.[m
[32m+[m[32m     */[m
[32m+[m[32m    private containerElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs. üòâ[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(containerElement: string | HTMLElement);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the QR code to a SVG and renders it in the container.[m
[32m+[m[32m     */[m
[32m+[m[32m    write(contents: string, width: number, height: number, hints?: Map<EncodeHintType, any>): SVGSVGElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the content to a Barcode type.[m
[32m+[m[32m     */[m
[32m+[m[32m    private encode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Renders the SVG in the container.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @note the input matrix uses 0 == white, 1 == black. The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).[m
[32m+[m[32m     */[m
[32m+[m[32m    private renderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG element.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected createSVGElement(w: number, h: number): SVGSVGElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected createSvgPathPlaceholderElement(w: number, h: number): SVGPathElement;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected createSvgRectElement(x: number, y: number, w: number, h: number): SVGRectElement;[m
[32m+[m[32m}[m
[32m+[m[32mexport { BrowserSvgCodeWriter };[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.js b/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2aaccfa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/BrowserSvgCodeWriter.js[m
[36m@@ -0,0 +1,134 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BrowserSvgCodeWriter = void 0;[m
[32m+[m[32mvar EncodeHintType_1 = require("../core/EncodeHintType");[m
[32m+[m[32mvar Encoder_1 = require("../core/qrcode/encoder/Encoder");[m
[32m+[m[32mvar ErrorCorrectionLevel_1 = require("../core/qrcode/decoder/ErrorCorrectionLevel");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../core/IllegalArgumentException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../core/IllegalStateException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mvar BrowserSvgCodeWriter = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs. üòâ[m
[32m+[m[32m     */[m
[32m+[m[32m    function BrowserSvgCodeWriter(containerElement) {[m
[32m+[m[32m        if (typeof containerElement === 'string') {[m
[32m+[m[32m            this.containerElement = document.getElementById(containerElement);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.containerElement = containerElement;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the QR code to a SVG and renders it in the container.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.write = function (contents, width, height, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        if (contents.length === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Found empty contents');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (width < 0 || height < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Requested dimensions are too small: ' + width + 'x' + height);[m
[32m+[m[32m        }[m
[32m+[m[32m        var quietZone = hints && hints.get(EncodeHintType_1.default.MARGIN) !== undefined[m
[32m+[m[32m            ? Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10)[m
[32m+[m[32m            : BrowserSvgCodeWriter.QUIET_ZONE_SIZE;[m
[32m+[m[32m        var code = this.encode(hints, contents);[m
[32m+[m[32m        return this.renderResult(code, width, height, quietZone);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the content to a Barcode type.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.encode = function (hints, contents) {[m
[32m+[m[32m        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;[m
[32m+[m[32m        if (hints && hints.get(EncodeHintType_1.default.ERROR_CORRECTION) !== undefined) {[m
[32m+[m[32m            errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());[m
[32m+[m[32m        }[m
[32m+[m[32m        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);[m
[32m+[m[32m        return code;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Renders the SVG in the container.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @note the input matrix uses 0 == white, 1 == black. The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {[m
[32m+[m[32m        // if (this.format && format != this.format) {[m
[32m+[m[32m        //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)[m
[32m+[m[32m        // }[m
[32m+[m[32m        var input = code.getMatrix();[m
[32m+[m[32m        if (input === null) {[m
[32m+[m[32m            throw new IllegalStateException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var inputWidth = input.getWidth();[m
[32m+[m[32m        var inputHeight = input.getHeight();[m
[32m+[m[32m        var qrWidth = inputWidth + (quietZone * 2);[m
[32m+[m[32m        var qrHeight = inputHeight + (quietZone * 2);[m
[32m+[m[32m        var outputWidth = Math.max(width, qrWidth);[m
[32m+[m[32m        var outputHeight = Math.max(height, qrHeight);[m
[32m+[m[32m        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));[m
[32m+[m[32m        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested[m
[32m+[m[32m        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.[m
[32m+[m[32m        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will[m
[32m+[m[32m        // handle all the padding from 100x100 (the actual QR) up to 200x160.[m
[32m+[m[32m        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);[m
[32m+[m[32m        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);[m
[32m+[m[32m        var svgElement = this.createSVGElement(outputWidth, outputHeight);[m
[32m+[m[32m        var placeholder = this.createSvgPathPlaceholderElement(width, height);[m
[32m+[m[32m        svgElement.append(placeholder);[m
[32m+[m[32m        this.containerElement.appendChild(svgElement);[m
[32m+[m[32m        // 2D loop[m
[32m+[m[32m        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {[m
[32m+[m[32m            // Write the contents of this row of the barcode[m
[32m+[m[32m            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {[m
[32m+[m[32m                if (input.get(inputX, inputY) === 1) {[m
[32m+[m[32m                    var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);[m
[32m+[m[32m                    svgElement.appendChild(svgRectElement);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return svgElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG element.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.createSVGElement = function (w, h) {[m
[32m+[m[32m        var el = document.createElementNS(BrowserSvgCodeWriter.SVG_NS, 'svg');[m
[32m+[m[32m        el.setAttributeNS(null, 'width', h.toString());[m
[32m+[m[32m        el.setAttributeNS(null, 'height', w.toString());[m
[32m+[m[32m        return el;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.createSvgPathPlaceholderElement = function (w, h) {[m
[32m+[m[32m        var el = document.createElementNS(BrowserSvgCodeWriter.SVG_NS, 'path');[m
[32m+[m[32m        el.setAttributeNS(null, 'd', "M0 0h" + w + "v" + h + "H0z");[m
[32m+[m[32m        el.setAttributeNS(null, 'fill', 'none');[m
[32m+[m[32m        return el;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a SVG rect.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.prototype.createSvgRectElement = function (x, y, w, h) {[m
[32m+[m[32m        var el = document.createElementNS(BrowserSvgCodeWriter.SVG_NS, 'rect');[m
[32m+[m[32m        el.setAttributeNS(null, 'x', x.toString());[m
[32m+[m[32m        el.setAttributeNS(null, 'y', y.toString());[m
[32m+[m[32m        el.setAttributeNS(null, 'height', w.toString());[m
[32m+[m[32m        el.setAttributeNS(null, 'width', h.toString());[m
[32m+[m[32m        el.setAttributeNS(null, 'fill', '#000000');[m
[32m+[m[32m        return el;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Default quiet zone in pixels.[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.QUIET_ZONE_SIZE = 4;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * SVG markup NameSpace[m
[32m+[m[32m     */[m
[32m+[m[32m    BrowserSvgCodeWriter.SVG_NS = 'http://www.w3.org/2000/svg';[m
[32m+[m[32m    return BrowserSvgCodeWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.BrowserSvgCodeWriter = BrowserSvgCodeWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e63f0ca[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.d.ts[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mimport Exception from '../core/Exception';[m
[32m+[m[32mimport Result from '../core/Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * Callback format for continuous decode scan.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare type DecodeContinuouslyCallback = (result: Result, error?: Exception) => any;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js b/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c8ad2e5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/DecodeContinuouslyCallback.js[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e0ebfc8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.d.ts[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mimport LuminanceSource from '../core/LuminanceSource';[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class HTMLCanvasElementLuminanceSource extends LuminanceSource {[m
[32m+[m[32m    private canvas;[m
[32m+[m[32m    private buffer;[m
[32m+[m[32m    private static DEGREE_TO_RADIANS;[m
[32m+[m[32m    private static FRAME_INDEX;[m
[32m+[m[32m    private tempCanvasElement;[m
[32m+[m[32m    constructor(canvas: HTMLCanvasElement, doAutoInvert?: boolean);[m
[32m+[m[32m    private static makeBufferFromCanvasImageData;[m
[32m+[m[32m    private static toGrayscaleBuffer;[m
[32m+[m[32m    getRow(y: number, row: Uint8ClampedArray): Uint8ClampedArray;[m
[32m+[m[32m    getMatrix(): Uint8ClampedArray;[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): LuminanceSource;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is always true, since the image is a gray-scale image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return true[m
[32m+[m[32m     */[m
[32m+[m[32m    isRotateSupported(): boolean;[m
[32m+[m[32m    rotateCounterClockwise(): LuminanceSource;[m
[32m+[m[32m    rotateCounterClockwise45(): LuminanceSource;[m
[32m+[m[32m    private getTempCanvasElement;[m
[32m+[m[32m    private rotate;[m
[32m+[m[32m    invert(): LuminanceSource;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js b/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9147463[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/HTMLCanvasElementLuminanceSource.js[m
[36m@@ -0,0 +1,173 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.HTMLCanvasElementLuminanceSource = void 0;[m
[32m+[m[32mvar InvertedLuminanceSource_1 = require("../core/InvertedLuminanceSource");[m
[32m+[m[32mvar LuminanceSource_1 = require("../core/LuminanceSource");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../core/IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m */[m
[32m+[m[32mvar HTMLCanvasElementLuminanceSource = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(HTMLCanvasElementLuminanceSource, _super);[m
[32m+[m[32m    function HTMLCanvasElementLuminanceSource(canvas, doAutoInvert) {[m
[32m+[m[32m        if (doAutoInvert === void 0) { doAutoInvert = false; }[m
[32m+[m[32m        var _this = _super.call(this, canvas.width, canvas.height) || this;[m
[32m+[m[32m        _this.canvas = canvas;[m
[32m+[m[32m        _this.tempCanvasElement = null;[m
[32m+[m[32m        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas, doAutoInvert);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas, doAutoInvert) {[m
[32m+[m[32m        if (doAutoInvert === void 0) { doAutoInvert = false; }[m
[32m+[m[32m        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);[m
[32m+[m[32m        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height, doAutoInvert);[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height, doAutoInvert) {[m
[32m+[m[32m        if (doAutoInvert === void 0) { doAutoInvert = false; }[m
[32m+[m[32m        var grayscaleBuffer = new Uint8ClampedArray(width * height);[m
[32m+[m[32m        HTMLCanvasElementLuminanceSource.FRAME_INDEX = !HTMLCanvasElementLuminanceSource.FRAME_INDEX;[m
[32m+[m[32m        if (HTMLCanvasElementLuminanceSource.FRAME_INDEX || !doAutoInvert) {[m
[32m+[m[32m            for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {[m
[32m+[m[32m                var gray = void 0;[m
[32m+[m[32m                var alpha = imageBuffer[i + 3];[m
[32m+[m[32m                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent[m
[32m+[m[32m                // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a[m
[32m+[m[32m                // barcode image. Force any such pixel to be white:[m
[32m+[m[32m                if (alpha === 0) {[m
[32m+[m[32m                    gray = 0xFF;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    var pixelR = imageBuffer[i];[m
[32m+[m[32m                    var pixelG = imageBuffer[i + 1];[m
[32m+[m[32m                    var pixelB = imageBuffer[i + 2];[m
[32m+[m[32m                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),[m
[32m+[m[32m                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.[m
[32m+[m[32m                    // 0x200 >> 10 is 0.5, it implements rounding.[m
[32m+[m[32m                    gray = (306 * pixelR +[m
[32m+[m[32m                        601 * pixelG +[m
[32m+[m[32m                        117 * pixelB +[m
[32m+[m[32m                        0x200) >> 10;[m
[32m+[m[32m                }[m
[32m+[m[32m                grayscaleBuffer[j] = gray;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            for (var i = 0, j = 0, length_2 = imageBuffer.length; i < length_2; i += 4, j++) {[m
[32m+[m[32m                var gray = void 0;[m
[32m+[m[32m                var alpha = imageBuffer[i + 3];[m
[32m+[m[32m                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent[m
[32m+[m[32m                // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a[m
[32m+[m[32m                // barcode image. Force any such pixel to be white:[m
[32m+[m[32m                if (alpha === 0) {[m
[32m+[m[32m                    gray = 0xFF;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    var pixelR = imageBuffer[i];[m
[32m+[m[32m                    var pixelG = imageBuffer[i + 1];[m
[32m+[m[32m                    var pixelB = imageBuffer[i + 2];[m
[32m+[m[32m                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),[m
[32m+[m[32m                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.[m
[32m+[m[32m                    // 0x200 >> 10 is 0.5, it implements rounding.[m
[32m+[m[32m                    gray = (306 * pixelR +[m
[32m+[m[32m                        601 * pixelG +[m
[32m+[m[32m                        117 * pixelB +[m
[32m+[m[32m                        0x200) >> 10;[m
[32m+[m[32m                }[m
[32m+[m[32m                grayscaleBuffer[j] = 0xFF - gray;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return grayscaleBuffer;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {[m
[32m+[m[32m        if (y < 0 || y >= this.getHeight()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);[m
[32m+[m[32m        }[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        var start = y * width;[m
[32m+[m[32m        if (row === null) {[m
[32m+[m[32m            row = this.buffer.slice(start, start + width);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            if (row.length < width) {[m
[32m+[m[32m                row = new Uint8ClampedArray(width);[m
[32m+[m[32m            }[m
[32m+[m[32m            // The underlying raster of image consists of bytes with the luminance values[m
[32m+[m[32m            // TODO: can avoid set/slice?[m
[32m+[m[32m            row.set(this.buffer.slice(start, start + width));[m
[32m+[m[32m        }[m
[32m+[m[32m        return row;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {[m
[32m+[m[32m        return this.buffer;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        _super.prototype.crop.call(this, left, top, width, height);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is always true, since the image is a gray-scale image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return true[m
[32m+[m[32m     */[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {[m
[32m+[m[32m        this.rotate(-90);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {[m
[32m+[m[32m        this.rotate(-45);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {[m
[32m+[m[32m        if (null === this.tempCanvasElement) {[m
[32m+[m[32m            var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');[m
[32m+[m[32m            tempCanvasElement.width = this.canvas.width;[m
[32m+[m[32m            tempCanvasElement.height = this.canvas.height;[m
[32m+[m[32m            this.tempCanvasElement = tempCanvasElement;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.tempCanvasElement;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {[m
[32m+[m[32m        var tempCanvasElement = this.getTempCanvasElement();[m
[32m+[m[32m        var tempContext = tempCanvasElement.getContext('2d');[m
[32m+[m[32m        var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;[m
[32m+[m[32m        // Calculate and set new dimensions for temp canvas[m
[32m+[m[32m        var width = this.canvas.width;[m
[32m+[m[32m        var height = this.canvas.height;[m
[32m+[m[32m        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);[m
[32m+[m[32m        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);[m
[32m+[m[32m        tempCanvasElement.width = newWidth;[m
[32m+[m[32m        tempCanvasElement.height = newHeight;[m
[32m+[m[32m        // Draw at center of temp canvas to prevent clipping of image data[m
[32m+[m[32m        tempContext.translate(newWidth / 2, newHeight / 2);[m
[32m+[m[32m        tempContext.rotate(angleRadians);[m
[32m+[m[32m        tempContext.drawImage(this.canvas, width / -2, height / -2);[m
[32m+[m[32m        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.prototype.invert = function () {[m
[32m+[m[32m        return new InvertedLuminanceSource_1.default(this);[m
[32m+[m[32m    };[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;[m
[32m+[m[32m    HTMLCanvasElementLuminanceSource.FRAME_INDEX = true;[m
[32m+[m[32m    return HTMLCanvasElementLuminanceSource;[m
[32m+[m[32m}(LuminanceSource_1.default));[m
[32m+[m[32mexports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..22775b8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.d.ts[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * HTML elements that can be decoded.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare type HTMLVisualMediaElement = HTMLVideoElement | HTMLImageElement;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js b/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c8ad2e5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/HTMLVisualMediaElement.js[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.d.ts b/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..6a0530a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.d.ts[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Video input device metadata containing the id and label of the device if available.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class VideoInputDevice implements MediaDeviceInfo {[m
[32m+[m[32m    deviceId: string;[m
[32m+[m[32m    label: string;[m
[32m+[m[32m    /** @inheritdoc */[m
[32m+[m[32m    readonly kind = "videoinput";[m
[32m+[m[32m    /** @inheritdoc */[m
[32m+[m[32m    readonly groupId: string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of VideoInputDevice.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string} deviceId the video input device id[m
[32m+[m[32m     * @param {string} label the label of the device if available[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(deviceId: string, label: string, groupId?: string);[m
[32m+[m[32m    /** @inheritdoc */[m
[32m+[m[32m    toJSON(): {[m
[32m+[m[32m        kind: string;[m
[32m+[m[32m        groupId: string;[m
[32m+[m[32m        deviceId: string;[m
[32m+[m[32m        label: string;[m
[32m+[m[32m    };[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js b/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5013a03[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/browser/VideoInputDevice.js[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.VideoInputDevice = void 0;[m
[32m+[m[32m/**[m
[32m+[m[32m * @deprecated Moving to @zxing/browser[m
[32m+[m[32m *[m
[32m+[m[32m * Video input device metadata containing the id and label of the device if available.[m
[32m+[m[32m */[m
[32m+[m[32mvar VideoInputDevice = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an instance of VideoInputDevice.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param {string} deviceId the video input device id[m
[32m+[m[32m     * @param {string} label the label of the device if available[m
[32m+[m[32m     */[m
[32m+[m[32m    function VideoInputDevice(deviceId, label, groupId) {[m
[32m+[m[32m        this.deviceId = deviceId;[m
[32m+[m[32m        this.label = label;[m
[32m+[m[32m        /** @inheritdoc */[m
[32m+[m[32m        this.kind = 'videoinput';[m
[32m+[m[32m        this.groupId = groupId || undefined;[m
[32m+[m[32m    }[m
[32m+[m[32m    /** @inheritdoc */[m
[32m+[m[32m    VideoInputDevice.prototype.toJSON = function () {[m
[32m+[m[32m        return {[m
[32m+[m[32m            kind: this.kind,[m
[32m+[m[32m            groupId: this.groupId,[m
[32m+[m[32m            deviceId: this.deviceId,[m
[32m+[m[32m            label: this.label,[m
[32m+[m[32m        };[m
[32m+[m[32m    };[m
[32m+[m[32m    return VideoInputDevice;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.VideoInputDevice = VideoInputDevice;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0c2ff6e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ArgumentException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.js b/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9c4cf25[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArgumentException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ArgumentException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ArgumentException, _super);[m
[32m+[m[32m    function ArgumentException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ArgumentException.kind = 'ArgumentException';[m
[32m+[m[32m    return ArgumentException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = ArgumentException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4929b60[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ArithmeticException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.js b/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..29622fa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArithmeticException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ArithmeticException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ArithmeticException, _super);[m
[32m+[m[32m    function ArithmeticException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ArithmeticException.kind = 'ArithmeticException';[m
[32m+[m[32m    return ArithmeticException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = ArithmeticException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..8a553fa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport IndexOutOfBoundsException from './IndexOutOfBoundsException';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {[m
[32m+[m[32m    index: number;[m
[32m+[m[32m    message: string;[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m    constructor(index?: number, message?: string);[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js b/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c38c1e6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ArrayIndexOutOfBoundsException.js[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IndexOutOfBoundsException_1 = require("./IndexOutOfBoundsException");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ArrayIndexOutOfBoundsException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ArrayIndexOutOfBoundsException, _super);[m
[32m+[m[32m    function ArrayIndexOutOfBoundsException(index, message) {[m
[32m+[m[32m        if (index === void 0) { index = undefined; }[m
[32m+[m[32m        if (message === void 0) { message = undefined; }[m
[32m+[m[32m        var _this = _super.call(this, message) || this;[m
[32m+[m[32m        _this.index = index;[m
[32m+[m[32m        _this.message = message;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';[m
[32m+[m[32m    return ArrayIndexOutOfBoundsException;[m
[32m+[m[32m}(IndexOutOfBoundsException_1.default));[m
[32m+[m[32mexports.default = ArrayIndexOutOfBoundsException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.d.ts b/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..bccb1f4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.d.ts[m
[36m@@ -0,0 +1,42 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Enumerates barcode formats known to this package. Please keep alphabetized.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mdeclare enum BarcodeFormat {[m
[32m+[m[32m    /** Aztec 2D barcode format. */[m
[32m+[m[32m    AZTEC = 0,[m
[32m+[m[32m    /** CODABAR 1D format. */[m
[32m+[m[32m    CODABAR = 1,[m
[32m+[m[32m    /** Code 39 1D format. */[m
[32m+[m[32m    CODE_39 = 2,[m
[32m+[m[32m    /** Code 93 1D format. */[m
[32m+[m[32m    CODE_93 = 3,[m
[32m+[m[32m    /** Code 128 1D format. */[m
[32m+[m[32m    CODE_128 = 4,[m
[32m+[m[32m    /** Data Matrix 2D barcode format. */[m
[32m+[m[32m    DATA_MATRIX = 5,[m
[32m+[m[32m    /** EAN-8 1D format. */[m
[32m+[m[32m    EAN_8 = 6,[m
[32m+[m[32m    /** EAN-13 1D format. */[m
[32m+[m[32m    EAN_13 = 7,[m
[32m+[m[32m    /** ITF (Interleaved Two of Five) 1D format. */[m
[32m+[m[32m    ITF = 8,[m
[32m+[m[32m    /** MaxiCode 2D barcode format. */[m
[32m+[m[32m    MAXICODE = 9,[m
[32m+[m[32m    /** PDF417 format. */[m
[32m+[m[32m    PDF_417 = 10,[m
[32m+[m[32m    /** QR Code 2D barcode format. */[m
[32m+[m[32m    QR_CODE = 11,[m
[32m+[m[32m    /** RSS 14 */[m
[32m+[m[32m    RSS_14 = 12,[m
[32m+[m[32m    /** RSS EXPANDED */[m
[32m+[m[32m    RSS_EXPANDED = 13,[m
[32m+[m[32m    /** UPC-A 1D format. */[m
[32m+[m[32m    UPC_A = 14,[m
[32m+[m[32m    /** UPC-E 1D format. */[m
[32m+[m[32m    UPC_E = 15,[m
[32m+[m[32m    /** UPC/EAN extension format. Not a stand-alone format. */[m
[32m+[m[32m    UPC_EAN_EXTENSION = 16[m
[32m+[m[32m}[m
[32m+[m[32mexport default BarcodeFormat;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.js b/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a7e26b2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/BarcodeFormat.js[m
[36m@@ -0,0 +1,64 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Direct port to TypeScript of ZXing by Adrian To»ôcƒÉ[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * Enumerates barcode formats known to this package. Please keep alphabetized.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar BarcodeFormat;[m
[32m+[m[32m(function (BarcodeFormat) {[m
[32m+[m[32m    /** Aztec 2D barcode format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["AZTEC"] = 0] = "AZTEC";[m
[32m+[m[32m    /** CODABAR 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["CODABAR"] = 1] = "CODABAR";[m
[32m+[m[32m    /** Code 39 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["CODE_39"] = 2] = "CODE_39";[m
[32m+[m[32m    /** Code 93 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["CODE_93"] = 3] = "CODE_93";[m
[32m+[m[32m    /** Code 128 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["CODE_128"] = 4] = "CODE_128";[m
[32m+[m[32m    /** Data Matrix 2D barcode format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["DATA_MATRIX"] = 5] = "DATA_MATRIX";[m
[32m+[m[32m    /** EAN-8 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["EAN_8"] = 6] = "EAN_8";[m
[32m+[m[32m    /** EAN-13 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["EAN_13"] = 7] = "EAN_13";[m
[32m+[m[32m    /** ITF (Interleaved Two of Five) 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["ITF"] = 8] = "ITF";[m
[32m+[m[32m    /** MaxiCode 2D barcode format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["MAXICODE"] = 9] = "MAXICODE";[m
[32m+[m[32m    /** PDF417 format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["PDF_417"] = 10] = "PDF_417";[m
[32m+[m[32m    /** QR Code 2D barcode format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["QR_CODE"] = 11] = "QR_CODE";[m
[32m+[m[32m    /** RSS 14 */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["RSS_14"] = 12] = "RSS_14";[m
[32m+[m[32m    /** RSS EXPANDED */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";[m
[32m+[m[32m    /** UPC-A 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["UPC_A"] = 14] = "UPC_A";[m
[32m+[m[32m    /** UPC-E 1D format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["UPC_E"] = 15] = "UPC_E";[m
[32m+[m[32m    /** UPC/EAN extension format. Not a stand-alone format. */[m
[32m+[m[32m    BarcodeFormat[BarcodeFormat["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";[m
[32m+[m[32m})(BarcodeFormat || (BarcodeFormat = {}));[m
[32m+[m[32mexports.default = BarcodeFormat;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Binarizer.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Binarizer.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4ca80ca[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Binarizer.d.ts[m
[36m@@ -0,0 +1,53 @@[m
[32m+[m[32mimport LuminanceSource from './LuminanceSource';[m
[32m+[m[32mimport BitArray from './common/BitArray';[m
[32m+[m[32mimport BitMatrix from './common/BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.[m
[32m+[m[32m * It allows the algorithm to vary polymorphically, for example allowing a very expensive[m
[32m+[m[32m * thresholding technique for servers and a fast one for mobile. It also permits the implementation[m
[32m+[m[32m * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mdeclare abstract class Binarizer {[m
[32m+[m[32m    private source;[m
[32m+[m[32m    protected constructor(source: LuminanceSource);[m
[32m+[m[32m    getLuminanceSource(): LuminanceSource;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return[m
[32m+[m[32m     * cached data. Callers should assume this method is expensive and call it as seldom as possible.[m
[32m+[m[32m     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.[m
[32m+[m[32m     * For callers which only examine one row of pixels at a time, the same BitArray should be reused[m
[32m+[m[32m     * and passed in with each call for performance. However it is legal to keep more than one row[m
[32m+[m[32m     * at a time if needed.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to fetch, which must be in [0, bitmap height)[m
[32m+[m[32m     * @param row An optional preallocated array. If null or too small, it will be ignored.[m
[32m+[m[32m     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.[m
[32m+[m[32m     * @return The array of bits for this row (true means black).[m
[32m+[m[32m     * @throws NotFoundException if row can't be binarized[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract getBlackRow(y: number, row: BitArray): BitArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts a 2D array of luminance data to 1 bit data. As above, assume this method is expensive[m
[32m+[m[32m     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or[m
[32m+[m[32m     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one[m
[32m+[m[32m     * fetched using getBlackRow(), so don't mix and match between them.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return The 2D array of bits for the image (true means black).[m
[32m+[m[32m     * @throws NotFoundException if image can't be binarized to make a matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract getBlackMatrix(): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a new object with the same type as this Binarizer implementation, but with pristine[m
[32m+[m[32m     * state. This is needed because Binarizer implementations may be stateful, e.g. keeping a cache[m
[32m+[m[32m     * of 1 bit data. See Effective Java for why we can't use Java's clone() method.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param source The LuminanceSource this Binarizer will operate on.[m
[32m+[m[32m     * @return A new concrete Binarizer implementation object.[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract createBinarizer(source: LuminanceSource): Binarizer;[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m}[m
[32m+[m[32mexport default Binarizer;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Binarizer.js b/frontend/node_modules/@zxing/library/cjs/core/Binarizer.js[m
[1mnew file mode 100644[m
[1mindex 0000000..49746e4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Binarizer.js[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.[m
[32m+[m[32m * It allows the algorithm to vary polymorphically, for example allowing a very expensive[m
[32m+[m[32m * thresholding technique for servers and a fast one for mobile. It also permits the implementation[m
[32m+[m[32m * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar Binarizer = /** @class */ (function () {[m
[32m+[m[32m    function Binarizer(source) {[m
[32m+[m[32m        this.source = source;[m
[32m+[m[32m    }[m
[32m+[m[32m    Binarizer.prototype.getLuminanceSource = function () {[m
[32m+[m[32m        return this.source;[m
[32m+[m[32m    };[m
[32m+[m[32m    Binarizer.prototype.getWidth = function () {[m
[32m+[m[32m        return this.source.getWidth();[m
[32m+[m[32m    };[m
[32m+[m[32m    Binarizer.prototype.getHeight = function () {[m
[32m+[m[32m        return this.source.getHeight();[m
[32m+[m[32m    };[m
[32m+[m[32m    return Binarizer;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Binarizer;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.d.ts b/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3642aed[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.d.ts[m
[36m@@ -0,0 +1,78 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * This class is the core bitmap class used by ZXing to represent 1 bit data. Reader objects[m
[32m+[m[32m * accept a BinaryBitmap and attempt to decode it.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mimport Binarizer from './Binarizer';[m
[32m+[m[32mimport BitArray from './common/BitArray';[m
[32m+[m[32mimport BitMatrix from './common/BitMatrix';[m
[32m+[m[32mexport default class BinaryBitmap {[m
[32m+[m[32m    private binarizer;[m
[32m+[m[32m    private matrix;[m
[32m+[m[32m    constructor(binarizer: Binarizer);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return[m
[32m+[m[32m     * cached data. Callers should assume this method is expensive and call it as seldom as possible.[m
[32m+[m[32m     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to fetch, which must be in [0, bitmap height)[m
[32m+[m[32m     * @param row An optional preallocated array. If null or too small, it will be ignored.[m
[32m+[m[32m     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.[m
[32m+[m[32m     * @return The array of bits for this row (true means black).[m
[32m+[m[32m     * @throws NotFoundException if row can't be binarized[m
[32m+[m[32m     */[m
[32m+[m[32m    getBlackRow(y: number, row: BitArray): BitArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive[m
[32m+[m[32m     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or[m
[32m+[m[32m     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one[m
[32m+[m[32m     * fetched using getBlackRow(), so don't mix and match between them.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return The 2D array of bits for the image (true means black).[m
[32m+[m[32m     * @throws NotFoundException if image can't be binarized to make a matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    getBlackMatrix(): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this bitmap can be cropped.[m
[32m+[m[32m     */[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with cropped image data. Implementations may keep a reference to the[m
[32m+[m[32m     * original data rather than a copy. Only callable if isCropSupported() is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The left coordinate, which must be in [0,getWidth())[m
[32m+[m[32m     * @param top The top coordinate, which must be in [0,getHeight())[m
[32m+[m[32m     * @param width The width of the rectangle to crop.[m
[32m+[m[32m     * @param height The height of the rectangle to crop.[m
[32m+[m[32m     * @return A cropped version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): BinaryBitmap;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this bitmap supports counter-clockwise rotation.[m
[32m+[m[32m     */[m
[32m+[m[32m    isRotateSupported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 90 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    rotateCounterClockwise(): BinaryBitmap;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 45 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    rotateCounterClockwise45(): BinaryBitmap;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.js b/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5ea7f91[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/BinaryBitmap.js[m
[36m@@ -0,0 +1,129 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("./IllegalArgumentException");[m
[32m+[m[32mvar BinaryBitmap = /** @class */ (function () {[m
[32m+[m[32m    function BinaryBitmap(binarizer) {[m
[32m+[m[32m        this.binarizer = binarizer;[m
[32m+[m[32m        if (binarizer === null) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.getWidth = function () {[m
[32m+[m[32m        return this.binarizer.getWidth();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.getHeight = function () {[m
[32m+[m[32m        return this.binarizer.getHeight();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return[m
[32m+[m[32m     * cached data. Callers should assume this method is expensive and call it as seldom as possible.[m
[32m+[m[32m     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to fetch, which must be in [0, bitmap height)[m
[32m+[m[32m     * @param row An optional preallocated array. If null or too small, it will be ignored.[m
[32m+[m[32m     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.[m
[32m+[m[32m     * @return The array of bits for this row (true means black).[m
[32m+[m[32m     * @throws NotFoundException if row can't be binarized[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {[m
[32m+[m[32m        return this.binarizer.getBlackRow(y, row);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive[m
[32m+[m[32m     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or[m
[32m+[m[32m     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one[m
[32m+[m[32m     * fetched using getBlackRow(), so don't mix and match between them.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return The 2D array of bits for the image (true means black).[m
[32m+[m[32m     * @throws NotFoundException if image can't be binarized to make a matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.getBlackMatrix = function () {[m
[32m+[m[32m        // The matrix is created on demand the first time it is requested, then cached. There are two[m
[32m+[m[32m        // reasons for this:[m
[32m+[m[32m        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a[m
[32m+[m[32m        //    1D Reader finds a barcode before the 2D Readers run.[m
[32m+[m[32m        // 2. This work will only be done once even if the caller installs multiple 2D Readers.[m
[32m+[m[32m        if (this.matrix === null || this.matrix === undefined) {[m
[32m+[m[32m            this.matrix = this.binarizer.getBlackMatrix();[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this bitmap can be cropped.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.isCropSupported = function () {[m
[32m+[m[32m        return this.binarizer.getLuminanceSource().isCropSupported();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with cropped image data. Implementations may keep a reference to the[m
[32m+[m[32m     * original data rather than a copy. Only callable if isCropSupported() is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The left coordinate, which must be in [0,getWidth())[m
[32m+[m[32m     * @param top The top coordinate, which must be in [0,getHeight())[m
[32m+[m[32m     * @param width The width of the rectangle to crop.[m
[32m+[m[32m     * @param height The height of the rectangle to crop.[m
[32m+[m[32m     * @return A cropped version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);[m
[32m+[m[32m        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this bitmap supports counter-clockwise rotation.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.isRotateSupported = function () {[m
[32m+[m[32m        return this.binarizer.getLuminanceSource().isRotateSupported();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 90 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.rotateCounterClockwise = function () {[m
[32m+[m[32m        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();[m
[32m+[m[32m        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 45 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {[m
[32m+[m[32m        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();[m
[32m+[m[32m        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BinaryBitmap.prototype.toString = function () {[m
[32m+[m[32m        try {[m
[32m+[m[32m            return this.getBlackMatrix().toString();[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e /*: NotFoundException*/) {[m
[32m+[m[32m            return '';[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return BinaryBitmap;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BinaryBitmap;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3023deb[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ChecksumException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m    static getChecksumInstance(): ChecksumException;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.js b/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..45f851f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ChecksumException.js[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ChecksumException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ChecksumException, _super);[m
[32m+[m[32m    function ChecksumException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ChecksumException.getChecksumInstance = function () {[m
[32m+[m[32m        return new ChecksumException();[m
[32m+[m[32m    };[m
[32m+[m[32m    ChecksumException.kind = 'ChecksumException';[m
[32m+[m[32m    return ChecksumException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = ChecksumException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.d.ts b/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..6742e03[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.d.ts[m
[36m@@ -0,0 +1,74 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates a type of hint that a caller may pass to a barcode reader to help it[m
[32m+[m[32m * more quickly or accurately decode it. It is up to implementations to decide what,[m
[32m+[m[32m * if anything, to do with the information that is supplied.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @see Reader#decode(BinaryBitmap,java.util.Map)[m
[32m+[m[32m */[m
[32m+[m[32mdeclare enum DecodeHintType {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.[m
[32m+[m[32m     */[m
[32m+[m[32m    OTHER = 0,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    PURE_BARCODE = 1,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Image is known to be of one of a few possible formats.[m
[32m+[m[32m     * Maps to a {@link List} of {@link BarcodeFormat}s.[m
[32m+[m[32m     */[m
[32m+[m[32m    POSSIBLE_FORMATS = 2,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Spend more time to try to find a barcode; optimize for accuracy, not speed.[m
[32m+[m[32m     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    TRY_HARDER = 3,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what character encoding to use when decoding, where applicable (type String)[m
[32m+[m[32m     */[m
[32m+[m[32m    CHARACTER_SET = 4,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ALLOWED_LENGTHS = 5,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ASSUME_CODE_39_CHECK_DIGIT = 6,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Enable extended mode for Code 39 codes. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ENABLE_CODE_39_EXTENDED_MODE = 7,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.[m
[32m+[m[32m     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ASSUME_GS1 = 8,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They[m
[32m+[m[32m     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them[m
[32m+[m[32m     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    RETURN_CODABAR_START_END = 9,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The caller needs to be notified via callback when a possible {@link ResultPoint}[m
[32m+[m[32m     * is found. Maps to a {@link ResultPointCallback}.[m
[32m+[m[32m     */[m
[32m+[m[32m    NEED_RESULT_POINT_CALLBACK = 10,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.[m
[32m+[m[32m     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].[m
[32m+[m[32m     * If it is optional to have an extension, do not set this hint. If this is set,[m
[32m+[m[32m     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned[m
[32m+[m[32m     * at all.[m
[32m+[m[32m     */[m
[32m+[m[32m    ALLOWED_EAN_EXTENSIONS = 11[m
[32m+[m[32m}[m
[32m+[m[32mexport default DecodeHintType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.js b/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8a63110[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/DecodeHintType.js[m
[36m@@ -0,0 +1,109 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates a type of hint that a caller may pass to a barcode reader to help it[m
[32m+[m[32m * more quickly or accurately decode it. It is up to implementations to decide what,[m
[32m+[m[32m * if anything, to do with the information that is supplied.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @see Reader#decode(BinaryBitmap,java.util.Map)[m
[32m+[m[32m */[m
[32m+[m[32mvar DecodeHintType;[m
[32m+[m[32m(function (DecodeHintType) {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["OTHER"] = 0] = "OTHER"; /*(Object.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["PURE_BARCODE"] = 1] = "PURE_BARCODE"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Image is known to be of one of a few possible formats.[m
[32m+[m[32m     * Maps to a {@link List} of {@link BarcodeFormat}s.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS"; /*(List.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Spend more time to try to find a barcode; optimize for accuracy, not speed.[m
[32m+[m[32m     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["TRY_HARDER"] = 3] = "TRY_HARDER"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what character encoding to use when decoding, where applicable (type String)[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["CHARACTER_SET"] = 4] = "CHARACTER_SET"; /*(String.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS"; /*(Int32Array.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Enable extended mode for Code 39 codes. Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["ENABLE_CODE_39_EXTENDED_MODE"] = 7] = "ENABLE_CODE_39_EXTENDED_MODE"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.[m
[32m+[m[32m     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;[m
[32m+[m[32m     * use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["ASSUME_GS1"] = 8] = "ASSUME_GS1"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They[m
[32m+[m[32m     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them[m
[32m+[m[32m     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["RETURN_CODABAR_START_END"] = 9] = "RETURN_CODABAR_START_END"; /*(Void.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The caller needs to be notified via callback when a possible {@link ResultPoint}[m
[32m+[m[32m     * is found. Maps to a {@link ResultPointCallback}.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["NEED_RESULT_POINT_CALLBACK"] = 10] = "NEED_RESULT_POINT_CALLBACK"; /*(ResultPointCallback.class)*/[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.[m
[32m+[m[32m     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].[m
[32m+[m[32m     * If it is optional to have an extension, do not set this hint. If this is set,[m
[32m+[m[32m     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned[m
[32m+[m[32m     * at all.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodeHintType[DecodeHintType["ALLOWED_EAN_EXTENSIONS"] = 11] = "ALLOWED_EAN_EXTENSIONS"; /*(Int32Array.class)*/[m
[32m+[m[32m    // End of enumeration values.[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Data type the hint is expecting.[m
[32m+[m[32m     * Among the possible values the {@link Void} stands out as being used for[m
[32m+[m[32m     * hints that do not expect a value to be supplied (flag hints). Such hints[m
[32m+[m[32m     * will possibly have their value ignored, or replaced by a[m
[32m+[m[32m     * {@link Boolean#TRUE}. Hint suppliers should probably use[m
[32m+[m[32m     * {@link Boolean#TRUE} as directed by the actual hint documentation.[m
[32m+[m[32m     */[m
[32m+[m[32m    // private valueType: Class<?>[m
[32m+[m[32m    // DecodeHintType(valueType: Class<?>) {[m
[32m+[m[32m    //   this.valueType = valueType[m
[32m+[m[32m    // }[m
[32m+[m[32m    // public getValueType(): Class<?> {[m
[32m+[m[32m    //   return valueType[m
[32m+[m[32m    // }[m
[32m+[m[32m})(DecodeHintType || (DecodeHintType = {}));[m
[32m+[m[32mexports.default = DecodeHintType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Dimension.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Dimension.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d7f0255[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Dimension.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Simply encapsulates a width and height.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Dimension {[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    constructor(width: number, height: number);[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m    equals(other: any): boolean;[m
[32m+[m[32m    hashCode(): number;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Dimension.js b/frontend/node_modules/@zxing/library/cjs/core/Dimension.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7230e78[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Dimension.js[m
[36m@@ -0,0 +1,55 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("./IllegalArgumentException");[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * Simply encapsulates a width and height.[m
[32m+[m[32m */[m
[32m+[m[32mvar Dimension = /** @class */ (function () {[m
[32m+[m[32m    function Dimension(width /*int*/, height /*int*/) {[m
[32m+[m[32m        this.width = width;[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m        if (width < 0 || height < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    Dimension.prototype.getWidth = function () {[m
[32m+[m[32m        return this.width;[m
[32m+[m[32m    };[m
[32m+[m[32m    Dimension.prototype.getHeight = function () {[m
[32m+[m[32m        return this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    Dimension.prototype.equals = function (other) {[m
[32m+[m[32m        if (other instanceof Dimension) {[m
[32m+[m[32m            var d = other;[m
[32m+[m[32m            return this.width === d.width && this.height === d.height;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    Dimension.prototype.hashCode = function () {[m
[32m+[m[32m        return this.width * 32713 + this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    Dimension.prototype.toString = function () {[m
[32m+[m[32m        return this.width + 'x' + this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Dimension;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Dimension;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.d.ts b/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..599bac2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.d.ts[m
[36m@@ -0,0 +1,99 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * These are a set of hints that you may pass to Writers to specify their behavior.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mdeclare enum EncodeHintType {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what degree of error correction to use, for example in QR Codes.[m
[32m+[m[32m     * Type depends on the encoder. For example for QR codes it's type[m
[32m+[m[32m     * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.[m
[32m+[m[32m     * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.[m
[32m+[m[32m     * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.[m
[32m+[m[32m     * In all cases, it can also be a {@link String} representation of the desired value as well.[m
[32m+[m[32m     * Note: an Aztec symbol should have a minimum of 25% EC words.[m
[32m+[m[32m     */[m
[32m+[m[32m    ERROR_CORRECTION = 0,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what character encoding to use where applicable (type {@link String})[m
[32m+[m[32m     */[m
[32m+[m[32m    CHARACTER_SET = 1,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})[m
[32m+[m[32m     */[m
[32m+[m[32m    DATA_MATRIX_SHAPE = 2,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether to use compact mode for Data Matrix (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String } value).[m
[32m+[m[32m     * The compact encoding mode also supports the encoding of characters that are not in the ISO-8859-1[m
[32m+[m[32m     * character set via ECIs.[m
[32m+[m[32m     * Please note that in that case, the most compact character encoding is chosen for characters in[m
[32m+[m[32m     * the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not[m
[32m+[m[32m     * support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by[m
[32m+[m[32m     * means of the {@link #CHARACTER_SET} encoding hint.[m
[32m+[m[32m     * Compact encoding also provides GS1-FNC1 support when {@link #GS1_FORMAT} is selected. In this case[m
[32m+[m[32m     * group-separator character (ASCII 29 decimal) can be used to encode the positions of FNC1 codewords[m
[32m+[m[32m     * for the purpose of delimiting AIs.[m
[32m+[m[32m     * This option and {@link #FORCE_C40} are mutually exclusive.[m
[32m+[m[32m     */[m
[32m+[m[32m    DATA_MATRIX_COMPACT = 3,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated use width/height params in[m
[32m+[m[32m     * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}[m
[32m+[m[32m     */[m
[32m+[m[32m    MIN_SIZE = 4,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated without replacement[m
[32m+[m[32m     */[m
[32m+[m[32m    MAX_SIZE = 5,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary[m
[32m+[m[32m     * by format; for example it controls margin before and after the barcode horizontally for[m
[32m+[m[32m     * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    MARGIN = 6,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String} value).[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417_COMPACT = 7,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what compaction mode to use for PDF417 (type[m
[32m+[m[32m     * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its[m
[32m+[m[32m     * enum values).[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417_COMPACTION = 8,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the minimum and maximum number of rows and columns for PDF417 (type[m
[32m+[m[32m     * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417_DIMENSIONS = 9,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the required number of layers for an Aztec code.[m
[32m+[m[32m     * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.[m
[32m+[m[32m     * 0 indicates to use the minimum number of layers (the default).[m
[32m+[m[32m     * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.[m
[32m+[m[32m     * (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    AZTEC_LAYERS = 10,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the exact version of QR code to be encoded.[m
[32m+[m[32m     * (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    QR_VERSION = 11,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String } value).[m
[32m+[m[32m     */[m
[32m+[m[32m    GS1_FORMAT = 12,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Forces C40 encoding for data-matrix (type {@link Boolean}, or "true" or "false") {@link String } value). This[m
[32m+[m[32m     * option and {@link #DATA_MATRIX_COMPACT} are mutually exclusive.[m
[32m+[m[32m     */[m
[32m+[m[32m    FORCE_C40 = 13[m
[32m+[m[32m}[m
[32m+[m[32mexport default EncodeHintType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.js b/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.js[m
[1mnew file mode 100644[m
[1mindex 0000000..81b96d6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/EncodeHintType.js[m
[36m@@ -0,0 +1,120 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * These are a set of hints that you may pass to Writers to specify their behavior.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar EncodeHintType;[m
[32m+[m[32m(function (EncodeHintType) {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what degree of error correction to use, for example in QR Codes.[m
[32m+[m[32m     * Type depends on the encoder. For example for QR codes it's type[m
[32m+[m[32m     * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.[m
[32m+[m[32m     * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.[m
[32m+[m[32m     * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.[m
[32m+[m[32m     * In all cases, it can also be a {@link String} representation of the desired value as well.[m
[32m+[m[32m     * Note: an Aztec symbol should have a minimum of 25% EC words.[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what character encoding to use where applicable (type {@link String})[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["CHARACTER_SET"] = 1] = "CHARACTER_SET";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether to use compact mode for Data Matrix (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String } value).[m
[32m+[m[32m     * The compact encoding mode also supports the encoding of characters that are not in the ISO-8859-1[m
[32m+[m[32m     * character set via ECIs.[m
[32m+[m[32m     * Please note that in that case, the most compact character encoding is chosen for characters in[m
[32m+[m[32m     * the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not[m
[32m+[m[32m     * support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by[m
[32m+[m[32m     * means of the {@link #CHARACTER_SET} encoding hint.[m
[32m+[m[32m     * Compact encoding also provides GS1-FNC1 support when {@link #GS1_FORMAT} is selected. In this case[m
[32m+[m[32m     * group-separator character (ASCII 29 decimal) can be used to encode the positions of FNC1 codewords[m
[32m+[m[32m     * for the purpose of delimiting AIs.[m
[32m+[m[32m     * This option and {@link #FORCE_C40} are mutually exclusive.[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["DATA_MATRIX_COMPACT"] = 3] = "DATA_MATRIX_COMPACT";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated use width/height params in[m
[32m+[m[32m     * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Deprecated*/[m
[32m+[m[32m    EncodeHintType[EncodeHintType["MIN_SIZE"] = 4] = "MIN_SIZE";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated without replacement[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Deprecated*/[m
[32m+[m[32m    EncodeHintType[EncodeHintType["MAX_SIZE"] = 5] = "MAX_SIZE";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary[m
[32m+[m[32m     * by format; for example it controls margin before and after the barcode horizontally for[m
[32m+[m[32m     * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["MARGIN"] = 6] = "MARGIN";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String} value).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["PDF417_COMPACT"] = 7] = "PDF417_COMPACT";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies what compaction mode to use for PDF417 (type[m
[32m+[m[32m     * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its[m
[32m+[m[32m     * enum values).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["PDF417_COMPACTION"] = 8] = "PDF417_COMPACTION";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the minimum and maximum number of rows and columns for PDF417 (type[m
[32m+[m[32m     * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["PDF417_DIMENSIONS"] = 9] = "PDF417_DIMENSIONS";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the required number of layers for an Aztec code.[m
[32m+[m[32m     * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.[m
[32m+[m[32m     * 0 indicates to use the minimum number of layers (the default).[m
[32m+[m[32m     * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.[m
[32m+[m[32m     * (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["AZTEC_LAYERS"] = 10] = "AZTEC_LAYERS";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies the exact version of QR code to be encoded.[m
[32m+[m[32m     * (Type {@link Integer}, or {@link String} representation of the integer value).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["QR_VERSION"] = 11] = "QR_VERSION";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or "true" or "false"[m
[32m+[m[32m     * {@link String } value).[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["GS1_FORMAT"] = 12] = "GS1_FORMAT";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Forces C40 encoding for data-matrix (type {@link Boolean}, or "true" or "false") {@link String } value). This[m
[32m+[m[32m     * option and {@link #DATA_MATRIX_COMPACT} are mutually exclusive.[m
[32m+[m[32m     */[m
[32m+[m[32m    EncodeHintType[EncodeHintType["FORCE_C40"] = 13] = "FORCE_C40";[m
[32m+[m[32m})(EncodeHintType || (EncodeHintType = {}));[m
[32m+[m[32mexports.default = EncodeHintType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Exception.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Exception.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..114d6be[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Exception.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport { CustomError } from 'ts-custom-error';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Exception extends CustomError {[m
[32m+[m[32m    message: string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * It's typed as string so it can be extended and overriden.[m
[32m+[m[32m     */[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allows Exception to be constructed directly[m
[32m+[m[32m     * with some message and prototype definition.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(message?: string);[m
[32m+[m[32m    getKind(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Exception.js b/frontend/node_modules/@zxing/library/cjs/core/Exception.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ec49b85[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Exception.js[m
[36m@@ -0,0 +1,42 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ts_custom_error_1 = require("ts-custom-error");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar Exception = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Exception, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Allows Exception to be constructed directly[m
[32m+[m[32m     * with some message and prototype definition.[m
[32m+[m[32m     */[m
[32m+[m[32m    function Exception(message) {[m
[32m+[m[32m        if (message === void 0) { message = undefined; }[m
[32m+[m[32m        var _this = _super.call(this, message) || this;[m
[32m+[m[32m        _this.message = message;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Exception.prototype.getKind = function () {[m
[32m+[m[32m        var ex = this.constructor;[m
[32m+[m[32m        return ex.kind;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * It's typed as string so it can be extended and overriden.[m
[32m+[m[32m     */[m
[32m+[m[32m    Exception.kind = 'Exception';[m
[32m+[m[32m    return Exception;[m
[32m+[m[32m}(ts_custom_error_1.CustomError));[m
[32m+[m[32mexports.default = Exception;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/FormatException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/FormatException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..dbbdf9d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/FormatException.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class FormatException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m    static getFormatInstance(): FormatException;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/FormatException.js b/frontend/node_modules/@zxing/library/cjs/core/FormatException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1469ed2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/FormatException.js[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar FormatException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(FormatException, _super);[m
[32m+[m[32m    function FormatException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    FormatException.getFormatInstance = function () {[m
[32m+[m[32m        return new FormatException();[m
[32m+[m[32m    };[m
[32m+[m[32m    FormatException.kind = 'FormatException';[m
[32m+[m[32m    return FormatException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = FormatException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..65585e8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class IllegalArgumentException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js b/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0890098[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IllegalArgumentException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar IllegalArgumentException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(IllegalArgumentException, _super);[m
[32m+[m[32m    function IllegalArgumentException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    IllegalArgumentException.kind = 'IllegalArgumentException';[m
[32m+[m[32m    return IllegalArgumentException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = IllegalArgumentException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3860f98[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class IllegalStateException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.js b/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..eeaba69[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IllegalStateException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar IllegalStateException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(IllegalStateException, _super);[m
[32m+[m[32m    function IllegalStateException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    IllegalStateException.kind = 'IllegalStateException';[m
[32m+[m[32m    return IllegalStateException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = IllegalStateException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f9bfe4f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class IndexOutOfBoundsException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js b/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2aed811[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/IndexOutOfBoundsException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar IndexOutOfBoundsException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(IndexOutOfBoundsException, _super);[m
[32m+[m[32m    function IndexOutOfBoundsException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';[m
[32m+[m[32m    return IndexOutOfBoundsException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = IndexOutOfBoundsException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.d.ts b/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..92de19f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.d.ts[m
[36m@@ -0,0 +1,22 @@[m
[32m+[m[32mimport LuminanceSource from './LuminanceSource';[m
[32m+[m[32m/**[m
[32m+[m[32m * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes[m
[32m+[m[32m * white and vice versa, and each value becomes (255-value).[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class InvertedLuminanceSource extends LuminanceSource {[m
[32m+[m[32m    private delegate;[m
[32m+[m[32m    constructor(delegate: LuminanceSource);[m
[32m+[m[32m    getRow(y: number, row?: Uint8ClampedArray): Uint8ClampedArray;[m
[32m+[m[32m    getMatrix(): Uint8ClampedArray;[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): LuminanceSource;[m
[32m+[m[32m    isRotateSupported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return original delegate {@link LuminanceSource} since invert undoes itself[m
[32m+[m[32m     */[m
[32m+[m[32m    invert(): LuminanceSource;[m
[32m+[m[32m    rotateCounterClockwise(): LuminanceSource;[m
[32m+[m[32m    rotateCounterClockwise45(): LuminanceSource;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js b/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a7f2514[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/InvertedLuminanceSource.js[m
[36m@@ -0,0 +1,94 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar LuminanceSource_1 = require("./LuminanceSource");[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes[m
[32m+[m[32m * white and vice versa, and each value becomes (255-value).[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar InvertedLuminanceSource = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(InvertedLuminanceSource, _super);[m
[32m+[m[32m    function InvertedLuminanceSource(delegate) {[m
[32m+[m[32m        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;[m
[32m+[m[32m        _this.delegate = delegate;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.getRow = function (y /*int*/, row) {[m
[32m+[m[32m        var sourceRow = this.delegate.getRow(y, row);[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        for (var i = 0; i < width; i++) {[m
[32m+[m[32m            sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));[m
[32m+[m[32m        }[m
[32m+[m[32m        return sourceRow;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.getMatrix = function () {[m
[32m+[m[32m        var matrix = this.delegate.getMatrix();[m
[32m+[m[32m        var length = this.getWidth() * this.getHeight();[m
[32m+[m[32m        var invertedMatrix = new Uint8ClampedArray(length);[m
[32m+[m[32m        for (var i = 0; i < length; i++) {[m
[32m+[m[32m            invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));[m
[32m+[m[32m        }[m
[32m+[m[32m        return invertedMatrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.isCropSupported = function () {[m
[32m+[m[32m        return this.delegate.isCropSupported();[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.isRotateSupported = function () {[m
[32m+[m[32m        return this.delegate.isRotateSupported();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return original delegate {@link LuminanceSource} since invert undoes itself[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.invert = function () {[m
[32m+[m[32m        return this.delegate;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.rotateCounterClockwise = function () {[m
[32m+[m[32m        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    InvertedLuminanceSource.prototype.rotateCounterClockwise45 = function () {[m
[32m+[m[32m        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());[m
[32m+[m[32m    };[m
[32m+[m[32m    return InvertedLuminanceSource;[m
[32m+[m[32m}(LuminanceSource_1.default));[m
[32m+[m[32mexports.default = InvertedLuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.d.ts b/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c00b23c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.d.ts[m
[36m@@ -0,0 +1,84 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * The purpose of this class hierarchy is to abstract different bitmap implementations across[m
[32m+[m[32m * platforms into a standard interface for requesting greyscale luminance values. The interface[m
[32m+[m[32m * only provides immutable methods; therefore crop and rotation create copies. This is to ensure[m
[32m+[m[32m * that one Reader does not modify the original luminance source and leave it in an unknown state[m
[32m+[m[32m * for other Readers in the chain.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mdeclare abstract class LuminanceSource {[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    protected constructor(width: number, height: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Fetches one row of luminance data from the underlying platform's bitmap. Values range from[m
[32m+[m[32m     * 0 (black) to 255 (white). Because Java does not have an unsigned byte type, callers will have[m
[32m+[m[32m     * to bitwise and with 0xff for each value. It is preferable for implementations of this method[m
[32m+[m[32m     * to only fetch this row rather than the whole image, since no 2D Readers may be installed and[m
[32m+[m[32m     * getMatrix() may never be called.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to fetch, which must be in [0,getHeight())[m
[32m+[m[32m     * @param row An optional preallocated array. If null or too small, it will be ignored.[m
[32m+[m[32m     *            Always use the returned object, and ignore the .length of the array.[m
[32m+[m[32m     * @return An array containing the luminance data.[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract getRow(y: number, row?: Uint8ClampedArray): Uint8ClampedArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Fetches luminance data for the underlying bitmap. Values should be fetched using:[m
[32m+[m[32m     * {@code int luminance = array[y * width + x] & 0xff}[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A row-major 2D array of luminance values. Do not use result.length as it may be[m
[32m+[m[32m     *         larger than width * height bytes on some platforms. Do not modify the contents[m
[32m+[m[32m     *         of the result.[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract getMatrix(): Uint8ClampedArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this subclass supports cropping.[m
[32m+[m[32m     */[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with cropped image data. Implementations may keep a reference to the[m
[32m+[m[32m     * original data rather than a copy. Only callable if isCropSupported() is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The left coordinate, which must be in [0,getWidth())[m
[32m+[m[32m     * @param top The top coordinate, which must be in [0,getHeight())[m
[32m+[m[32m     * @param width The width of the rectangle to crop.[m
[32m+[m[32m     * @param height The height of the rectangle to crop.[m
[32m+[m[32m     * @return A cropped version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): LuminanceSource;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this subclass supports counter-clockwise rotation.[m
[32m+[m[32m     */[m
[32m+[m[32m    isRotateSupported(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return a wrapper of this {@code LuminanceSource} which inverts the luminances it returns -- black becomes[m
[32m+[m[32m     *  white and vice versa, and each value becomes (255-value).[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract invert(): LuminanceSource;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 90 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    rotateCounterClockwise(): LuminanceSource;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 45 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    rotateCounterClockwise45(): LuminanceSource;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[32m+[m[32mexport default LuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.js b/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bbfea24[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/LuminanceSource.js[m
[36m@@ -0,0 +1,119 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar StringBuilder_1 = require("./util/StringBuilder");[m
[32m+[m[32mvar UnsupportedOperationException_1 = require("./UnsupportedOperationException");[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * The purpose of this class hierarchy is to abstract different bitmap implementations across[m
[32m+[m[32m * platforms into a standard interface for requesting greyscale luminance values. The interface[m
[32m+[m[32m * only provides immutable methods; therefore crop and rotation create copies. This is to ensure[m
[32m+[m[32m * that one Reader does not modify the original luminance source and leave it in an unknown state[m
[32m+[m[32m * for other Readers in the chain.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar LuminanceSource = /** @class */ (function () {[m
[32m+[m[32m    function LuminanceSource(width /*int*/, height /*int*/) {[m
[32m+[m[32m        this.width = width;[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.getWidth = function () {[m
[32m+[m[32m        return this.width;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the bitmap.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.getHeight = function () {[m
[32m+[m[32m        return this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this subclass supports cropping.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.isCropSupported = function () {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with cropped image data. Implementations may keep a reference to the[m
[32m+[m[32m     * original data rather than a copy. Only callable if isCropSupported() is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The left coordinate, which must be in [0,getWidth())[m
[32m+[m[32m     * @param top The top coordinate, which must be in [0,getHeight())[m
[32m+[m[32m     * @param width The width of the rectangle to crop.[m
[32m+[m[32m     * @param height The height of the rectangle to crop.[m
[32m+[m[32m     * @return A cropped version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        throw new UnsupportedOperationException_1.default('This luminance source does not support cropping.');[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return Whether this subclass supports counter-clockwise rotation.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.isRotateSupported = function () {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 90 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.rotateCounterClockwise = function () {[m
[32m+[m[32m        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 90 degrees.');[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a new object with rotated image data by 45 degrees counterclockwise.[m
[32m+[m[32m     * Only callable if {@link #isRotateSupported()} is true.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return A rotated version of this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    LuminanceSource.prototype.rotateCounterClockwise45 = function () {[m
[32m+[m[32m        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 45 degrees.');[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    LuminanceSource.prototype.toString = function () {[m
[32m+[m[32m        var row = new Uint8ClampedArray(this.width);[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        for (var y = 0; y < this.height; y++) {[m
[32m+[m[32m            var sourceRow = this.getRow(y, row);[m
[32m+[m[32m            for (var x = 0; x < this.width; x++) {[m
[32m+[m[32m                var luminance = sourceRow[x] & 0xFF;[m
[32m+[m[32m                var c = void 0;[m
[32m+[m[32m                if (luminance < 0x40) {[m
[32m+[m[32m                    c = '#';[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (luminance < 0x80) {[m
[32m+[m[32m                    c = '+';[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (luminance < 0xC0) {[m
[32m+[m[32m                    c = '.';[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    c = ' ';[m
[32m+[m[32m                }[m
[32m+[m[32m                result.append(c);[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append('\n');[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    return LuminanceSource;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = LuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9a933ba[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.d.ts[m
[36m@@ -0,0 +1,59 @@[m
[32m+[m[32mimport DecodeHintType from './DecodeHintType';[m
[32m+[m[32mimport Reader from './Reader';[m
[32m+[m[32mimport Result from './Result';[m
[32m+[m[32mimport BinaryBitmap from './BinaryBitmap';[m
[32m+[m[32m/**[m
[32m+[m[32m * MultiFormatReader is a convenience class and the main entry point into the library for most uses.[m
[32m+[m[32m * By default it attempts to decode all barcode formats that the library supports. Optionally, you[m
[32m+[m[32m * can provide a hints object to request different behavior, for example only decoding QR codes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MultiFormatReader implements Reader {[m
[32m+[m[32m    private hints;[m
[32m+[m[32m    private readers;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it[m
[32m+[m[32m     * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.[m
[32m+[m[32m     * Use setHints() followed by decodeWithState() for continuous scan applications.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decode an image using the hints provided. Does not honor existing state.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @param hints The hints to use, clearing the previous state.[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decode an image using the state set up by calling setHints() previously. Continuous scan[m
[32m+[m[32m     * clients will get a <b>large</b> speed increase by using this instead of decode().[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeWithState(image: BinaryBitmap): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls[m
[32m+[m[32m     * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This[m
[32m+[m[32m     * is important for performance in continuous scan clients.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param hints The set of hints to use for subsequent calls to decode(image)[m
[32m+[m[32m     */[m
[32m+[m[32m    setHints(hints?: Map<DecodeHintType, any> | null): void;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private decodeInternal;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.js b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0c09006[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatReader.js[m
[36m@@ -0,0 +1,215 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecodeHintType_1 = require("./DecodeHintType");[m
[32m+[m[32mvar BarcodeFormat_1 = require("./BarcodeFormat");[m
[32m+[m[32mvar QRCodeReader_1 = require("./qrcode/QRCodeReader");[m
[32m+[m[32mvar AztecReader_1 = require("./aztec/AztecReader");[m
[32m+[m[32mvar MultiFormatOneDReader_1 = require("./oned/MultiFormatOneDReader");[m
[32m+[m[32mvar DataMatrixReader_1 = require("./datamatrix/DataMatrixReader");[m
[32m+[m[32mvar NotFoundException_1 = require("./NotFoundException");[m
[32m+[m[32mvar PDF417Reader_1 = require("./pdf417/PDF417Reader");[m
[32m+[m[32mvar ReaderException_1 = require("./ReaderException");[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * MultiFormatReader is a convenience class and the main entry point into the library for most uses.[m
[32m+[m[32m * By default it attempts to decode all barcode formats that the library supports. Optionally, you[m
[32m+[m[32m * can provide a hints object to request different behavior, for example only decoding QR codes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar MultiFormatReader = /** @class */ (function () {[m
[32m+[m[32m    function MultiFormatReader() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it[m
[32m+[m[32m     * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.[m
[32m+[m[32m     * Use setHints() followed by decodeWithState() for continuous scan applications.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    // public decode(image: BinaryBitmap): Result {[m
[32m+[m[32m    //   setHints(null)[m
[32m+[m[32m    //   return decodeInternal(image)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decode an image using the hints provided. Does not honor existing state.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @param hints The hints to use, clearing the previous state.[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    MultiFormatReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        this.setHints(hints);[m
[32m+[m[32m        return this.decodeInternal(image);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decode an image using the state set up by calling setHints() previously. Continuous scan[m
[32m+[m[32m     * clients will get a <b>large</b> speed increase by using this instead of decode().[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The pixel data to decode[m
[32m+[m[32m     * @return The contents of the image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException Any errors which occurred[m
[32m+[m[32m     */[m
[32m+[m[32m    MultiFormatReader.prototype.decodeWithState = function (image) {[m
[32m+[m[32m        // Make sure to set up the default state so we don't crash[m
[32m+[m[32m        if (this.readers === null || this.readers === undefined) {[m
[32m+[m[32m            this.setHints(null);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.decodeInternal(image);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls[m
[32m+[m[32m     * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This[m
[32m+[m[32m     * is important for performance in continuous scan clients.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param hints The set of hints to use for subsequent calls to decode(image)[m
[32m+[m[32m     */[m
[32m+[m[32m    MultiFormatReader.prototype.setHints = function (hints) {[m
[32m+[m[32m        this.hints = hints;[m
[32m+[m[32m        var tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);[m
[32m+[m[32m        /*@SuppressWarnings("unchecked")*/[m
[32m+[m[32m        var formats = hints === null || hints === undefined ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);[m
[32m+[m[32m        var readers = new Array();[m
[32m+[m[32m        if (formats !== null && formats !== undefined) {[m
[32m+[m[32m            var addOneDReader = formats.some(function (f) {[m
[32m+[m[32m                return f === BarcodeFormat_1.default.UPC_A ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.UPC_E ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.EAN_13 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.EAN_8 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.CODABAR ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.CODE_39 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.CODE_93 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.CODE_128 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.ITF ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.RSS_14 ||[m
[32m+[m[32m                    f === BarcodeFormat_1.default.RSS_EXPANDED;[m
[32m+[m[32m            });[m
[32m+[m[32m            // Put 1D readers upfront in "normal" mode[m
[32m+[m[32m            // TYPESCRIPTPORT: TODO: uncomment below as they are ported[m
[32m+[m[32m            if (addOneDReader && !tryHarder) {[m
[32m+[m[32m                readers.push(new MultiFormatOneDReader_1.default(hints));[m
[32m+[m[32m            }[m
[32m+[m[32m            if (formats.includes(BarcodeFormat_1.default.QR_CODE)) {[m
[32m+[m[32m                readers.push(new QRCodeReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (formats.includes(BarcodeFormat_1.default.DATA_MATRIX)) {[m
[32m+[m[32m                readers.push(new DataMatrixReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (formats.includes(BarcodeFormat_1.default.AZTEC)) {[m
[32m+[m[32m                readers.push(new AztecReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (formats.includes(BarcodeFormat_1.default.PDF_417)) {[m
[32m+[m[32m                readers.push(new PDF417Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            // if (formats.includes(BarcodeFormat.MAXICODE)) {[m
[32m+[m[32m            //    readers.push(new MaxiCodeReader())[m
[32m+[m[32m            // }[m
[32m+[m[32m            // At end in "try harder" mode[m
[32m+[m[32m            if (addOneDReader && tryHarder) {[m
[32m+[m[32m                readers.push(new MultiFormatOneDReader_1.default(hints));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (readers.length === 0) {[m
[32m+[m[32m            if (!tryHarder) {[m
[32m+[m[32m                readers.push(new MultiFormatOneDReader_1.default(hints));[m
[32m+[m[32m            }[m
[32m+[m[32m            readers.push(new QRCodeReader_1.default());[m
[32m+[m[32m            readers.push(new DataMatrixReader_1.default());[m
[32m+[m[32m            readers.push(new AztecReader_1.default());[m
[32m+[m[32m            readers.push(new PDF417Reader_1.default());[m
[32m+[m[32m            // readers.push(new MaxiCodeReader())[m
[32m+[m[32m            if (tryHarder) {[m
[32m+[m[32m                readers.push(new MultiFormatOneDReader_1.default(hints));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.readers = readers; // .toArray(new Reader[readers.size()])[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    MultiFormatReader.prototype.reset = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (this.readers !== null) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                    var reader = _c.value;[m
[32m+[m[32m                    reader.reset();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    MultiFormatReader.prototype.decodeInternal = function (image) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        if (this.readers === null) {[m
[32m+[m[32m            throw new ReaderException_1.default('No readers where selected, nothing can be read.');[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var reader = _c.value;[m
[32m+[m[32m                // Trying to decode with ${reader} reader.[m
[32m+[m[32m                try {[m
[32m+[m[32m                    return reader.decode(image, this.hints);[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (ex) {[m
[32m+[m[32m                    if (ex instanceof ReaderException_1.default) {[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // Bad Exception.[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default('No MultiFormat Readers were able to detect the code.');[m
[32m+[m[32m    };[m
[32m+[m[32m    return MultiFormatReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = MultiFormatReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..bb3c008[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport BitMatrix from './common/BitMatrix';[m
[32m+[m[32mimport Writer from './Writer';[m
[32m+[m[32mimport BarcodeFormat from './BarcodeFormat';[m
[32m+[m[32mimport EncodeHintType from './EncodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat[m
[32m+[m[32m * requested and encodes the barcode with the supplied contents.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MultiFormatWriter implements Writer {[m
[32m+[m[32m    encode(contents: string, format: BarcodeFormat, width: number, height: number, hints: Map<EncodeHintType, any>): BitMatrix;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8ff9417[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/MultiFormatWriter.js[m
[36m@@ -0,0 +1,99 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import DataMatrixWriter from './datamatrix/DataMatrixWriter'[m
[32m+[m[32m// import CodaBarWriter from './oned/CodaBarWriter'[m
[32m+[m[32m// import Code128Writer from './oned/Code128Writer'[m
[32m+[m[32m// import Code39Writer from './oned/Code39Writer'[m
[32m+[m[32m// import Code93Writer from './oned/Code93Writer'[m
[32m+[m[32m// import EAN13Writer from './oned/EAN13Writer'[m
[32m+[m[32m// import EAN8Writer from './oned/EAN8Writer'[m
[32m+[m[32m// import ITFWriter from './oned/ITFWriter'[m
[32m+[m[32m// import UPCAWriter from './oned/UPCAWriter'[m
[32m+[m[32m// import UPCEWriter from './oned/UPCEWriter'[m
[32m+[m[32m// import PDF417Writer from './pdf417/PDF417Writer'[m
[32m+[m[32mvar QRCodeWriter_1 = require("./qrcode/QRCodeWriter");[m
[32m+[m[32mvar BarcodeFormat_1 = require("./BarcodeFormat");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("./IllegalArgumentException");[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat[m
[32m+[m[32m * requested and encodes the barcode with the supplied contents.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar MultiFormatWriter = /** @class */ (function () {[m
[32m+[m[32m    function MultiFormatWriter() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    // public encode(contents: string,[m
[32m+[m[32m    //                         format: BarcodeFormat,[m
[32m+[m[32m    //                         width: number /*int*/,[m
[32m+[m[32m    //                         height: number /*int*/): BitMatrix /*throws WriterException */ {[m
[32m+[m[32m    //   return encode(contents, format, width, height, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    MultiFormatWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {[m
[32m+[m[32m        var writer;[m
[32m+[m[32m        switch (format) {[m
[32m+[m[32m            // case BarcodeFormat.EAN_8:[m
[32m+[m[32m            //   writer = new EAN8Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.UPC_E:[m
[32m+[m[32m            //   writer = new UPCEWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.EAN_13:[m
[32m+[m[32m            //   writer = new EAN13Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.UPC_A:[m
[32m+[m[32m            //   writer = new UPCAWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            case BarcodeFormat_1.default.QR_CODE:[m
[32m+[m[32m                writer = new QRCodeWriter_1.default();[m
[32m+[m[32m                break;[m
[32m+[m[32m            // case BarcodeFormat.CODE_39:[m
[32m+[m[32m            //   writer = new Code39Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.CODE_93:[m
[32m+[m[32m            //   writer = new Code93Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.CODE_128:[m
[32m+[m[32m            //   writer = new Code128Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.ITF:[m
[32m+[m[32m            //   writer = new ITFWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.PDF_417:[m
[32m+[m[32m            //   writer = new PDF417Writer()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.CODABAR:[m
[32m+[m[32m            //   writer = new CodaBarWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.DATA_MATRIX:[m
[32m+[m[32m            //   writer = new DataMatrixWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            // case BarcodeFormat.AZTEC:[m
[32m+[m[32m            //   writer = new AztecWriter()[m
[32m+[m[32m            //   break[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('No encoder available for format ' + format);[m
[32m+[m[32m        }[m
[32m+[m[32m        return writer.encode(contents, format, width, height, hints);[m
[32m+[m[32m    };[m
[32m+[m[32m    return MultiFormatWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = MultiFormatWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..056e0b7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class NotFoundException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m    static getNotFoundInstance(): NotFoundException;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.js b/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7c959bd[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/NotFoundException.js[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar NotFoundException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(NotFoundException, _super);[m
[32m+[m[32m    function NotFoundException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    NotFoundException.getNotFoundInstance = function () {[m
[32m+[m[32m        return new NotFoundException();[m
[32m+[m[32m    };[m
[32m+[m[32m    NotFoundException.kind = 'NotFoundException';[m
[32m+[m[32m    return NotFoundException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = NotFoundException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..1137d28[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class NullPointerException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.js b/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8c46b70[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/NullPointerException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar NullPointerException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(NullPointerException, _super);[m
[32m+[m[32m    function NullPointerException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    NullPointerException.kind = 'NullPointerException';[m
[32m+[m[32m    return NullPointerException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = NullPointerException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.d.ts b/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..673705c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.d.ts[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class OutOfMemoryError extends Exception {[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js b/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js[m
[1mnew file mode 100644[m
[1mindex 0000000..881e873[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/OutOfMemoryError.js[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar OutOfMemoryError = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(OutOfMemoryError, _super);[m
[32m+[m[32m    function OutOfMemoryError() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    return OutOfMemoryError;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = OutOfMemoryError;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.d.ts b/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ceb4ea4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.d.ts[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32mimport LuminanceSource from './LuminanceSource';[m
[32m+[m[32m/**[m
[32m+[m[32m * This object extends LuminanceSource around an array of YUV data returned from the camera driver,[m
[32m+[m[32m * with the option to crop to a rectangle within the full data. This can be used to exclude[m
[32m+[m[32m * superfluous pixels around the perimeter and speed up decoding.[m
[32m+[m[32m *[m
[32m+[m[32m * It works for any pixel format where the Y channel is planar and appears first, including[m
[32m+[m[32m * YCbCr_420_SP and YCbCr_422_SP.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PlanarYUVLuminanceSource extends LuminanceSource {[m
[32m+[m[32m    private yuvData;[m
[32m+[m[32m    private dataWidth;[m
[32m+[m[32m    private dataHeight;[m
[32m+[m[32m    private left;[m
[32m+[m[32m    private top;[m
[32m+[m[32m    private static THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m    constructor(yuvData: Uint8ClampedArray, dataWidth: number, dataHeight: number, left: number, top: number, width: number, height: number, reverseHorizontal: boolean);[m
[32m+[m[32m    getRow(y: number, row?: Uint8ClampedArray): Uint8ClampedArray;[m
[32m+[m[32m    getMatrix(): Uint8ClampedArray;[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): LuminanceSource;[m
[32m+[m[32m    renderThumbnail(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return width of image from {@link #renderThumbnail()}[m
[32m+[m[32m     */[m
[32m+[m[32m    getThumbnailWidth(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return height of image from {@link #renderThumbnail()}[m
[32m+[m[32m     */[m
[32m+[m[32m    getThumbnailHeight(): number;[m
[32m+[m[32m    private reverseHorizontal;[m
[32m+[m[32m    invert(): LuminanceSource;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js b/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8950fa9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/PlanarYUVLuminanceSource.js[m
[36m@@ -0,0 +1,154 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32mvar System_1 = require("./util/System");[m
[32m+[m[32mvar LuminanceSource_1 = require("./LuminanceSource");[m
[32m+[m[32mvar InvertedLuminanceSource_1 = require("./InvertedLuminanceSource");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("./IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * This object extends LuminanceSource around an array of YUV data returned from the camera driver,[m
[32m+[m[32m * with the option to crop to a rectangle within the full data. This can be used to exclude[m
[32m+[m[32m * superfluous pixels around the perimeter and speed up decoding.[m
[32m+[m[32m *[m
[32m+[m[32m * It works for any pixel format where the Y channel is planar and appears first, including[m
[32m+[m[32m * YCbCr_420_SP and YCbCr_422_SP.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar PlanarYUVLuminanceSource = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(PlanarYUVLuminanceSource, _super);[m
[32m+[m[32m    function PlanarYUVLuminanceSource(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {[m
[32m+[m[32m        var _this = _super.call(this, width, height) || this;[m
[32m+[m[32m        _this.yuvData = yuvData;[m
[32m+[m[32m        _this.dataWidth = dataWidth;[m
[32m+[m[32m        _this.dataHeight = dataHeight;[m
[32m+[m[32m        _this.left = left;[m
[32m+[m[32m        _this.top = top;[m
[32m+[m[32m        if (left + width > dataWidth || top + height > dataHeight) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (reverseHorizontal) {[m
[32m+[m[32m            _this.reverseHorizontal(width, height);[m
[32m+[m[32m        }[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.getRow = function (y /*int*/, row) {[m
[32m+[m[32m        if (y < 0 || y >= this.getHeight()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);[m
[32m+[m[32m        }[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        if (row === null || row === undefined || row.length < width) {[m
[32m+[m[32m            row = new Uint8ClampedArray(width);[m
[32m+[m[32m        }[m
[32m+[m[32m        var offset = (y + this.top) * this.dataWidth + this.left;[m
[32m+[m[32m        System_1.default.arraycopy(this.yuvData, offset, row, 0, width);[m
[32m+[m[32m        return row;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.getMatrix = function () {[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        var height = this.getHeight();[m
[32m+[m[32m        // If the caller asks for the entire underlying image, save the copy and give them the[m
[32m+[m[32m        // original data. The docs specifically warn that result.length must be ignored.[m
[32m+[m[32m        if (width === this.dataWidth && height === this.dataHeight) {[m
[32m+[m[32m            return this.yuvData;[m
[32m+[m[32m        }[m
[32m+[m[32m        var area = width * height;[m
[32m+[m[32m        var matrix = new Uint8ClampedArray(area);[m
[32m+[m[32m        var inputOffset = this.top * this.dataWidth + this.left;[m
[32m+[m[32m        // If the width matches the full width of the underlying data, perform a single copy.[m
[32m+[m[32m        if (width === this.dataWidth) {[m
[32m+[m[32m            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, 0, area);[m
[32m+[m[32m            return matrix;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Otherwise copy one cropped row at a time.[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            var outputOffset = y * width;[m
[32m+[m[32m            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);[m
[32m+[m[32m            inputOffset += this.dataWidth;[m
[32m+[m[32m        }[m
[32m+[m[32m        return matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.isCropSupported = function () {[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);[m
[32m+[m[32m    };[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.renderThumbnail = function () {[m
[32m+[m[32m        var width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m        var height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m        var pixels = new Int32Array(width * height);[m
[32m+[m[32m        var yuv = this.yuvData;[m
[32m+[m[32m        var inputOffset = this.top * this.dataWidth + this.left;[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            var outputOffset = y * width;[m
[32m+[m[32m            for (var x = 0; x < width; x++) {[m
[32m+[m[32m                var grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;[m
[32m+[m[32m                pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);[m
[32m+[m[32m            }[m
[32m+[m[32m            inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m        }[m
[32m+[m[32m        return pixels;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return width of image from {@link #renderThumbnail()}[m
[32m+[m[32m     */[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.getThumbnailWidth = function () {[m
[32m+[m[32m        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return height of image from {@link #renderThumbnail()}[m
[32m+[m[32m     */[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.getThumbnailHeight = function () {[m
[32m+[m[32m        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;[m
[32m+[m[32m    };[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.reverseHorizontal = function (width /*int*/, height /*int*/) {[m
[32m+[m[32m        var yuvData = this.yuvData;[m
[32m+[m[32m        for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {[m
[32m+[m[32m            var middle = rowStart + width / 2;[m
[32m+[m[32m            for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {[m
[32m+[m[32m                var temp = yuvData[x1];[m
[32m+[m[32m                yuvData[x1] = yuvData[x2];[m
[32m+[m[32m                yuvData[x2] = temp;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    PlanarYUVLuminanceSource.prototype.invert = function () {[m
[32m+[m[32m        return new InvertedLuminanceSource_1.default(this);[m
[32m+[m[32m    };[m
[32m+[m[32m    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;[m
[32m+[m[32m    return PlanarYUVLuminanceSource;[m
[32m+[m[32m}(LuminanceSource_1.default));[m
[32m+[m[32mexports.default = PlanarYUVLuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.d.ts b/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c4c3efa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.d.ts[m
[36m@@ -0,0 +1,22 @@[m
[32m+[m[32mimport './InvertedLuminanceSource';[m
[32m+[m[32mimport LuminanceSource from './LuminanceSource';[m
[32m+[m[32m/**[m
[32m+[m[32m * This class is used to help decode images from files which arrive as RGB data from[m
[32m+[m[32m * an ARGB pixel array. It does not support rotation.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Betaminos[m
[32m+[m[32m */[m
[32m+[m[32mexport default class RGBLuminanceSource extends LuminanceSource {[m
[32m+[m[32m    private dataWidth?;[m
[32m+[m[32m    private dataHeight?;[m
[32m+[m[32m    private left?;[m
[32m+[m[32m    private top?;[m
[32m+[m[32m    private luminances;[m
[32m+[m[32m    constructor(luminances: Uint8ClampedArray | Int32Array, width: number, height: number, dataWidth?: number, dataHeight?: number, left?: number, top?: number);[m
[32m+[m[32m    getRow(y: number, row?: Uint8ClampedArray): Uint8ClampedArray;[m
[32m+[m[32m    getMatrix(): Uint8ClampedArray;[m
[32m+[m[32m    isCropSupported(): boolean;[m
[32m+[m[32m    crop(left: number, top: number, width: number, height: number): LuminanceSource;[m
[32m+[m[32m    invert(): LuminanceSource;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js b/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..cdac031[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/RGBLuminanceSource.js[m
[36m@@ -0,0 +1,136 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32mrequire("./InvertedLuminanceSource"); // required because of circular dependencies between LuminanceSource and InvertedLuminanceSource[m
[32m+[m[32mvar InvertedLuminanceSource_1 = require("./InvertedLuminanceSource");[m
[32m+[m[32mvar LuminanceSource_1 = require("./LuminanceSource");[m
[32m+[m[32mvar System_1 = require("./util/System");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("./IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * This class is used to help decode images from files which arrive as RGB data from[m
[32m+[m[32m * an ARGB pixel array. It does not support rotation.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Betaminos[m
[32m+[m[32m */[m
[32m+[m[32mvar RGBLuminanceSource = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(RGBLuminanceSource, _super);[m
[32m+[m[32m    function RGBLuminanceSource(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {[m
[32m+[m[32m        var _this = _super.call(this, width, height) || this;[m
[32m+[m[32m        _this.dataWidth = dataWidth;[m
[32m+[m[32m        _this.dataHeight = dataHeight;[m
[32m+[m[32m        _this.left = left;[m
[32m+[m[32m        _this.top = top;[m
[32m+[m[32m        if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array[m
[32m+[m[32m            var size = width * height;[m
[32m+[m[32m            var luminancesUint8Array = new Uint8ClampedArray(size);[m
[32m+[m[32m            for (var offset = 0; offset < size; offset++) {[m
[32m+[m[32m                var pixel = luminances[offset];[m
[32m+[m[32m                var r = (pixel >> 16) & 0xff; // red[m
[32m+[m[32m                var g2 = (pixel >> 7) & 0x1fe; // 2 * green[m
[32m+[m[32m                var b = pixel & 0xff; // blue[m
[32m+[m[32m                // Calculate green-favouring average cheaply[m
[32m+[m[32m                luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;[m
[32m+[m[32m            }[m
[32m+[m[32m            _this.luminances = luminancesUint8Array;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            _this.luminances = luminances;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === dataWidth) {[m
[32m+[m[32m            _this.dataWidth = width;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === dataHeight) {[m
[32m+[m[32m            _this.dataHeight = height;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === left) {[m
[32m+[m[32m            _this.left = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === top) {[m
[32m+[m[32m            _this.top = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');[m
[32m+[m[32m        }[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    RGBLuminanceSource.prototype.getRow = function (y /*int*/, row) {[m
[32m+[m[32m        if (y < 0 || y >= this.getHeight()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);[m
[32m+[m[32m        }[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        if (row === null || row === undefined || row.length < width) {[m
[32m+[m[32m            row = new Uint8ClampedArray(width);[m
[32m+[m[32m        }[m
[32m+[m[32m        var offset = (y + this.top) * this.dataWidth + this.left;[m
[32m+[m[32m        System_1.default.arraycopy(this.luminances, offset, row, 0, width);[m
[32m+[m[32m        return row;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    RGBLuminanceSource.prototype.getMatrix = function () {[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        var height = this.getHeight();[m
[32m+[m[32m        // If the caller asks for the entire underlying image, save the copy and give them the[m
[32m+[m[32m        // original data. The docs specifically warn that result.length must be ignored.[m
[32m+[m[32m        if (width === this.dataWidth && height === this.dataHeight) {[m
[32m+[m[32m            return this.luminances;[m
[32m+[m[32m        }[m
[32m+[m[32m        var area = width * height;[m
[32m+[m[32m        var matrix = new Uint8ClampedArray(area);[m
[32m+[m[32m        var inputOffset = this.top * this.dataWidth + this.left;[m
[32m+[m[32m        // If the width matches the full width of the underlying data, perform a single copy.[m
[32m+[m[32m        if (width === this.dataWidth) {[m
[32m+[m[32m            System_1.default.arraycopy(this.luminances, inputOffset, matrix, 0, area);[m
[32m+[m[32m            return matrix;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Otherwise copy one cropped row at a time.[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            var outputOffset = y * width;[m
[32m+[m[32m            System_1.default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);[m
[32m+[m[32m            inputOffset += this.dataWidth;[m
[32m+[m[32m        }[m
[32m+[m[32m        return matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    RGBLuminanceSource.prototype.isCropSupported = function () {[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    RGBLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);[m
[32m+[m[32m    };[m
[32m+[m[32m    RGBLuminanceSource.prototype.invert = function () {[m
[32m+[m[32m        return new InvertedLuminanceSource_1.default(this);[m
[32m+[m[32m    };[m
[32m+[m[32m    return RGBLuminanceSource;[m
[32m+[m[32m}(LuminanceSource_1.default));[m
[32m+[m[32mexports.default = RGBLuminanceSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d3acb54[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Reader.d.ts[m
[36m@@ -0,0 +1,49 @@[m
[32m+[m[32mimport BinaryBitmap from './BinaryBitmap';[m
[32m+[m[32mimport Result from './Result';[m
[32m+[m[32mimport DecodeHintType from './DecodeHintType';[m
[32m+[m[32mexport default Reader;[m
[32m+[m[32m/**[m
[32m+[m[32m * Implementations of this interface can decode an image of a barcode in some format into[m
[32m+[m[32m * the it: string encodes. For example, {@link com.google.zxing.qrcode.QRCodeReader} can[m
[32m+[m[32m * decode a QR code. The decoder may optionally receive hints from the caller which may help[m
[32m+[m[32m * it decode more quickly or accurately.[m
[32m+[m[32m *[m
[32m+[m[32m * See {@link MultiFormatReader}, which attempts to determine what barcode[m
[32m+[m[32m * format is present within the image as well, and then decodes it accordingly.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32minterface Reader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a barcode in some format within an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image of barcode to decode[m
[32m+[m[32m     * @return which: string the barcode encodes[m
[32m+[m[32m     * @throws NotFoundException if no potential barcode is found[m
[32m+[m[32m     * @throws ChecksumException if a potential barcode is found but does not pass its checksum[m
[32m+[m[32m     * @throws FormatException if a potential barcode is found but format is invalid[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a barcode in some format within an image. This method also accepts[m
[32m+[m[32m     * hints, each possibly associated to some data, which may help the implementation decode.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image of barcode to decode[m
[32m+[m[32m     * @param hints passed as a {@link Map} from {@link DecodeHintType}[m
[32m+[m[32m     * to arbitrary data. The[m
[32m+[m[32m     * meaning of the data depends upon the hint type. The implementation may or may not do[m
[32m+[m[32m     * anything with these hints.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return which: string the barcode encodes[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException if no potential barcode is found[m
[32m+[m[32m     * @throws ChecksumException if a potential barcode is found but does not pass its checksum[m
[32m+[m[32m     * @throws FormatException if a potential barcode is found but format is invalid[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any> | null): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Resets any internal state the implementation has after a decode, to prepare it[m
[32m+[m[32m     * for reuse.[m
[32m+[m[32m     */[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Reader.js b/frontend/node_modules/@zxing/library/cjs/core/Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..3aa1fe2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Reader.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ReaderException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ReaderException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..95ff146[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ReaderException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ReaderException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ReaderException.js b/frontend/node_modules/@zxing/library/cjs/core/ReaderException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d35e4a9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ReaderException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ReaderException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ReaderException, _super);[m
[32m+[m[32m    function ReaderException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ReaderException.kind = 'ReaderException';[m
[32m+[m[32m    return ReaderException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = ReaderException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5488e63[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ReedSolomonException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.js b/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ade8295[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ReedSolomonException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar ReedSolomonException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ReedSolomonException, _super);[m
[32m+[m[32m    function ReedSolomonException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ReedSolomonException.kind = 'ReedSolomonException';[m
[32m+[m[32m    return ReedSolomonException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = ReedSolomonException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Result.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Result.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ccbbe93[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Result.d.ts[m
[36m@@ -0,0 +1,52 @@[m
[32m+[m[32mimport ResultPoint from './ResultPoint';[m
[32m+[m[32mimport BarcodeFormat from './BarcodeFormat';[m
[32m+[m[32mimport ResultMetadataType from './ResultMetadataType';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of decoding a barcode within an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Result {[m
[32m+[m[32m    private text;[m
[32m+[m[32m    private rawBytes;[m
[32m+[m[32m    private numBits;[m
[32m+[m[32m    private resultPoints;[m
[32m+[m[32m    private format;[m
[32m+[m[32m    private timestamp;[m
[32m+[m[32m    private resultMetadata;[m
[32m+[m[32m    constructor(text: string, rawBytes: Uint8Array, numBits: number, resultPoints: ResultPoint[], format: BarcodeFormat, timestamp?: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw text encoded by the barcode[m
[32m+[m[32m     */[m
[32m+[m[32m    getText(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}[m
[32m+[m[32m     */[m
[32m+[m[32m    getRawBytes(): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    getNumBits(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return points related to the barcode in the image. These are typically points[m
[32m+[m[32m     *         identifying finder patterns or the corners of the barcode. The exact meaning is[m
[32m+[m[32m     *         specific to the type of barcode that was decoded.[m
[32m+[m[32m     */[m
[32m+[m[32m    getResultPoints(): Array<ResultPoint>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    getBarcodeFormat(): BarcodeFormat;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be[m
[32m+[m[32m     *   {@code null}. This contains optional metadata about what was detected about the barcode,[m
[32m+[m[32m     *   like orientation.[m
[32m+[m[32m     */[m
[32m+[m[32m    getResultMetadata(): Map<ResultMetadataType, Object>;[m
[32m+[m[32m    putMetadata(type: ResultMetadataType, value: Object): void;[m
[32m+[m[32m    putAllMetadata(metadata: Map<ResultMetadataType, Object>): void;[m
[32m+[m[32m    addResultPoints(newPoints: Array<ResultPoint>): void;[m
[32m+[m[32m    getTimestamp(): number;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Result.js b/frontend/node_modules/@zxing/library/cjs/core/Result.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b3c9009[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Result.js[m
[36m@@ -0,0 +1,144 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar System_1 = require("./util/System");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of decoding a barcode within an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Result = /** @class */ (function () {[m
[32m+[m[32m    // public constructor(private text: string,[m
[32m+[m[32m    //               Uint8Array rawBytes,[m
[32m+[m[32m    //               ResultPoconst resultPoints: Int32Array,[m
[32m+[m[32m    //               BarcodeFormat format) {[m
[32m+[m[32m    //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())[m
[32m+[m[32m    // }[m
[32m+[m[32m    // public constructor(text: string,[m
[32m+[m[32m    //               Uint8Array rawBytes,[m
[32m+[m[32m    //               ResultPoconst resultPoints: Int32Array,[m
[32m+[m[32m    //               BarcodeFormat format,[m
[32m+[m[32m    //               long timestamp) {[m
[32m+[m[32m    //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,[m
[32m+[m[32m    //        resultPoints, format, timestamp)[m
[32m+[m[32m    // }[m
[32m+[m[32m    function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {[m
[32m+[m[32m        if (numBits === void 0) { numBits = rawBytes == null ? 0 : 8 * rawBytes.length; }[m
[32m+[m[32m        if (timestamp === void 0) { timestamp = System_1.default.currentTimeMillis(); }[m
[32m+[m[32m        this.text = text;[m
[32m+[m[32m        this.rawBytes = rawBytes;[m
[32m+[m[32m        this.numBits = numBits;[m
[32m+[m[32m        this.resultPoints = resultPoints;[m
[32m+[m[32m        this.format = format;[m
[32m+[m[32m        this.timestamp = timestamp;[m
[32m+[m[32m        this.text = text;[m
[32m+[m[32m        this.rawBytes = rawBytes;[m
[32m+[m[32m        if (undefined === numBits || null === numBits) {[m
[32m+[m[32m            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.numBits = numBits;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.resultPoints = resultPoints;[m
[32m+[m[32m        this.format = format;[m
[32m+[m[32m        this.resultMetadata = null;[m
[32m+[m[32m        if (undefined === timestamp || null === timestamp) {[m
[32m+[m[32m            this.timestamp = System_1.default.currentTimeMillis();[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.timestamp = timestamp;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw text encoded by the barcode[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getText = function () {[m
[32m+[m[32m        return this.text;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getRawBytes = function () {[m
[32m+[m[32m        return this.rawBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getNumBits = function () {[m
[32m+[m[32m        return this.numBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return points related to the barcode in the image. These are typically points[m
[32m+[m[32m     *         identifying finder patterns or the corners of the barcode. The exact meaning is[m
[32m+[m[32m     *         specific to the type of barcode that was decoded.[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getResultPoints = function () {[m
[32m+[m[32m        return this.resultPoints;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getBarcodeFormat = function () {[m
[32m+[m[32m        return this.format;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be[m
[32m+[m[32m     *   {@code null}. This contains optional metadata about what was detected about the barcode,[m
[32m+[m[32m     *   like orientation.[m
[32m+[m[32m     */[m
[32m+[m[32m    Result.prototype.getResultMetadata = function () {[m
[32m+[m[32m        return this.resultMetadata;[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.putMetadata = function (type, value) {[m
[32m+[m[32m        if (this.resultMetadata === null) {[m
[32m+[m[32m            this.resultMetadata = new Map();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.resultMetadata.set(type, value);[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.putAllMetadata = function (metadata) {[m
[32m+[m[32m        if (metadata !== null) {[m
[32m+[m[32m            if (this.resultMetadata === null) {[m
[32m+[m[32m                this.resultMetadata = metadata;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.resultMetadata = new Map(metadata);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.addResultPoints = function (newPoints) {[m
[32m+[m[32m        var oldPoints = this.resultPoints;[m
[32m+[m[32m        if (oldPoints === null) {[m
[32m+[m[32m            this.resultPoints = newPoints;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (newPoints !== null && newPoints.length > 0) {[m
[32m+[m[32m            var allPoints = new Array(oldPoints.length + newPoints.length);[m
[32m+[m[32m            System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);[m
[32m+[m[32m            System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);[m
[32m+[m[32m            this.resultPoints = allPoints;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.getTimestamp = function () {[m
[32m+[m[32m        return this.timestamp;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    Result.prototype.toString = function () {[m
[32m+[m[32m        return this.text;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Result;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Result;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e30a696[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.d.ts[m
[36m@@ -0,0 +1,68 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Represents some type of metadata about the result of the decoding that the decoder[m
[32m+[m[32m * wishes to communicate back to the caller.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mdeclare enum ResultMetadataType {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.[m
[32m+[m[32m     */[m
[32m+[m[32m    OTHER = 0,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Denotes the likely approximate orientation of the barcode in the image. This value[m
[32m+[m[32m     * is given as degrees rotated clockwise from the normal, upright orientation.[m
[32m+[m[32m     * For example a 1D barcode which was found by reading top-to-bottom would be[m
[32m+[m[32m     * said to have orientation "90". This key maps to an {@link Integer} whose[m
[32m+[m[32m     * value is in the range [0,360).[m
[32m+[m[32m     */[m
[32m+[m[32m    ORIENTATION = 1,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'[m
[32m+[m[32m     * which is sometimes used to encode binary data. While {@link Result} makes available[m
[32m+[m[32m     * the complete raw bytes in the barcode for these formats, it does not offer the bytes[m
[32m+[m[32m     * from the byte segments alone.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the[m
[32m+[m[32m     * raw bytes in the byte segments in the barcode, in order.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    BYTE_SEGMENTS = 2,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Error correction level used, if applicable. The value type depends on the[m
[32m+[m[32m     * format, but is typically a String.[m
[32m+[m[32m     */[m
[32m+[m[32m    ERROR_CORRECTION_LEVEL = 3,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some periodicals, indicates the issue number as an {@link Integer}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ISSUE_NUMBER = 4,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, indicates the suggested retail price in the barcode as a[m
[32m+[m[32m     * formatted {@link String}.[m
[32m+[m[32m     */[m
[32m+[m[32m    SUGGESTED_PRICE = 5,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, the possible country of manufacture as a {@link String} denoting the[m
[32m+[m[32m     * ISO country code. Some map to multiple possible countries, like "US/CA".[m
[32m+[m[32m     */[m
[32m+[m[32m    POSSIBLE_COUNTRY = 6,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, the extension text[m
[32m+[m[32m     */[m
[32m+[m[32m    UPC_EAN_EXTENSION = 7,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * PDF417-specific metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417_EXTRA_METADATA = 8,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If the code format supports structured append and the current scanned code is part of one then the[m
[32m+[m[32m     * sequence number is given with it.[m
[32m+[m[32m     */[m
[32m+[m[32m    STRUCTURED_APPEND_SEQUENCE = 9,[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If the code format supports structured append and the current scanned code is part of one then the[m
[32m+[m[32m     * parity is given with it.[m
[32m+[m[32m     */[m
[32m+[m[32m    STRUCTURED_APPEND_PARITY = 10[m
[32m+[m[32m}[m
[32m+[m[32mexport default ResultMetadataType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.js b/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.js[m
[1mnew file mode 100644[m
[1mindex 0000000..3cfb7e8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultMetadataType.js[m
[36m@@ -0,0 +1,87 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * Represents some type of metadata about the result of the decoding that the decoder[m
[32m+[m[32m * wishes to communicate back to the caller.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar ResultMetadataType;[m
[32m+[m[32m(function (ResultMetadataType) {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["OTHER"] = 0] = "OTHER";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Denotes the likely approximate orientation of the barcode in the image. This value[m
[32m+[m[32m     * is given as degrees rotated clockwise from the normal, upright orientation.[m
[32m+[m[32m     * For example a 1D barcode which was found by reading top-to-bottom would be[m
[32m+[m[32m     * said to have orientation "90". This key maps to an {@link Integer} whose[m
[32m+[m[32m     * value is in the range [0,360).[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["ORIENTATION"] = 1] = "ORIENTATION";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'[m
[32m+[m[32m     * which is sometimes used to encode binary data. While {@link Result} makes available[m
[32m+[m[32m     * the complete raw bytes in the barcode for these formats, it does not offer the bytes[m
[32m+[m[32m     * from the byte segments alone.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the[m
[32m+[m[32m     * raw bytes in the byte segments in the barcode, in order.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Error correction level used, if applicable. The value type depends on the[m
[32m+[m[32m     * format, but is typically a String.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some periodicals, indicates the issue number as an {@link Integer}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, indicates the suggested retail price in the barcode as a[m
[32m+[m[32m     * formatted {@link String}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, the possible country of manufacture as a {@link String} denoting the[m
[32m+[m[32m     * ISO country code. Some map to multiple possible countries, like "US/CA".[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For some products, the extension text[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * PDF417-specific metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If the code format supports structured append and the current scanned code is part of one then the[m
[32m+[m[32m     * sequence number is given with it.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * If the code format supports structured append and the current scanned code is part of one then the[m
[32m+[m[32m     * parity is given with it.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";[m
[32m+[m[32m})(ResultMetadataType || (ResultMetadataType = {}));[m
[32m+[m[32mexports.default = ResultMetadataType;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..37cc41b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.d.ts[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32mimport { float, int } from '../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this[m
[32m+[m[32m * would be the location of a finder pattern or the corner of the barcode, for example.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ResultPoint {[m
[32m+[m[32m    private x;[m
[32m+[m[32m    private y;[m
[32m+[m[32m    constructor(x: float, y: float);[m
[32m+[m[32m    getX(): float;[m
[32m+[m[32m    getY(): float;[m
[32m+[m[32m    equals(other: Object): boolean;[m
[32m+[m[32m    hashCode(): int;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC[m
[32m+[m[32m     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param patterns array of three {@code ResultPoint} to order[m
[32m+[m[32m     */[m
[32m+[m[32m    static orderBestPatterns(patterns: Array<ResultPoint>): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param pattern1 first pattern[m
[32m+[m[32m     * @param pattern2 second pattern[m
[32m+[m[32m     * @return distance between two points[m
[32m+[m[32m     */[m
[32m+[m[32m    static distance(pattern1: ResultPoint, pattern2: ResultPoint): float;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the z component of the cross product between vectors BC and BA.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static crossProductZ;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.js b/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5796663[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultPoint.js[m
[36m@@ -0,0 +1,115 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing {*/[m
[32m+[m[32mvar MathUtils_1 = require("./common/detector/MathUtils");[m
[32m+[m[32mvar Float_1 = require("./util/Float");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this[m
[32m+[m[32m * would be the location of a finder pattern or the corner of the barcode, for example.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar ResultPoint = /** @class */ (function () {[m
[32m+[m[32m    function ResultPoint(x, y) {[m
[32m+[m[32m        this.x = x;[m
[32m+[m[32m        this.y = y;[m
[32m+[m[32m    }[m
[32m+[m[32m    ResultPoint.prototype.getX = function () {[m
[32m+[m[32m        return this.x;[m
[32m+[m[32m    };[m
[32m+[m[32m    ResultPoint.prototype.getY = function () {[m
[32m+[m[32m        return this.y;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    ResultPoint.prototype.equals = function (other) {[m
[32m+[m[32m        if (other instanceof ResultPoint) {[m
[32m+[m[32m            var otherPoint = other;[m
[32m+[m[32m            return this.x === otherPoint.x && this.y === otherPoint.y;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    ResultPoint.prototype.hashCode = function () {[m
[32m+[m[32m        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    ResultPoint.prototype.toString = function () {[m
[32m+[m[32m        return '(' + this.x + ',' + this.y + ')';[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC[m
[32m+[m[32m     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param patterns array of three {@code ResultPoint} to order[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultPoint.orderBestPatterns = function (patterns) {[m
[32m+[m[32m        // Find distances between pattern centers[m
[32m+[m[32m        var zeroOneDistance = this.distance(patterns[0], patterns[1]);[m
[32m+[m[32m        var oneTwoDistance = this.distance(patterns[1], patterns[2]);[m
[32m+[m[32m        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);[m
[32m+[m[32m        var pointA;[m
[32m+[m[32m        var pointB;[m
[32m+[m[32m        var pointC;[m
[32m+[m[32m        // Assume one closest to other two is B; A and C will just be guesses at first[m
[32m+[m[32m        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {[m
[32m+[m[32m            pointB = patterns[0];[m
[32m+[m[32m            pointA = patterns[1];[m
[32m+[m[32m            pointC = patterns[2];[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {[m
[32m+[m[32m            pointB = patterns[1];[m
[32m+[m[32m            pointA = patterns[0];[m
[32m+[m[32m            pointC = patterns[2];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            pointB = patterns[2];[m
[32m+[m[32m            pointA = patterns[0];[m
[32m+[m[32m            pointC = patterns[1];[m
[32m+[m[32m        }[m
[32m+[m[32m        // Use cross product to figure out whether A and C are correct or flipped.[m
[32m+[m[32m        // This asks whether BC x BA has a positive z component, which is the arrangement[m
[32m+[m[32m        // we want for A, B, C. If it's negative, then we've got it flipped around and[m
[32m+[m[32m        // should swap A and C.[m
[32m+[m[32m        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {[m
[32m+[m[32m            var temp = pointA;[m
[32m+[m[32m            pointA = pointC;[m
[32m+[m[32m            pointC = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        patterns[0] = pointA;[m
[32m+[m[32m        patterns[1] = pointB;[m
[32m+[m[32m        patterns[2] = pointC;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param pattern1 first pattern[m
[32m+[m[32m     * @param pattern2 second pattern[m
[32m+[m[32m     * @return distance between two points[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultPoint.distance = function (pattern1, pattern2) {[m
[32m+[m[32m        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the z component of the cross product between vectors BC and BA.[m
[32m+[m[32m     */[m
[32m+[m[32m    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {[m
[32m+[m[32m        var bX = pointB.x;[m
[32m+[m[32m        var bY = pointB.y;[m
[32m+[m[32m        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));[m
[32m+[m[32m    };[m
[32m+[m[32m    return ResultPoint;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ResultPoint;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.d.ts b/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e8918ff[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.d.ts[m
[36m@@ -0,0 +1,11 @@[m
[32m+[m[32mimport ResultPoint from './ResultPoint';[m
[32m+[m[32mexport default ResultPointCallback;[m
[32m+[m[32m/**[m
[32m+[m[32m * Callback which is invoked when a possible result point (significant[m
[32m+[m[32m * point in the barcode image such as a corner) is found.[m
[32m+[m[32m *[m
[32m+[m[32m * @see DecodeHintType#NEED_RESULT_POINT_CALLBACK[m
[32m+[m[32m */[m
[32m+[m[32minterface ResultPointCallback {[m
[32m+[m[32m    foundPossibleResultPoint(point: ResultPoint): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.js b/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0432319[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/ResultPointCallback.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..05e6886[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class UnsupportedOperationException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js b/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..3c602c5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/UnsupportedOperationException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar UnsupportedOperationException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(UnsupportedOperationException, _super);[m
[32m+[m[32m    function UnsupportedOperationException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    UnsupportedOperationException.kind = 'UnsupportedOperationException';[m
[32m+[m[32m    return UnsupportedOperationException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = UnsupportedOperationException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Writer.d.ts b/frontend/node_modules/@zxing/library/cjs/core/Writer.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..80a9593[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Writer.d.ts[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32mimport BitMatrix from './common/BitMatrix';[m
[32m+[m[32mimport BarcodeFormat from './BarcodeFormat';[m
[32m+[m[32mimport EncodeHintType from './EncodeHintType';[m
[32m+[m[32mexport default Writer;[m
[32m+[m[32m/**[m
[32m+[m[32m * The base class for all objects which encode/generate a barcode image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32minterface Writer {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encode a barcode using the default settings.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param contents The contents to encode in the barcode[m
[32m+[m[32m     * @param format The barcode format to generate[m
[32m+[m[32m     * @param width The preferred width in pixels[m
[32m+[m[32m     * @param height The preferred height in pixels[m
[32m+[m[32m     * @return {@link BitMatrix} representing encoded barcode image[m
[32m+[m[32m     * @throws WriterException if contents cannot be encoded legally in a format[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param contents The contents to encode in the barcode[m
[32m+[m[32m     * @param format The barcode format to generate[m
[32m+[m[32m     * @param width The preferred width in pixels[m
[32m+[m[32m     * @param height The preferred height in pixels[m
[32m+[m[32m     * @param hints Additional parameters to supply to the encoder[m
[32m+[m[32m     * @return {@link BitMatrix} representing encoded barcode image[m
[32m+[m[32m     * @throws WriterException if contents cannot be encoded legally in a format[m
[32m+[m[32m     */[m
[32m+[m[32m    encode(contents: string, format: BarcodeFormat, width: number, height: number, hints: Map<EncodeHintType, any>): BitMatrix;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/Writer.js b/frontend/node_modules/@zxing/library/cjs/core/Writer.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b82ba08[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/Writer.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/WriterException.d.ts b/frontend/node_modules/@zxing/library/cjs/core/WriterException.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d212e9d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/WriterException.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport Exception from './Exception';[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class WriterException extends Exception {[m
[32m+[m[32m    static readonly kind: string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/WriterException.js b/frontend/node_modules/@zxing/library/cjs/core/WriterException.js[m
[1mnew file mode 100644[m
[1mindex 0000000..07050f0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/WriterException.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Exception_1 = require("./Exception");[m
[32m+[m[32m/**[m
[32m+[m[32m * Custom Error class of type Exception.[m
[32m+[m[32m */[m
[32m+[m[32mvar WriterException = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(WriterException, _super);[m
[32m+[m[32m    function WriterException() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    WriterException.kind = 'WriterException';[m
[32m+[m[32m    return WriterException;[m
[32m+[m[32m}(Exception_1.default));[m
[32m+[m[32mexports.default = WriterException;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ecfced1[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport ResultPoint from '../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../common/BitMatrix';[m
[32m+[m[32mimport DetectorResult from '../common/DetectorResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,[m
[32m+[m[32m * like the number of layers and whether it's compact.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AztecDetectorResult extends DetectorResult {[m
[32m+[m[32m    private compact;[m
[32m+[m[32m    private nbDatablocks;[m
[32m+[m[32m    private nbLayers;[m
[32m+[m[32m    constructor(bits: BitMatrix, points: ResultPoint[], compact: boolean, nbDatablocks: number, nbLayers: number);[m
[32m+[m[32m    getNbLayers(): number;[m
[32m+[m[32m    getNbDatablocks(): number;[m
[32m+[m[32m    isCompact(): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..56252f9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecDetectorResult.js[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DetectorResult_1 = require("../common/DetectorResult");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,[m
[32m+[m[32m * like the number of layers and whether it's compact.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar AztecDetectorResult = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AztecDetectorResult, _super);[m
[32m+[m[32m    function AztecDetectorResult(bits, points, compact, nbDatablocks, nbLayers) {[m
[32m+[m[32m        var _this = _super.call(this, bits, points) || this;[m
[32m+[m[32m        _this.compact = compact;[m
[32m+[m[32m        _this.nbDatablocks = nbDatablocks;[m
[32m+[m[32m        _this.nbLayers = nbLayers;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AztecDetectorResult.prototype.getNbLayers = function () {[m
[32m+[m[32m        return this.nbLayers;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecDetectorResult.prototype.getNbDatablocks = function () {[m
[32m+[m[32m        return this.nbDatablocks;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecDetectorResult.prototype.isCompact = function () {[m
[32m+[m[32m        return this.compact;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AztecDetectorResult;[m
[32m+[m[32m}(DetectorResult_1.default));[m
[32m+[m[32mexports.default = AztecDetectorResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..51ba048[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.d.ts[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mimport Reader from '../Reader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode Aztec codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AztecReader implements Reader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a Data Matrix code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the Data Matrix code[m
[32m+[m[32m     * @throws NotFoundException if a Data Matrix code cannot be found[m
[32m+[m[32m     * @throws FormatException if a Data Matrix code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any> | null): Result;[m
[32m+[m[32m    private reportFoundResultPoints;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2a8c0a2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecReader.js[m
[36m@@ -0,0 +1,98 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar System_1 = require("../util/System");[m
[32m+[m[32mvar Decoder_1 = require("./decoder/Decoder");[m
[32m+[m[32mvar Detector_1 = require("./detector/Detector");[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode Aztec codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mvar AztecReader = /** @class */ (function () {[m
[32m+[m[32m    function AztecReader() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a Data Matrix code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the Data Matrix code[m
[32m+[m[32m     * @throws NotFoundException if a Data Matrix code cannot be found[m
[32m+[m[32m     * @throws FormatException if a Data Matrix code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        var exception = null;[m
[32m+[m[32m        var detector = new Detector_1.default(image.getBlackMatrix());[m
[32m+[m[32m        var points = null;[m
[32m+[m[32m        var decoderResult = null;[m
[32m+[m[32m        try {[m
[32m+[m[32m            var detectorResult = detector.detectMirror(false);[m
[32m+[m[32m            points = detectorResult.getPoints();[m
[32m+[m[32m            this.reportFoundResultPoints(hints, points);[m
[32m+[m[32m            decoderResult = new Decoder_1.default().decode(detectorResult);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            exception = e;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decoderResult == null) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                var detectorResult = detector.detectMirror(true);[m
[32m+[m[32m                points = detectorResult.getPoints();[m
[32m+[m[32m                this.reportFoundResultPoints(hints, points);[m
[32m+[m[32m                decoderResult = new Decoder_1.default().decode(detectorResult);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e) {[m
[32m+[m[32m                if (exception != null) {[m
[32m+[m[32m                    throw exception;[m
[32m+[m[32m                }[m
[32m+[m[32m                throw e;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat_1.default.AZTEC, System_1.default.currentTimeMillis());[m
[32m+[m[32m        var byteSegments = decoderResult.getByteSegments();[m
[32m+[m[32m        if (byteSegments != null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);[m
[32m+[m[32m        }[m
[32m+[m[32m        var ecLevel = decoderResult.getECLevel();[m
[32m+[m[32m        if (ecLevel != null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecReader.prototype.reportFoundResultPoints = function (hints, points) {[m
[32m+[m[32m        if (hints != null) {[m
[32m+[m[32m            var rpcb_1 = hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);[m
[32m+[m[32m            if (rpcb_1 != null) {[m
[32m+[m[32m                points.forEach(function (point, idx, arr) {[m
[32m+[m[32m                    rpcb_1.foundPossibleResultPoint(point);[m
[32m+[m[32m                });[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    AztecReader.prototype.reset = function () {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    };[m
[32m+[m[32m    return AztecReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AztecReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..21c0f2e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.d.ts[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport EncodeHintType from '../EncodeHintType';[m
[32m+[m[32mimport Writer from '../Writer';[m
[32m+[m[32mimport BitMatrix from '../common/BitMatrix';[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * Renders an Aztec code as a {@link BitMatrix}.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AztecWriter implements Writer {[m
[32m+[m[32m    encode(contents: string, format: BarcodeFormat, width: int, height: int): BitMatrix;[m
[32m+[m[32m    encodeWithHints(contents: string, format: BarcodeFormat, width: int, height: int, hints: Map<EncodeHintType, any>): BitMatrix;[m
[32m+[m[32m    private static encodeLayers;[m
[32m+[m[32m    private static renderResult;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a300c0b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/AztecWriter.js[m
[36m@@ -0,0 +1,96 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.aztec;[m
[32m+[m[32m// import com.google.zxing.BarcodeFormat;[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32m// import com.google.zxing.EncodeHintType;[m
[32m+[m[32mvar EncodeHintType_1 = require("../EncodeHintType");[m
[32m+[m[32m// import com.google.zxing.aztec.encoder.Encoder;[m
[32m+[m[32mvar Encoder_1 = require("./encoder/Encoder");[m
[32m+[m[32m// import com.google.zxing.common.BitMatrix;[m
[32m+[m[32mvar BitMatrix_1 = require("../common/BitMatrix");[m
[32m+[m[32m// import java.nio.charset.Charset;[m
[32m+[m[32mvar Charset_1 = require("../util/Charset");[m
[32m+[m[32m// import java.nio.charset.StandardCharsets;[m
[32m+[m[32mvar StandardCharsets_1 = require("../util/StandardCharsets");[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32mvar Integer_1 = require("../util/Integer");[m
[32m+[m[32mvar IllegalStateException_1 = require("../IllegalStateException");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32mvar StringUtils_1 = require("../common/StringUtils");[m
[32m+[m[32m/**[m
[32m+[m[32m * Renders an Aztec code as a {@link BitMatrix}.[m
[32m+[m[32m */[m
[32m+[m[32mvar AztecWriter = /** @class */ (function () {[m
[32m+[m[32m    function AztecWriter() {[m
[32m+[m[32m    }[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    AztecWriter.prototype.encode = function (contents, format, width, height) {[m
[32m+[m[32m        return this.encodeWithHints(contents, format, width, height, null);[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    AztecWriter.prototype.encodeWithHints = function (contents, format, width, height, hints) {[m
[32m+[m[32m        var charset = StandardCharsets_1.default.ISO_8859_1;[m
[32m+[m[32m        var eccPercent = Encoder_1.default.DEFAULT_EC_PERCENT;[m
[32m+[m[32m        var layers = Encoder_1.default.DEFAULT_AZTEC_LAYERS;[m
[32m+[m[32m        if (hints != null) {[m
[32m+[m[32m            if (hints.has(EncodeHintType_1.default.CHARACTER_SET)) {[m
[32m+[m[32m                charset = Charset_1.default.forName(hints.get(EncodeHintType_1.default.CHARACTER_SET).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (hints.has(EncodeHintType_1.default.ERROR_CORRECTION)) {[m
[32m+[m[32m                eccPercent = Integer_1.default.parseInt(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (hints.has(EncodeHintType_1.default.AZTEC_LAYERS)) {[m
[32m+[m[32m                layers = Integer_1.default.parseInt(hints.get(EncodeHintType_1.default.AZTEC_LAYERS).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecWriter.encodeLayers = function (contents, format, width, height, charset, eccPercent, layers) {[m
[32m+[m[32m        if (format !== BarcodeFormat_1.default.AZTEC) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Can only encode AZTEC, but got ' + format);[m
[32m+[m[32m        }[m
[32m+[m[32m        var aztec = Encoder_1.default.encode(StringUtils_1.default.getBytes(contents, charset), eccPercent, layers);[m
[32m+[m[32m        return AztecWriter.renderResult(aztec, width, height);[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecWriter.renderResult = function (code, width, height) {[m
[32m+[m[32m        var input = code.getMatrix();[m
[32m+[m[32m        if (input == null) {[m
[32m+[m[32m            throw new IllegalStateException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var inputWidth = input.getWidth();[m
[32m+[m[32m        var inputHeight = input.getHeight();[m
[32m+[m[32m        var outputWidth = Math.max(width, inputWidth);[m
[32m+[m[32m        var outputHeight = Math.max(height, inputHeight);[m
[32m+[m[32m        var multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);[m
[32m+[m[32m        var leftPadding = (outputWidth - (inputWidth * multiple)) / 2;[m
[32m+[m[32m        var topPadding = (outputHeight - (inputHeight * multiple)) / 2;[m
[32m+[m[32m        var output = new BitMatrix_1.default(outputWidth, outputHeight);[m
[32m+[m[32m        for (var inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {[m
[32m+[m[32m            // Write the contents of this row of the barcode[m
[32m+[m[32m            for (var inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {[m
[32m+[m[32m                if (input.get(inputX, inputY)) {[m
[32m+[m[32m                    output.setRegion(outputX, outputY, multiple, multiple);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return output;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AztecWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AztecWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a296c19[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.d.ts[m
[36m@@ -0,0 +1,61 @@[m
[32m+[m[32mimport AztecDetectorResult from '../AztecDetectorResult';[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the Aztec Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Decoder {[m
[32m+[m[32m    private static UPPER_TABLE;[m
[32m+[m[32m    private static LOWER_TABLE;[m
[32m+[m[32m    private static MIXED_TABLE;[m
[32m+[m[32m    private static PUNCT_TABLE;[m
[32m+[m[32m    private static DIGIT_TABLE;[m
[32m+[m[32m    private ddata;[m
[32m+[m[32m    decode(detectorResult: AztecDetectorResult): DecoderResult;[m
[32m+[m[32m    static highLevelDecode(correctedBits: boolean[]): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the string encoded in the aztec code bits[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the decoded string[m
[32m+[m[32m     */[m
[32m+[m[32m    private static getEncodedData;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * gets the table corresponding to the char passed[m
[32m+[m[32m     */[m
[32m+[m[32m    private static getTable;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the character (or string) corresponding to the passed code in the given table[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param table the table used[m
[32m+[m[32m     * @param code the code of the character[m
[32m+[m[32m     */[m
[32m+[m[32m    private static getCharacter;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Performs RS error correction on an array of bits.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the corrected array[m
[32m+[m[32m     * @throws FormatException if the input contains too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    private correctBits;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the array of bits from an Aztec Code matrix[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the array of bits[m
[32m+[m[32m     */[m
[32m+[m[32m    private extractBits;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reads a code of given length and at given index in an array of bits[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readCode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reads a code of length 8 in an array of bits, padding with zeros[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readByte;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Packs a bit array into bytes, most significant bit first[m
[32m+[m[32m     */[m
[32m+[m[32m    static convertBoolArrayToByteArray(boolArr: boolean[]): Uint8Array;[m
[32m+[m[32m    private totalBitsInLayer;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c16ec20[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/decoder/Decoder.js[m
[36m@@ -0,0 +1,353 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecoderResult_1 = require("../../common/DecoderResult");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar ReedSolomonDecoder_1 = require("../../common/reedsolomon/ReedSolomonDecoder");[m
[32m+[m[32mvar IllegalStateException_1 = require("../../IllegalStateException");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32m// import java.util.Arrays;[m
[32m+[m[32mvar Table;[m
[32m+[m[32m(function (Table) {[m
[32m+[m[32m    Table[Table["UPPER"] = 0] = "UPPER";[m
[32m+[m[32m    Table[Table["LOWER"] = 1] = "LOWER";[m
[32m+[m[32m    Table[Table["MIXED"] = 2] = "MIXED";[m
[32m+[m[32m    Table[Table["DIGIT"] = 3] = "DIGIT";[m
[32m+[m[32m    Table[Table["PUNCT"] = 4] = "PUNCT";[m
[32m+[m[32m    Table[Table["BINARY"] = 5] = "BINARY";[m
[32m+[m[32m})(Table || (Table = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the Aztec Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mvar Decoder = /** @class */ (function () {[m
[32m+[m[32m    function Decoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    Decoder.prototype.decode = function (detectorResult) {[m
[32m+[m[32m        this.ddata = detectorResult;[m
[32m+[m[32m        var matrix = detectorResult.getBits();[m
[32m+[m[32m        var rawbits = this.extractBits(matrix);[m
[32m+[m[32m        var correctedBits = this.correctBits(rawbits);[m
[32m+[m[32m        var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);[m
[32m+[m[32m        var result = Decoder.getEncodedData(correctedBits);[m
[32m+[m[32m        var decoderResult = new DecoderResult_1.default(rawBytes, result, null, null);[m
[32m+[m[32m        decoderResult.setNumBits(correctedBits.length);[m
[32m+[m[32m        return decoderResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    // This method is used for testing the high-level encoder[m
[32m+[m[32m    Decoder.highLevelDecode = function (correctedBits) {[m
[32m+[m[32m        return this.getEncodedData(correctedBits);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the string encoded in the aztec code bits[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the decoded string[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.getEncodedData = function (correctedBits) {[m
[32m+[m[32m        var endIndex = correctedBits.length;[m
[32m+[m[32m        var latchTable = Table.UPPER; // table most recently latched to[m
[32m+[m[32m        var shiftTable = Table.UPPER; // table to use for the next read[m
[32m+[m[32m        var result = '';[m
[32m+[m[32m        var index = 0;[m
[32m+[m[32m        while (index < endIndex) {[m
[32m+[m[32m            if (shiftTable === Table.BINARY) {[m
[32m+[m[32m                if (endIndex - index < 5) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                var length_1 = Decoder.readCode(correctedBits, index, 5);[m
[32m+[m[32m                index += 5;[m
[32m+[m[32m                if (length_1 === 0) {[m
[32m+[m[32m                    if (endIndex - index < 11) {[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    length_1 = Decoder.readCode(correctedBits, index, 11) + 31;[m
[32m+[m[32m                    index += 11;[m
[32m+[m[32m                }[m
[32m+[m[32m                for (var charCount = 0; charCount < length_1; charCount++) {[m
[32m+[m[32m                    if (endIndex - index < 8) {[m
[32m+[m[32m                        index = endIndex; // Force outer loop to exit[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    var code = Decoder.readCode(correctedBits, index, 8);[m
[32m+[m[32m                    result += /*(char)*/ StringUtils_1.default.castAsNonUtf8Char(code);[m
[32m+[m[32m                    index += 8;[m
[32m+[m[32m                }[m
[32m+[m[32m                // Go back to whatever mode we had been in[m
[32m+[m[32m                shiftTable = latchTable;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                var size = shiftTable === Table.DIGIT ? 4 : 5;[m
[32m+[m[32m                if (endIndex - index < size) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                var code = Decoder.readCode(correctedBits, index, size);[m
[32m+[m[32m                index += size;[m
[32m+[m[32m                var str = Decoder.getCharacter(shiftTable, code);[m
[32m+[m[32m                if (str.startsWith('CTRL_')) {[m
[32m+[m[32m                    // Table changes[m
[32m+[m[32m                    // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.[m
[32m+[m[32m                    // That's including when that mode is a shift.[m
[32m+[m[32m                    // Our test case dlusbs.png for issue #642 exercises that.[m
[32m+[m[32m                    latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S[m
[32m+[m[32m                    shiftTable = Decoder.getTable(str.charAt(5));[m
[32m+[m[32m                    if (str.charAt(6) === 'L') {[m
[32m+[m[32m                        latchTable = shiftTable;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    result += str;[m
[32m+[m[32m                    // Go back to whatever mode we had been in[m
[32m+[m[32m                    shiftTable = latchTable;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * gets the table corresponding to the char passed[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.getTable = function (t) {[m
[32m+[m[32m        switch (t) {[m
[32m+[m[32m            case 'L':[m
[32m+[m[32m                return Table.LOWER;[m
[32m+[m[32m            case 'P':[m
[32m+[m[32m                return Table.PUNCT;[m
[32m+[m[32m            case 'M':[m
[32m+[m[32m                return Table.MIXED;[m
[32m+[m[32m            case 'D':[m
[32m+[m[32m                return Table.DIGIT;[m
[32m+[m[32m            case 'B':[m
[32m+[m[32m                return Table.BINARY;[m
[32m+[m[32m            case 'U':[m
[32m+[m[32m            default:[m
[32m+[m[32m                return Table.UPPER;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the character (or string) corresponding to the passed code in the given table[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param table the table used[m
[32m+[m[32m     * @param code the code of the character[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.getCharacter = function (table, code) {[m
[32m+[m[32m        switch (table) {[m
[32m+[m[32m            case Table.UPPER:[m
[32m+[m[32m                return Decoder.UPPER_TABLE[code];[m
[32m+[m[32m            case Table.LOWER:[m
[32m+[m[32m                return Decoder.LOWER_TABLE[code];[m
[32m+[m[32m            case Table.MIXED:[m
[32m+[m[32m                return Decoder.MIXED_TABLE[code];[m
[32m+[m[32m            case Table.PUNCT:[m
[32m+[m[32m                return Decoder.PUNCT_TABLE[code];[m
[32m+[m[32m            case Table.DIGIT:[m
[32m+[m[32m                return Decoder.DIGIT_TABLE[code];[m
[32m+[m[32m            default:[m
[32m+[m[32m                // Should not reach here.[m
[32m+[m[32m                throw new IllegalStateException_1.default('Bad table');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Performs RS error correction on an array of bits.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the corrected array[m
[32m+[m[32m     * @throws FormatException if the input contains too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.correctBits = function (rawbits) {[m
[32m+[m[32m        var gf;[m
[32m+[m[32m        var codewordSize;[m
[32m+[m[32m        if (this.ddata.getNbLayers() <= 2) {[m
[32m+[m[32m            codewordSize = 6;[m
[32m+[m[32m            gf = GenericGF_1.default.AZTEC_DATA_6;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.ddata.getNbLayers() <= 8) {[m
[32m+[m[32m            codewordSize = 8;[m
[32m+[m[32m            gf = GenericGF_1.default.AZTEC_DATA_8;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.ddata.getNbLayers() <= 22) {[m
[32m+[m[32m            codewordSize = 10;[m
[32m+[m[32m            gf = GenericGF_1.default.AZTEC_DATA_10;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            codewordSize = 12;[m
[32m+[m[32m            gf = GenericGF_1.default.AZTEC_DATA_12;[m
[32m+[m[32m        }[m
[32m+[m[32m        var numDataCodewords = this.ddata.getNbDatablocks();[m
[32m+[m[32m        var numCodewords = rawbits.length / codewordSize;[m
[32m+[m[32m        if (numCodewords < numDataCodewords) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var offset = rawbits.length % codewordSize;[m
[32m+[m[32m        var dataWords = new Int32Array(numCodewords);[m
[32m+[m[32m        for (var i = 0; i < numCodewords; i++, offset += codewordSize) {[m
[32m+[m[32m            dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            var rsDecoder = new ReedSolomonDecoder_1.default(gf);[m
[32m+[m[32m            rsDecoder.decode(dataWords, numCodewords - numDataCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ex) {[m
[32m+[m[32m            throw new FormatException_1.default(ex);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now perform the unstuffing operation.[m
[32m+[m[32m        // First, count how many bits are going to be thrown out as stuffing[m
[32m+[m[32m        var mask = (1 << codewordSize) - 1;[m
[32m+[m[32m        var stuffedBits = 0;[m
[32m+[m[32m        for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m            var dataWord = dataWords[i];[m
[32m+[m[32m            if (dataWord === 0 || dataWord === mask) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (dataWord === 1 || dataWord === mask - 1) {[m
[32m+[m[32m                stuffedBits++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now, actually unpack the bits and remove the stuffing[m
[32m+[m[32m        var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);[m
[32m+[m[32m        var index = 0;[m
[32m+[m[32m        for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m            var dataWord = dataWords[i];[m
[32m+[m[32m            if (dataWord === 1 || dataWord === mask - 1) {[m
[32m+[m[32m                // next codewordSize-1 bits are all zeros or all ones[m
[32m+[m[32m                correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);[m
[32m+[m[32m                // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);[m
[32m+[m[32m                index += codewordSize - 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                for (var bit = codewordSize - 1; bit >= 0; --bit) {[m
[32m+[m[32m                    correctedBits[index++] = (dataWord & (1 << bit)) !== 0;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return correctedBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the array of bits from an Aztec Code matrix[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the array of bits[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.extractBits = function (matrix) {[m
[32m+[m[32m        var compact = this.ddata.isCompact();[m
[32m+[m[32m        var layers = this.ddata.getNbLayers();[m
[32m+[m[32m        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines[m
[32m+[m[32m        var alignmentMap = new Int32Array(baseMatrixSize);[m
[32m+[m[32m        var rawbits = new Array(this.totalBitsInLayer(layers, compact));[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            for (var i = 0; i < alignmentMap.length; i++) {[m
[32m+[m[32m                alignmentMap[i] = i;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);[m
[32m+[m[32m            var origCenter = baseMatrixSize / 2;[m
[32m+[m[32m            var center = Integer_1.default.truncDivision(matrixSize, 2);[m
[32m+[m[32m            for (var i = 0; i < origCenter; i++) {[m
[32m+[m[32m                var newOffset = i + Integer_1.default.truncDivision(i, 15);[m
[32m+[m[32m                alignmentMap[origCenter - i - 1] = center - newOffset - 1;[m
[32m+[m[32m                alignmentMap[origCenter + i] = center + newOffset + 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0, rowOffset = 0; i < layers; i++) {[m
[32m+[m[32m            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);[m
[32m+[m[32m            // The top-left most point of this layer is <low, low> (not including alignment lines)[m
[32m+[m[32m            var low = i * 2;[m
[32m+[m[32m            // The bottom-right most point of this layer is <high, high> (not including alignment lines)[m
[32m+[m[32m            var high = baseMatrixSize - 1 - low;[m
[32m+[m[32m            // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows[m
[32m+[m[32m            for (var j = 0; j < rowSize; j++) {[m
[32m+[m[32m                var columnOffset = j * 2;[m
[32m+[m[32m                for (var k = 0; k < 2; k++) {[m
[32m+[m[32m                    // left column[m
[32m+[m[32m                    rawbits[rowOffset + columnOffset + k] =[m
[32m+[m[32m                        matrix.get(alignmentMap[low + k], alignmentMap[low + j]);[m
[32m+[m[32m                    // bottom row[m
[32m+[m[32m                    rawbits[rowOffset + 2 * rowSize + columnOffset + k] =[m
[32m+[m[32m                        matrix.get(alignmentMap[low + j], alignmentMap[high - k]);[m
[32m+[m[32m                    // right column[m
[32m+[m[32m                    rawbits[rowOffset + 4 * rowSize + columnOffset + k] =[m
[32m+[m[32m                        matrix.get(alignmentMap[high - k], alignmentMap[high - j]);[m
[32m+[m[32m                    // top row[m
[32m+[m[32m                    rawbits[rowOffset + 6 * rowSize + columnOffset + k] =[m
[32m+[m[32m                        matrix.get(alignmentMap[high - j], alignmentMap[low + k]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            rowOffset += rowSize * 8;[m
[32m+[m[32m        }[m
[32m+[m[32m        return rawbits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reads a code of given length and at given index in an array of bits[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.readCode = function (rawbits, startIndex, length) {[m
[32m+[m[32m        var res = 0;[m
[32m+[m[32m        for (var i = startIndex; i < startIndex + length; i++) {[m
[32m+[m[32m            res <<= 1;[m
[32m+[m[32m            if (rawbits[i]) {[m
[32m+[m[32m                res |= 0x01;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return res;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reads a code of length 8 in an array of bits, padding with zeros[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.readByte = function (rawbits, startIndex) {[m
[32m+[m[32m        var n = rawbits.length - startIndex;[m
[32m+[m[32m        if (n >= 8) {[m
[32m+[m[32m            return Decoder.readCode(rawbits, startIndex, 8);[m
[32m+[m[32m        }[m
[32m+[m[32m        return Decoder.readCode(rawbits, startIndex, n) << (8 - n);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Packs a bit array into bytes, most significant bit first[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.convertBoolArrayToByteArray = function (boolArr) {[m
[32m+[m[32m        var byteArr = new Uint8Array((boolArr.length + 7) / 8);[m
[32m+[m[32m        for (var i = 0; i < byteArr.length; i++) {[m
[32m+[m[32m            byteArr[i] = Decoder.readByte(boolArr, 8 * i);[m
[32m+[m[32m        }[m
[32m+[m[32m        return byteArr;[m
[32m+[m[32m    };[m
[32m+[m[32m    Decoder.prototype.totalBitsInLayer = function (layers, compact) {[m
[32m+[m[32m        return ((compact ? 88 : 112) + 16 * layers) * layers;[m
[32m+[m[32m    };[m
[32m+[m[32m    Decoder.UPPER_TABLE = [[m
[32m+[m[32m        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',[m
[32m+[m[32m        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'[m
[32m+[m[32m    ];[m
[32m+[m[32m    Decoder.LOWER_TABLE = [[m
[32m+[m[32m        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',[m
[32m+[m[32m        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'[m
[32m+[m[32m    ];[m
[32m+[m[32m    Decoder.MIXED_TABLE = [[m
[32m+[m[32m        'CTRL_PS', ' ', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\b', '\t', '\n',[m
[32m+[m[32m        '\x0b', '\f', '\r', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', '@', '\\', '^', '_',[m
[32m+[m[32m        '`', '|', '~', '\x7f', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'[m
[32m+[m[32m    ];[m
[32m+[m[32m    Decoder.PUNCT_TABLE = [[m
[32m+[m[32m        '', '\r', '\r\n', '. ', ', ', ': ', '!', '"', '#', '$', '%', '&', '\'', '(', ')',[m
[32m+[m[32m        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'[m
[32m+[m[32m    ];[m
[32m+[m[32m    Decoder.DIGIT_TABLE = [[m
[32m+[m[32m        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'[m
[32m+[m[32m    ];[m
[32m+[m[32m    return Decoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Decoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..466c77c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.d.ts[m
[36m@@ -0,0 +1,120 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport AztecDetectorResult from '../AztecDetectorResult';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mexport declare class Point {[m
[32m+[m[32m    private x;[m
[32m+[m[32m    private y;[m
[32m+[m[32m    toResultPoint(): ResultPoint;[m
[32m+[m[32m    constructor(x: number, y: number);[m
[32m+[m[32m    getX(): number;[m
[32m+[m[32m    getY(): number;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m * @author Frank Yellin[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Detector {[m
[32m+[m[32m    private EXPECTED_CORNER_BITS;[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private compact;[m
[32m+[m[32m    private nbLayers;[m
[32m+[m[32m    private nbDataBlocks;[m
[32m+[m[32m    private nbCenterLayers;[m
[32m+[m[32m    private shift;[m
[32m+[m[32m    constructor(image: BitMatrix);[m
[32m+[m[32m    detect(): AztecDetectorResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detects an Aztec Code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param isMirror if true, image is a mirror-image of original[m
[32m+[m[32m     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code[m
[32m+[m[32m     * @throws NotFoundException if no Aztec Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    detectMirror(isMirror: boolean): AztecDetectorResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Extracts the number of data layers and data blocks from the layer around the bull's eye.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bullsEyeCorners the array of bull's eye corners[m
[32m+[m[32m     * @throws NotFoundException in case of too many errors or invalid parameters[m
[32m+[m[32m     */[m
[32m+[m[32m    private extractParameters;[m
[32m+[m[32m    private getRotation;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Corrects the parameter bits using Reed-Solomon algorithm.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param parameterData parameter bits[m
[32m+[m[32m     * @param compact true if this is a compact Aztec code[m
[32m+[m[32m     * @throws NotFoundException if the array contains too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    private getCorrectedParameterData;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Finds the corners of a bull-eye centered on the passed point.[m
[32m+[m[32m     * This returns the centers of the diagonal points just outside the bull's eye[m
[32m+[m[32m     * Returns [topRight, bottomRight, bottomLeft, topLeft][m
[32m+[m[32m     *[m
[32m+[m[32m     * @param pCenter Center point[m
[32m+[m[32m     * @return The corners of the bull-eye[m
[32m+[m[32m     * @throws NotFoundException If no valid bull-eye can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    private getBullsEyeCorners;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Finds a candidate center point of an Aztec code from an image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the center point[m
[32m+[m[32m     */[m
[32m+[m[32m    private getMatrixCenter;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the Aztec code corners from the bull's eye corners and the parameters.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bullsEyeCorners the array of bull's eye corners[m
[32m+[m[32m     * @return the array of aztec code corners[m
[32m+[m[32m     */[m
[32m+[m[32m    private getMatrixCornerPoints;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a BitMatrix by sampling the provided image.[m
[32m+[m[32m     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the[m
[32m+[m[32m     * diagonal just outside the bull's eye.[m
[32m+[m[32m     */[m
[32m+[m[32m    private sampleGrid;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Samples a line.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param p1   start point (inclusive)[m
[32m+[m[32m     * @param p2   end point (exclusive)[m
[32m+[m[32m     * @param size number of bits[m
[32m+[m[32m     * @return the array of bits as an int (first bit is high-order bit of result)[m
[32m+[m[32m     */[m
[32m+[m[32m    private sampleLine;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the border of the rectangle passed in parameter is compound of white points only[m
[32m+[m[32m     *         or black points only[m
[32m+[m[32m     */[m
[32m+[m[32m    private isWhiteOrBlackRectangle;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the color of a segment[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else[m
[32m+[m[32m     */[m
[32m+[m[32m    private getColor;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the coordinate of the first point with a different color in the given direction[m
[32m+[m[32m     */[m
[32m+[m[32m    private getFirstDifferent;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Expand the square represented by the corner points by pushing out equally in all directions[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param cornerPoints the corners of the square, which has the bull's eye at its center[m
[32m+[m[32m     * @param oldSide the original length of the side of the square in the target bit matrix[m
[32m+[m[32m     * @param newSide the new length of the size of the square in the target bit matrix[m
[32m+[m[32m     * @return the corners of the expanded square[m
[32m+[m[32m     */[m
[32m+[m[32m    private expandSquare;[m
[32m+[m[32m    private isValid;[m
[32m+[m[32m    private isValidPoint;[m
[32m+[m[32m    private distancePoint;[m
[32m+[m[32m    private distanceResultPoint;[m
[32m+[m[32m    private getDimension;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ea6911f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/detector/Detector.js[m
[36m@@ -0,0 +1,492 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.Point = void 0;[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar AztecDetectorResult_1 = require("../AztecDetectorResult");[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32mvar WhiteRectangleDetector_1 = require("../../common/detector/WhiteRectangleDetector");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar ReedSolomonDecoder_1 = require("../../common/reedsolomon/ReedSolomonDecoder");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32mvar GridSamplerInstance_1 = require("../../common/GridSamplerInstance");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar Point = /** @class */ (function () {[m
[32m+[m[32m    function Point(x, y) {[m
[32m+[m[32m        this.x = x;[m
[32m+[m[32m        this.y = y;[m
[32m+[m[32m    }[m
[32m+[m[32m    Point.prototype.toResultPoint = function () {[m
[32m+[m[32m        return new ResultPoint_1.default(this.getX(), this.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    Point.prototype.getX = function () {[m
[32m+[m[32m        return this.x;[m
[32m+[m[32m    };[m
[32m+[m[32m    Point.prototype.getY = function () {[m
[32m+[m[32m        return this.y;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Point;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.Point = Point;[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m * @author Frank Yellin[m
[32m+[m[32m */[m
[32m+[m[32mvar Detector = /** @class */ (function () {[m
[32m+[m[32m    function Detector(image) {[m
[32m+[m[32m        this.EXPECTED_CORNER_BITS = new Int32Array([[m
[32m+[m[32m            0xee0,[m
[32m+[m[32m            0x1dc,[m
[32m+[m[32m            0x83b,[m
[32m+[m[32m            0x707,[m
[32m+[m[32m        ]);[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m    }[m
[32m+[m[32m    Detector.prototype.detect = function () {[m
[32m+[m[32m        return this.detectMirror(false);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detects an Aztec Code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param isMirror if true, image is a mirror-image of original[m
[32m+[m[32m     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code[m
[32m+[m[32m     * @throws NotFoundException if no Aztec Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.detectMirror = function (isMirror) {[m
[32m+[m[32m        // 1. Get the center of the aztec matrix[m
[32m+[m[32m        var pCenter = this.getMatrixCenter();[m
[32m+[m[32m        // 2. Get the center points of the four diagonal points just outside the bull's eye[m
[32m+[m[32m        //  [topRight, bottomRight, bottomLeft, topLeft][m
[32m+[m[32m        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);[m
[32m+[m[32m        if (isMirror) {[m
[32m+[m[32m            var temp = bullsEyeCorners[0];[m
[32m+[m[32m            bullsEyeCorners[0] = bullsEyeCorners[2];[m
[32m+[m[32m            bullsEyeCorners[2] = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        // 3. Get the size of the matrix and other parameters from the bull's eye[m
[32m+[m[32m        this.extractParameters(bullsEyeCorners);[m
[32m+[m[32m        // 4. Sample the grid[m
[32m+[m[32m        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);[m
[32m+[m[32m        // 5. Get the corners of the matrix.[m
[32m+[m[32m        var corners = this.getMatrixCornerPoints(bullsEyeCorners);[m
[32m+[m[32m        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Extracts the number of data layers and data blocks from the layer around the bull's eye.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bullsEyeCorners the array of bull's eye corners[m
[32m+[m[32m     * @throws NotFoundException in case of too many errors or invalid parameters[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.extractParameters = function (bullsEyeCorners) {[m
[32m+[m[32m        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||[m
[32m+[m[32m            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var length = 2 * this.nbCenterLayers;[m
[32m+[m[32m        // Get the bits around the bull's eye[m
[32m+[m[32m        var sides = new Int32Array([[m
[32m+[m[32m            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),[m
[32m+[m[32m            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),[m
[32m+[m[32m            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),[m
[32m+[m[32m            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top[m
[32m+[m[32m        ]);[m
[32m+[m[32m        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three[m
[32m+[m[32m        // orientation marks.[m
[32m+[m[32m        // sides[shift] is the row/column that goes from the corner with three[m
[32m+[m[32m        // orientation marks to the corner with two.[m
[32m+[m[32m        this.shift = this.getRotation(sides, length);[m
[32m+[m[32m        // Flatten the parameter bits into a single 28- or 40-bit long[m
[32m+[m[32m        var parameterData = 0;[m
[32m+[m[32m        for (var i = 0; i < 4; i++) {[m
[32m+[m[32m            var side = sides[(this.shift + i) % 4];[m
[32m+[m[32m            if (this.compact) {[m
[32m+[m[32m                // Each side of the form ..XXXXXXX. where Xs are parameter data[m
[32m+[m[32m                parameterData <<= 7;[m
[32m+[m[32m                parameterData += (side >> 1) & 0x7F;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data[m
[32m+[m[32m                parameterData <<= 10;[m
[32m+[m[32m                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Corrects parameter data using RS.  Returns just the data portion[m
[32m+[m[32m        // without the error correction.[m
[32m+[m[32m        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);[m
[32m+[m[32m        if (this.compact) {[m
[32m+[m[32m            // 8 bits:  2 bits layers and 6 bits data blocks[m
[32m+[m[32m            this.nbLayers = (correctedData >> 6) + 1;[m
[32m+[m[32m            this.nbDataBlocks = (correctedData & 0x3F) + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // 16 bits:  5 bits layers and 11 bits data blocks[m
[32m+[m[32m            this.nbLayers = (correctedData >> 11) + 1;[m
[32m+[m[32m            this.nbDataBlocks = (correctedData & 0x7FF) + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.getRotation = function (sides, length) {[m
[32m+[m[32m        // In a normal pattern, we expect to See[m
[32m+[m[32m        //   **    .*             D       A[m
[32m+[m[32m        //   *      *[m
[32m+[m[32m        //[m
[32m+[m[32m        //   .      *[m
[32m+[m[32m        //   ..    ..             C       B[m
[32m+[m[32m        //[m
[32m+[m[32m        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate[m
[32m+[m[32m        // into a 12-bit integer.  Start with the bit at A[m
[32m+[m[32m        var cornerBits = 0;[m
[32m+[m[32m        sides.forEach(function (side, idx, arr) {[m
[32m+[m[32m            // XX......X where X's are orientation marks[m
[32m+[m[32m            var t = ((side >> (length - 2)) << 1) + (side & 1);[m
[32m+[m[32m            cornerBits = (cornerBits << 3) + t;[m
[32m+[m[32m        });[m
[32m+[m[32m        // for (var side in sides) {[m
[32m+[m[32m        //     // XX......X where X's are orientation marks[m
[32m+[m[32m        //     var t = ((side >> (length - 2)) << 1) + (side & 1);[m
[32m+[m[32m        //     cornerBits = (cornerBits << 3) + t;[m
[32m+[m[32m        // }[m
[32m+[m[32m        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are[m
[32m+[m[32m        // together.  cornerBits is now:[m
[32m+[m[32m        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D[m
[32m+[m[32m        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);[m
[32m+[m[32m        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left[m
[32m+[m[32m        // corner. Since the four rotation values have a Hamming distance of 8, we[m
[32m+[m[32m        // can easily tolerate two errors.[m
[32m+[m[32m        for (var shift = 0; shift < 4; shift++) {[m
[32m+[m[32m            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {[m
[32m+[m[32m                return shift;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Corrects the parameter bits using Reed-Solomon algorithm.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param parameterData parameter bits[m
[32m+[m[32m     * @param compact true if this is a compact Aztec code[m
[32m+[m[32m     * @throws NotFoundException if the array contains too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {[m
[32m+[m[32m        var numCodewords;[m
[32m+[m[32m        var numDataCodewords;[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            numCodewords = 7;[m
[32m+[m[32m            numDataCodewords = 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            numCodewords = 10;[m
[32m+[m[32m            numDataCodewords = 4;[m
[32m+[m[32m        }[m
[32m+[m[32m        var numECCodewords = numCodewords - numDataCodewords;[m
[32m+[m[32m        var parameterWords = new Int32Array(numCodewords);[m
[32m+[m[32m        for (var i = numCodewords - 1; i >= 0; --i) {[m
[32m+[m[32m            parameterWords[i] = parameterData & 0xF;[m
[32m+[m[32m            parameterData >>= 4;[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);[m
[32m+[m[32m            rsDecoder.decode(parameterWords, numECCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Toss the error correction.  Just return the data as an integer[m
[32m+[m[32m        var result = 0;[m
[32m+[m[32m        for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m            result = (result << 4) + parameterWords[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Finds the corners of a bull-eye centered on the passed point.[m
[32m+[m[32m     * This returns the centers of the diagonal points just outside the bull's eye[m
[32m+[m[32m     * Returns [topRight, bottomRight, bottomLeft, topLeft][m
[32m+[m[32m     *[m
[32m+[m[32m     * @param pCenter Center point[m
[32m+[m[32m     * @return The corners of the bull-eye[m
[32m+[m[32m     * @throws NotFoundException If no valid bull-eye can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getBullsEyeCorners = function (pCenter) {[m
[32m+[m[32m        var pina = pCenter;[m
[32m+[m[32m        var pinb = pCenter;[m
[32m+[m[32m        var pinc = pCenter;[m
[32m+[m[32m        var pind = pCenter;[m
[32m+[m[32m        var color = true;[m
[32m+[m[32m        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {[m
[32m+[m[32m            var pouta = this.getFirstDifferent(pina, color, 1, -1);[m
[32m+[m[32m            var poutb = this.getFirstDifferent(pinb, color, 1, 1);[m
[32m+[m[32m            var poutc = this.getFirstDifferent(pinc, color, -1, 1);[m
[32m+[m[32m            var poutd = this.getFirstDifferent(pind, color, -1, -1);[m
[32m+[m[32m            // d      a[m
[32m+[m[32m            //[m
[32m+[m[32m            // c      b[m
[32m+[m[32m            if (this.nbCenterLayers > 2) {[m
[32m+[m[32m                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));[m
[32m+[m[32m                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            pina = pouta;[m
[32m+[m[32m            pinb = poutb;[m
[32m+[m[32m            pinc = poutc;[m
[32m+[m[32m            pind = poutd;[m
[32m+[m[32m            color = !color;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.compact = this.nbCenterLayers === 5;[m
[32m+[m[32m        // Expand the square by .5 pixel in each direction so that we're on the border[m
[32m+[m[32m        // between the white square and the black square[m
[32m+[m[32m        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);[m
[32m+[m[32m        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);[m
[32m+[m[32m        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);[m
[32m+[m[32m        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);[m
[32m+[m[32m        // Expand the square so that its corners are the centers of the points[m
[32m+[m[32m        // just outside the bull's eye.[m
[32m+[m[32m        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Finds a candidate center point of an Aztec code from an image[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return the center point[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getMatrixCenter = function () {[m
[32m+[m[32m        var pointA;[m
[32m+[m[32m        var pointB;[m
[32m+[m[32m        var pointC;[m
[32m+[m[32m        var pointD;[m
[32m+[m[32m        // Get a white rectangle that can be the border of the matrix in center bull's eye or[m
[32m+[m[32m        try {[m
[32m+[m[32m            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();[m
[32m+[m[32m            pointA = cornerPoints[0];[m
[32m+[m[32m            pointB = cornerPoints[1];[m
[32m+[m[32m            pointC = cornerPoints[2];[m
[32m+[m[32m            pointD = cornerPoints[3];[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            // This exception can be in case the initial rectangle is white[m
[32m+[m[32m            // In that case, surely in the bull's eye, we try to expand the rectangle.[m
[32m+[m[32m            var cx_1 = this.image.getWidth() / 2;[m
[32m+[m[32m            var cy_1 = this.image.getHeight() / 2;[m
[32m+[m[32m            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();[m
[32m+[m[32m            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();[m
[32m+[m[32m            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();[m
[32m+[m[32m            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Compute the center of the rectangle[m
[32m+[m[32m        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);[m
[32m+[m[32m        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);[m
[32m+[m[32m        // Redetermine the white rectangle starting from previously computed center.[m
[32m+[m[32m        // This will ensure that we end up with a white rectangle in center bull's eye[m
[32m+[m[32m        // in order to compute a more accurate center.[m
[32m+[m[32m        try {[m
[32m+[m[32m            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();[m
[32m+[m[32m            pointA = cornerPoints[0];[m
[32m+[m[32m            pointB = cornerPoints[1];[m
[32m+[m[32m            pointC = cornerPoints[2];[m
[32m+[m[32m            pointD = cornerPoints[3];[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            // This exception can be in case the initial rectangle is white[m
[32m+[m[32m            // In that case we try to expand the rectangle.[m
[32m+[m[32m            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();[m
[32m+[m[32m            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();[m
[32m+[m[32m            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();[m
[32m+[m[32m            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Recompute the center of the rectangle[m
[32m+[m[32m        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);[m
[32m+[m[32m        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);[m
[32m+[m[32m        return new Point(cx, cy);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the Aztec code corners from the bull's eye corners and the parameters.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bullsEyeCorners the array of bull's eye corners[m
[32m+[m[32m     * @return the array of aztec code corners[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {[m
[32m+[m[32m        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a BitMatrix by sampling the provided image.[m
[32m+[m[32m     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the[m
[32m+[m[32m     * diagonal just outside the bull's eye.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {[m
[32m+[m[32m        var sampler = GridSamplerInstance_1.default.getInstance();[m
[32m+[m[32m        var dimension = this.getDimension();[m
[32m+[m[32m        var low = dimension / 2 - this.nbCenterLayers;[m
[32m+[m[32m        var high = dimension / 2 + this.nbCenterLayers;[m
[32m+[m[32m        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft[m
[32m+[m[32m        high, low, // topright[m
[32m+[m[32m        high, high, // bottomright[m
[32m+[m[32m        low, high, // bottomleft[m
[32m+[m[32m        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Samples a line.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param p1   start point (inclusive)[m
[32m+[m[32m     * @param p2   end point (exclusive)[m
[32m+[m[32m     * @param size number of bits[m
[32m+[m[32m     * @return the array of bits as an int (first bit is high-order bit of result)[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.sampleLine = function (p1, p2, size) {[m
[32m+[m[32m        var result = 0;[m
[32m+[m[32m        var d = this.distanceResultPoint(p1, p2);[m
[32m+[m[32m        var moduleSize = d / size;[m
[32m+[m[32m        var px = p1.getX();[m
[32m+[m[32m        var py = p1.getY();[m
[32m+[m[32m        var dx = moduleSize * (p2.getX() - p1.getX()) / d;[m
[32m+[m[32m        var dy = moduleSize * (p2.getY() - p1.getY()) / d;[m
[32m+[m[32m        for (var i = 0; i < size; i++) {[m
[32m+[m[32m            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {[m
[32m+[m[32m                result |= 1 << (size - i - 1);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the border of the rectangle passed in parameter is compound of white points only[m
[32m+[m[32m     *         or black points only[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {[m
[32m+[m[32m        var corr = 3;[m
[32m+[m[32m        p1 = new Point(p1.getX() - corr, p1.getY() + corr);[m
[32m+[m[32m        p2 = new Point(p2.getX() - corr, p2.getY() - corr);[m
[32m+[m[32m        p3 = new Point(p3.getX() + corr, p3.getY() - corr);[m
[32m+[m[32m        p4 = new Point(p4.getX() + corr, p4.getY() + corr);[m
[32m+[m[32m        var cInit = this.getColor(p4, p1);[m
[32m+[m[32m        if (cInit === 0) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var c = this.getColor(p1, p2);[m
[32m+[m[32m        if (c !== cInit) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        c = this.getColor(p2, p3);[m
[32m+[m[32m        if (c !== cInit) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        c = this.getColor(p3, p4);[m
[32m+[m[32m        return c === cInit;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the color of a segment[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getColor = function (p1, p2) {[m
[32m+[m[32m        var d = this.distancePoint(p1, p2);[m
[32m+[m[32m        var dx = (p2.getX() - p1.getX()) / d;[m
[32m+[m[32m        var dy = (p2.getY() - p1.getY()) / d;[m
[32m+[m[32m        var error = 0;[m
[32m+[m[32m        var px = p1.getX();[m
[32m+[m[32m        var py = p1.getY();[m
[32m+[m[32m        var colorModel = this.image.get(p1.getX(), p1.getY());[m
[32m+[m[32m        var iMax = Math.ceil(d);[m
[32m+[m[32m        for (var i = 0; i < iMax; i++) {[m
[32m+[m[32m            px += dx;[m
[32m+[m[32m            py += dy;[m
[32m+[m[32m            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {[m
[32m+[m[32m                error++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var errRatio = error / d;[m
[32m+[m[32m        if (errRatio > 0.1 && errRatio < 0.9) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        return (errRatio <= 0.1) === colorModel ? 1 : -1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Gets the coordinate of the first point with a different color in the given direction[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {[m
[32m+[m[32m        var x = init.getX() + dx;[m
[32m+[m[32m        var y = init.getY() + dy;[m
[32m+[m[32m        while (this.isValid(x, y) && this.image.get(x, y) === color) {[m
[32m+[m[32m            x += dx;[m
[32m+[m[32m            y += dy;[m
[32m+[m[32m        }[m
[32m+[m[32m        x -= dx;[m
[32m+[m[32m        y -= dy;[m
[32m+[m[32m        while (this.isValid(x, y) && this.image.get(x, y) === color) {[m
[32m+[m[32m            x += dx;[m
[32m+[m[32m        }[m
[32m+[m[32m        x -= dx;[m
[32m+[m[32m        while (this.isValid(x, y) && this.image.get(x, y) === color) {[m
[32m+[m[32m            y += dy;[m
[32m+[m[32m        }[m
[32m+[m[32m        y -= dy;[m
[32m+[m[32m        return new Point(x, y);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Expand the square represented by the corner points by pushing out equally in all directions[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param cornerPoints the corners of the square, which has the bull's eye at its center[m
[32m+[m[32m     * @param oldSide the original length of the side of the square in the target bit matrix[m
[32m+[m[32m     * @param newSide the new length of the size of the square in the target bit matrix[m
[32m+[m[32m     * @return the corners of the expanded square[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {[m
[32m+[m[32m        var ratio = newSide / (2.0 * oldSide);[m
[32m+[m[32m        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();[m
[32m+[m[32m        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();[m
[32m+[m[32m        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;[m
[32m+[m[32m        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;[m
[32m+[m[32m        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);[m
[32m+[m[32m        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);[m
[32m+[m[32m        dx = cornerPoints[1].getX() - cornerPoints[3].getX();[m
[32m+[m[32m        dy = cornerPoints[1].getY() - cornerPoints[3].getY();[m
[32m+[m[32m        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;[m
[32m+[m[32m        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;[m
[32m+[m[32m        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);[m
[32m+[m[32m        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);[m
[32m+[m[32m        var results = [result0, result1, result2, result3];[m
[32m+[m[32m        return results;[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.isValid = function (x, y) {[m
[32m+[m[32m        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.isValidPoint = function (point) {[m
[32m+[m[32m        var x = MathUtils_1.default.round(point.getX());[m
[32m+[m[32m        var y = MathUtils_1.default.round(point.getY());[m
[32m+[m[32m        return this.isValid(x, y);[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.distancePoint = function (a, b) {[m
[32m+[m[32m        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.distanceResultPoint = function (a, b) {[m
[32m+[m[32m        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.getDimension = function () {[m
[32m+[m[32m        if (this.compact) {[m
[32m+[m[32m            return 4 * this.nbLayers + 11;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.nbLayers <= 4) {[m
[32m+[m[32m            return 4 * this.nbLayers + 15;[m
[32m+[m[32m        }[m
[32m+[m[32m        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Detector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Detector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..92a6cc2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.d.ts[m
[36m@@ -0,0 +1,39 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * Aztec 2D code representation[m
[32m+[m[32m *[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AztecCode {[m
[32m+[m[32m    private compact;[m
[32m+[m[32m    private size;[m
[32m+[m[32m    private layers;[m
[32m+[m[32m    private codeWords;[m
[32m+[m[32m    private matrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@code true} if compact instead of full mode[m
[32m+[m[32m     */[m
[32m+[m[32m    isCompact(): boolean;[m
[32m+[m[32m    setCompact(compact: boolean): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return size in pixels (width and height)[m
[32m+[m[32m     */[m
[32m+[m[32m    getSize(): int;[m
[32m+[m[32m    setSize(size: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of levels[m
[32m+[m[32m     */[m
[32m+[m[32m    getLayers(): int;[m
[32m+[m[32m    setLayers(layers: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of data codewords[m
[32m+[m[32m     */[m
[32m+[m[32m    getCodeWords(): int;[m
[32m+[m[32m    setCodeWords(codeWords: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the symbol image[m
[32m+[m[32m     */[m
[32m+[m[32m    getMatrix(): BitMatrix;[m
[32m+[m[32m    setMatrix(matrix: BitMatrix): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js[m
[1mnew file mode 100644[m
[1mindex 0000000..430bade[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/AztecCode.js[m
[36m@@ -0,0 +1,73 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * Aztec 2D code representation[m
[32m+[m[32m *[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mvar AztecCode = /** @class */ (function () {[m
[32m+[m[32m    function AztecCode() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return {@code true} if compact instead of full mode[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecCode.prototype.isCompact = function () {[m
[32m+[m[32m        return this.compact;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecCode.prototype.setCompact = function (compact) {[m
[32m+[m[32m        this.compact = compact;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return size in pixels (width and height)[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecCode.prototype.getSize = function () {[m
[32m+[m[32m        return this.size;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecCode.prototype.setSize = function (size) {[m
[32m+[m[32m        this.size = size;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of levels[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecCode.prototype.getLayers = function () {[m
[32m+[m[32m        return this.layers;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecCode.prototype.setLayers = function (layers) {[m
[32m+[m[32m        this.layers = layers;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of data codewords[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecCode.prototype.getCodeWords = function () {[m
[32m+[m[32m        return this.codeWords;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecCode.prototype.setCodeWords = function (codeWords) {[m
[32m+[m[32m        this.codeWords = codeWords;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the symbol image[m
[32m+[m[32m     */[m
[32m+[m[32m    AztecCode.prototype.getMatrix = function () {[m
[32m+[m[32m        return this.matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    AztecCode.prototype.setMatrix = function (matrix) {[m
[32m+[m[32m        this.matrix = matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AztecCode;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AztecCode;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..85f600c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport Token from './Token';[m
[32m+[m[32mimport SimpleToken from './SimpleToken';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32mexport default class BinaryShiftToken extends SimpleToken {[m
[32m+[m[32m    private binaryShiftStart;[m
[32m+[m[32m    private binaryShiftByteCount;[m
[32m+[m[32m    constructor(previous: Token, binaryShiftStart: int, binaryShiftByteCount: int);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    appendTo(bitArray: BitArray, text: Uint8Array): void;[m
[32m+[m[32m    addBinaryShift(start: int, byteCount: int): Token;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fab5939[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/BinaryShiftToken.js[m
[36m@@ -0,0 +1,76 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar SimpleToken_1 = require("./SimpleToken");[m
[32m+[m[32mvar BinaryShiftToken = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(BinaryShiftToken, _super);[m
[32m+[m[32m    function BinaryShiftToken(previous, binaryShiftStart, binaryShiftByteCount) {[m
[32m+[m[32m        var _this = _super.call(this, previous, 0, 0) || this;[m
[32m+[m[32m        _this.binaryShiftStart = binaryShiftStart;[m
[32m+[m[32m        _this.binaryShiftByteCount = binaryShiftByteCount;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryShiftToken.prototype.appendTo = function (bitArray, text) {[m
[32m+[m[32m        for (var i = 0; i < this.binaryShiftByteCount; i++) {[m
[32m+[m[32m            if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {[m
[32m+[m[32m                // We need a header before the first character, and before[m
[32m+[m[32m                // character 31 when the total byte code is <= 62[m
[32m+[m[32m                bitArray.appendBits(31, 5); // BINARY_SHIFT[m
[32m+[m[32m                if (this.binaryShiftByteCount > 62) {[m
[32m+[m[32m                    bitArray.appendBits(this.binaryShiftByteCount - 31, 16);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (i === 0) {[m
[32m+[m[32m                    // 1 <= binaryShiftByteCode <= 62[m
[32m+[m[32m                    bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    // 32 <= binaryShiftCount <= 62 and i == 31[m
[32m+[m[32m                    bitArray.appendBits(this.binaryShiftByteCount - 31, 5);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            bitArray.appendBits(text[this.binaryShiftStart + i], 8);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    BinaryShiftToken.prototype.addBinaryShift = function (start, byteCount) {[m
[32m+[m[32m        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);[m
[32m+[m[32m        return new BinaryShiftToken(this, start, byteCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    BinaryShiftToken.prototype.toString = function () {[m
[32m+[m[32m        return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';[m
[32m+[m[32m    };[m
[32m+[m[32m    return BinaryShiftToken;[m
[32m+[m[32m}(SimpleToken_1.default));[m
[32m+[m[32mexports.default = BinaryShiftToken;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..1d087cc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.d.ts[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32mexport declare function static_CHAR_MAP(CHAR_MAP: Int32Array[]): Int32Array[];[m
[32m+[m[32mexport declare const CHAR_MAP: Int32Array[];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js[m
[1mnew file mode 100644[m
[1mindex 0000000..678cda8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/CharMap.js[m
[36m@@ -0,0 +1,105 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.CHAR_MAP = exports.static_CHAR_MAP = void 0;[m
[32m+[m[32mvar C = require("./EncoderConstants");[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mfunction static_CHAR_MAP(CHAR_MAP) {[m
[32m+[m[32m    var spaceCharCode = StringUtils_1.default.getCharCode(' ');[m
[32m+[m[32m    var pointCharCode = StringUtils_1.default.getCharCode('.');[m
[32m+[m[32m    var commaCharCode = StringUtils_1.default.getCharCode(',');[m
[32m+[m[32m    CHAR_MAP[C.MODE_UPPER][spaceCharCode] = 1;[m
[32m+[m[32m    var zUpperCharCode = StringUtils_1.default.getCharCode('Z');[m
[32m+[m[32m    var aUpperCharCode = StringUtils_1.default.getCharCode('A');[m
[32m+[m[32m    for (var c = aUpperCharCode; c <= zUpperCharCode; c++) {[m
[32m+[m[32m        CHAR_MAP[C.MODE_UPPER][c] = c - aUpperCharCode + 2;[m
[32m+[m[32m    }[m
[32m+[m[32m    CHAR_MAP[C.MODE_LOWER][spaceCharCode] = 1;[m
[32m+[m[32m    var zLowerCharCode = StringUtils_1.default.getCharCode('z');[m
[32m+[m[32m    var aLowerCharCode = StringUtils_1.default.getCharCode('a');[m
[32m+[m[32m    for (var c = aLowerCharCode; c <= zLowerCharCode; c++) {[m
[32m+[m[32m        CHAR_MAP[C.MODE_LOWER][c] = c - aLowerCharCode + 2;[m
[32m+[m[32m    }[m
[32m+[m[32m    CHAR_MAP[C.MODE_DIGIT][spaceCharCode] = 1;[m
[32m+[m[32m    var nineCharCode = StringUtils_1.default.getCharCode('9');[m
[32m+[m[32m    var zeroCharCode = StringUtils_1.default.getCharCode('0');[m
[32m+[m[32m    for (var c = zeroCharCode; c <= nineCharCode; c++) {[m
[32m+[m[32m        CHAR_MAP[C.MODE_DIGIT][c] = c - zeroCharCode + 2;[m
[32m+[m[32m    }[m
[32m+[m[32m    CHAR_MAP[C.MODE_DIGIT][commaCharCode] = 12;[m
[32m+[m[32m    CHAR_MAP[C.MODE_DIGIT][pointCharCode] = 13;[m
[32m+[m[32m    var mixedTable = [[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        ' ',[m
[32m+[m[32m        '\x01',[m
[32m+[m[32m        '\x02',[m
[32m+[m[32m        '\x03',[m
[32m+[m[32m        '\x04',[m
[32m+[m[32m        '\x05',[m
[32m+[m[32m        '\x06',[m
[32m+[m[32m        '\x07',[m
[32m+[m[32m        '\b',[m
[32m+[m[32m        '\t',[m
[32m+[m[32m        '\n',[m
[32m+[m[32m        '\x0b',[m
[32m+[m[32m        '\f',[m
[32m+[m[32m        '\r',[m
[32m+[m[32m        '\x1b',[m
[32m+[m[32m        '\x1c',[m
[32m+[m[32m        '\x1d',[m
[32m+[m[32m        '\x1e',[m
[32m+[m[32m        '\x1f',[m
[32m+[m[32m        '@',[m
[32m+[m[32m        '\\',[m
[32m+[m[32m        '^',[m
[32m+[m[32m        '_',[m
[32m+[m[32m        '`',[m
[32m+[m[32m        '|',[m
[32m+[m[32m        '~',[m
[32m+[m[32m        '\x7f'[m
[32m+[m[32m    ];[m
[32m+[m[32m    for (var i = 0; i < mixedTable.length; i++) {[m
[32m+[m[32m        CHAR_MAP[C.MODE_MIXED][StringUtils_1.default.getCharCode(mixedTable[i])] = i;[m
[32m+[m[32m    }[m
[32m+[m[32m    var punctTable = [[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        '\r',[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        '\x00',[m
[32m+[m[32m        '!',[m
[32m+[m[32m        '\'',[m
[32m+[m[32m        '#',[m
[32m+[m[32m        '$',[m
[32m+[m[32m        '%',[m
[32m+[m[32m        '&',[m
[32m+[m[32m        '\'',[m
[32m+[m[32m        '(',[m
[32m+[m[32m        ')',[m
[32m+[m[32m        '*',[m
[32m+[m[32m        '+',[m
[32m+[m[32m        ',',[m
[32m+[m[32m        '-',[m
[32m+[m[32m        '.',[m
[32m+[m[32m        '/',[m
[32m+[m[32m        ':',[m
[32m+[m[32m        ';',[m
[32m+[m[32m        '<',[m
[32m+[m[32m        '=',[m
[32m+[m[32m        '>',[m
[32m+[m[32m        '?',[m
[32m+[m[32m        '[',[m
[32m+[m[32m        ']',[m
[32m+[m[32m        '{',[m
[32m+[m[32m        '}'[m
[32m+[m[32m    ];[m
[32m+[m[32m    for (var i = 0; i < punctTable.length; i++) {[m
[32m+[m[32m        if (StringUtils_1.default.getCharCode(punctTable[i]) > 0) {[m
[32m+[m[32m            CHAR_MAP[C.MODE_PUNCT][StringUtils_1.default.getCharCode(punctTable[i])] = i;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return CHAR_MAP;[m
[32m+[m[32m}[m
[32m+[m[32mexports.static_CHAR_MAP = static_CHAR_MAP;[m
[32m+[m[32mexports.CHAR_MAP = static_CHAR_MAP(Arrays_1.default.createInt32Array(5, 256));[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..1a2c260[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.d.ts[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport AztecCode from './AztecCode';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * Generates Aztec 2D barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Encoder {[m
[32m+[m[32m    static DEFAULT_EC_PERCENT: int;[m
[32m+[m[32m    static DEFAULT_AZTEC_LAYERS: int;[m
[32m+[m[32m    private static MAX_NB_BITS;[m
[32m+[m[32m    private static MAX_NB_BITS_COMPACT;[m
[32m+[m[32m    private static WORD_SIZE;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the given binary content as an Aztec symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param data input data string[m
[32m+[m[32m     * @return Aztec symbol matrix with metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    static encodeBytes(data: Uint8Array): AztecCode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the given binary content as an Aztec symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param data input data string[m
[32m+[m[32m     * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,[m
[32m+[m[32m     *                      a minimum of 23% + 3 words is recommended)[m
[32m+[m[32m     * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers[m
[32m+[m[32m     * @return Aztec symbol matrix with metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    static encode(data: Uint8Array, minECCPercent: int, userSpecifiedLayers: int): AztecCode;[m
[32m+[m[32m    private static drawBullsEye;[m
[32m+[m[32m    static generateModeMessage(compact: boolean, layers: int, messageSizeInWords: int): BitArray;[m
[32m+[m[32m    private static drawModeMessage;[m
[32m+[m[32m    private static generateCheckWords;[m
[32m+[m[32m    private static bitsToWords;[m
[32m+[m[32m    private static getGF;[m
[32m+[m[32m    static stuffBits(bits: BitArray, wordSize: int): BitArray;[m
[32m+[m[32m    private static totalBitsInLayer;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..984b84c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Encoder.js[m
[36m@@ -0,0 +1,363 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BitArray_1 = require("../../common/BitArray");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar BitMatrix_1 = require("../../common/BitMatrix");[m
[32m+[m[32mvar AztecCode_1 = require("./AztecCode");[m
[32m+[m[32mvar ReedSolomonEncoder_1 = require("../../common/reedsolomon/ReedSolomonEncoder");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m// package com.google.zxing.aztec.encoder;[m
[32m+[m[32m// import com.google.zxing.common.BitArray;[m
[32m+[m[32m// import com.google.zxing.common.BitMatrix;[m
[32m+[m[32m// import com.google.zxing.common.reedsolomon.GenericGF;[m
[32m+[m[32m// import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;[m
[32m+[m[32m/**[m
[32m+[m[32m * Generates Aztec 2D barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mvar Encoder = /** @class */ (function () {[m
[32m+[m[32m    function Encoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the given binary content as an Aztec symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param data input data string[m
[32m+[m[32m     * @return Aztec symbol matrix with metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.encodeBytes = function (data) {[m
[32m+[m[32m        return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes the given binary content as an Aztec symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param data input data string[m
[32m+[m[32m     * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,[m
[32m+[m[32m     *                      a minimum of 23% + 3 words is recommended)[m
[32m+[m[32m     * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers[m
[32m+[m[32m     * @return Aztec symbol matrix with metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {[m
[32m+[m[32m        // High-level encode[m
[32m+[m[32m        var bits = new HighLevelEncoder_1.default(data).encode();[m
[32m+[m[32m        // stuff bits and choose symbol size[m
[32m+[m[32m        var eccBits = Integer_1.default.truncDivision((bits.getSize() * minECCPercent), 100) + 11;[m
[32m+[m[32m        var totalSizeBits = bits.getSize() + eccBits;[m
[32m+[m[32m        var compact;[m
[32m+[m[32m        var layers;[m
[32m+[m[32m        var totalBitsInLayer;[m
[32m+[m[32m        var wordSize;[m
[32m+[m[32m        var stuffedBits;[m
[32m+[m[32m        if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {[m
[32m+[m[32m            compact = userSpecifiedLayers < 0;[m
[32m+[m[32m            layers = Math.abs(userSpecifiedLayers);[m
[32m+[m[32m            if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {[m
[32m+[m[32m                throw new IllegalArgumentException_1.default(StringUtils_1.default.format('Illegal value %s for layers', userSpecifiedLayers));[m
[32m+[m[32m            }[m
[32m+[m[32m            totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);[m
[32m+[m[32m            wordSize = Encoder.WORD_SIZE[layers];[m
[32m+[m[32m            var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);[m
[32m+[m[32m            stuffedBits = Encoder.stuffBits(bits, wordSize);[m
[32m+[m[32m            if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('Data to large for user specified layer');[m
[32m+[m[32m            }[m
[32m+[m[32m            if (compact && stuffedBits.getSize() > wordSize * 64) {[m
[32m+[m[32m                // Compact format only allows 64 data words, though C4 can hold more words than that[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('Data to large for user specified layer');[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            wordSize = 0;[m
[32m+[m[32m            stuffedBits = null;[m
[32m+[m[32m            // We look at the possible table sizes in the order Compact1, Compact2, Compact3,[m
[32m+[m[32m            // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)[m
[32m+[m[32m            // is the same size, but has more data.[m
[32m+[m[32m            for (var i /*int*/ = 0;; i++) {[m
[32m+[m[32m                if (i > Encoder.MAX_NB_BITS) {[m
[32m+[m[32m                    throw new IllegalArgumentException_1.default('Data too large for an Aztec code');[m
[32m+[m[32m                }[m
[32m+[m[32m                compact = i <= 3;[m
[32m+[m[32m                layers = compact ? i + 1 : i;[m
[32m+[m[32m                totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);[m
[32m+[m[32m                if (totalSizeBits > totalBitsInLayer) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                // [Re]stuff the bits if this is the first opportunity, or if the[m
[32m+[m[32m                // wordSize has changed[m
[32m+[m[32m                if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {[m
[32m+[m[32m                    wordSize = Encoder.WORD_SIZE[layers];[m
[32m+[m[32m                    stuffedBits = Encoder.stuffBits(bits, wordSize);[m
[32m+[m[32m                }[m
[32m+[m[32m                var usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);[m
[32m+[m[32m                if (compact && stuffedBits.getSize() > wordSize * 64) {[m
[32m+[m[32m                    // Compact format only allows 64 data words, though C4 can hold more words than that[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);[m
[32m+[m[32m        // generate mode message[m
[32m+[m[32m        var messageSizeInWords = stuffedBits.getSize() / wordSize;[m
[32m+[m[32m        var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords);[m
[32m+[m[32m        // allocate symbol[m
[32m+[m[32m        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines[m
[32m+[m[32m        var alignmentMap = new Int32Array(baseMatrixSize);[m
[32m+[m[32m        var matrixSize;[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            // no alignment marks in compact mode, alignmentMap is a no-op[m
[32m+[m[32m            matrixSize = baseMatrixSize;[m
[32m+[m[32m            for (var i /*int*/ = 0; i < alignmentMap.length; i++) {[m
[32m+[m[32m                alignmentMap[i] = i;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);[m
[32m+[m[32m            var origCenter = Integer_1.default.truncDivision(baseMatrixSize, 2);[m
[32m+[m[32m            var center = Integer_1.default.truncDivision(matrixSize, 2);[m
[32m+[m[32m            for (var i /*int*/ = 0; i < origCenter; i++) {[m
[32m+[m[32m                var newOffset = i + Integer_1.default.truncDivision(i, 15);[m
[32m+[m[32m                alignmentMap[origCenter - i - 1] = center - newOffset - 1;[m
[32m+[m[32m                alignmentMap[origCenter + i] = center + newOffset + 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var matrix = new BitMatrix_1.default(matrixSize);[m
[32m+[m[32m        // draw data bits[m
[32m+[m[32m        for (var i /*int*/ = 0, rowOffset = 0; i < layers; i++) {[m
[32m+[m[32m            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);[m
[32m+[m[32m            for (var j /*int*/ = 0; j < rowSize; j++) {[m
[32m+[m[32m                var columnOffset = j * 2;[m
[32m+[m[32m                for (var k /*int*/ = 0; k < 2; k++) {[m
[32m+[m[32m                    if (messageBits.get(rowOffset + columnOffset + k)) {[m
[32m+[m[32m                        matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {[m
[32m+[m[32m                        matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {[m
[32m+[m[32m                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {[m
[32m+[m[32m                        matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            rowOffset += rowSize * 8;[m
[32m+[m[32m        }[m
[32m+[m[32m        // draw mode message[m
[32m+[m[32m        Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage);[m
[32m+[m[32m        // draw alignment marks[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            Encoder.drawBullsEye(matrix, Integer_1.default.truncDivision(matrixSize, 2), 5);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            Encoder.drawBullsEye(matrix, Integer_1.default.truncDivision(matrixSize, 2), 7);[m
[32m+[m[32m            for (var i /*int*/ = 0, j = 0; i < Integer_1.default.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {[m
[32m+[m[32m                for (var k /*int*/ = Integer_1.default.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {[m
[32m+[m[32m                    matrix.set(Integer_1.default.truncDivision(matrixSize, 2) - j, k);[m
[32m+[m[32m                    matrix.set(Integer_1.default.truncDivision(matrixSize, 2) + j, k);[m
[32m+[m[32m                    matrix.set(k, Integer_1.default.truncDivision(matrixSize, 2) - j);[m
[32m+[m[32m                    matrix.set(k, Integer_1.default.truncDivision(matrixSize, 2) + j);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var aztec = new AztecCode_1.default();[m
[32m+[m[32m        aztec.setCompact(compact);[m
[32m+[m[32m        aztec.setSize(matrixSize);[m
[32m+[m[32m        aztec.setLayers(layers);[m
[32m+[m[32m        aztec.setCodeWords(messageSizeInWords);[m
[32m+[m[32m        aztec.setMatrix(matrix);[m
[32m+[m[32m        return aztec;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.drawBullsEye = function (matrix, center, size) {[m
[32m+[m[32m        for (var i /*int*/ = 0; i < size; i += 2) {[m
[32m+[m[32m            for (var j /*int*/ = center - i; j <= center + i; j++) {[m
[32m+[m[32m                matrix.set(j, center - i);[m
[32m+[m[32m                matrix.set(j, center + i);[m
[32m+[m[32m                matrix.set(center - i, j);[m
[32m+[m[32m                matrix.set(center + i, j);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        matrix.set(center - size, center - size);[m
[32m+[m[32m        matrix.set(center - size + 1, center - size);[m
[32m+[m[32m        matrix.set(center - size, center - size + 1);[m
[32m+[m[32m        matrix.set(center + size, center - size);[m
[32m+[m[32m        matrix.set(center + size, center - size + 1);[m
[32m+[m[32m        matrix.set(center + size, center + size - 1);[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {[m
[32m+[m[32m        var modeMessage = new BitArray_1.default();[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            modeMessage.appendBits(layers - 1, 2);[m
[32m+[m[32m            modeMessage.appendBits(messageSizeInWords - 1, 6);[m
[32m+[m[32m            modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            modeMessage.appendBits(layers - 1, 5);[m
[32m+[m[32m            modeMessage.appendBits(messageSizeInWords - 1, 11);[m
[32m+[m[32m            modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);[m
[32m+[m[32m        }[m
[32m+[m[32m        return modeMessage;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {[m
[32m+[m[32m        var center = Integer_1.default.truncDivision(matrixSize, 2);[m
[32m+[m[32m        if (compact) {[m
[32m+[m[32m            for (var i /*int*/ = 0; i < 7; i++) {[m
[32m+[m[32m                var offset = center - 3 + i;[m
[32m+[m[32m                if (modeMessage.get(i)) {[m
[32m+[m[32m                    matrix.set(offset, center - 5);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(i + 7)) {[m
[32m+[m[32m                    matrix.set(center + 5, offset);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(20 - i)) {[m
[32m+[m[32m                    matrix.set(offset, center + 5);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(27 - i)) {[m
[32m+[m[32m                    matrix.set(center - 5, offset);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            for (var i /*int*/ = 0; i < 10; i++) {[m
[32m+[m[32m                var offset = center - 5 + i + Integer_1.default.truncDivision(i, 5);[m
[32m+[m[32m                if (modeMessage.get(i)) {[m
[32m+[m[32m                    matrix.set(offset, center - 7);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(i + 10)) {[m
[32m+[m[32m                    matrix.set(center + 7, offset);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(29 - i)) {[m
[32m+[m[32m                    matrix.set(offset, center + 7);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (modeMessage.get(39 - i)) {[m
[32m+[m[32m                    matrix.set(center - 7, offset);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed[m
[32m+[m[32m        var messageSizeInWords = bitArray.getSize() / wordSize;[m
[32m+[m[32m        var rs = new ReedSolomonEncoder_1.default(Encoder.getGF(wordSize));[m
[32m+[m[32m        var totalWords = Integer_1.default.truncDivision(totalBits, wordSize);[m
[32m+[m[32m        var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);[m
[32m+[m[32m        rs.encode(messageWords, totalWords - messageSizeInWords);[m
[32m+[m[32m        var startPad = totalBits % wordSize;[m
[32m+[m[32m        var messageBits = new BitArray_1.default();[m
[32m+[m[32m        messageBits.appendBits(0, startPad);[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var messageWord = _c.value /*: int*/;[m
[32m+[m[32m                messageBits.appendBits(messageWord, wordSize);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return messageBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {[m
[32m+[m[32m        var message = new Int32Array(totalWords);[m
[32m+[m[32m        var i;[m
[32m+[m[32m        var n;[m
[32m+[m[32m        for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {[m
[32m+[m[32m            var value = 0;[m
[32m+[m[32m            for (var j /*int*/ = 0; j < wordSize; j++) {[m
[32m+[m[32m                value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            message[i] = value;[m
[32m+[m[32m        }[m
[32m+[m[32m        return message;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.getGF = function (wordSize) {[m
[32m+[m[32m        switch (wordSize) {[m
[32m+[m[32m            case 4:[m
[32m+[m[32m                return GenericGF_1.default.AZTEC_PARAM;[m
[32m+[m[32m            case 6:[m
[32m+[m[32m                return GenericGF_1.default.AZTEC_DATA_6;[m
[32m+[m[32m            case 8:[m
[32m+[m[32m                return GenericGF_1.default.AZTEC_DATA_8;[m
[32m+[m[32m            case 10:[m
[32m+[m[32m                return GenericGF_1.default.AZTEC_DATA_10;[m
[32m+[m[32m            case 12:[m
[32m+[m[32m                return GenericGF_1.default.AZTEC_DATA_12;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('Unsupported word size ' + wordSize);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.stuffBits = function (bits, wordSize) {[m
[32m+[m[32m        var out = new BitArray_1.default();[m
[32m+[m[32m        var n = bits.getSize();[m
[32m+[m[32m        var mask = (1 << wordSize) - 2;[m
[32m+[m[32m        for (var i /*int*/ = 0; i < n; i += wordSize) {[m
[32m+[m[32m            var word = 0;[m
[32m+[m[32m            for (var j /*int*/ = 0; j < wordSize; j++) {[m
[32m+[m[32m                if (i + j >= n || bits.get(i + j)) {[m
[32m+[m[32m                    word |= 1 << (wordSize - 1 - j);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if ((word & mask) === mask) {[m
[32m+[m[32m                out.appendBits(word & mask, wordSize);[m
[32m+[m[32m                i--;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if ((word & mask) === 0) {[m
[32m+[m[32m                out.appendBits(word | 1, wordSize);[m
[32m+[m[32m                i--;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                out.appendBits(word, wordSize);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return out;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.totalBitsInLayer = function (layers, compact) {[m
[32m+[m[32m        return ((compact ? 88 : 112) + 16 * layers) * layers;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words[m
[32m+[m[32m    Encoder.DEFAULT_AZTEC_LAYERS = 0;[m
[32m+[m[32m    Encoder.MAX_NB_BITS = 32;[m
[32m+[m[32m    Encoder.MAX_NB_BITS_COMPACT = 4;[m
[32m+[m[32m    Encoder.WORD_SIZE = Int32Array.from([[m
[32m+[m[32m        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,[m
[32m+[m[32m        12, 12, 12, 12, 12, 12, 12, 12, 12, 12[m
[32m+[m[32m    ]);[m
[32m+[m[32m    return Encoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Encoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ea2cb60[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.d.ts[m
[36m@@ -0,0 +1,9 @@[m
[32m+[m[32mimport Token from './Token';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32mexport declare const /*final*/ MODE_NAMES: String[];[m
[32m+[m[32mexport declare const /*final*/ MODE_UPPER: int;[m
[32m+[m[32mexport declare const /*final*/ MODE_LOWER: int;[m
[32m+[m[32mexport declare const /*final*/ MODE_DIGIT: int;[m
[32m+[m[32mexport declare const /*final*/ MODE_MIXED: int;[m
[32m+[m[32mexport declare const /*final*/ MODE_PUNCT: int;[m
[32m+[m[32mexport declare const EMPTY_TOKEN: Token;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js[m
[1mnew file mode 100644[m
[1mindex 0000000..59f31b5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/EncoderConstants.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.EMPTY_TOKEN = exports.MODE_PUNCT = exports.MODE_MIXED = exports.MODE_DIGIT = exports.MODE_LOWER = exports.MODE_UPPER = exports.MODE_NAMES = void 0;[m
[32m+[m[32mvar SimpleToken_1 = require("./SimpleToken");[m
[32m+[m[32mexports.MODE_NAMES = [[m
[32m+[m[32m    'UPPER',[m
[32m+[m[32m    'LOWER',[m
[32m+[m[32m    'DIGIT',[m
[32m+[m[32m    'MIXED',[m
[32m+[m[32m    'PUNCT'[m
[32m+[m[32m];[m
[32m+[m[32mexports.MODE_UPPER = 0; // 5 bits[m
[32m+[m[32mexports.MODE_LOWER = 1; // 5 bits[m
[32m+[m[32mexports.MODE_DIGIT = 2; // 4 bits[m
[32m+[m[32mexports.MODE_MIXED = 3; // 5 bits[m
[32m+[m[32mexports.MODE_PUNCT = 4; // 5 bits[m
[32m+[m[32mexports.EMPTY_TOKEN = new SimpleToken_1.default(null, 0, 0);[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e47f2c7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32m/**[m
[32m+[m[32m * This produces nearly optimal encodings of text into the first-level of[m
[32m+[m[32m * encoding used by Aztec code.[m
[32m+[m[32m *[m
[32m+[m[32m * It uses a dynamic algorithm.  For each prefix of the string, it determines[m
[32m+[m[32m * a set of encodings that could lead to this prefix.  We repeatedly add a[m
[32m+[m[32m * character and generate a new set of optimal encodings until we have read[m
[32m+[m[32m * through the entire input.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Frank Yellin[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mexport default class HighLevelEncoder {[m
[32m+[m[32m    private text;[m
[32m+[m[32m    constructor(text: Uint8Array);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return text represented by this encoder encoded as a {@link BitArray}[m
[32m+[m[32m     */[m
[32m+[m[32m    encode(): BitArray;[m
[32m+[m[32m    private updateStateListForChar;[m
[32m+[m[32m    private updateStateForChar;[m
[32m+[m[32m    private static updateStateListForPair;[m
[32m+[m[32m    private static updateStateForPair;[m
[32m+[m[32m    private static simplifyStates;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ff22e6a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/HighLevelEncoder.js[m
[36m@@ -0,0 +1,256 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import java.util.Collection;[m
[32m+[m[32m// import java.util.Collections;[m
[32m+[m[32mvar Collections_1 = require("../../util/Collections");[m
[32m+[m[32m// import java.util.Comparator;[m
[32m+[m[32m// import java.util.Iterator;[m
[32m+[m[32m// import java.util.LinkedList;[m
[32m+[m[32mvar State_1 = require("./State");[m
[32m+[m[32mvar C = require("./EncoderConstants");[m
[32m+[m[32mvar CharMap = require("./CharMap");[m
[32m+[m[32mvar ShiftTable = require("./ShiftTable");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32m/**[m
[32m+[m[32m * This produces nearly optimal encodings of text into the first-level of[m
[32m+[m[32m * encoding used by Aztec code.[m
[32m+[m[32m *[m
[32m+[m[32m * It uses a dynamic algorithm.  For each prefix of the string, it determines[m
[32m+[m[32m * a set of encodings that could lead to this prefix.  We repeatedly add a[m
[32m+[m[32m * character and generate a new set of optimal encodings until we have read[m
[32m+[m[32m * through the entire input.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Frank Yellin[m
[32m+[m[32m * @author Rustam Abdullaev[m
[32m+[m[32m */[m
[32m+[m[32mvar HighLevelEncoder = /** @class */ (function () {[m
[32m+[m[32m    function HighLevelEncoder(text) {[m
[32m+[m[32m        this.text = text;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return text represented by this encoder encoded as a {@link BitArray}[m
[32m+[m[32m     */[m
[32m+[m[32m    HighLevelEncoder.prototype.encode = function () {[m
[32m+[m[32m        var spaceCharCode = StringUtils_1.default.getCharCode(' ');[m
[32m+[m[32m        var lineBreakCharCode = StringUtils_1.default.getCharCode('\n');[m
[32m+[m[32m        var states = Collections_1.default.singletonList(State_1.default.INITIAL_STATE);[m
[32m+[m[32m        for (var index = 0; index < this.text.length; index++) {[m
[32m+[m[32m            var pairCode = void 0;[m
[32m+[m[32m            var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;[m
[32m+[m[32m            switch (this.text[index]) {[m
[32m+[m[32m                case StringUtils_1.default.getCharCode('\r'):[m
[32m+[m[32m                    pairCode = nextChar === lineBreakCharCode ? 2 : 0;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case StringUtils_1.default.getCharCode('.'):[m
[32m+[m[32m                    pairCode = nextChar === spaceCharCode ? 3 : 0;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case StringUtils_1.default.getCharCode(','):[m
[32m+[m[32m                    pairCode = nextChar === spaceCharCode ? 4 : 0;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case StringUtils_1.default.getCharCode(':'):[m
[32m+[m[32m                    pairCode = nextChar === spaceCharCode ? 5 : 0;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                default:[m
[32m+[m[32m                    pairCode = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (pairCode > 0) {[m
[32m+[m[32m                // We have one of the four special PUNCT pairs.  Treat them specially.[m
[32m+[m[32m                // Get a new set of states for the two new characters.[m
[32m+[m[32m                states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);[m
[32m+[m[32m                index++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Get a new set of states for the new character.[m
[32m+[m[32m                states = this.updateStateListForChar(states, index);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // We are left with a set of states.  Find the shortest one.[m
[32m+[m[32m        var minState = Collections_1.default.min(states, function (a, b) {[m
[32m+[m[32m            return a.getBitCount() - b.getBitCount();[m
[32m+[m[32m        });[m
[32m+[m[32m        // Convert it to a bit array, and return.[m
[32m+[m[32m        return minState.toBitArray(this.text);[m
[32m+[m[32m    };[m
[32m+[m[32m    // We update a set of states for a new character by updating each state[m
[32m+[m[32m    // for the new character, merging the results, and then removing the[m
[32m+[m[32m    // non-optimal states.[m
[32m+[m[32m    HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var result = [];[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {[m
[32m+[m[32m                var state = states_1_1.value /*State*/;[m
[32m+[m[32m                this.updateStateForChar(state, index, result);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return HighLevelEncoder.simplifyStates(result);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Return a set of states that represent the possible ways of updating this[m
[32m+[m[32m    // state for the next character.  The resulting set of states are added to[m
[32m+[m[32m    // the "result" list.[m
[32m+[m[32m    HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {[m
[32m+[m[32m        var ch = (this.text[index] & 0xff);[m
[32m+[m[32m        var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;[m
[32m+[m[32m        var stateNoBinary = null;[m
[32m+[m[32m        for (var mode /*int*/ = 0; mode <= C.MODE_PUNCT; mode++) {[m
[32m+[m[32m            var charInMode = CharMap.CHAR_MAP[mode][ch];[m
[32m+[m[32m            if (charInMode > 0) {[m
[32m+[m[32m                if (stateNoBinary == null) {[m
[32m+[m[32m                    // Only create stateNoBinary the first time it's required.[m
[32m+[m[32m                    stateNoBinary = state.endBinaryShift(index);[m
[32m+[m[32m                }[m
[32m+[m[32m                // Try generating the character by latching to its mode[m
[32m+[m[32m                if (!charInCurrentTable ||[m
[32m+[m[32m                    mode === state.getMode() ||[m
[32m+[m[32m                    mode === C.MODE_DIGIT) {[m
[32m+[m[32m                    // If the character is in the current table, we don't want to latch to[m
[32m+[m[32m                    // any other mode except possibly digit (which uses only 4 bits).  Any[m
[32m+[m[32m                    // other latch would be equally successful *after* this character, and[m
[32m+[m[32m                    // so wouldn't save any bits.[m
[32m+[m[32m                    var latchState = stateNoBinary.latchAndAppend(mode, charInMode);[m
[32m+[m[32m                    result.push(latchState);[m
[32m+[m[32m                }[m
[32m+[m[32m                // Try generating the character by switching to its mode.[m
[32m+[m[32m                if (!charInCurrentTable &&[m
[32m+[m[32m                    ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {[m
[32m+[m[32m                    // It never makes sense to temporarily shift to another mode if the[m
[32m+[m[32m                    // character exists in the current mode.  That can never save bits.[m
[32m+[m[32m                    var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);[m
[32m+[m[32m                    result.push(shiftState);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (state.getBinaryShiftByteCount() > 0 ||[m
[32m+[m[32m            CharMap.CHAR_MAP[state.getMode()][ch] === 0) {[m
[32m+[m[32m            // It's never worthwhile to go into binary shift mode if you're not already[m
[32m+[m[32m            // in binary shift mode, and the character exists in your current mode.[m
[32m+[m[32m            // That can never save bits over just outputting the char in the current mode.[m
[32m+[m[32m            var binaryState = state.addBinaryShiftChar(index);[m
[32m+[m[32m            result.push(binaryState);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        var result = [];[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {[m
[32m+[m[32m                var state = states_2_1.value /*State*/;[m
[32m+[m[32m                this.updateStateForPair(state, index, pairCode, result);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.simplifyStates(result);[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {[m
[32m+[m[32m        var stateNoBinary = state.endBinaryShift(index);[m
[32m+[m[32m        // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code[m
[32m+[m[32m        result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));[m
[32m+[m[32m        if (state.getMode() !== C.MODE_PUNCT) {[m
[32m+[m[32m            // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.[m
[32m+[m[32m            // Every state except C.MODE_PUNCT (handled above) can shift[m
[32m+[m[32m            result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));[m
[32m+[m[32m        }[m
[32m+[m[32m        if (pairCode === 3 || pairCode === 4) {[m
[32m+[m[32m            // both characters are in DIGITS.  Sometimes better to just add two digits[m
[32m+[m[32m            var digitState = stateNoBinary[m
[32m+[m[32m                .latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT[m
[32m+[m[32m                .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT[m
[32m+[m[32m            result.push(digitState);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (state.getBinaryShiftByteCount() > 0) {[m
[32m+[m[32m            // It only makes sense to do the characters as binary if we're already[m
[32m+[m[32m            // in binary mode.[m
[32m+[m[32m            var binaryState = state[m
[32m+[m[32m                .addBinaryShiftChar(index)[m
[32m+[m[32m                .addBinaryShiftChar(index + 1);[m
[32m+[m[32m            result.push(binaryState);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.simplifyStates = function (states) {[m
[32m+[m[32m        var e_3, _a, e_4, _b;[m
[32m+[m[32m        var result = [];[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {[m
[32m+[m[32m                var newState = states_3_1.value;[m
[32m+[m[32m                var add = true;[m
[32m+[m[32m                var _loop_1 = function (oldState) {[m
[32m+[m[32m                    if (oldState.isBetterThanOrEqualTo(newState)) {[m
[32m+[m[32m                        add = false;[m
[32m+[m[32m                        return "break";[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (newState.isBetterThanOrEqualTo(oldState)) {[m
[32m+[m[32m                        // iterator.remove();[m
[32m+[m[32m                        result = result.filter(function (x) { return x !== oldState; }); // remove old state[m
[32m+[m[32m                    }[m
[32m+[m[32m                };[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {[m
[32m+[m[32m                        var oldState = result_1_1.value;[m
[32m+[m[32m                        var state_1 = _loop_1(oldState);[m
[32m+[m[32m                        if (state_1 === "break")[m
[32m+[m[32m                            break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (add) {[m
[32m+[m[32m                    result.push(newState);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return HighLevelEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = HighLevelEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..747dfa3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.d.ts[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mexport declare const LATCH_TABLE: Int32Array[];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e841df8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/LatchTable.js[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.LATCH_TABLE = void 0;[m
[32m+[m[32m// The Latch Table shows, for each pair of Modes, the optimal method for[m
[32m+[m[32m// getting from one mode to another.  In the worst possible case, this can[m
[32m+[m[32m// be up to 14 bits.  In the best possible case, we are already there![m
[32m+[m[32m// The high half-word of each entry gives the number of bits.[m
[32m+[m[32m// The low half-word of each entry are the actual bits necessary to change[m
[32m+[m[32mexports.LATCH_TABLE = [[m
[32m+[m[32m    Int32Array.from([[m
[32m+[m[32m        0,[m
[32m+[m[32m        (5 << 16) + 28,[m
[32m+[m[32m        (5 << 16) + 30,[m
[32m+[m[32m        (5 << 16) + 29,[m
[32m+[m[32m        (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT[m
[32m+[m[32m    ]),[m
[32m+[m[32m    Int32Array.from([[m
[32m+[m[32m        (9 << 16) + (30 << 4) + 14,[m
[32m+[m[32m        0,[m
[32m+[m[32m        (5 << 16) + 30,[m
[32m+[m[32m        (5 << 16) + 29,[m
[32m+[m[32m        (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT[m
[32m+[m[32m    ]),[m
[32m+[m[32m    Int32Array.from([[m
[32m+[m[32m        (4 << 16) + 14,[m
[32m+[m[32m        (9 << 16) + (14 << 5) + 28,[m
[32m+[m[32m        0,[m
[32m+[m[32m        (9 << 16) + (14 << 5) + 29,[m
[32m+[m[32m        (14 << 16) + (14 << 10) + (29 << 5) + 30[m
[32m+[m[32m        // DIGIT -> UPPER -> MIXED -> PUNCT[m
[32m+[m[32m    ]),[m
[32m+[m[32m    Int32Array.from([[m
[32m+[m[32m        (5 << 16) + 29,[m
[32m+[m[32m        (5 << 16) + 28,[m
[32m+[m[32m        (10 << 16) + (29 << 5) + 30,[m
[32m+[m[32m        0,[m
[32m+[m[32m        (5 << 16) + 30 // MIXED -> PUNCT[m
[32m+[m[32m    ]),[m
[32m+[m[32m    Int32Array.from([[m
[32m+[m[32m        (5 << 16) + 31,[m
[32m+[m[32m        (10 << 16) + (31 << 5) + 28,[m
[32m+[m[32m        (10 << 16) + (31 << 5) + 30,[m
[32m+[m[32m        (10 << 16) + (31 << 5) + 29,[m
[32m+[m[32m        0[m
[32m+[m[32m    ])[m
[32m+[m[32m];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9d84d5f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.d.ts[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32mexport declare function static_SHIFT_TABLE(SHIFT_TABLE: Int32Array[]): Int32Array[];[m
[32m+[m[32mexport declare const /*final*/ SHIFT_TABLE: Int32Array[];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ef9fa70[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/ShiftTable.js[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.SHIFT_TABLE = exports.static_SHIFT_TABLE = void 0;[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar C = require("./EncoderConstants");[m
[32m+[m[32mfunction static_SHIFT_TABLE(SHIFT_TABLE) {[m
[32m+[m[32m    var e_1, _a;[m
[32m+[m[32m    try {[m
[32m+[m[32m        for (var SHIFT_TABLE_1 = __values(SHIFT_TABLE), SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next(); !SHIFT_TABLE_1_1.done; SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next()) {[m
[32m+[m[32m            var table = SHIFT_TABLE_1_1.value /*Int32Array*/;[m
[32m+[m[32m            Arrays_1.default.fill(table, -1);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m    finally {[m
[32m+[m[32m        try {[m
[32m+[m[32m            if (SHIFT_TABLE_1_1 && !SHIFT_TABLE_1_1.done && (_a = SHIFT_TABLE_1.return)) _a.call(SHIFT_TABLE_1);[m
[32m+[m[32m        }[m
[32m+[m[32m        finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m    }[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_UPPER][C.MODE_PUNCT] = 0;[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_LOWER][C.MODE_PUNCT] = 0;[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_LOWER][C.MODE_UPPER] = 28;[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_MIXED][C.MODE_PUNCT] = 0;[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_DIGIT][C.MODE_PUNCT] = 0;[m
[32m+[m[32m    SHIFT_TABLE[C.MODE_DIGIT][C.MODE_UPPER] = 15;[m
[32m+[m[32m    return SHIFT_TABLE;[m
[32m+[m[32m}[m
[32m+[m[32mexports.static_SHIFT_TABLE = static_SHIFT_TABLE;[m
[32m+[m[32mexports.SHIFT_TABLE = static_SHIFT_TABLE(Arrays_1.default.createInt32Array(6, 6)); // mode shift codes, per table[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..14952ce[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport Token from './Token';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32mexport default class SimpleToken extends Token {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private bitCount;[m
[32m+[m[32m    constructor(previous: Token, value: int, bitCount: int);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    appendTo(bitArray: BitArray, text: Uint8Array): void;[m
[32m+[m[32m    add(value: int, bitCount: int): Token;[m
[32m+[m[32m    addBinaryShift(start: int, byteCount: int): Token;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ff24d6b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/SimpleToken.js[m
[36m@@ -0,0 +1,65 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Token_1 = require("./Token");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar SimpleToken = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(SimpleToken, _super);[m
[32m+[m[32m    function SimpleToken(previous, value, bitCount) {[m
[32m+[m[32m        var _this = _super.call(this, previous) || this;[m
[32m+[m[32m        _this.value = value;[m
[32m+[m[32m        _this.bitCount = bitCount;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    SimpleToken.prototype.appendTo = function (bitArray, text) {[m
[32m+[m[32m        bitArray.appendBits(this.value, this.bitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    SimpleToken.prototype.add = function (value, bitCount) {[m
[32m+[m[32m        return new SimpleToken(this, value, bitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    SimpleToken.prototype.addBinaryShift = function (start, byteCount) {[m
[32m+[m[32m        // no-op can't binary shift a simple token[m
[32m+[m[32m        console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');[m
[32m+[m[32m        return new SimpleToken(this, start, byteCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    SimpleToken.prototype.toString = function () {[m
[32m+[m[32m        var value = this.value & ((1 << this.bitCount) - 1);[m
[32m+[m[32m        value |= 1 << this.bitCount;[m
[32m+[m[32m        return '<' + Integer_1.default.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';[m
[32m+[m[32m    };[m
[32m+[m[32m    return SimpleToken;[m
[32m+[m[32m}(Token_1.default));[m
[32m+[m[32mexports.default = SimpleToken;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..fcc2a15[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.d.ts[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport Token from './Token';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * State represents all information about a sequence necessary to generate the current output.[m
[32m+[m[32m * Note that a state is immutable.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class State {[m
[32m+[m[32m    static INITIAL_STATE: State;[m
[32m+[m[32m    private mode;[m
[32m+[m[32m    private token;[m
[32m+[m[32m    private binaryShiftByteCount;[m
[32m+[m[32m    private bitCount;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    getMode(): int;[m
[32m+[m[32m    getToken(): Token;[m
[32m+[m[32m    getBinaryShiftByteCount(): int;[m
[32m+[m[32m    getBitCount(): int;[m
[32m+[m[32m    latchAndAppend(mode: int, value: int): State;[m
[32m+[m[32m    shiftAndAppend(mode: int, value: int): State;[m
[32m+[m[32m    addBinaryShiftChar(index: int): State;[m
[32m+[m[32m    endBinaryShift(index: int): State;[m
[32m+[m[32m    isBetterThanOrEqualTo(other: State): boolean;[m
[32m+[m[32m    toBitArray(text: Uint8Array): BitArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m    private static calculateBinaryShiftCost;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js[m
[1mnew file mode 100644[m
[1mindex 0000000..69c7e81[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/State.js[m
[36m@@ -0,0 +1,194 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.aztec.encoder;[m
[32m+[m[32m// import java.util.Deque;[m
[32m+[m[32m// import java.util.LinkedList;[m
[32m+[m[32m// import com.google.zxing.common.BitArray;[m
[32m+[m[32mvar BitArray_1 = require("../../common/BitArray");[m
[32m+[m[32mvar TokenHelpers = require("./TokenHelpers");[m
[32m+[m[32mvar C = require("./EncoderConstants");[m
[32m+[m[32mvar LatchTable = require("./LatchTable");[m
[32m+[m[32mvar ShiftTable = require("./ShiftTable");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32m/**[m
[32m+[m[32m * State represents all information about a sequence necessary to generate the current output.[m
[32m+[m[32m * Note that a state is immutable.[m
[32m+[m[32m */[m
[32m+[m[32mvar State = /** @class */ (function () {[m
[32m+[m[32m    function State(token, mode, binaryBytes, bitCount) {[m
[32m+[m[32m        this.token = token;[m
[32m+[m[32m        this.mode = mode;[m
[32m+[m[32m        this.binaryShiftByteCount = binaryBytes;[m
[32m+[m[32m        this.bitCount = bitCount;[m
[32m+[m[32m        // Make sure we match the token[m
[32m+[m[32m        // int binaryShiftBitCount = (binaryShiftByteCount * 8) +[m
[32m+[m[32m        //    (binaryShiftByteCount === 0 ? 0 :[m
[32m+[m[32m        //     binaryShiftByteCount <= 31 ? 10 :[m
[32m+[m[32m        //     binaryShiftByteCount <= 62 ? 20 : 21);[m
[32m+[m[32m        // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;[m
[32m+[m[32m    }[m
[32m+[m[32m    State.prototype.getMode = function () {[m
[32m+[m[32m        return this.mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    State.prototype.getToken = function () {[m
[32m+[m[32m        return this.token;[m
[32m+[m[32m    };[m
[32m+[m[32m    State.prototype.getBinaryShiftByteCount = function () {[m
[32m+[m[32m        return this.binaryShiftByteCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    State.prototype.getBitCount = function () {[m
[32m+[m[32m        return this.bitCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Create a new state representing this state with a latch to a (not[m
[32m+[m[32m    // necessary different) mode, and then a code.[m
[32m+[m[32m    State.prototype.latchAndAppend = function (mode, value) {[m
[32m+[m[32m        // assert binaryShiftByteCount === 0;[m
[32m+[m[32m        var bitCount = this.bitCount;[m
[32m+[m[32m        var token = this.token;[m
[32m+[m[32m        if (mode !== this.mode) {[m
[32m+[m[32m            var latch = LatchTable.LATCH_TABLE[this.mode][mode];[m
[32m+[m[32m            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);[m
[32m+[m[32m            bitCount += latch >> 16;[m
[32m+[m[32m        }[m
[32m+[m[32m        var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;[m
[32m+[m[32m        token = TokenHelpers.add(token, value, latchModeBitCount);[m
[32m+[m[32m        return new State(token, mode, 0, bitCount + latchModeBitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Create a new state representing this state, with a temporary shift[m
[32m+[m[32m    // to a different mode to output a single value.[m
[32m+[m[32m    State.prototype.shiftAndAppend = function (mode, value) {[m
[32m+[m[32m        // assert binaryShiftByteCount === 0 && this.mode !== mode;[m
[32m+[m[32m        var token = this.token;[m
[32m+[m[32m        var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5;[m
[32m+[m[32m        // Shifts exist only to UPPER and PUNCT, both with tokens size 5.[m
[32m+[m[32m        token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);[m
[32m+[m[32m        token = TokenHelpers.add(token, value, 5);[m
[32m+[m[32m        return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Create a new state representing this state, but an additional character[m
[32m+[m[32m    // output in Binary Shift mode.[m
[32m+[m[32m    State.prototype.addBinaryShiftChar = function (index) {[m
[32m+[m[32m        var token = this.token;[m
[32m+[m[32m        var mode = this.mode;[m
[32m+[m[32m        var bitCount = this.bitCount;[m
[32m+[m[32m        if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {[m
[32m+[m[32m            // assert binaryShiftByteCount === 0;[m
[32m+[m[32m            var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];[m
[32m+[m[32m            token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);[m
[32m+[m[32m            bitCount += latch >> 16;[m
[32m+[m[32m            mode = C.MODE_UPPER;[m
[32m+[m[32m        }[m
[32m+[m[32m        var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31[m
[32m+[m[32m            ? 18[m
[32m+[m[32m            : this.binaryShiftByteCount === 62[m
[32m+[m[32m                ? 9[m
[32m+[m[32m                : 8;[m
[32m+[m[32m        var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);[m
[32m+[m[32m        if (result.binaryShiftByteCount === 2047 + 31) {[m
[32m+[m[32m            // The string is as long as it's allowed to be.  We should end it.[m
[32m+[m[32m            result = result.endBinaryShift(index + 1);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Create the state identical to this one, but we are no longer in[m
[32m+[m[32m    // Binary Shift mode.[m
[32m+[m[32m    State.prototype.endBinaryShift = function (index) {[m
[32m+[m[32m        if (this.binaryShiftByteCount === 0) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        var token = this.token;[m
[32m+[m[32m        token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);[m
[32m+[m[32m        // assert token.getTotalBitCount() === this.bitCount;[m
[32m+[m[32m        return new State(token, this.mode, 0, this.bitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Returns true if "this" state is better (equal: or) to be in than "that"[m
[32m+[m[32m    // state under all possible circumstances.[m
[32m+[m[32m    State.prototype.isBetterThanOrEqualTo = function (other) {[m
[32m+[m[32m        var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);[m
[32m+[m[32m        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {[m
[32m+[m[32m            // add additional B/S encoding cost of other, if any[m
[32m+[m[32m            newModeBitCount +=[m
[32m+[m[32m                State.calculateBinaryShiftCost(other) -[m
[32m+[m[32m                    State.calculateBinaryShiftCost(this);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&[m
[32m+[m[32m            other.binaryShiftByteCount > 0) {[m
[32m+[m[32m            // maximum possible additional cost (it: h)[m
[32m+[m[32m            newModeBitCount += 10;[m
[32m+[m[32m        }[m
[32m+[m[32m        return newModeBitCount <= other.bitCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    State.prototype.toBitArray = function (text) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        // Reverse the tokens, so that they are in the order that they should[m
[32m+[m[32m        // be output[m
[32m+[m[32m        var symbols = [];[m
[32m+[m[32m        for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {[m
[32m+[m[32m            symbols.unshift(token);[m
[32m+[m[32m        }[m
[32m+[m[32m        var bitArray = new BitArray_1.default();[m
[32m+[m[32m        try {[m
[32m+[m[32m            // Add each token to the result.[m
[32m+[m[32m            for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {[m
[32m+[m[32m                var symbol = symbols_1_1.value;[m
[32m+[m[32m                symbol.appendTo(bitArray, text);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // assert bitArray.getSize() === this.bitCount;[m
[32m+[m[32m        return bitArray;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @Override[m
[32m+[m[32m     */[m
[32m+[m[32m    State.prototype.toString = function () {[m
[32m+[m[32m        return StringUtils_1.default.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    State.calculateBinaryShiftCost = function (state) {[m
[32m+[m[32m        if (state.binaryShiftByteCount > 62) {[m
[32m+[m[32m            return 21; // B/S with extended length[m
[32m+[m[32m        }[m
[32m+[m[32m        if (state.binaryShiftByteCount > 31) {[m
[32m+[m[32m            return 20; // two B/S[m
[32m+[m[32m        }[m
[32m+[m[32m        if (state.binaryShiftByteCount > 0) {[m
[32m+[m[32m            return 10; // one B/S[m
[32m+[m[32m        }[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);[m
[32m+[m[32m    return State;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = State;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ccc2a48[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32mexport default abstract class Token {[m
[32m+[m[32m    private previous;[m
[32m+[m[32m    constructor(previous: Token);[m
[32m+[m[32m    getPrevious(): Token;[m
[32m+[m[32m    abstract add(value: int, bitCount: int): Token;[m
[32m+[m[32m    abstract addBinaryShift(start: int, byteCount: int): Token;[m
[32m+[m[32m    abstract appendTo(bitArray: BitArray, text: Uint8Array): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js[m
[1mnew file mode 100644[m
[1mindex 0000000..aa2f6bc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/Token.js[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Token = /** @class */ (function () {[m
[32m+[m[32m    function Token(previous) {[m
[32m+[m[32m        this.previous = previous;[m
[32m+[m[32m    }[m
[32m+[m[32m    Token.prototype.getPrevious = function () {[m
[32m+[m[32m        return this.previous;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Token;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Token;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.d.ts b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4c5297b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.d.ts[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mimport Token from './Token';[m
[32m+[m[32mexport declare function addBinaryShift(token: Token, start: number, byteCount: number): Token;[m
[32m+[m[32mexport declare function add(token: Token, value: number, bitCount: number): Token;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0f3b49f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/aztec/encoder/TokenHelpers.js[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.add = exports.addBinaryShift = void 0;[m
[32m+[m[32mvar SimpleToken_1 = require("./SimpleToken");[m
[32m+[m[32mvar BinaryShiftToken_1 = require("./BinaryShiftToken");[m
[32m+[m[32mfunction addBinaryShift(token, start, byteCount) {[m
[32m+[m[32m    // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);[m
[32m+[m[32m    return new BinaryShiftToken_1.default(token, start, byteCount);[m
[32m+[m[32m}[m
[32m+[m[32mexports.addBinaryShift = addBinaryShift;[m
[32m+[m[32mfunction add(token, value, bitCount) {[m
[32m+[m[32m    return new SimpleToken_1.default(token, value, bitCount);[m
[32m+[m[32m}[m
[32m+[m[32mexports.add = add;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..dc6633f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.d.ts[m
[36m@@ -0,0 +1,111 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BitArray {[m
[32m+[m[32m    private size;[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    constructor(size?: number, bits?: Int32Array);[m
[32m+[m[32m    getSize(): number;[m
[32m+[m[32m    getSizeInBytes(): number;[m
[32m+[m[32m    private ensureCapacity;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param i bit to get[m
[32m+[m[32m     * @return true iff bit i is set[m
[32m+[m[32m     */[m
[32m+[m[32m    get(i: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i bit to set[m
[32m+[m[32m     */[m
[32m+[m[32m    set(i: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Flips bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i bit to set[m
[32m+[m[32m     */[m
[32m+[m[32m    flip(i: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param from first bit to check[m
[32m+[m[32m     * @return index of first bit that is set, starting from the given index, or size if none are set[m
[32m+[m[32m     *  at or beyond this given index[m
[32m+[m[32m     * @see #getNextUnset(int)[m
[32m+[m[32m     */[m
[32m+[m[32m    getNextSet(from: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param from index to start looking for unset bit[m
[32m+[m[32m     * @return index of next unset bit, or {@code size} if none are unset until the end[m
[32m+[m[32m     * @see #getNextSet(int)[m
[32m+[m[32m     */[m
[32m+[m[32m    getNextUnset(from: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a block of 32 bits, starting at bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i first bit to set[m
[32m+[m[32m     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit[m
[32m+[m[32m     * corresponds to bit i, the next-least-significant to i+1, and so on.[m
[32m+[m[32m     */[m
[32m+[m[32m    setBulk(i: number, newBits: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a range of bits.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param start start of range, inclusive.[m
[32m+[m[32m     * @param end end of range, exclusive[m
[32m+[m[32m     */[m
[32m+[m[32m    setRange(start: number, end: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Clears all bits (sets to false).[m
[32m+[m[32m     */[m
[32m+[m[32m    clear(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Efficient method to check if a range of bits is set, or not set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param start start of range, inclusive.[m
[32m+[m[32m     * @param end end of range, exclusive[m
[32m+[m[32m     * @param value if true, checks that bits in range are set, otherwise checks that they are not set[m
[32m+[m[32m     * @return true iff all bits are set or not set in range, according to value argument[m
[32m+[m[32m     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array[m
[32m+[m[32m     */[m
[32m+[m[32m    isRange(start: number, end: number, value: boolean): boolean;[m
[32m+[m[32m    appendBit(bit: boolean): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Appends the least-significant bits, from value, in order from most-significant to[m
[32m+[m[32m     * least-significant. For example, appending 6 bits from 0x000001E will append the bits[m
[32m+[m[32m     * 0, 1, 1, 1, 1, 0 in that order.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param value {@code int} containing bits to append[m
[32m+[m[32m     * @param numBits bits from value to append[m
[32m+[m[32m     */[m
[32m+[m[32m    appendBits(value: number, numBits: number): void;[m
[32m+[m[32m    appendBitArray(other: BitArray): void;[m
[32m+[m[32m    xor(other: BitArray): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitOffset first bit to start writing[m
[32m+[m[32m     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite[m
[32m+[m[32m     *  of the internal representation, which is exposed by {@link #getBitArray()}[m
[32m+[m[32m     * @param offset position in array to start writing[m
[32m+[m[32m     * @param numBytes how many bytes to write[m
[32m+[m[32m     */[m
[32m+[m[32m    toBytes(bitOffset: number, array: Uint8Array, offset: number, numBytes: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return underlying array of ints. The first element holds the first 32 bits, and the least[m
[32m+[m[32m     *         significant bit is bit 0.[m
[32m+[m[32m     */[m
[32m+[m[32m    getBitArray(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reverses all bits in the array.[m
[32m+[m[32m     */[m
[32m+[m[32m    reverse(): void;[m
[32m+[m[32m    private static makeArray;[m
[32m+[m[32m    equals(o: any): boolean;[m
[32m+[m[32m    hashCode(): number;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    clone(): BitArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * converts to boolean array.[m
[32m+[m[32m     */[m
[32m+[m[32m    toArray(): Array<boolean>;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.js b/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9ecb446[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitArray.js[m
[36m@@ -0,0 +1,369 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32m/*import java.util.Arrays;*/[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32mvar Arrays_1 = require("../util/Arrays");[m
[32m+[m[32mvar Integer_1 = require("../util/Integer");[m
[32m+[m[32mvar System_1 = require("../util/System");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar BitArray /*implements Cloneable*/ = /** @class */ (function () {[m
[32m+[m[32m    // public constructor() {[m
[32m+[m[32m    //   this.size = 0[m
[32m+[m[32m    //   this.bits = new Int32Array(1)[m
[32m+[m[32m    // }[m
[32m+[m[32m    // public constructor(size?: number /*int*/) {[m
[32m+[m[32m    //   if (undefined === size) {[m
[32m+[m[32m    //     this.size = 0[m
[32m+[m[32m    //   } else {[m
[32m+[m[32m    //     this.size = size[m
[32m+[m[32m    //   }[m
[32m+[m[32m    //   this.bits = this.makeArray(size)[m
[32m+[m[32m    // }[m
[32m+[m[32m    // For testing only[m
[32m+[m[32m    function BitArray(size /*int*/, bits) {[m
[32m+[m[32m        if (undefined === size) {[m
[32m+[m[32m            this.size = 0;[m
[32m+[m[32m            this.bits = new Int32Array(1);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.size = size;[m
[32m+[m[32m            if (undefined === bits || null === bits) {[m
[32m+[m[32m                this.bits = BitArray.makeArray(size);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.bits = bits;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    BitArray.prototype.getSize = function () {[m
[32m+[m[32m        return this.size;[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.prototype.getSizeInBytes = function () {[m
[32m+[m[32m        return Math.floor((this.size + 7) / 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.prototype.ensureCapacity = function (size /*int*/) {[m
[32m+[m[32m        if (size > this.bits.length * 32) {[m
[32m+[m[32m            var newBits = BitArray.makeArray(size);[m
[32m+[m[32m            System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);[m
[32m+[m[32m            this.bits = newBits;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param i bit to get[m
[32m+[m[32m     * @return true iff bit i is set[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.get = function (i /*int*/) {[m
[32m+[m[32m        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i bit to set[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.set = function (i /*int*/) {[m
[32m+[m[32m        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Flips bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i bit to set[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.flip = function (i /*int*/) {[m
[32m+[m[32m        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param from first bit to check[m
[32m+[m[32m     * @return index of first bit that is set, starting from the given index, or size if none are set[m
[32m+[m[32m     *  at or beyond this given index[m
[32m+[m[32m     * @see #getNextUnset(int)[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.getNextSet = function (from /*int*/) {[m
[32m+[m[32m        var size = this.size;[m
[32m+[m[32m        if (from >= size) {[m
[32m+[m[32m            return size;[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var bitsOffset = Math.floor(from / 32);[m
[32m+[m[32m        var currentBits = bits[bitsOffset];[m
[32m+[m[32m        // mask off lesser bits first[m
[32m+[m[32m        currentBits &= ~((1 << (from & 0x1F)) - 1);[m
[32m+[m[32m        var length = bits.length;[m
[32m+[m[32m        while (currentBits === 0) {[m
[32m+[m[32m            if (++bitsOffset === length) {[m
[32m+[m[32m                return size;[m
[32m+[m[32m            }[m
[32m+[m[32m            currentBits = bits[bitsOffset];[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);[m
[32m+[m[32m        return result > size ? size : result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param from index to start looking for unset bit[m
[32m+[m[32m     * @return index of next unset bit, or {@code size} if none are unset until the end[m
[32m+[m[32m     * @see #getNextSet(int)[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.getNextUnset = function (from /*int*/) {[m
[32m+[m[32m        var size = this.size;[m
[32m+[m[32m        if (from >= size) {[m
[32m+[m[32m            return size;[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var bitsOffset = Math.floor(from / 32);[m
[32m+[m[32m        var currentBits = ~bits[bitsOffset];[m
[32m+[m[32m        // mask off lesser bits first[m
[32m+[m[32m        currentBits &= ~((1 << (from & 0x1F)) - 1);[m
[32m+[m[32m        var length = bits.length;[m
[32m+[m[32m        while (currentBits === 0) {[m
[32m+[m[32m            if (++bitsOffset === length) {[m
[32m+[m[32m                return size;[m
[32m+[m[32m            }[m
[32m+[m[32m            currentBits = ~bits[bitsOffset];[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);[m
[32m+[m[32m        return result > size ? size : result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a block of 32 bits, starting at bit i.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param i first bit to set[m
[32m+[m[32m     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit[m
[32m+[m[32m     * corresponds to bit i, the next-least-significant to i+1, and so on.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {[m
[32m+[m[32m        this.bits[Math.floor(i / 32)] = newBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets a range of bits.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param start start of range, inclusive.[m
[32m+[m[32m     * @param end end of range, exclusive[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {[m
[32m+[m[32m        if (end < start || start < 0 || end > this.size) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (end === start) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        end--; // will be easier to treat this as the last actually set bit -- inclusive[m
[32m+[m[32m        var firstInt = Math.floor(start / 32);[m
[32m+[m[32m        var lastInt = Math.floor(end / 32);[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var i = firstInt; i <= lastInt; i++) {[m
[32m+[m[32m            var firstBit = i > firstInt ? 0 : start & 0x1F;[m
[32m+[m[32m            var lastBit = i < lastInt ? 31 : end & 0x1F;[m
[32m+[m[32m            // Ones from firstBit to lastBit, inclusive[m
[32m+[m[32m            var mask = (2 << lastBit) - (1 << firstBit);[m
[32m+[m[32m            bits[i] |= mask;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Clears all bits (sets to false).[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.clear = function () {[m
[32m+[m[32m        var max = this.bits.length;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var i = 0; i < max; i++) {[m
[32m+[m[32m            bits[i] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Efficient method to check if a range of bits is set, or not set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param start start of range, inclusive.[m
[32m+[m[32m     * @param end end of range, exclusive[m
[32m+[m[32m     * @param value if true, checks that bits in range are set, otherwise checks that they are not set[m
[32m+[m[32m     * @return true iff all bits are set or not set in range, according to value argument[m
[32m+[m[32m     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {[m
[32m+[m[32m        if (end < start || start < 0 || end > this.size) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (end === start) {[m
[32m+[m[32m            return true; // empty range matches[m
[32m+[m[32m        }[m
[32m+[m[32m        end--; // will be easier to treat this as the last actually set bit -- inclusive[m
[32m+[m[32m        var firstInt = Math.floor(start / 32);[m
[32m+[m[32m        var lastInt = Math.floor(end / 32);[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var i = firstInt; i <= lastInt; i++) {[m
[32m+[m[32m            var firstBit = i > firstInt ? 0 : start & 0x1F;[m
[32m+[m[32m            var lastBit = i < lastInt ? 31 : end & 0x1F;[m
[32m+[m[32m            // Ones from firstBit to lastBit, inclusive[m
[32m+[m[32m            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;[m
[32m+[m[32m            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits[m
[32m+[m[32m            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,[m
[32m+[m[32m            // equals the mask, or we're looking for 0s and the masked portion is not all 0s[m
[32m+[m[32m            if ((bits[i] & mask) !== (value ? mask : 0)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.prototype.appendBit = function (bit) {[m
[32m+[m[32m        this.ensureCapacity(this.size + 1);[m
[32m+[m[32m        if (bit) {[m
[32m+[m[32m            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.size++;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Appends the least-significant bits, from value, in order from most-significant to[m
[32m+[m[32m     * least-significant. For example, appending 6 bits from 0x000001E will append the bits[m
[32m+[m[32m     * 0, 1, 1, 1, 1, 0 in that order.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param value {@code int} containing bits to append[m
[32m+[m[32m     * @param numBits bits from value to append[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {[m
[32m+[m[32m        if (numBits < 0 || numBits > 32) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');[m
[32m+[m[32m        }[m
[32m+[m[32m        this.ensureCapacity(this.size + numBits);[m
[32m+[m[32m        // const appendBit = this.appendBit;[m
[32m+[m[32m        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {[m
[32m+[m[32m            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.prototype.appendBitArray = function (other) {[m
[32m+[m[32m        var otherSize = other.size;[m
[32m+[m[32m        this.ensureCapacity(this.size + otherSize);[m
[32m+[m[32m        // const appendBit = this.appendBit;[m
[32m+[m[32m        for (var i = 0; i < otherSize; i++) {[m
[32m+[m[32m            this.appendBit(other.get(i));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.prototype.xor = function (other) {[m
[32m+[m[32m        if (this.size !== other.size) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Sizes don\'t match');[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var i = 0, length_1 = bits.length; i < length_1; i++) {[m
[32m+[m[32m            // The last int could be incomplete (i.e. not have 32 bits in[m
[32m+[m[32m            // it) but there is no problem since 0 XOR 0 == 0.[m
[32m+[m[32m            bits[i] ^= other.bits[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitOffset first bit to start writing[m
[32m+[m[32m     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite[m
[32m+[m[32m     *  of the internal representation, which is exposed by {@link #getBitArray()}[m
[32m+[m[32m     * @param offset position in array to start writing[m
[32m+[m[32m     * @param numBytes how many bytes to write[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {[m
[32m+[m[32m        for (var i = 0; i < numBytes; i++) {[m
[32m+[m[32m            var theByte = 0;[m
[32m+[m[32m            for (var j = 0; j < 8; j++) {[m
[32m+[m[32m                if (this.get(bitOffset)) {[m
[32m+[m[32m                    theByte |= 1 << (7 - j);[m
[32m+[m[32m                }[m
[32m+[m[32m                bitOffset++;[m
[32m+[m[32m            }[m
[32m+[m[32m            array[offset + i] = /*(byte)*/ theByte;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return underlying array of ints. The first element holds the first 32 bits, and the least[m
[32m+[m[32m     *         significant bit is bit 0.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.getBitArray = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Reverses all bits in the array.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.reverse = function () {[m
[32m+[m[32m        var newBits = new Int32Array(this.bits.length);[m
[32m+[m[32m        // reverse all int's first[m
[32m+[m[32m        var len = Math.floor((this.size - 1) / 32);[m
[32m+[m[32m        var oldBitsLen = len + 1;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var i = 0; i < oldBitsLen; i++) {[m
[32m+[m[32m            var x = bits[i];[m
[32m+[m[32m            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);[m
[32m+[m[32m            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);[m
[32m+[m[32m            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);[m
[32m+[m[32m            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);[m
[32m+[m[32m            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);[m
[32m+[m[32m            newBits[len - i] = /*(int)*/ x;[m
[32m+[m[32m        }[m
[32m+[m[32m        // now correct the int's if the bit size isn't a multiple of 32[m
[32m+[m[32m        if (this.size !== oldBitsLen * 32) {[m
[32m+[m[32m            var leftOffset = oldBitsLen * 32 - this.size;[m
[32m+[m[32m            var currentInt = newBits[0] >>> leftOffset;[m
[32m+[m[32m            for (var i = 1; i < oldBitsLen; i++) {[m
[32m+[m[32m                var nextInt = newBits[i];[m
[32m+[m[32m                currentInt |= nextInt << (32 - leftOffset);[m
[32m+[m[32m                newBits[i - 1] = currentInt;[m
[32m+[m[32m                currentInt = nextInt >>> leftOffset;[m
[32m+[m[32m            }[m
[32m+[m[32m            newBits[oldBitsLen - 1] = currentInt;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bits = newBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    BitArray.makeArray = function (size /*int*/) {[m
[32m+[m[32m        return new Int32Array(Math.floor((size + 31) / 32));[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitArray.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof BitArray)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitArray.prototype.hashCode = function () {[m
[32m+[m[32m        return 31 * this.size + Arrays_1.default.hashCode(this.bits);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitArray.prototype.toString = function () {[m
[32m+[m[32m        var result = '';[m
[32m+[m[32m        for (var i = 0, size = this.size; i < size; i++) {[m
[32m+[m[32m            if ((i & 0x07) === 0) {[m
[32m+[m[32m                result += ' ';[m
[32m+[m[32m            }[m
[32m+[m[32m            result += this.get(i) ? 'X' : '.';[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitArray.prototype.clone = function () {[m
[32m+[m[32m        return new BitArray(this.size, this.bits.slice());[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * converts to boolean array.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitArray.prototype.toArray = function () {[m
[32m+[m[32m        var result = [];[m
[32m+[m[32m        for (var i = 0, size = this.size; i < size; i++) {[m
[32m+[m[32m            result.push(this.get(i));[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitArray;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitArray;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..31fc510[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.d.ts[m
[36m@@ -0,0 +1,157 @@[m
[32m+[m[32mimport BitArray from './BitArray';[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common[m
[32m+[m[32m * module, x is the column position, and y is the row position. The ordering is always x, y.[m
[32m+[m[32m * The origin is at the top-left.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins[m
[32m+[m[32m * with a new int. This is done intentionally so that we can copy out a row into a BitArray very[m
[32m+[m[32m * efficiently.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,[m
[32m+[m[32m * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BitMatrix {[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private height?;[m
[32m+[m[32m    private rowSize?;[m
[32m+[m[32m    private bits?;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an empty square {@link BitMatrix}.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param dimension height and width[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an empty {@link BitMatrix}.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param width bit matrix width[m
[32m+[m[32m     * @param height bit matrix height[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(width: number, height?: number, rowSize?: number, bits?: Int32Array);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @function parse[m
[32m+[m[32m     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows[m
[32m+[m[32m     * @return {@link BitMatrix} representation of image[m
[32m+[m[32m     */[m
[32m+[m[32m    static parseFromBooleanArray(image: boolean[][]): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @function parse[m
[32m+[m[32m     * @param stringRepresentation[m
[32m+[m[32m     * @param setString[m
[32m+[m[32m     * @param unsetString[m
[32m+[m[32m     */[m
[32m+[m[32m    static parseFromString(stringRepresentation: string, setString: string, unsetString: string): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Gets the requested bit, where true means black.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     * @return value of given bit in matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    get(x: number, y: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Sets the given bit to true.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     */[m
[32m+[m[32m    set(x: number, y: number): void;[m
[32m+[m[32m    unset(x: number, y: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Flips the given bit.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     */[m
[32m+[m[32m    flip(x: number, y: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding[m
[32m+[m[32m     * mask bit is set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mask XOR mask[m
[32m+[m[32m     */[m
[32m+[m[32m    xor(mask: BitMatrix): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Clears all bits (sets to false).[m
[32m+[m[32m     */[m
[32m+[m[32m    clear(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Sets a square region of the bit matrix to true.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The horizontal position to begin at (inclusive)[m
[32m+[m[32m     * @param top The vertical position to begin at (inclusive)[m
[32m+[m[32m     * @param width The width of the region[m
[32m+[m[32m     * @param height The height of the region[m
[32m+[m[32m     */[m
[32m+[m[32m    setRegion(left: number, top: number, width: number, height: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A fast method to retrieve one row of data from the matrix as a BitArray.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to retrieve[m
[32m+[m[32m     * @param row An optional caller-allocated BitArray, will be allocated if null or too small[m
[32m+[m[32m     * @return The resulting BitArray - this reference should always be used even when passing[m
[32m+[m[32m     *         your own row[m
[32m+[m[32m     */[m
[32m+[m[32m    getRow(y: number, row?: BitArray): BitArray;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param y row to set[m
[32m+[m[32m     * @param row {@link BitArray} to copy from[m
[32m+[m[32m     */[m
[32m+[m[32m    setRow(y: number, row: BitArray): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees[m
[32m+[m[32m     */[m
[32m+[m[32m    rotate180(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white[m
[32m+[m[32m     */[m
[32m+[m[32m    getEnclosingRectangle(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is useful in detecting a corner of a 'pure' barcode.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white[m
[32m+[m[32m     */[m
[32m+[m[32m    getTopLeftOnBit(): Int32Array;[m
[32m+[m[32m    getBottomRightOnBit(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The row size of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    getRowSize(): number;[m
[32m+[m[32m    equals(o: Object): boolean;[m
[32m+[m[32m    hashCode(): int;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return string representation using "X" for set and " " for unset bits[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param setString representation of a set bit[m
[32m+[m[32m     * @param unsetString representation of an unset bit[m
[32m+[m[32m     * @return string representation of entire matrix utilizing given strings[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param setString representation of a set bit[m
[32m+[m[32m     * @param unsetString representation of an unset bit[m
[32m+[m[32m     * @param lineSeparator newline character in string representation[m
[32m+[m[32m     * @return string representation of entire matrix utilizing given strings and line separator[m
[32m+[m[32m     * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always[m
[32m+[m[32m     */[m
[32m+[m[32m    toString(setString?: string, unsetString?: string, lineSeparator?: string): string;[m
[32m+[m[32m    private buildToString;[m
[32m+[m[32m    clone(): BitMatrix;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.js b/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e6da21e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitMatrix.js[m
[36m@@ -0,0 +1,489 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32m/*import java.util.Arrays;*/[m
[32m+[m[32mvar BitArray_1 = require("./BitArray");[m
[32m+[m[32mvar System_1 = require("../util/System");[m
[32m+[m[32mvar Arrays_1 = require("../util/Arrays");[m
[32m+[m[32mvar StringBuilder_1 = require("../util/StringBuilder");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common[m
[32m+[m[32m * module, x is the column position, and y is the row position. The ordering is always x, y.[m
[32m+[m[32m * The origin is at the top-left.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins[m
[32m+[m[32m * with a new int. This is done intentionally so that we can copy out a row into a BitArray very[m
[32m+[m[32m * efficiently.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,[m
[32m+[m[32m * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar BitMatrix /*implements Cloneable*/ = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an empty square {@link BitMatrix}.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param dimension height and width[m
[32m+[m[32m     */[m
[32m+[m[32m    // public constructor(dimension: number /*int*/) {[m
[32m+[m[32m    //   this(dimension, dimension)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates an empty {@link BitMatrix}.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param width bit matrix width[m
[32m+[m[32m     * @param height bit matrix height[m
[32m+[m[32m     */[m
[32m+[m[32m    // public constructor(width: number /*int*/, height: number /*int*/) {[m
[32m+[m[32m    //   if (width < 1 || height < 1) {[m
[32m+[m[32m    //     throw new IllegalArgumentException("Both dimensions must be greater than 0")[m
[32m+[m[32m    //   }[m
[32m+[m[32m    //   this.width = width[m
[32m+[m[32m    //   this.height = height[m
[32m+[m[32m    //   this.rowSize = (width + 31) / 32[m
[32m+[m[32m    //   bits = new int[rowSize * height];[m
[32m+[m[32m    // }[m
[32m+[m[32m    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {[m
[32m+[m[32m        this.width = width;[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m        this.rowSize = rowSize;[m
[32m+[m[32m        this.bits = bits;[m
[32m+[m[32m        if (undefined === height || null === height) {[m
[32m+[m[32m            height = width;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m        if (width < 1 || height < 1) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Both dimensions must be greater than 0');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === rowSize || null === rowSize) {[m
[32m+[m[32m            rowSize = Math.floor((width + 31) / 32);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.rowSize = rowSize;[m
[32m+[m[32m        if (undefined === bits || null === bits) {[m
[32m+[m[32m            this.bits = new Int32Array(this.rowSize * this.height);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @function parse[m
[32m+[m[32m     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows[m
[32m+[m[32m     * @return {@link BitMatrix} representation of image[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.parseFromBooleanArray = function (image) {[m
[32m+[m[32m        var height = image.length;[m
[32m+[m[32m        var width = image[0].length;[m
[32m+[m[32m        var bits = new BitMatrix(width, height);[m
[32m+[m[32m        for (var i = 0; i < height; i++) {[m
[32m+[m[32m            var imageI = image[i];[m
[32m+[m[32m            for (var j = 0; j < width; j++) {[m
[32m+[m[32m                if (imageI[j]) {[m
[32m+[m[32m                    bits.set(j, i);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @function parse[m
[32m+[m[32m     * @param stringRepresentation[m
[32m+[m[32m     * @param setString[m
[32m+[m[32m     * @param unsetString[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {[m
[32m+[m[32m        if (stringRepresentation === null) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('stringRepresentation cannot be null');[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = new Array(stringRepresentation.length);[m
[32m+[m[32m        var bitsPos = 0;[m
[32m+[m[32m        var rowStartPos = 0;[m
[32m+[m[32m        var rowLength = -1;[m
[32m+[m[32m        var nRows = 0;[m
[32m+[m[32m        var pos = 0;[m
[32m+[m[32m        while (pos < stringRepresentation.length) {[m
[32m+[m[32m            if (stringRepresentation.charAt(pos) === '\n' ||[m
[32m+[m[32m                stringRepresentation.charAt(pos) === '\r') {[m
[32m+[m[32m                if (bitsPos > rowStartPos) {[m
[32m+[m[32m                    if (rowLength === -1) {[m
[32m+[m[32m                        rowLength = bitsPos - rowStartPos;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (bitsPos - rowStartPos !== rowLength) {[m
[32m+[m[32m                        throw new IllegalArgumentException_1.default('row lengths do not match');[m
[32m+[m[32m                    }[m
[32m+[m[32m                    rowStartPos = bitsPos;[m
[32m+[m[32m                    nRows++;[m
[32m+[m[32m                }[m
[32m+[m[32m                pos++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {[m
[32m+[m[32m                pos += setString.length;[m
[32m+[m[32m                bits[bitsPos] = true;[m
[32m+[m[32m                bitsPos++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {[m
[32m+[m[32m                pos += unsetString.length;[m
[32m+[m[32m                bits[bitsPos] = false;[m
[32m+[m[32m                bitsPos++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('illegal character encountered: ' + stringRepresentation.substring(pos));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // no EOL at end?[m
[32m+[m[32m        if (bitsPos > rowStartPos) {[m
[32m+[m[32m            if (rowLength === -1) {[m
[32m+[m[32m                rowLength = bitsPos - rowStartPos;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (bitsPos - rowStartPos !== rowLength) {[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('row lengths do not match');[m
[32m+[m[32m            }[m
[32m+[m[32m            nRows++;[m
[32m+[m[32m        }[m
[32m+[m[32m        var matrix = new BitMatrix(rowLength, nRows);[m
[32m+[m[32m        for (var i = 0; i < bitsPos; i++) {[m
[32m+[m[32m            if (bits[i]) {[m
[32m+[m[32m                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Gets the requested bit, where true means black.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     * @return value of given bit in matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {[m
[32m+[m[32m        var offset = y * this.rowSize + Math.floor(x / 32);[m
[32m+[m[32m        return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Sets the given bit to true.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {[m
[32m+[m[32m        var offset = y * this.rowSize + Math.floor(x / 32);[m
[32m+[m[32m        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;[m
[32m+[m[32m    };[m
[32m+[m[32m    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {[m
[32m+[m[32m        var offset = y * this.rowSize + Math.floor(x / 32);[m
[32m+[m[32m        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Flips the given bit.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param x The horizontal component (i.e. which column)[m
[32m+[m[32m     * @param y The vertical component (i.e. which row)[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {[m
[32m+[m[32m        var offset = y * this.rowSize + Math.floor(x / 32);[m
[32m+[m[32m        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding[m
[32m+[m[32m     * mask bit is set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mask XOR mask[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.xor = function (mask) {[m
[32m+[m[32m        if (this.width !== mask.getWidth() || this.height !== mask.getHeight()[m
[32m+[m[32m            || this.rowSize !== mask.getRowSize()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('input matrix dimensions do not match');[m
[32m+[m[32m        }[m
[32m+[m[32m        var rowArray = new BitArray_1.default(Math.floor(this.width / 32) + 1);[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var y = 0, height = this.height; y < height; y++) {[m
[32m+[m[32m            var offset = y * rowSize;[m
[32m+[m[32m            var row = mask.getRow(y, rowArray).getBitArray();[m
[32m+[m[32m            for (var x = 0; x < rowSize; x++) {[m
[32m+[m[32m                bits[offset + x] ^= row[x];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Clears all bits (sets to false).[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.clear = function () {[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var max = bits.length;[m
[32m+[m[32m        for (var i = 0; i < max; i++) {[m
[32m+[m[32m            bits[i] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Sets a square region of the bit matrix to true.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param left The horizontal position to begin at (inclusive)[m
[32m+[m[32m     * @param top The vertical position to begin at (inclusive)[m
[32m+[m[32m     * @param width The width of the region[m
[32m+[m[32m     * @param height The height of the region[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        if (top < 0 || left < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Left and top must be nonnegative');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (height < 1 || width < 1) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Height and width must be at least 1');[m
[32m+[m[32m        }[m
[32m+[m[32m        var right = left + width;[m
[32m+[m[32m        var bottom = top + height;[m
[32m+[m[32m        if (bottom > this.height || right > this.width) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('The region must fit inside the matrix');[m
[32m+[m[32m        }[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        for (var y = top; y < bottom; y++) {[m
[32m+[m[32m            var offset = y * rowSize;[m
[32m+[m[32m            for (var x = left; x < right; x++) {[m
[32m+[m[32m                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A fast method to retrieve one row of data from the matrix as a BitArray.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y The row to retrieve[m
[32m+[m[32m     * @param row An optional caller-allocated BitArray, will be allocated if null or too small[m
[32m+[m[32m     * @return The resulting BitArray - this reference should always be used even when passing[m
[32m+[m[32m     *         your own row[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getRow = function (y /*int*/, row) {[m
[32m+[m[32m        if (row === null || row === undefined || row.getSize() < this.width) {[m
[32m+[m[32m            row = new BitArray_1.default(this.width);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            row.clear();[m
[32m+[m[32m        }[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var offset = y * rowSize;[m
[32m+[m[32m        for (var x = 0; x < rowSize; x++) {[m
[32m+[m[32m            row.setBulk(x * 32, bits[offset + x]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return row;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param y row to set[m
[32m+[m[32m     * @param row {@link BitArray} to copy from[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.setRow = function (y /*int*/, row) {[m
[32m+[m[32m        System_1.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.rotate180 = function () {[m
[32m+[m[32m        var width = this.getWidth();[m
[32m+[m[32m        var height = this.getHeight();[m
[32m+[m[32m        var topRow = new BitArray_1.default(width);[m
[32m+[m[32m        var bottomRow = new BitArray_1.default(width);[m
[32m+[m[32m        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {[m
[32m+[m[32m            topRow = this.getRow(i, topRow);[m
[32m+[m[32m            bottomRow = this.getRow(height - 1 - i, bottomRow);[m
[32m+[m[32m            topRow.reverse();[m
[32m+[m[32m            bottomRow.reverse();[m
[32m+[m[32m            this.setRow(i, bottomRow);[m
[32m+[m[32m            this.setRow(height - 1 - i, topRow);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getEnclosingRectangle = function () {[m
[32m+[m[32m        var width = this.width;[m
[32m+[m[32m        var height = this.height;[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var left = width;[m
[32m+[m[32m        var top = height;[m
[32m+[m[32m        var right = -1;[m
[32m+[m[32m        var bottom = -1;[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            for (var x32 = 0; x32 < rowSize; x32++) {[m
[32m+[m[32m                var theBits = bits[y * rowSize + x32];[m
[32m+[m[32m                if (theBits !== 0) {[m
[32m+[m[32m                    if (y < top) {[m
[32m+[m[32m                        top = y;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (y > bottom) {[m
[32m+[m[32m                        bottom = y;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (x32 * 32 < left) {[m
[32m+[m[32m                        var bit = 0;[m
[32m+[m[32m                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {[m
[32m+[m[32m                            bit++;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if ((x32 * 32 + bit) < left) {[m
[32m+[m[32m                            left = x32 * 32 + bit;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (x32 * 32 + 31 > right) {[m
[32m+[m[32m                        var bit = 31;[m
[32m+[m[32m                        while ((theBits >>> bit) === 0) {[m
[32m+[m[32m                            bit--;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if ((x32 * 32 + bit) > right) {[m
[32m+[m[32m                            right = x32 * 32 + bit;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (right < left || bottom < top) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This is useful in detecting a corner of a 'pure' barcode.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getTopLeftOnBit = function () {[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var bitsOffset = 0;[m
[32m+[m[32m        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {[m
[32m+[m[32m            bitsOffset++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bitsOffset === bits.length) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var y = bitsOffset / rowSize;[m
[32m+[m[32m        var x = (bitsOffset % rowSize) * 32;[m
[32m+[m[32m        var theBits = bits[bitsOffset];[m
[32m+[m[32m        var bit = 0;[m
[32m+[m[32m        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {[m
[32m+[m[32m            bit++;[m
[32m+[m[32m        }[m
[32m+[m[32m        x += bit;[m
[32m+[m[32m        return Int32Array.from([x, y]);[m
[32m+[m[32m    };[m
[32m+[m[32m    BitMatrix.prototype.getBottomRightOnBit = function () {[m
[32m+[m[32m        var rowSize = this.rowSize;[m
[32m+[m[32m        var bits = this.bits;[m
[32m+[m[32m        var bitsOffset = bits.length - 1;[m
[32m+[m[32m        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {[m
[32m+[m[32m            bitsOffset--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bitsOffset < 0) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var y = Math.floor(bitsOffset / rowSize);[m
[32m+[m[32m        var x = Math.floor(bitsOffset % rowSize) * 32;[m
[32m+[m[32m        var theBits = bits[bitsOffset];[m
[32m+[m[32m        var bit = 31;[m
[32m+[m[32m        while ((theBits >>> bit) === 0) {[m
[32m+[m[32m            bit--;[m
[32m+[m[32m        }[m
[32m+[m[32m        x += bit;[m
[32m+[m[32m        return Int32Array.from([x, y]);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The width of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getWidth = function () {[m
[32m+[m[32m        return this.width;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The height of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getHeight = function () {[m
[32m+[m[32m        return this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return The row size of the matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrix.prototype.getRowSize = function () {[m
[32m+[m[32m        return this.rowSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitMatrix.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof BitMatrix)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&[m
[32m+[m[32m            Arrays_1.default.equals(this.bits, other.bits);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitMatrix.prototype.hashCode = function () {[m
[32m+[m[32m        var hash = this.width;[m
[32m+[m[32m        hash = 31 * hash + this.width;[m
[32m+[m[32m        hash = 31 * hash + this.height;[m
[32m+[m[32m        hash = 31 * hash + this.rowSize;[m
[32m+[m[32m        hash = 31 * hash + Arrays_1.default.hashCode(this.bits);[m
[32m+[m[32m        return hash;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return string representation using "X" for set and " " for unset bits[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    // public toString(): string {[m
[32m+[m[32m    //   return toString(": "X, "  ")[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param setString representation of a set bit[m
[32m+[m[32m     * @param unsetString representation of an unset bit[m
[32m+[m[32m     * @return string representation of entire matrix utilizing given strings[m
[32m+[m[32m     */[m
[32m+[m[32m    // public toString(setString: string = "X ", unsetString: string = "  "): string {[m
[32m+[m[32m    //   return this.buildToString(setString, unsetString, "\n")[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param setString representation of a set bit[m
[32m+[m[32m     * @param unsetString representation of an unset bit[m
[32m+[m[32m     * @param lineSeparator newline character in string representation[m
[32m+[m[32m     * @return string representation of entire matrix utilizing given strings and line separator[m
[32m+[m[32m     * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Deprecated[m
[32m+[m[32m    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {[m
[32m+[m[32m        if (setString === void 0) { setString = 'X '; }[m
[32m+[m[32m        if (unsetString === void 0) { unsetString = '  '; }[m
[32m+[m[32m        if (lineSeparator === void 0) { lineSeparator = '\n'; }[m
[32m+[m[32m        return this.buildToString(setString, unsetString, lineSeparator);[m
[32m+[m[32m    };[m
[32m+[m[32m    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        // result.append(lineSeparator);[m
[32m+[m[32m        for (var y = 0, height = this.height; y < height; y++) {[m
[32m+[m[32m            for (var x = 0, width = this.width; x < width; x++) {[m
[32m+[m[32m                result.append(this.get(x, y) ? setString : unsetString);[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(lineSeparator);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    BitMatrix.prototype.clone = function () {[m
[32m+[m[32m        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitMatrix;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitMatrix;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2219677[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.d.ts[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the[m
[32m+[m[32m * number of bits read is not often a multiple of 8.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array[m
[32m+[m[32m * it passed in, in which case all bets are off.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BitSource {[m
[32m+[m[32m    private bytes;[m
[32m+[m[32m    private byteOffset;[m
[32m+[m[32m    private bitOffset;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.[m
[32m+[m[32m     * Bits are read within a byte from most-significant to least-significant bit.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(bytes: Uint8Array);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    getBitOffset(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    getByteOffset(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param numBits number of bits to read[m
[32m+[m[32m     * @return int representing the bits read. The bits will appear as the least-significant[m
[32m+[m[32m     *         bits of the int[m
[32m+[m[32m     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available[m
[32m+[m[32m     */[m
[32m+[m[32m    readBits(numBits: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of bits that can be read successfully[m
[32m+[m[32m     */[m
[32m+[m[32m    available(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.js b/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b729a83[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/BitSource.js[m
[36m@@ -0,0 +1,106 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the[m
[32m+[m[32m * number of bits read is not often a multiple of 8.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array[m
[32m+[m[32m * it passed in, in which case all bets are off.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar BitSource = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.[m
[32m+[m[32m     * Bits are read within a byte from most-significant to least-significant bit.[m
[32m+[m[32m     */[m
[32m+[m[32m    function BitSource(bytes) {[m
[32m+[m[32m        this.bytes = bytes;[m
[32m+[m[32m        this.byteOffset = 0;[m
[32m+[m[32m        this.bitOffset = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitSource.prototype.getBitOffset = function () {[m
[32m+[m[32m        return this.bitOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitSource.prototype.getByteOffset = function () {[m
[32m+[m[32m        return this.byteOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param numBits number of bits to read[m
[32m+[m[32m     * @return int representing the bits read. The bits will appear as the least-significant[m
[32m+[m[32m     *         bits of the int[m
[32m+[m[32m     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available[m
[32m+[m[32m     */[m
[32m+[m[32m    BitSource.prototype.readBits = function (numBits /*int*/) {[m
[32m+[m[32m        if (numBits < 1 || numBits > 32 || numBits > this.available()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('' + numBits);[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = 0;[m
[32m+[m[32m        var bitOffset = this.bitOffset;[m
[32m+[m[32m        var byteOffset = this.byteOffset;[m
[32m+[m[32m        var bytes = this.bytes;[m
[32m+[m[32m        // First, read remainder from current byte[m
[32m+[m[32m        if (bitOffset > 0) {[m
[32m+[m[32m            var bitsLeft = 8 - bitOffset;[m
[32m+[m[32m            var toRead = numBits < bitsLeft ? numBits : bitsLeft;[m
[32m+[m[32m            var bitsToNotRead = bitsLeft - toRead;[m
[32m+[m[32m            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;[m
[32m+[m[32m            result = (bytes[byteOffset] & mask) >> bitsToNotRead;[m
[32m+[m[32m            numBits -= toRead;[m
[32m+[m[32m            bitOffset += toRead;[m
[32m+[m[32m            if (bitOffset === 8) {[m
[32m+[m[32m                bitOffset = 0;[m
[32m+[m[32m                byteOffset++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Next read whole bytes[m
[32m+[m[32m        if (numBits > 0) {[m
[32m+[m[32m            while (numBits >= 8) {[m
[32m+[m[32m                result = (result << 8) | (bytes[byteOffset] & 0xFF);[m
[32m+[m[32m                byteOffset++;[m
[32m+[m[32m                numBits -= 8;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Finally read a partial byte[m
[32m+[m[32m            if (numBits > 0) {[m
[32m+[m[32m                var bitsToNotRead = 8 - numBits;[m
[32m+[m[32m                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;[m
[32m+[m[32m                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);[m
[32m+[m[32m                bitOffset += numBits;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bitOffset = bitOffset;[m
[32m+[m[32m        this.byteOffset = byteOffset;[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of bits that can be read successfully[m
[32m+[m[32m     */[m
[32m+[m[32m    BitSource.prototype.available = function () {[m
[32m+[m[32m        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitSource;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitSource;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..17f9f43[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.d.ts[m
[36m@@ -0,0 +1,89 @@[m
[32m+[m[32mexport declare enum CharacterSetValueIdentifiers {[m
[32m+[m[32m    Cp437 = 0,[m
[32m+[m[32m    ISO8859_1 = 1,[m
[32m+[m[32m    ISO8859_2 = 2,[m
[32m+[m[32m    ISO8859_3 = 3,[m
[32m+[m[32m    ISO8859_4 = 4,[m
[32m+[m[32m    ISO8859_5 = 5,[m
[32m+[m[32m    ISO8859_6 = 6,[m
[32m+[m[32m    ISO8859_7 = 7,[m
[32m+[m[32m    ISO8859_8 = 8,[m
[32m+[m[32m    ISO8859_9 = 9,[m
[32m+[m[32m    ISO8859_10 = 10,[m
[32m+[m[32m    ISO8859_11 = 11,[m
[32m+[m[32m    ISO8859_13 = 12,[m
[32m+[m[32m    ISO8859_14 = 13,[m
[32m+[m[32m    ISO8859_15 = 14,[m
[32m+[m[32m    ISO8859_16 = 15,[m
[32m+[m[32m    SJIS = 16,[m
[32m+[m[32m    Cp1250 = 17,[m
[32m+[m[32m    Cp1251 = 18,[m
[32m+[m[32m    Cp1252 = 19,[m
[32m+[m[32m    Cp1256 = 20,[m
[32m+[m[32m    UnicodeBigUnmarked = 21,[m
[32m+[m[32m    UTF8 = 22,[m
[32m+[m[32m    ASCII = 23,[m
[32m+[m[32m    Big5 = 24,[m
[32m+[m[32m    GB18030 = 25,[m
[32m+[m[32m    EUC_KR = 26[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1[m
[32m+[m[32m * of ISO 18004.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class CharacterSetECI {[m
[32m+[m[32m    valueIdentifier: CharacterSetValueIdentifiers;[m
[32m+[m[32m    name: string;[m
[32m+[m[32m    private static VALUE_IDENTIFIER_TO_ECI;[m
[32m+[m[32m    private static VALUES_TO_ECI;[m
[32m+[m[32m    private static NAME_TO_ECI;[m
[32m+[m[32m    static readonly Cp437: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_1: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_2: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_3: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_4: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_5: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_6: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_7: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_8: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_9: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_10: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_11: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_13: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_14: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_15: CharacterSetECI;[m
[32m+[m[32m    static readonly ISO8859_16: CharacterSetECI;[m
[32m+[m[32m    static readonly SJIS: CharacterSetECI;[m
[32m+[m[32m    static readonly Cp1250: CharacterSetECI;[m
[32m+[m[32m    static readonly Cp1251: CharacterSetECI;[m
[32m+[m[32m    static readonly Cp1252: CharacterSetECI;[m
[32m+[m[32m    static readonly Cp1256: CharacterSetECI;[m
[32m+[m[32m    static readonly UnicodeBigUnmarked: CharacterSetECI;[m
[32m+[m[32m    static readonly UTF8: CharacterSetECI;[m
[32m+[m[32m    static readonly ASCII: CharacterSetECI;[m
[32m+[m[32m    static readonly Big5: CharacterSetECI;[m
[32m+[m[32m    static readonly GB18030: CharacterSetECI;[m
[32m+[m[32m    static readonly EUC_KR: CharacterSetECI;[m
[32m+[m[32m    values: Int32Array;[m
[32m+[m[32m    otherEncodingNames: string[];[m
[32m+[m[32m    constructor(valueIdentifier: CharacterSetValueIdentifiers, valuesParam: Int32Array | number, name: string, ...otherEncodingNames: string[]);[m
[32m+[m[32m    getValueIdentifier(): CharacterSetValueIdentifiers;[m
[32m+[m[32m    getName(): string;[m
[32m+[m[32m    getValue(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param value character set ECI value[m
[32m+[m[32m     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but[m
[32m+[m[32m     *   unsupported[m
[32m+[m[32m     * @throws FormatException if ECI value is invalid[m
[32m+[m[32m     */[m
[32m+[m[32m    static getCharacterSetECIByValue(value: number): CharacterSetECI;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param name character set ECI encoding name[m
[32m+[m[32m     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal[m
[32m+[m[32m     *   but unsupported[m
[32m+[m[32m     */[m
[32m+[m[32m    static getCharacterSetECIByName(name: string): CharacterSetECI;[m
[32m+[m[32m    equals(o: CharacterSetECI): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js b/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2063066[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/CharacterSetECI.js[m
[36m@@ -0,0 +1,198 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.CharacterSetValueIdentifiers = void 0;[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32m/*import java.util.HashMap;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32mvar CharacterSetValueIdentifiers;[m
[32m+[m[32m(function (CharacterSetValueIdentifiers) {[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp437"] = 0] = "Cp437";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_1"] = 1] = "ISO8859_1";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_2"] = 2] = "ISO8859_2";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_3"] = 3] = "ISO8859_3";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_4"] = 4] = "ISO8859_4";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_5"] = 5] = "ISO8859_5";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_6"] = 6] = "ISO8859_6";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_7"] = 7] = "ISO8859_7";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_8"] = 8] = "ISO8859_8";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_9"] = 9] = "ISO8859_9";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_10"] = 10] = "ISO8859_10";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_11"] = 11] = "ISO8859_11";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_13"] = 12] = "ISO8859_13";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_14"] = 13] = "ISO8859_14";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_15"] = 14] = "ISO8859_15";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_16"] = 15] = "ISO8859_16";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["SJIS"] = 16] = "SJIS";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1250"] = 17] = "Cp1250";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1251"] = 18] = "Cp1251";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1252"] = 19] = "Cp1252";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1256"] = 20] = "Cp1256";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UTF8"] = 22] = "UTF8";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ASCII"] = 23] = "ASCII";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Big5"] = 24] = "Big5";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["GB18030"] = 25] = "GB18030";[m
[32m+[m[32m    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["EUC_KR"] = 26] = "EUC_KR";[m
[32m+[m[32m})(CharacterSetValueIdentifiers = exports.CharacterSetValueIdentifiers || (exports.CharacterSetValueIdentifiers = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1[m
[32m+[m[32m * of ISO 18004.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar CharacterSetECI = /** @class */ (function () {[m
[32m+[m[32m    function CharacterSetECI(valueIdentifier, valuesParam, name) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var otherEncodingNames = [];[m
[32m+[m[32m        for (var _i = 3; _i < arguments.length; _i++) {[m
[32m+[m[32m            otherEncodingNames[_i - 3] = arguments[_i];[m
[32m+[m[32m        }[m
[32m+[m[32m        this.valueIdentifier = valueIdentifier;[m
[32m+[m[32m        this.name = name;[m
[32m+[m[32m        if (typeof valuesParam === 'number') {[m
[32m+[m[32m            this.values = Int32Array.from([valuesParam]);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.values = valuesParam;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.otherEncodingNames = otherEncodingNames;[m
[32m+[m[32m        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);[m
[32m+[m[32m        CharacterSetECI.NAME_TO_ECI.set(name, this);[m
[32m+[m[32m        var values = this.values;[m
[32m+[m[32m        for (var i = 0, length_1 = values.length; i !== length_1; i++) {[m
[32m+[m[32m            var v = values[i];[m
[32m+[m[32m            CharacterSetECI.VALUES_TO_ECI.set(v, this);[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var otherEncodingNames_1 = __values(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {[m
[32m+[m[32m                var otherName = otherEncodingNames_1_1.value;[m
[32m+[m[32m                CharacterSetECI.NAME_TO_ECI.set(otherName, this);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return)) _a.call(otherEncodingNames_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    // CharacterSetECI(value: number /*int*/) {[m
[32m+[m[32m    //   this(new Int32Array {value})[m
[32m+[m[32m    // }[m
[32m+[m[32m    // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {[m
[32m+[m[32m    //   this.values = new Int32Array {value}[m
[32m+[m[32m    //   this.otherEncodingNames = otherEncodingNames[m
[32m+[m[32m    // }[m
[32m+[m[32m    // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {[m
[32m+[m[32m    //   this.values = values[m
[32m+[m[32m    //   this.otherEncodingNames = otherEncodingNames[m
[32m+[m[32m    // }[m
[32m+[m[32m    CharacterSetECI.prototype.getValueIdentifier = function () {[m
[32m+[m[32m        return this.valueIdentifier;[m
[32m+[m[32m    };[m
[32m+[m[32m    CharacterSetECI.prototype.getName = function () {[m
[32m+[m[32m        return this.name;[m
[32m+[m[32m    };[m
[32m+[m[32m    CharacterSetECI.prototype.getValue = function () {[m
[32m+[m[32m        return this.values[0];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param value character set ECI value[m
[32m+[m[32m     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but[m
[32m+[m[32m     *   unsupported[m
[32m+[m[32m     * @throws FormatException if ECI value is invalid[m
[32m+[m[32m     */[m
[32m+[m[32m    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {[m
[32m+[m[32m        if (value < 0 || value >= 900) {[m
[32m+[m[32m            throw new FormatException_1.default('incorect value');[m
[32m+[m[32m        }[m
[32m+[m[32m        var characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);[m
[32m+[m[32m        if (undefined === characterSet) {[m
[32m+[m[32m            throw new FormatException_1.default('incorect value');[m
[32m+[m[32m        }[m
[32m+[m[32m        return characterSet;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param name character set ECI encoding name[m
[32m+[m[32m     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal[m
[32m+[m[32m     *   but unsupported[m
[32m+[m[32m     */[m
[32m+[m[32m    CharacterSetECI.getCharacterSetECIByName = function (name) {[m
[32m+[m[32m        var characterSet = CharacterSetECI.NAME_TO_ECI.get(name);[m
[32m+[m[32m        if (undefined === characterSet) {[m
[32m+[m[32m            throw new FormatException_1.default('incorect value');[m
[32m+[m[32m        }[m
[32m+[m[32m        return characterSet;[m
[32m+[m[32m    };[m
[32m+[m[32m    CharacterSetECI.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof CharacterSetECI)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.getName() === other.getName();[m
[32m+[m[32m    };[m
[32m+[m[32m    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();[m
[32m+[m[32m    CharacterSetECI.VALUES_TO_ECI = new Map();[m
[32m+[m[32m    CharacterSetECI.NAME_TO_ECI = new Map();[m
[32m+[m[32m    // Enum name is a Java encoding valid for java.lang and java.io[m
[32m+[m[32m    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java[m
[32m+[m[32m    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)[m
[32m+[m[32m    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default[m
[32m+[m[32m    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');[m
[32m+[m[32m    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');[m
[32m+[m[32m    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');[m
[32m+[m[32m    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');[m
[32m+[m[32m    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');[m
[32m+[m[32m    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');[m
[32m+[m[32m    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');[m
[32m+[m[32m    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');[m
[32m+[m[32m    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');[m
[32m+[m[32m    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');[m
[32m+[m[32m    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');[m
[32m+[m[32m    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');[m
[32m+[m[32m    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');[m
[32m+[m[32m    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');[m
[32m+[m[32m    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');[m
[32m+[m[32m    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');[m
[32m+[m[32m    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');[m
[32m+[m[32m    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');[m
[32m+[m[32m    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');[m
[32m+[m[32m    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');[m
[32m+[m[32m    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');[m
[32m+[m[32m    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');[m
[32m+[m[32m    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');[m
[32m+[m[32m    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');[m
[32m+[m[32m    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');[m
[32m+[m[32m    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');[m
[32m+[m[32m    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');[m
[32m+[m[32m    return CharacterSetECI;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = CharacterSetECI;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..78b741d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.d.ts[m
[36m@@ -0,0 +1,64 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of decoding a matrix of bits. This typically[m
[32m+[m[32m * applies to 2D barcode formats. For now it contains the raw bytes obtained,[m
[32m+[m[32m * as well as a String interpretation of those bytes, if applicable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DecoderResult {[m
[32m+[m[32m    private rawBytes;[m
[32m+[m[32m    private text;[m
[32m+[m[32m    private byteSegments;[m
[32m+[m[32m    private ecLevel;[m
[32m+[m[32m    private structuredAppendSequenceNumber;[m
[32m+[m[32m    private structuredAppendParity;[m
[32m+[m[32m    private numBits;[m
[32m+[m[32m    private errorsCorrected;[m
[32m+[m[32m    private erasures;[m
[32m+[m[32m    private other;[m
[32m+[m[32m    constructor(rawBytes: Uint8Array, text: string, byteSegments: Uint8Array[], ecLevel: string, structuredAppendSequenceNumber?: number, structuredAppendParity?: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw bytes representing the result, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    getRawBytes(): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    getNumBits(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    setNumBits(numBits: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return text representation of the result[m
[32m+[m[32m     */[m
[32m+[m[32m    getText(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return list of byte segments in the result, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    getByteSegments(): Uint8Array[];[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return name of error correction level used, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    getECLevel(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of errors corrected, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    getErrorsCorrected(): number;[m
[32m+[m[32m    setErrorsCorrected(errorsCorrected: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of erasures corrected, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    getErasures(): number;[m
[32m+[m[32m    setErasures(erasures: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return arbitrary additional metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    getOther(): any;[m
[32m+[m[32m    setOther(other: any): void;[m
[32m+[m[32m    hasStructuredAppend(): boolean;[m
[32m+[m[32m    getStructuredAppendParity(): number;[m
[32m+[m[32m    getStructuredAppendSequenceNumber(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.js b/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..372e29d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DecoderResult.js[m
[36m@@ -0,0 +1,121 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32m/*import java.util.List;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of decoding a matrix of bits. This typically[m
[32m+[m[32m * applies to 2D barcode formats. For now it contains the raw bytes obtained,[m
[32m+[m[32m * as well as a String interpretation of those bytes, if applicable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DecoderResult = /** @class */ (function () {[m
[32m+[m[32m    // public constructor(rawBytes: Uint8Array,[m
[32m+[m[32m    //                      text: string,[m
[32m+[m[32m    //                      List<Uint8Array> byteSegments,[m
[32m+[m[32m    //                      String ecLevel) {[m
[32m+[m[32m    //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)[m
[32m+[m[32m    // }[m
[32m+[m[32m    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {[m
[32m+[m[32m        if (structuredAppendSequenceNumber === void 0) { structuredAppendSequenceNumber = -1; }[m
[32m+[m[32m        if (structuredAppendParity === void 0) { structuredAppendParity = -1; }[m
[32m+[m[32m        this.rawBytes = rawBytes;[m
[32m+[m[32m        this.text = text;[m
[32m+[m[32m        this.byteSegments = byteSegments;[m
[32m+[m[32m        this.ecLevel = ecLevel;[m
[32m+[m[32m        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;[m
[32m+[m[32m        this.structuredAppendParity = structuredAppendParity;[m
[32m+[m[32m        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return raw bytes representing the result, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getRawBytes = function () {[m
[32m+[m[32m        return this.rawBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getNumBits = function () {[m
[32m+[m[32m        return this.numBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}[m
[32m+[m[32m     * @since 3.3.0[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {[m
[32m+[m[32m        this.numBits = numBits;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return text representation of the result[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getText = function () {[m
[32m+[m[32m        return this.text;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return list of byte segments in the result, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getByteSegments = function () {[m
[32m+[m[32m        return this.byteSegments;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return name of error correction level used, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getECLevel = function () {[m
[32m+[m[32m        return this.ecLevel;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of errors corrected, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getErrorsCorrected = function () {[m
[32m+[m[32m        return this.errorsCorrected;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {[m
[32m+[m[32m        this.errorsCorrected = errorsCorrected;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of erasures corrected, or {@code null} if not applicable[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getErasures = function () {[m
[32m+[m[32m        return this.erasures;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {[m
[32m+[m[32m        this.erasures = erasures;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return arbitrary additional metadata[m
[32m+[m[32m     */[m
[32m+[m[32m    DecoderResult.prototype.getOther = function () {[m
[32m+[m[32m        return this.other;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.setOther = function (other) {[m
[32m+[m[32m        this.other = other;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.hasStructuredAppend = function () {[m
[32m+[m[32m        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.getStructuredAppendParity = function () {[m
[32m+[m[32m        return this.structuredAppendParity;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {[m
[32m+[m[32m        return this.structuredAppendSequenceNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DecoderResult;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DecoderResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b5eaa92[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport GridSampler from './GridSampler';[m
[32m+[m[32mimport BitMatrix from './BitMatrix';[m
[32m+[m[32mimport PerspectiveTransform from './PerspectiveTransform';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DefaultGridSampler extends GridSampler {[m
[32m+[m[32m    sampleGrid(image: BitMatrix, dimensionX: number, dimensionY: number, p1ToX: number, p1ToY: number, p2ToX: number, p2ToY: number, p3ToX: number, p3ToY: number, p4ToX: number, p4ToY: number, p1FromX: number, p1FromY: number, p2FromX: number, p2FromY: number, p3FromX: number, p3FromY: number, p4FromX: number, p4FromY: number): BitMatrix;[m
[32m+[m[32m    sampleGridWithTransform(image: BitMatrix, dimensionX: number, dimensionY: number, transform: PerspectiveTransform): BitMatrix;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js b/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ac54493[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DefaultGridSampler.js[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32mvar GridSampler_1 = require("./GridSampler");[m
[32m+[m[32mvar BitMatrix_1 = require("./BitMatrix");[m
[32m+[m[32mvar PerspectiveTransform_1 = require("./PerspectiveTransform");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DefaultGridSampler = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DefaultGridSampler, _super);[m
[32m+[m[32m    function DefaultGridSampler() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    DefaultGridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {[m
[32m+[m[32m        var transform = PerspectiveTransform_1.default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);[m
[32m+[m[32m        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    DefaultGridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) {[m
[32m+[m[32m        if (dimensionX <= 0 || dimensionY <= 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = new BitMatrix_1.default(dimensionX, dimensionY);[m
[32m+[m[32m        var points = new Float32Array(2 * dimensionX);[m
[32m+[m[32m        for (var y = 0; y < dimensionY; y++) {[m
[32m+[m[32m            var max = points.length;[m
[32m+[m[32m            var iValue = y + 0.5;[m
[32m+[m[32m            for (var x = 0; x < max; x += 2) {[m
[32m+[m[32m                points[x] = (x / 2) + 0.5;[m
[32m+[m[32m                points[x + 1] = iValue;[m
[32m+[m[32m            }[m
[32m+[m[32m            transform.transformPoints(points);[m
[32m+[m[32m            // Quick check to see if points transformed to something inside the image[m
[32m+[m[32m            // sufficient to check the endpoints[m
[32m+[m[32m            GridSampler_1.default.checkAndNudgePoints(image, points);[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var x = 0; x < max; x += 2) {[m
[32m+[m[32m                    if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {[m
[32m+[m[32m                        // Black(-ish) pixel[m
[32m+[m[32m                        bits.set(x / 2, y);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {[m
[32m+[m[32m                // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting[m
[32m+[m[32m                // transform gets "twisted" such that it maps a straight line of points to a set of points[m
[32m+[m[32m                // whose endpoints are in bounds, but others are not. There is probably some mathematical[m
[32m+[m[32m                // way to detect this about the transformation that I don't know yet.[m
[32m+[m[32m                // This results in an ugly runtime exception despite our clever checks above -- can't have[m
[32m+[m[32m                // that. We could check each point's coordinates but that feels duplicative. We settle for[m
[32m+[m[32m                // catching and wrapping ArrayIndexOutOfBoundsException.[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DefaultGridSampler;[m
[32m+[m[32m}(GridSampler_1.default));[m
[32m+[m[32mexports.default = DefaultGridSampler;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b5ae0af[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.d.ts[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mimport ResultPoint from '../ResultPoint';[m
[32m+[m[32mimport BitMatrix from './BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw[m
[32m+[m[32m * matrix of black/white pixels corresponding to the barcode, and possibly points of interest[m
[32m+[m[32m * in the image, like the location of finder patterns or corners of the barcode in the image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DetectorResult {[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    private points;[m
[32m+[m[32m    constructor(bits: BitMatrix, points: Array<ResultPoint>);[m
[32m+[m[32m    getBits(): BitMatrix;[m
[32m+[m[32m    getPoints(): Array<ResultPoint>;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.js b/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a4c6be8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/DetectorResult.js[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw[m
[32m+[m[32m * matrix of black/white pixels corresponding to the barcode, and possibly points of interest[m
[32m+[m[32m * in the image, like the location of finder patterns or corners of the barcode in the image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DetectorResult = /** @class */ (function () {[m
[32m+[m[32m    function DetectorResult(bits, points) {[m
[32m+[m[32m        this.bits = bits;[m
[32m+[m[32m        this.points = points;[m
[32m+[m[32m    }[m
[32m+[m[32m    DetectorResult.prototype.getBits = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectorResult.prototype.getPoints = function () {[m
[32m+[m[32m        return this.points;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DetectorResult;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DetectorResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..37a9ad0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.d.ts[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Set of CharsetEncoders for a given input string[m
[32m+[m[32m *[m
[32m+[m[32m * Invariants:[m
[32m+[m[32m * - The list contains only encoders from CharacterSetECI (list is shorter then the list of encoders available on[m
[32m+[m[32m *   the platform for which ECI values are defined).[m
[32m+[m[32m * - The list contains encoders at least one encoder for every character in the input.[m
[32m+[m[32m * - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded[m
[32m+[m[32m *       by it.[m
[32m+[m[32m * - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the[m
[32m+[m[32m *   UTF-8 encoder and the UTF-16BE encoder.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Alex Geller[m
[32m+[m[32m */[m
[32m+[m[32mimport { char } from '../../customTypings';[m
[32m+[m[32mimport Charset from '../util/Charset';[m
[32m+[m[32mexport declare class ECIEncoderSet {[m
[32m+[m[32m    private readonly ENCODERS;[m
[32m+[m[32m    private encoders;[m
[32m+[m[32m    private priorityEncoderIndex;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs an encoder set[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stringToEncode the string that needs to be encoded[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset} or null.[m
[32m+[m[32m     * @param fnc1 fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar[m
[32m+[m[32m     * code. When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(stringToEncode: string, priorityCharset: Charset, fnc1: number);[m
[32m+[m[32m    length(): number;[m
[32m+[m[32m    getCharsetName(index: number): string;[m
[32m+[m[32m    getCharset(index: number): Charset;[m
[32m+[m[32m    getECIValue(encoderIndex: number): number;[m
[32m+[m[32m    getPriorityEncoderIndex(): number;[m
[32m+[m[32m    canEncode(c: char, encoderIndex: number): boolean;[m
[32m+[m[32m    encode(c: char, encoderIndex: number): Uint8Array;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js b/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js[m
[1mnew file mode 100644[m
[1mindex 0000000..08042b2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/ECIEncoderSet.js[m
[36m@@ -0,0 +1,215 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/**[m
[32m+[m[32m * Set of CharsetEncoders for a given input string[m
[32m+[m[32m *[m
[32m+[m[32m * Invariants:[m
[32m+[m[32m * - The list contains only encoders from CharacterSetECI (list is shorter then the list of encoders available on[m
[32m+[m[32m *   the platform for which ECI values are defined).[m
[32m+[m[32m * - The list contains encoders at least one encoder for every character in the input.[m
[32m+[m[32m * - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded[m
[32m+[m[32m *       by it.[m
[32m+[m[32m * - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the[m
[32m+[m[32m *   UTF-8 encoder and the UTF-16BE encoder.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Alex Geller[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.ECIEncoderSet = void 0;[m
[32m+[m[32mvar Charset_1 = require("../util/Charset");[m
[32m+[m[32mvar StandardCharsets_1 = require("../util/StandardCharsets");[m
[32m+[m[32mvar StringEncoding_1 = require("../util/StringEncoding");[m
[32m+[m[32mvar StringUtils_1 = require("./StringUtils");[m
[32m+[m[32mvar CharsetEncoder = /** @class */ (function () {[m
[32m+[m[32m    function CharsetEncoder(charset) {[m
[32m+[m[32m        this.charset = charset;[m
[32m+[m[32m        this.name = charset.name;[m
[32m+[m[32m    }[m
[32m+[m[32m    CharsetEncoder.prototype.canEncode = function (c) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            return StringEncoding_1.default.encode(c, this.charset) != null;[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ex) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return CharsetEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mvar ECIEncoderSet = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs an encoder set[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stringToEncode the string that needs to be encoded[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset} or null.[m
[32m+[m[32m     * @param fnc1 fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar[m
[32m+[m[32m     * code. When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().[m
[32m+[m[32m     */[m
[32m+[m[32m    function ECIEncoderSet(stringToEncode, priorityCharset, fnc1) {[m
[32m+[m[32m        var e_1, _a, e_2, _b, e_3, _c;[m
[32m+[m[32m        this.ENCODERS = [[m
[32m+[m[32m            'IBM437',[m
[32m+[m[32m            'ISO-8859-2',[m
[32m+[m[32m            'ISO-8859-3',[m
[32m+[m[32m            'ISO-8859-4',[m
[32m+[m[32m            'ISO-8859-5',[m
[32m+[m[32m            'ISO-8859-6',[m
[32m+[m[32m            'ISO-8859-7',[m
[32m+[m[32m            'ISO-8859-8',[m
[32m+[m[32m            'ISO-8859-9',[m
[32m+[m[32m            'ISO-8859-10',[m
[32m+[m[32m            'ISO-8859-11',[m
[32m+[m[32m            'ISO-8859-13',[m
[32m+[m[32m            'ISO-8859-14',[m
[32m+[m[32m            'ISO-8859-15',[m
[32m+[m[32m            'ISO-8859-16',[m
[32m+[m[32m            'windows-1250',[m
[32m+[m[32m            'windows-1251',[m
[32m+[m[32m            'windows-1252',[m
[32m+[m[32m            'windows-1256',[m
[32m+[m[32m            'Shift_JIS',[m
[32m+[m[32m        ].map(function (name) { return new CharsetEncoder(Charset_1.default.forName(name)); });[m
[32m+[m[32m        this.encoders = [];[m
[32m+[m[32m        var neededEncoders = [];[m
[32m+[m[32m        // we always need the ISO-8859-1 encoder. It is the default encoding[m
[32m+[m[32m        neededEncoders.push(new CharsetEncoder(StandardCharsets_1.default.ISO_8859_1));[m
[32m+[m[32m        var needUnicodeEncoder = priorityCharset != null && priorityCharset.name.startsWith('UTF');[m
[32m+[m[32m        // Walk over the input string and see if all characters can be encoded with the list of encoders[m
[32m+[m[32m        for (var i = 0; i < stringToEncode.length; i++) {[m
[32m+[m[32m            var canEncode = false;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var neededEncoders_1 = (e_1 = void 0, __values(neededEncoders)), neededEncoders_1_1 = neededEncoders_1.next(); !neededEncoders_1_1.done; neededEncoders_1_1 = neededEncoders_1.next()) {[m
[32m+[m[32m                    var encoder = neededEncoders_1_1.value;[m
[32m+[m[32m                    var singleCharacter = stringToEncode.charAt(i);[m
[32m+[m[32m                    var c = singleCharacter.charCodeAt(0);[m
[32m+[m[32m                    if (c === fnc1 || encoder.canEncode(singleCharacter)) {[m
[32m+[m[32m                        canEncode = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (neededEncoders_1_1 && !neededEncoders_1_1.done && (_a = neededEncoders_1.return)) _a.call(neededEncoders_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!canEncode) {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    // for the character at position i we don't yet have an encoder in the list[m
[32m+[m[32m                    for (var _d = (e_2 = void 0, __values(this.ENCODERS)), _e = _d.next(); !_e.done; _e = _d.next()) {[m
[32m+[m[32m                        var encoder = _e.value;[m
[32m+[m[32m                        if (encoder.canEncode(stringToEncode.charAt(i))) {[m
[32m+[m[32m                            // Good, we found an encoder that can encode the character. We add him to the list and continue scanning[m
[32m+[m[32m                            // the input[m
[32m+[m[32m                            neededEncoders.push(encoder);[m
[32m+[m[32m                            canEncode = true;[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!canEncode) {[m
[32m+[m[32m                // The character is not encodeable by any of the single byte encoders so we remember that we will need a[m
[32m+[m[32m                // Unicode encoder.[m
[32m+[m[32m                needUnicodeEncoder = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (neededEncoders.length === 1 && !needUnicodeEncoder) {[m
[32m+[m[32m            // the entire input can be encoded by the ISO-8859-1 encoder[m
[32m+[m[32m            this.encoders = [neededEncoders[0]];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // we need more than one single byte encoder or we need a Unicode encoder.[m
[32m+[m[32m            // In this case we append a UTF-8 and UTF-16 encoder to the list[m
[32m+[m[32m            this.encoders = [];[m
[32m+[m[32m            var index = 0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var neededEncoders_2 = __values(neededEncoders), neededEncoders_2_1 = neededEncoders_2.next(); !neededEncoders_2_1.done; neededEncoders_2_1 = neededEncoders_2.next()) {[m
[32m+[m[32m                    var encoder = neededEncoders_2_1.value;[m
[32m+[m[32m                    this.encoders[index++] = encoder;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (neededEncoders_2_1 && !neededEncoders_2_1.done && (_c = neededEncoders_2.return)) _c.call(neededEncoders_2);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            // this.encoders[index] = new CharsetEncoder(StandardCharsets.UTF_8);[m
[32m+[m[32m            // this.encoders[index + 1] = new CharsetEncoder(StandardCharsets.UTF_16BE);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Compute priorityEncoderIndex by looking up priorityCharset in encoders[m
[32m+[m[32m        var priorityEncoderIndexValue = -1;[m
[32m+[m[32m        if (priorityCharset != null) {[m
[32m+[m[32m            for (var i = 0; i < this.encoders.length; i++) {[m
[32m+[m[32m                if (this.encoders[i] != null &&[m
[32m+[m[32m                    priorityCharset.name === this.encoders[i].name) {[m
[32m+[m[32m                    priorityEncoderIndexValue = i;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.priorityEncoderIndex = priorityEncoderIndexValue;[m
[32m+[m[32m        // invariants[m
[32m+[m[32m        // if(this?.encoders?.[0].name !== StandardCharsets.ISO_8859_1)){[m
[32m+[m[32m        // throw new Error("ISO-8859-1 must be the first encoder");[m
[32m+[m[32m        // }[m
[32m+[m[32m    }[m
[32m+[m[32m    ECIEncoderSet.prototype.length = function () {[m
[32m+[m[32m        return this.encoders.length;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECIEncoderSet.prototype.getCharsetName = function (index) {[m
[32m+[m[32m        if (!(index < this.length())) {[m
[32m+[m[32m            throw new Error('index must be less than length');[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.encoders[index].name;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECIEncoderSet.prototype.getCharset = function (index) {[m
[32m+[m[32m        if (!(index < this.length())) {[m
[32m+[m[32m            throw new Error('index must be less than length');[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.encoders[index].charset;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECIEncoderSet.prototype.getECIValue = function (encoderIndex) {[m
[32m+[m[32m        return this.encoders[encoderIndex].charset.getValueIdentifier();[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m     *  returns -1 if no priority charset was defined[m
[32m+[m[32m     */[m
[32m+[m[32m    ECIEncoderSet.prototype.getPriorityEncoderIndex = function () {[m
[32m+[m[32m        return this.priorityEncoderIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECIEncoderSet.prototype.canEncode = function (c, encoderIndex) {[m
[32m+[m[32m        if (!(encoderIndex < this.length())) {[m
[32m+[m[32m            throw new Error('index must be less than length');[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECIEncoderSet.prototype.encode = function (c, encoderIndex) {[m
[32m+[m[32m        if (!(encoderIndex < this.length())) {[m
[32m+[m[32m            throw new Error('index must be less than length');[m
[32m+[m[32m        }[m
[32m+[m[32m        return StringEncoding_1.default.encode(StringUtils_1.default.getCharAt(c), this.encoders[encoderIndex].name);[m
[32m+[m[32m    };[m
[32m+[m[32m    return ECIEncoderSet;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.ECIEncoderSet = ECIEncoderSet;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5137d8e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.d.ts[m
[36m@@ -0,0 +1,79 @@[m
[32m+[m[32mexport default interface ECIInput {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the length of this input.  The length is the number[m
[32m+[m[32m     * of {@code byte}s in or ECIs in the sequence.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the number of {@code char}s in this sequence[m
[32m+[m[32m     */[m
[32m+[m[32m    length(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code byte} value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code byte} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code byte} value as character or the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    charAt(index: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a {@code CharSequence} that is a subsequence of this sequence.[m
[32m+[m[32m     * The subsequence starts with the {@code char} value at the specified index and[m
[32m+[m[32m     * ends with the {@code char} value at index {@code end - 1}.  The length[m
[32m+[m[32m     * (in {@code char}s) of the[m
[32m+[m[32m     * returned sequence is {@code end - start}, so if {@code start == end}[m
[32m+[m[32m     * then an empty sequence is returned.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   start   the start index, inclusive[m
[32m+[m[32m     * @param   end     the end index, exclusive[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified subsequence[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if {@code start} or {@code end} are negative,[m
[32m+[m[32m     *          if {@code end} is greater than {@code length()},[m
[32m+[m[32m     *          or if {@code start} is greater than {@code end}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    subSequence(start: number, end: number): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines if a value is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the value[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  true if the value at position {@code index} is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     */[m
[32m+[m[32m    isECI(index: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code int} ECI value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code int} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code int} ECI value.[m
[32m+[m[32m     *          The ECI specified the encoding of all bytes with a higher index until the[m
[32m+[m[32m     *          next ECI or until the end of the input if no other ECI follows.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is not an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    getECIValue(index: number): number;[m
[32m+[m[32m    haveNCharacters(index: number, n: number): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.js b/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c8ad2e5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/ECIInput.js[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..27e3328[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.d.ts[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mimport Binarizer from '../Binarizer';[m
[32m+[m[32mimport LuminanceSource from '../LuminanceSource';[m
[32m+[m[32mimport BitArray from './BitArray';[m
[32m+[m[32mimport BitMatrix from './BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable[m
[32m+[m[32m * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding[m
[32m+[m[32m * algorithm. However, because it picks a global black point, it cannot handle difficult shadows[m
[32m+[m[32m * and gradients.[m
[32m+[m[32m *[m
[32m+[m[32m * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class GlobalHistogramBinarizer extends Binarizer {[m
[32m+[m[32m    private static LUMINANCE_BITS;[m
[32m+[m[32m    private static LUMINANCE_SHIFT;[m
[32m+[m[32m    private static LUMINANCE_BUCKETS;[m
[32m+[m[32m    private static EMPTY;[m
[32m+[m[32m    private luminances;[m
[32m+[m[32m    private buckets;[m
[32m+[m[32m    constructor(source: LuminanceSource);[m
[32m+[m[32m    getBlackRow(y: number, row: BitArray): BitArray;[m
[32m+[m[32m    getBlackMatrix(): BitMatrix;[m
[32m+[m[32m    createBinarizer(source: LuminanceSource): Binarizer;[m
[32m+[m[32m    private initArrays;[m
[32m+[m[32m    private static estimateBlackPoint;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js b/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f14ae2b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GlobalHistogramBinarizer.js[m
[36m@@ -0,0 +1,202 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32mvar Binarizer_1 = require("../Binarizer");[m
[32m+[m[32mvar BitArray_1 = require("./BitArray");[m
[32m+[m[32mvar BitMatrix_1 = require("./BitMatrix");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable[m
[32m+[m[32m * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding[m
[32m+[m[32m * algorithm. However, because it picks a global black point, it cannot handle difficult shadows[m
[32m+[m[32m * and gradients.[m
[32m+[m[32m *[m
[32m+[m[32m * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar GlobalHistogramBinarizer = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(GlobalHistogramBinarizer, _super);[m
[32m+[m[32m    function GlobalHistogramBinarizer(source) {[m
[32m+[m[32m        var _this = _super.call(this, source) || this;[m
[32m+[m[32m        _this.luminances = GlobalHistogramBinarizer.EMPTY;[m
[32m+[m[32m        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    // Applies simple sharpening to the row data to improve performance of the 1D Readers.[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {[m
[32m+[m[32m        var source = this.getLuminanceSource();[m
[32m+[m[32m        var width = source.getWidth();[m
[32m+[m[32m        if (row === undefined || row === null || row.getSize() < width) {[m
[32m+[m[32m            row = new BitArray_1.default(width);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            row.clear();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.initArrays(width);[m
[32m+[m[32m        var localLuminances = source.getRow(y, this.luminances);[m
[32m+[m[32m        var localBuckets = this.buckets;[m
[32m+[m[32m        for (var x = 0; x < width; x++) {[m
[32m+[m[32m            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;[m
[32m+[m[32m        }[m
[32m+[m[32m        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);[m
[32m+[m[32m        if (width < 3) {[m
[32m+[m[32m            // Special case for very small images[m
[32m+[m[32m            for (var x = 0; x < width; x++) {[m
[32m+[m[32m                if ((localLuminances[x] & 0xff) < blackPoint) {[m
[32m+[m[32m                    row.set(x);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var left = localLuminances[0] & 0xff;[m
[32m+[m[32m            var center = localLuminances[1] & 0xff;[m
[32m+[m[32m            for (var x = 1; x < width - 1; x++) {[m
[32m+[m[32m                var right = localLuminances[x + 1] & 0xff;[m
[32m+[m[32m                // A simple -1 4 -1 box filter with a weight of 2.[m
[32m+[m[32m                if (((center * 4) - left - right) / 2 < blackPoint) {[m
[32m+[m[32m                    row.set(x);[m
[32m+[m[32m                }[m
[32m+[m[32m                left = center;[m
[32m+[m[32m                center = right;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return row;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {[m
[32m+[m[32m        var source = this.getLuminanceSource();[m
[32m+[m[32m        var width = source.getWidth();[m
[32m+[m[32m        var height = source.getHeight();[m
[32m+[m[32m        var matrix = new BitMatrix_1.default(width, height);[m
[32m+[m[32m        // Quickly calculates the histogram by sampling four rows from the image. This proved to be[m
[32m+[m[32m        // more robust on the blackbox tests than sampling a diagonal as we used to do.[m
[32m+[m[32m        this.initArrays(width);[m
[32m+[m[32m        var localBuckets = this.buckets;[m
[32m+[m[32m        for (var y = 1; y < 5; y++) {[m
[32m+[m[32m            var row = Math.floor((height * y) / 5);[m
[32m+[m[32m            var localLuminances_1 = source.getRow(row, this.luminances);[m
[32m+[m[32m            var right = Math.floor((width * 4) / 5);[m
[32m+[m[32m            for (var x = Math.floor(width / 5); x < right; x++) {[m
[32m+[m[32m                var pixel = localLuminances_1[x] & 0xff;[m
[32m+[m[32m                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);[m
[32m+[m[32m        // We delay reading the entire image luminance until the black point estimation succeeds.[m
[32m+[m[32m        // Although we end up reading four rows twice, it is consistent with our motto of[m
[32m+[m[32m        // "fail quickly" which is necessary for continuous scanning.[m
[32m+[m[32m        var localLuminances = source.getMatrix();[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            var offset = y * width;[m
[32m+[m[32m            for (var x = 0; x < width; x++) {[m
[32m+[m[32m                var pixel = localLuminances[offset + x] & 0xff;[m
[32m+[m[32m                if (pixel < blackPoint) {[m
[32m+[m[32m                    matrix.set(x, y);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {[m
[32m+[m[32m        return new GlobalHistogramBinarizer(source);[m
[32m+[m[32m    };[m
[32m+[m[32m    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {[m
[32m+[m[32m        if (this.luminances.length < luminanceSize) {[m
[32m+[m[32m            this.luminances = new Uint8ClampedArray(luminanceSize);[m
[32m+[m[32m        }[m
[32m+[m[32m        var buckets = this.buckets;[m
[32m+[m[32m        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {[m
[32m+[m[32m            buckets[x] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {[m
[32m+[m[32m        // Find the tallest peak in the histogram.[m
[32m+[m[32m        var numBuckets = buckets.length;[m
[32m+[m[32m        var maxBucketCount = 0;[m
[32m+[m[32m        var firstPeak = 0;[m
[32m+[m[32m        var firstPeakSize = 0;[m
[32m+[m[32m        for (var x = 0; x < numBuckets; x++) {[m
[32m+[m[32m            if (buckets[x] > firstPeakSize) {[m
[32m+[m[32m                firstPeak = x;[m
[32m+[m[32m                firstPeakSize = buckets[x];[m
[32m+[m[32m            }[m
[32m+[m[32m            if (buckets[x] > maxBucketCount) {[m
[32m+[m[32m                maxBucketCount = buckets[x];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Find the second-tallest peak which is somewhat far from the tallest peak.[m
[32m+[m[32m        var secondPeak = 0;[m
[32m+[m[32m        var secondPeakScore = 0;[m
[32m+[m[32m        for (var x = 0; x < numBuckets; x++) {[m
[32m+[m[32m            var distanceToBiggest = x - firstPeak;[m
[32m+[m[32m            // Encourage more distant second peaks by multiplying by square of distance.[m
[32m+[m[32m            var score = buckets[x] * distanceToBiggest * distanceToBiggest;[m
[32m+[m[32m            if (score > secondPeakScore) {[m
[32m+[m[32m                secondPeak = x;[m
[32m+[m[32m                secondPeakScore = score;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Make sure firstPeak corresponds to the black peak.[m
[32m+[m[32m        if (firstPeak > secondPeak) {[m
[32m+[m[32m            var temp = firstPeak;[m
[32m+[m[32m            firstPeak = secondPeak;[m
[32m+[m[32m            secondPeak = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If there is too little contrast in the image to pick a meaningful black point, throw rather[m
[32m+[m[32m        // than waste time trying to decode the image, and risk false positives.[m
[32m+[m[32m        if (secondPeak - firstPeak <= numBuckets / 16) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Find a valley between them that is low and closer to the white peak.[m
[32m+[m[32m        var bestValley = secondPeak - 1;[m
[32m+[m[32m        var bestValleyScore = -1;[m
[32m+[m[32m        for (var x = secondPeak - 1; x > firstPeak; x--) {[m
[32m+[m[32m            var fromFirst = x - firstPeak;[m
[32m+[m[32m            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);[m
[32m+[m[32m            if (score > bestValleyScore) {[m
[32m+[m[32m                bestValley = x;[m
[32m+[m[32m                bestValleyScore = score;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;[m
[32m+[m[32m    };[m
[32m+[m[32m    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;[m
[32m+[m[32m    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;[m
[32m+[m[32m    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;[m
[32m+[m[32m    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);[m
[32m+[m[32m    return GlobalHistogramBinarizer;[m
[32m+[m[32m}(Binarizer_1.default));[m
[32m+[m[32mexports.default = GlobalHistogramBinarizer;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..21ac439[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.d.ts[m
[36m@@ -0,0 +1,67 @@[m
[32m+[m[32mimport BitMatrix from './BitMatrix';[m
[32m+[m[32mimport PerspectiveTransform from './PerspectiveTransform';[m
[32m+[m[32m/**[m
[32m+[m[32m * Implementations of this class can, given locations of finder patterns for a QR code in an[m
[32m+[m[32m * image, sample the right points in the image to reconstruct the QR code, accounting for[m
[32m+[m[32m * perspective distortion. It is abstracted since it is relatively expensive and should be allowed[m
[32m+[m[32m * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced[m
[32m+[m[32m * Imaging library, but which may not be available in other environments such as J2ME, and vice[m
[32m+[m[32m * versa.[m
[32m+[m[32m *[m
[32m+[m[32m * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}[m
[32m+[m[32m * with an instance of a class which implements this interface.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mdeclare abstract class GridSampler {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Samples an image for a rectangular matrix of bits of the given dimension. The sampling[m
[32m+[m[32m     * transformation is determined by the coordinates of 4 points, in the original and transformed[m
[32m+[m[32m     * image space.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image to sample[m
[32m+[m[32m     * @param dimensionX width of {@link BitMatrix} to sample from image[m
[32m+[m[32m     * @param dimensionY height of {@link BitMatrix} to sample from image[m
[32m+[m[32m     * @param p1ToX point 1 preimage X[m
[32m+[m[32m     * @param p1ToY point 1 preimage Y[m
[32m+[m[32m     * @param p2ToX point 2 preimage X[m
[32m+[m[32m     * @param p2ToY point 2 preimage Y[m
[32m+[m[32m     * @param p3ToX point 3 preimage X[m
[32m+[m[32m     * @param p3ToY point 3 preimage Y[m
[32m+[m[32m     * @param p4ToX point 4 preimage X[m
[32m+[m[32m     * @param p4ToY point 4 preimage Y[m
[32m+[m[32m     * @param p1FromX point 1 image X[m
[32m+[m[32m     * @param p1FromY point 1 image Y[m
[32m+[m[32m     * @param p2FromX point 2 image X[m
[32m+[m[32m     * @param p2FromY point 2 image Y[m
[32m+[m[32m     * @param p3FromX point 3 image X[m
[32m+[m[32m     * @param p3FromY point 3 image Y[m
[32m+[m[32m     * @param p4FromX point 4 image X[m
[32m+[m[32m     * @param p4FromY point 4 image Y[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link BitMatrix} representing a grid of points sampled from the image within a region[m
[32m+[m[32m     *   defined by the "from" parameters[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException if image can't be sampled, for example, if the transformation defined[m
[32m+[m[32m     *   by the given points is invalid or results in sampling outside the image boundaries[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract sampleGrid(image: BitMatrix, dimensionX: number, dimensionY: number, p1ToX: number, p1ToY: number, p2ToX: number, p2ToY: number, p3ToX: number, p3ToY: number, p4ToX: number, p4ToY: number, p1FromX: number, p1FromY: number, p2FromX: number, p2FromY: number, p3FromX: number, p3FromY: number, p4FromX: number, p4FromY: number): BitMatrix;[m
[32m+[m[32m    abstract sampleGridWithTransform(image: BitMatrix, dimensionX: number, dimensionY: number, transform: PerspectiveTransform): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Checks a set of points that have been transformed to sample points on an image against[m
[32m+[m[32m     * the image's dimensions to see if the point are even within the image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be[m
[32m+[m[32m     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder[m
[32m+[m[32m     * patterns in an image where the QR Code runs all the way to the image border.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>For efficiency, the method will check points from either end of the line until one is found[m
[32m+[m[32m     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image into which the points should map[m
[32m+[m[32m     * @param points actual points in x1,y1,...,xn,yn form[m
[32m+[m[32m     * @throws NotFoundException if an endpoint is lies outside the image boundaries[m
[32m+[m[32m     */[m
[32m+[m[32m    protected static checkAndNudgePoints(image: BitMatrix, points: Float32Array): void;[m
[32m+[m[32m}[m
[32m+[m[32mexport default GridSampler;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.js b/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.js[m
[1mnew file mode 100644[m
[1mindex 0000000..53bec56[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GridSampler.js[m
[36m@@ -0,0 +1,108 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * Implementations of this class can, given locations of finder patterns for a QR code in an[m
[32m+[m[32m * image, sample the right points in the image to reconstruct the QR code, accounting for[m
[32m+[m[32m * perspective distortion. It is abstracted since it is relatively expensive and should be allowed[m
[32m+[m[32m * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced[m
[32m+[m[32m * Imaging library, but which may not be available in other environments such as J2ME, and vice[m
[32m+[m[32m * versa.[m
[32m+[m[32m *[m
[32m+[m[32m * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}[m
[32m+[m[32m * with an instance of a class which implements this interface.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar GridSampler = /** @class */ (function () {[m
[32m+[m[32m    function GridSampler() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Checks a set of points that have been transformed to sample points on an image against[m
[32m+[m[32m     * the image's dimensions to see if the point are even within the image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be[m
[32m+[m[32m     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder[m
[32m+[m[32m     * patterns in an image where the QR Code runs all the way to the image border.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>For efficiency, the method will check points from either end of the line until one is found[m
[32m+[m[32m     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image into which the points should map[m
[32m+[m[32m     * @param points actual points in x1,y1,...,xn,yn form[m
[32m+[m[32m     * @throws NotFoundException if an endpoint is lies outside the image boundaries[m
[32m+[m[32m     */[m
[32m+[m[32m    GridSampler.checkAndNudgePoints = function (image, points) {[m
[32m+[m[32m        var width = image.getWidth();[m
[32m+[m[32m        var height = image.getHeight();[m
[32m+[m[32m        // Check and nudge points from start until we see some that are OK:[m
[32m+[m[32m        var nudged = true;[m
[32m+[m[32m        for (var offset = 0; offset < points.length && nudged; offset += 2) {[m
[32m+[m[32m            var x = Math.floor(points[offset]);[m
[32m+[m[32m            var y = Math.floor(points[offset + 1]);[m
[32m+[m[32m            if (x < -1 || x > width || y < -1 || y > height) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            nudged = false;[m
[32m+[m[32m            if (x === -1) {[m
[32m+[m[32m                points[offset] = 0.0;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (x === width) {[m
[32m+[m[32m                points[offset] = width - 1;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (y === -1) {[m
[32m+[m[32m                points[offset + 1] = 0.0;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (y === height) {[m
[32m+[m[32m                points[offset + 1] = height - 1;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Check and nudge points from end:[m
[32m+[m[32m        nudged = true;[m
[32m+[m[32m        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {[m
[32m+[m[32m            var x = Math.floor(points[offset]);[m
[32m+[m[32m            var y = Math.floor(points[offset + 1]);[m
[32m+[m[32m            if (x < -1 || x > width || y < -1 || y > height) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            nudged = false;[m
[32m+[m[32m            if (x === -1) {[m
[32m+[m[32m                points[offset] = 0.0;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (x === width) {[m
[32m+[m[32m                points[offset] = width - 1;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (y === -1) {[m
[32m+[m[32m                points[offset + 1] = 0.0;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (y === height) {[m
[32m+[m[32m                points[offset + 1] = height - 1;[m
[32m+[m[32m                nudged = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return GridSampler;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = GridSampler;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..8ed9ce5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport GridSampler from './GridSampler';[m
[32m+[m[32mexport default class GridSamplerInstance {[m
[32m+[m[32m    private static gridSampler;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the implementation of GridSampler used by the library. One global[m
[32m+[m[32m     * instance is stored, which may sound problematic. But, the implementation provided[m
[32m+[m[32m     * ought to be appropriate for the entire platform, and all uses of this library[m
[32m+[m[32m     * in the whole lifetime of the JVM. For instance, an Android activity can swap in[m
[32m+[m[32m     * an implementation that takes advantage of native platform libraries.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param newGridSampler The platform-specific object to install.[m
[32m+[m[32m     */[m
[32m+[m[32m    static setGridSampler(newGridSampler: GridSampler): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the current implementation of GridSampler[m
[32m+[m[32m     */[m
[32m+[m[32m    static getInstance(): GridSampler;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js b/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js[m
[1mnew file mode 100644[m
[1mindex 0000000..916c0de[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/GridSamplerInstance.js[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DefaultGridSampler_1 = require("./DefaultGridSampler");[m
[32m+[m[32mvar GridSamplerInstance = /** @class */ (function () {[m
[32m+[m[32m    function GridSamplerInstance() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sets the implementation of GridSampler used by the library. One global[m
[32m+[m[32m     * instance is stored, which may sound problematic. But, the implementation provided[m
[32m+[m[32m     * ought to be appropriate for the entire platform, and all uses of this library[m
[32m+[m[32m     * in the whole lifetime of the JVM. For instance, an Android activity can swap in[m
[32m+[m[32m     * an implementation that takes advantage of native platform libraries.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param newGridSampler The platform-specific object to install.[m
[32m+[m[32m     */[m
[32m+[m[32m    GridSamplerInstance.setGridSampler = function (newGridSampler) {[m
[32m+[m[32m        GridSamplerInstance.gridSampler = newGridSampler;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the current implementation of GridSampler[m
[32m+[m[32m     */[m
[32m+[m[32m    GridSamplerInstance.getInstance = function () {[m
[32m+[m[32m        return GridSamplerInstance.gridSampler;[m
[32m+[m[32m    };[m
[32m+[m[32m    GridSamplerInstance.gridSampler = new DefaultGridSampler_1.default();[m
[32m+[m[32m    return GridSamplerInstance;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = GridSamplerInstance;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..88f2ff5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.d.ts[m
[36m@@ -0,0 +1,54 @@[m
[32m+[m[32mimport Binarizer from '../Binarizer';[m
[32m+[m[32mimport LuminanceSource from '../LuminanceSource';[m
[32m+[m[32mimport GlobalHistogramBinarizer from './GlobalHistogramBinarizer';[m
[32m+[m[32mimport BitMatrix from './BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * This class implements a local thresholding algorithm, which while slower than the[m
[32m+[m[32m * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for[m
[32m+[m[32m * high frequency images of barcodes with black data on white backgrounds. For this application,[m
[32m+[m[32m * it does a much better job than a global blackpoint with severe shadows and gradients.[m
[32m+[m[32m * However it tends to produce artifacts on lower frequency images and is therefore not[m
[32m+[m[32m * a good general purpose binarizer for uses outside ZXing.[m
[32m+[m[32m *[m
[32m+[m[32m * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,[m
[32m+[m[32m * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already[m
[32m+[m[32m * inherently local, and only fails for horizontal gradients. We can revisit that problem later,[m
[32m+[m[32m * but for now it was not a win to use local blocks for 1D.[m
[32m+[m[32m *[m
[32m+[m[32m * This Binarizer is the default for the unit tests and the recommended class for library users.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class HybridBinarizer extends GlobalHistogramBinarizer {[m
[32m+[m[32m    private static BLOCK_SIZE_POWER;[m
[32m+[m[32m    private static BLOCK_SIZE;[m
[32m+[m[32m    private static BLOCK_SIZE_MASK;[m
[32m+[m[32m    private static MINIMUM_DIMENSION;[m
[32m+[m[32m    private static MIN_DYNAMIC_RANGE;[m
[32m+[m[32m    private matrix;[m
[32m+[m[32m    constructor(source: LuminanceSource);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates the final BitMatrix once for all requests. This could be called once from the[m
[32m+[m[32m     * constructor instead, but there are some advantages to doing it lazily, such as making[m
[32m+[m[32m     * profiling easier, and not doing heavy lifting when callers don't expect it.[m
[32m+[m[32m     */[m
[32m+[m[32m    getBlackMatrix(): BitMatrix;[m
[32m+[m[32m    createBinarizer(source: LuminanceSource): Binarizer;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For each block in the image, calculate the average black point using a 5x5 grid[m
[32m+[m[32m     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based[m
[32m+[m[32m     * on the last pixels in the row/column which are also used in the previous block).[m
[32m+[m[32m     */[m
[32m+[m[32m    private static calculateThresholdForBlock;[m
[32m+[m[32m    private static cap;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Applies a single threshold to a block of pixels.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static thresholdBlock;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates a single black point for each block of pixels and saves it away.[m
[32m+[m[32m     * See the following thread for a discussion of this algorithm:[m
[32m+[m[32m     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0[m
[32m+[m[32m     */[m
[32m+[m[32m    private static calculateBlackPoints;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js b/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6fe519d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js[m
[36m@@ -0,0 +1,224 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar GlobalHistogramBinarizer_1 = require("./GlobalHistogramBinarizer");[m
[32m+[m[32mvar BitMatrix_1 = require("./BitMatrix");[m
[32m+[m[32m/**[m
[32m+[m[32m * This class implements a local thresholding algorithm, which while slower than the[m
[32m+[m[32m * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for[m
[32m+[m[32m * high frequency images of barcodes with black data on white backgrounds. For this application,[m
[32m+[m[32m * it does a much better job than a global blackpoint with severe shadows and gradients.[m
[32m+[m[32m * However it tends to produce artifacts on lower frequency images and is therefore not[m
[32m+[m[32m * a good general purpose binarizer for uses outside ZXing.[m
[32m+[m[32m *[m
[32m+[m[32m * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,[m
[32m+[m[32m * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already[m
[32m+[m[32m * inherently local, and only fails for horizontal gradients. We can revisit that problem later,[m
[32m+[m[32m * but for now it was not a win to use local blocks for 1D.[m
[32m+[m[32m *[m
[32m+[m[32m * This Binarizer is the default for the unit tests and the recommended class for library users.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar HybridBinarizer = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(HybridBinarizer, _super);[m
[32m+[m[32m    function HybridBinarizer(source) {[m
[32m+[m[32m        var _this = _super.call(this, source) || this;[m
[32m+[m[32m        _this.matrix = null;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates the final BitMatrix once for all requests. This could be called once from the[m
[32m+[m[32m     * constructor instead, but there are some advantages to doing it lazily, such as making[m
[32m+[m[32m     * profiling easier, and not doing heavy lifting when callers don't expect it.[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    HybridBinarizer.prototype.getBlackMatrix = function () {[m
[32m+[m[32m        if (this.matrix !== null) {[m
[32m+[m[32m            return this.matrix;[m
[32m+[m[32m        }[m
[32m+[m[32m        var source = this.getLuminanceSource();[m
[32m+[m[32m        var width = source.getWidth();[m
[32m+[m[32m        var height = source.getHeight();[m
[32m+[m[32m        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {[m
[32m+[m[32m            var luminances = source.getMatrix();[m
[32m+[m[32m            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {[m
[32m+[m[32m                subWidth++;[m
[32m+[m[32m            }[m
[32m+[m[32m            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {[m
[32m+[m[32m                subHeight++;[m
[32m+[m[32m            }[m
[32m+[m[32m            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);[m
[32m+[m[32m            var newMatrix = new BitMatrix_1.default(width, height);[m
[32m+[m[32m            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);[m
[32m+[m[32m            this.matrix = newMatrix;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // If the image is too small, fall back to the global histogram approach.[m
[32m+[m[32m            this.matrix = _super.prototype.getBlackMatrix.call(this);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    HybridBinarizer.prototype.createBinarizer = function (source) {[m
[32m+[m[32m        return new HybridBinarizer(source);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * For each block in the image, calculate the average black point using a 5x5 grid[m
[32m+[m[32m     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based[m
[32m+[m[32m     * on the last pixels in the row/column which are also used in the previous block).[m
[32m+[m[32m     */[m
[32m+[m[32m    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {[m
[32m+[m[32m        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;[m
[32m+[m[32m        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;[m
[32m+[m[32m        for (var y = 0; y < subHeight; y++) {[m
[32m+[m[32m            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m            if (yoffset > maxYOffset) {[m
[32m+[m[32m                yoffset = maxYOffset;[m
[32m+[m[32m            }[m
[32m+[m[32m            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);[m
[32m+[m[32m            for (var x = 0; x < subWidth; x++) {[m
[32m+[m[32m                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m                if (xoffset > maxXOffset) {[m
[32m+[m[32m                    xoffset = maxXOffset;[m
[32m+[m[32m                }[m
[32m+[m[32m                var left = HybridBinarizer.cap(x, 2, subWidth - 3);[m
[32m+[m[32m                var sum = 0;[m
[32m+[m[32m                for (var z = -2; z <= 2; z++) {[m
[32m+[m[32m                    var blackRow = blackPoints[top_1 + z];[m
[32m+[m[32m                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];[m
[32m+[m[32m                }[m
[32m+[m[32m                var average = sum / 25;[m
[32m+[m[32m                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {[m
[32m+[m[32m        return value < min ? min : value > max ? max : value;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Applies a single threshold to a block of pixels.[m
[32m+[m[32m     */[m
[32m+[m[32m    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {[m
[32m+[m[32m        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {[m
[32m+[m[32m            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {[m
[32m+[m[32m                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.[m
[32m+[m[32m                if ((luminances[offset + x] & 0xFF) <= threshold) {[m
[32m+[m[32m                    matrix.set(xoffset + x, yoffset + y);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates a single black point for each block of pixels and saves it away.[m
[32m+[m[32m     * See the following thread for a discussion of this algorithm:[m
[32m+[m[32m     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0[m
[32m+[m[32m     */[m
[32m+[m[32m    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {[m
[32m+[m[32m        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;[m
[32m+[m[32m        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;[m
[32m+[m[32m        // tslint:disable-next-line:whitespace[m
[32m+[m[32m        var blackPoints = new Array(subHeight); // subWidth[m
[32m+[m[32m        for (var y = 0; y < subHeight; y++) {[m
[32m+[m[32m            blackPoints[y] = new Int32Array(subWidth);[m
[32m+[m[32m            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m            if (yoffset > maxYOffset) {[m
[32m+[m[32m                yoffset = maxYOffset;[m
[32m+[m[32m            }[m
[32m+[m[32m            for (var x = 0; x < subWidth; x++) {[m
[32m+[m[32m                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;[m
[32m+[m[32m                if (xoffset > maxXOffset) {[m
[32m+[m[32m                    xoffset = maxXOffset;[m
[32m+[m[32m                }[m
[32m+[m[32m                var sum = 0;[m
[32m+[m[32m                var min = 0xFF;[m
[32m+[m[32m                var max = 0;[m
[32m+[m[32m                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {[m
[32m+[m[32m                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {[m
[32m+[m[32m                        var pixel = luminances[offset + xx] & 0xFF;[m
[32m+[m[32m                        sum += pixel;[m
[32m+[m[32m                        // still looking for good contrast[m
[32m+[m[32m                        if (pixel < min) {[m
[32m+[m[32m                            min = pixel;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (pixel > max) {[m
[32m+[m[32m                            max = pixel;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // short-circuit min/max tests once dynamic range is met[m
[32m+[m[32m                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {[m
[32m+[m[32m                        // finish the rest of the rows quickly[m
[32m+[m[32m                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {[m
[32m+[m[32m                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {[m
[32m+[m[32m                                sum += luminances[offset + xx] & 0xFF;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                // The default estimate is the average of the values in the block.[m
[32m+[m[32m                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);[m
[32m+[m[32m                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {[m
[32m+[m[32m                    // If variation within the block is low, assume this is a block with only light or only[m
[32m+[m[32m                    // dark pixels. In that case we do not want to use the average, as it would divide this[m
[32m+[m[32m                    // low contrast area into black and white pixels, essentially creating data out of noise.[m
[32m+[m[32m                    //[m
[32m+[m[32m                    // The default assumption is that the block is light/background. Since no estimate for[m
[32m+[m[32m                    // the level of dark pixels exists locally, use half the min for the block.[m
[32m+[m[32m                    average = min / 2;[m
[32m+[m[32m                    if (y > 0 && x > 0) {[m
[32m+[m[32m                        // Correct the "white background" assumption for blocks that have neighbors by comparing[m
[32m+[m[32m                        // the pixels in this block to the previously calculated black points. This is based on[m
[32m+[m[32m                        // the fact that dark barcode symbology is always surrounded by some amount of light[m
[32m+[m[32m                        // background for which reasonable black point estimates were made. The bp estimated at[m
[32m+[m[32m                        // the boundaries is used for the interior.[m
[32m+[m[32m                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.[m
[32m+[m[32m                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;[m
[32m+[m[32m                        if (min < averageNeighborBlackPoint) {[m
[32m+[m[32m                            average = averageNeighborBlackPoint;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                blackPoints[y][x] = average;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return blackPoints;[m
[32m+[m[32m    };[m
[32m+[m[32m    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.[m
[32m+[m[32m    // So this is the smallest dimension in each axis we can accept.[m
[32m+[m[32m    HybridBinarizer.BLOCK_SIZE_POWER = 3;[m
[32m+[m[32m    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00[m
[32m+[m[32m    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11[m
[32m+[m[32m    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;[m
[32m+[m[32m    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;[m
[32m+[m[32m    return HybridBinarizer;[m
[32m+[m[32m}(GlobalHistogramBinarizer_1.default));[m
[32m+[m[32mexports.default = HybridBinarizer;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..68f36f3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.d.ts[m
[36m@@ -0,0 +1,124 @@[m
[32m+[m[32mimport { char } from 'src/customTypings';[m
[32m+[m[32mimport { ECIEncoderSet } from './ECIEncoderSet';[m
[32m+[m[32mimport Charset from '../util/Charset';[m
[32m+[m[32mimport ECIInput from './ECIInput';[m
[32m+[m[32mexport declare class MinimalECIInput implements ECIInput {[m
[32m+[m[32m    private bytes;[m
[32m+[m[32m    private fnc1;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs a minimal input[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stringToEncode the character string to encode[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not GS1[m
[32m+[m[32m     *   input.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(stringToEncode: string, priorityCharset: Charset, fnc1: number);[m
[32m+[m[32m    getFNC1Character(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the length of this input.  The length is the number[m
[32m+[m[32m     * of {@code byte}s, FNC1 characters or ECIs in the sequence.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the number of {@code char}s in this sequence[m
[32m+[m[32m     */[m
[32m+[m[32m    length(): number;[m
[32m+[m[32m    haveNCharacters(index: number, n: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code byte} value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code byte} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code byte} value as character or the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    charAt(index: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a {@code CharSequence} that is a subsequence of this sequence.[m
[32m+[m[32m     * The subsequence starts with the {@code char} value at the specified index and[m
[32m+[m[32m     * ends with the {@code char} value at index {@code end - 1}.  The length[m
[32m+[m[32m     * (in {@code char}s) of the[m
[32m+[m[32m     * returned sequence is {@code end - start}, so if {@code start == end}[m
[32m+[m[32m     * then an empty sequence is returned.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   start   the start index, inclusive[m
[32m+[m[32m     * @param   end     the end index, exclusive[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified subsequence[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if {@code start} or {@code end} are negative,[m
[32m+[m[32m     *          if {@code end} is greater than {@code length()},[m
[32m+[m[32m     *          or if {@code start} is greater than {@code end}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    subSequence(start: number, end: number): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines if a value is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the value[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  true if the value at position {@code index} is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     */[m
[32m+[m[32m    isECI(index: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines if a value is the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the value[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  true if the value at position {@code index} is the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     */[m
[32m+[m[32m    isFNC1(index: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code int} ECI value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code int} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code int} ECI value.[m
[32m+[m[32m     *          The ECI specified the encoding of all bytes with a higher index until the[m
[32m+[m[32m     *          next ECI or until the end of the input if no other ECI follows.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is not an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    getECIValue(index: number): number;[m
[32m+[m[32m    addEdge(edges: InputEdge[][], to: number, edge: InputEdge): void;[m
[32m+[m[32m    addEdges(stringToEncode: string, encoderSet: ECIEncoderSet, edges: InputEdge[][], from: number, previous: InputEdge, fnc1: number): void;[m
[32m+[m[32m    encodeMinimally(stringToEncode: string, encoderSet: ECIEncoderSet, fnc1: number): number[];[m
[32m+[m[32m}[m
[32m+[m[32mdeclare class InputEdge {[m
[32m+[m[32m    readonly c: char;[m
[32m+[m[32m    readonly encoderSet: ECIEncoderSet;[m
[32m+[m[32m    readonly encoderIndex: number;[m
[32m+[m[32m    readonly previous: InputEdge;[m
[32m+[m[32m    readonly fnc1: number;[m
[32m+[m[32m    readonly cachedTotalSize: number;[m
[32m+[m[32m    constructor(c: char, encoderSet: ECIEncoderSet, encoderIndex: number, previous: InputEdge, fnc1: number);[m
[32m+[m[32m    isFNC1(): boolean;[m
[32m+[m[32m}[m
[32m+[m[32mexport {};[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js b/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js[m
[1mnew file mode 100644[m
[1mindex 0000000..302127d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/MinimalECIInput.js[m
[36m@@ -0,0 +1,277 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.MinimalECIInput = void 0;[m
[32m+[m[32mvar ECIEncoderSet_1 = require("./ECIEncoderSet");[m
[32m+[m[32mvar Integer_1 = require("../util/Integer");[m
[32m+[m[32mvar StringBuilder_1 = require("../util/StringBuilder");[m
[32m+[m[32mvar COST_PER_ECI = 3; // approximated (latch + 2 codewords)[m
[32m+[m[32mvar MinimalECIInput = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Constructs a minimal input[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stringToEncode the character string to encode[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not GS1[m
[32m+[m[32m     *   input.[m
[32m+[m[32m     */[m
[32m+[m[32m    function MinimalECIInput(stringToEncode, priorityCharset, fnc1) {[m
[32m+[m[32m        this.fnc1 = fnc1;[m
[32m+[m[32m        var encoderSet = new ECIEncoderSet_1.ECIEncoderSet(stringToEncode, priorityCharset, fnc1);[m
[32m+[m[32m        if (encoderSet.length() === 1) {[m
[32m+[m[32m            // optimization for the case when all can be encoded without ECI in ISO-8859-1[m
[32m+[m[32m            for (var i = 0; i < this.bytes.length; i++) {[m
[32m+[m[32m                var c = stringToEncode.charAt(i).charCodeAt(0);[m
[32m+[m[32m                this.bytes[i] = c === fnc1 ? 1000 : c;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.bytes = this.encodeMinimally(stringToEncode, encoderSet, fnc1);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    MinimalECIInput.prototype.getFNC1Character = function () {[m
[32m+[m[32m        return this.fnc1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the length of this input.  The length is the number[m
[32m+[m[32m     * of {@code byte}s, FNC1 characters or ECIs in the sequence.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the number of {@code char}s in this sequence[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.length = function () {[m
[32m+[m[32m        return this.bytes.length;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalECIInput.prototype.haveNCharacters = function (index, n) {[m
[32m+[m[32m        if (index + n - 1 >= this.bytes.length) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < n; i++) {[m
[32m+[m[32m            if (this.isECI(index + i)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code byte} value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code byte} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code byte} value as character or the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.charAt = function (index) {[m
[32m+[m[32m        if (index < 0 || index >= this.length()) {[m
[32m+[m[32m            throw new Error('' + index);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isECI(index)) {[m
[32m+[m[32m            throw new Error('value at ' + index + ' is not a character but an ECI');[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.isFNC1(index) ? this.fnc1 : this.bytes[index];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns a {@code CharSequence} that is a subsequence of this sequence.[m
[32m+[m[32m     * The subsequence starts with the {@code char} value at the specified index and[m
[32m+[m[32m     * ends with the {@code char} value at index {@code end - 1}.  The length[m
[32m+[m[32m     * (in {@code char}s) of the[m
[32m+[m[32m     * returned sequence is {@code end - start}, so if {@code start == end}[m
[32m+[m[32m     * then an empty sequence is returned.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   start   the start index, inclusive[m
[32m+[m[32m     * @param   end     the end index, exclusive[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified subsequence[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if {@code start} or {@code end} are negative,[m
[32m+[m[32m     *          if {@code end} is greater than {@code length()},[m
[32m+[m[32m     *          or if {@code start} is greater than {@code end}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.subSequence = function (start, end) {[m
[32m+[m[32m        if (start < 0 || start > end || end > this.length()) {[m
[32m+[m[32m            throw new Error('' + start);[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        for (var i = start; i < end; i++) {[m
[32m+[m[32m            if (this.isECI(i)) {[m
[32m+[m[32m                throw new Error('value at ' + i + ' is not a character but an ECI');[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(this.charAt(i));[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines if a value is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the value[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  true if the value at position {@code index} is an ECI[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.isECI = function (index) {[m
[32m+[m[32m        if (index < 0 || index >= this.length()) {[m
[32m+[m[32m            throw new Error('' + index);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.bytes[index] > 255 && this.bytes[index] <= 999;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines if a value is the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the value[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  true if the value at position {@code index} is the FNC1 character[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.isFNC1 = function (index) {[m
[32m+[m[32m        if (index < 0 || index >= this.length()) {[m
[32m+[m[32m            throw new Error('' + index);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.bytes[index] === 1000;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the {@code int} ECI value at the specified index.  An index ranges from zero[m
[32m+[m[32m     * to {@code length() - 1}.  The first {@code byte} value of the sequence is at[m
[32m+[m[32m     * index zero, the next at index one, and so on, as for array[m
[32m+[m[32m     * indexing.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   index the index of the {@code int} value to be returned[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the specified {@code int} ECI value.[m
[32m+[m[32m     *          The ECI specified the encoding of all bytes with a higher index until the[m
[32m+[m[32m     *          next ECI or until the end of the input if no other ECI follows.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws  IndexOutOfBoundsException[m
[32m+[m[32m     *          if the {@code index} argument is negative or not less than[m
[32m+[m[32m     *          {@code length()}[m
[32m+[m[32m     * @throws  IllegalArgumentException[m
[32m+[m[32m     *          if the value at the {@code index} argument is not an ECI (@see #isECI)[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalECIInput.prototype.getECIValue = function (index) {[m
[32m+[m[32m        if (index < 0 || index >= this.length()) {[m
[32m+[m[32m            throw new Error('' + index);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!this.isECI(index)) {[m
[32m+[m[32m            throw new Error('value at ' + index + ' is not an ECI but a character');[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.bytes[index] - 256;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalECIInput.prototype.addEdge = function (edges, to, edge) {[m
[32m+[m[32m        if (edges[to][edge.encoderIndex] == null ||[m
[32m+[m[32m            edges[to][edge.encoderIndex].cachedTotalSize > edge.cachedTotalSize) {[m
[32m+[m[32m            edges[to][edge.encoderIndex] = edge;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalECIInput.prototype.addEdges = function (stringToEncode, encoderSet, edges, from, previous, fnc1) {[m
[32m+[m[32m        var ch = stringToEncode.charAt(from).charCodeAt(0);[m
[32m+[m[32m        var start = 0;[m
[32m+[m[32m        var end = encoderSet.length();[m
[32m+[m[32m        if (encoderSet.getPriorityEncoderIndex() >= 0 &&[m
[32m+[m[32m            (ch === fnc1 ||[m
[32m+[m[32m                encoderSet.canEncode(ch, encoderSet.getPriorityEncoderIndex()))) {[m
[32m+[m[32m            start = encoderSet.getPriorityEncoderIndex();[m
[32m+[m[32m            end = start + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = start; i < end; i++) {[m
[32m+[m[32m            if (ch === fnc1 || encoderSet.canEncode(ch, i)) {[m
[32m+[m[32m                this.addEdge(edges, from + 1, new InputEdge(ch, encoderSet, i, previous, fnc1));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalECIInput.prototype.encodeMinimally = function (stringToEncode, encoderSet, fnc1) {[m
[32m+[m[32m        var inputLength = stringToEncode.length;[m
[32m+[m[32m        // Array that represents vertices. There is a vertex for every character and encoding.[m
[32m+[m[32m        var edges = new InputEdge[inputLength + 1][encoderSet.length()]();[m
[32m+[m[32m        this.addEdges(stringToEncode, encoderSet, edges, 0, null, fnc1);[m
[32m+[m[32m        for (var i = 1; i <= inputLength; i++) {[m
[32m+[m[32m            for (var j = 0; j < encoderSet.length(); j++) {[m
[32m+[m[32m                if (edges[i][j] != null && i < inputLength) {[m
[32m+[m[32m                    this.addEdges(stringToEncode, encoderSet, edges, i, edges[i][j], fnc1);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            // optimize memory by removing edges that have been passed.[m
[32m+[m[32m            for (var j = 0; j < encoderSet.length(); j++) {[m
[32m+[m[32m                edges[i - 1][j] = null;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var minimalJ = -1;[m
[32m+[m[32m        var minimalSize = Integer_1.default.MAX_VALUE;[m
[32m+[m[32m        for (var j = 0; j < encoderSet.length(); j++) {[m
[32m+[m[32m            if (edges[inputLength][j] != null) {[m
[32m+[m[32m                var edge = edges[inputLength][j];[m
[32m+[m[32m                if (edge.cachedTotalSize < minimalSize) {[m
[32m+[m[32m                    minimalSize = edge.cachedTotalSize;[m
[32m+[m[32m                    minimalJ = j;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (minimalJ < 0) {[m
[32m+[m[32m            throw new Error('Failed to encode "' + stringToEncode + '"');[m
[32m+[m[32m        }[m
[32m+[m[32m        var intsAL = [];[m
[32m+[m[32m        var current = edges[inputLength][minimalJ];[m
[32m+[m[32m        while (current != null) {[m
[32m+[m[32m            if (current.isFNC1()) {[m
[32m+[m[32m                intsAL.unshift(1000);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                var bytes = encoderSet.encode(current.c, current.encoderIndex);[m
[32m+[m[32m                for (var i = bytes.length - 1; i >= 0; i--) {[m
[32m+[m[32m                    intsAL.unshift(bytes[i] & 0xff);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            var previousEncoderIndex = current.previous === null ? 0 : current.previous.encoderIndex;[m
[32m+[m[32m            if (previousEncoderIndex !== current.encoderIndex) {[m
[32m+[m[32m                intsAL.unshift(256 + encoderSet.getECIValue(current.encoderIndex));[m
[32m+[m[32m            }[m
[32m+[m[32m            current = current.previous;[m
[32m+[m[32m        }[m
[32m+[m[32m        var ints = [];[m
[32m+[m[32m        for (var i = 0; i < ints.length; i++) {[m
[32m+[m[32m            ints[i] = intsAL[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return ints;[m
[32m+[m[32m    };[m
[32m+[m[32m    return MinimalECIInput;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.MinimalECIInput = MinimalECIInput;[m
[32m+[m[32mvar InputEdge = /** @class */ (function () {[m
[32m+[m[32m    function InputEdge(c, encoderSet, encoderIndex, previous, fnc1) {[m
[32m+[m[32m        this.c = c;[m
[32m+[m[32m        this.encoderSet = encoderSet;[m
[32m+[m[32m        this.encoderIndex = encoderIndex;[m
[32m+[m[32m        this.previous = previous;[m
[32m+[m[32m        this.fnc1 = fnc1;[m
[32m+[m[32m        this.c = c === fnc1 ? 1000 : c;[m
[32m+[m[32m        var size = this.isFNC1() ? 1 : encoderSet.encode(c, encoderIndex).length;[m
[32m+[m[32m        var previousEncoderIndex = previous === null ? 0 : previous.encoderIndex;[m
[32m+[m[32m        if (previousEncoderIndex !== encoderIndex) {[m
[32m+[m[32m            size += COST_PER_ECI;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (previous != null) {[m
[32m+[m[32m            size += previous.cachedTotalSize;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.cachedTotalSize = size;[m
[32m+[m[32m    }[m
[32m+[m[32m    InputEdge.prototype.isFNC1 = function () {[m
[32m+[m[32m        return this.c === 1000;[m
[32m+[m[32m    };[m
[32m+[m[32m    return InputEdge;[m
[32m+[m[32m}());[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3a8aa00[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class implements a perspective transform in two dimensions. Given four source and four[m
[32m+[m[32m * destination points, it will compute the transformation implied between them. The code is based[m
[32m+[m[32m * directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PerspectiveTransform {[m
[32m+[m[32m    private a11;[m
[32m+[m[32m    private a21;[m
[32m+[m[32m    private a31;[m
[32m+[m[32m    private a12;[m
[32m+[m[32m    private a22;[m
[32m+[m[32m    private a32;[m
[32m+[m[32m    private a13;[m
[32m+[m[32m    private a23;[m
[32m+[m[32m    private a33;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    static quadrilateralToQuadrilateral(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x0p: number, y0p: number, x1p: number, y1p: number, x2p: number, y2p: number, x3p: number, y3p: number): PerspectiveTransform;[m
[32m+[m[32m    transformPoints(points: Float32Array): void;[m
[32m+[m[32m    transformPointsWithValues(xValues: Float32Array, yValues: Float32Array): void;[m
[32m+[m[32m    static squareToQuadrilateral(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): PerspectiveTransform;[m
[32m+[m[32m    static quadrilateralToSquare(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): PerspectiveTransform;[m
[32m+[m[32m    protected buildAdjoint(): PerspectiveTransform;[m
[32m+[m[32m    protected times(other: PerspectiveTransform): PerspectiveTransform;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js b/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2c1ef90[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/PerspectiveTransform.js[m
[36m@@ -0,0 +1,112 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class implements a perspective transform in two dimensions. Given four source and four[m
[32m+[m[32m * destination points, it will compute the transformation implied between them. The code is based[m
[32m+[m[32m * directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar PerspectiveTransform = /** @class */ (function () {[m
[32m+[m[32m    function PerspectiveTransform(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {[m
[32m+[m[32m        this.a11 = a11;[m
[32m+[m[32m        this.a21 = a21;[m
[32m+[m[32m        this.a31 = a31;[m
[32m+[m[32m        this.a12 = a12;[m
[32m+[m[32m        this.a22 = a22;[m
[32m+[m[32m        this.a32 = a32;[m
[32m+[m[32m        this.a13 = a13;[m
[32m+[m[32m        this.a23 = a23;[m
[32m+[m[32m        this.a33 = a33;[m
[32m+[m[32m    }[m
[32m+[m[32m    PerspectiveTransform.quadrilateralToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {[m
[32m+[m[32m        var qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);[m
[32m+[m[32m        var sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);[m
[32m+[m[32m        return sToQ.times(qToS);[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.prototype.transformPoints = function (points) {[m
[32m+[m[32m        var max = points.length;[m
[32m+[m[32m        var a11 = this.a11;[m
[32m+[m[32m        var a12 = this.a12;[m
[32m+[m[32m        var a13 = this.a13;[m
[32m+[m[32m        var a21 = this.a21;[m
[32m+[m[32m        var a22 = this.a22;[m
[32m+[m[32m        var a23 = this.a23;[m
[32m+[m[32m        var a31 = this.a31;[m
[32m+[m[32m        var a32 = this.a32;[m
[32m+[m[32m        var a33 = this.a33;[m
[32m+[m[32m        for (var i = 0; i < max; i += 2) {[m
[32m+[m[32m            var x = points[i];[m
[32m+[m[32m            var y = points[i + 1];[m
[32m+[m[32m            var denominator = a13 * x + a23 * y + a33;[m
[32m+[m[32m            points[i] = (a11 * x + a21 * y + a31) / denominator;[m
[32m+[m[32m            points[i + 1] = (a12 * x + a22 * y + a32) / denominator;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.prototype.transformPointsWithValues = function (xValues, yValues) {[m
[32m+[m[32m        var a11 = this.a11;[m
[32m+[m[32m        var a12 = this.a12;[m
[32m+[m[32m        var a13 = this.a13;[m
[32m+[m[32m        var a21 = this.a21;[m
[32m+[m[32m        var a22 = this.a22;[m
[32m+[m[32m        var a23 = this.a23;[m
[32m+[m[32m        var a31 = this.a31;[m
[32m+[m[32m        var a32 = this.a32;[m
[32m+[m[32m        var a33 = this.a33;[m
[32m+[m[32m        var n = xValues.length;[m
[32m+[m[32m        for (var i = 0; i < n; i++) {[m
[32m+[m[32m            var x = xValues[i];[m
[32m+[m[32m            var y = yValues[i];[m
[32m+[m[32m            var denominator = a13 * x + a23 * y + a33;[m
[32m+[m[32m            xValues[i] = (a11 * x + a21 * y + a31) / denominator;[m
[32m+[m[32m            yValues[i] = (a12 * x + a22 * y + a32) / denominator;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.squareToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {[m
[32m+[m[32m        var dx3 = x0 - x1 + x2 - x3;[m
[32m+[m[32m        var dy3 = y0 - y1 + y2 - y3;[m
[32m+[m[32m        if (dx3 === 0.0 && dy3 === 0.0) {[m
[32m+[m[32m            // Affine[m
[32m+[m[32m            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var dx1 = x1 - x2;[m
[32m+[m[32m            var dx2 = x3 - x2;[m
[32m+[m[32m            var dy1 = y1 - y2;[m
[32m+[m[32m            var dy2 = y3 - y2;[m
[32m+[m[32m            var denominator = dx1 * dy2 - dx2 * dy1;[m
[32m+[m[32m            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;[m
[32m+[m[32m            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;[m
[32m+[m[32m            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.quadrilateralToSquare = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {[m
[32m+[m[32m        // Here, the adjoint serves as the inverse:[m
[32m+[m[32m        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.prototype.buildAdjoint = function () {[m
[32m+[m[32m        // Adjoint is the transpose of the cofactor matrix:[m
[32m+[m[32m        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);[m
[32m+[m[32m    };[m
[32m+[m[32m    PerspectiveTransform.prototype.times = function (other) {[m
[32m+[m[32m        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);[m
[32m+[m[32m    };[m
[32m+[m[32m    return PerspectiveTransform;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PerspectiveTransform;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..48508c9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.d.ts[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport CharacterSetECI from './CharacterSetECI';[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32mimport Charset from '../util/Charset';[m
[32m+[m[32m/**[m
[32m+[m[32m * Common string-related functions.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author Alex Dupre[m
[32m+[m[32m */[m
[32m+[m[32mexport default class StringUtils {[m
[32m+[m[32m    static SHIFT_JIS: string;[m
[32m+[m[32m    static GB2312: string;[m
[32m+[m[32m    static ISO88591: string;[m
[32m+[m[32m    private static EUC_JP;[m
[32m+[m[32m    private static UTF8;[m
[32m+[m[32m    private static PLATFORM_DEFAULT_ENCODING;[m
[32m+[m[32m    private static ASSUME_SHIFT_JIS;[m
[32m+[m[32m    static castAsNonUtf8Char(code: number, encoding?: Charset): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bytes bytes encoding a string, whose encoding should be guessed[m
[32m+[m[32m     * @param hints decode hints if applicable[m
[32m+[m[32m     * @return name of guessed encoding; at the moment will only guess one of:[m
[32m+[m[32m     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform[m
[32m+[m[32m     *  default encoding if none of these can possibly be correct[m
[32m+[m[32m     */[m
[32m+[m[32m    static guessEncoding(bytes: Uint8Array, hints: Map<DecodeHintType, any>): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see https://stackoverflow.com/a/13439711/4367683[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param append The new string to append.[m
[32m+[m[32m     * @param args Argumets values to be formated.[m
[32m+[m[32m     */[m
[32m+[m[32m    static format(append: string, ...args: any[]): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    static getBytes(str: string, encoding: CharacterSetECI): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the charcode at the specified index or at index zero.[m
[32m+[m[32m     */[m
[32m+[m[32m    static getCharCode(str: string, index?: number): int;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns char for given charcode[m
[32m+[m[32m     */[m
[32m+[m[32m    static getCharAt(charCode: number): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.js b/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6d9e687[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/StringUtils.js[m
[36m@@ -0,0 +1,291 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright (C) 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common {*/[m
[32m+[m[32m/*import java.nio.charset.Charset;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar CharacterSetECI_1 = require("./CharacterSetECI");[m
[32m+[m[32mvar StringEncoding_1 = require("../util/StringEncoding");[m
[32m+[m[32m/**[m
[32m+[m[32m * Common string-related functions.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author Alex Dupre[m
[32m+[m[32m */[m
[32m+[m[32mvar StringUtils = /** @class */ (function () {[m
[32m+[m[32m    function StringUtils() {[m
[32m+[m[32m    }[m
[32m+[m[32m    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||[m
[32m+[m[32m    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);[m
[32m+[m[32m    StringUtils.castAsNonUtf8Char = function (code, encoding) {[m
[32m+[m[32m        if (encoding === void 0) { encoding = null; }[m
[32m+[m[32m        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts[m
[32m+[m[32m        // you can see this method as a Java version of String.fromCharCode[m
[32m+[m[32m        var e = encoding ? encoding.getName() : this.ISO88591;[m
[32m+[m[32m        // use passed format (fromCharCode will return UTF8 encoding)[m
[32m+[m[32m        return StringEncoding_1.default.decode(new Uint8Array([code]), e);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bytes bytes encoding a string, whose encoding should be guessed[m
[32m+[m[32m     * @param hints decode hints if applicable[m
[32m+[m[32m     * @return name of guessed encoding; at the moment will only guess one of:[m
[32m+[m[32m     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform[m
[32m+[m[32m     *  default encoding if none of these can possibly be correct[m
[32m+[m[32m     */[m
[32m+[m[32m    StringUtils.guessEncoding = function (bytes, hints) {[m
[32m+[m[32m        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {[m
[32m+[m[32m            return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();[m
[32m+[m[32m        }[m
[32m+[m[32m        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,[m
[32m+[m[32m        // which should be by far the most common encodings.[m
[32m+[m[32m        var length = bytes.length;[m
[32m+[m[32m        var canBeISO88591 = true;[m
[32m+[m[32m        var canBeShiftJIS = true;[m
[32m+[m[32m        var canBeUTF8 = true;[m
[32m+[m[32m        var utf8BytesLeft = 0;[m
[32m+[m[32m        // int utf8LowChars = 0[m
[32m+[m[32m        var utf2BytesChars = 0;[m
[32m+[m[32m        var utf3BytesChars = 0;[m
[32m+[m[32m        var utf4BytesChars = 0;[m
[32m+[m[32m        var sjisBytesLeft = 0;[m
[32m+[m[32m        // int sjisLowChars = 0[m
[32m+[m[32m        var sjisKatakanaChars = 0;[m
[32m+[m[32m        // int sjisDoubleBytesChars = 0[m
[32m+[m[32m        var sjisCurKatakanaWordLength = 0;[m
[32m+[m[32m        var sjisCurDoubleBytesWordLength = 0;[m
[32m+[m[32m        var sjisMaxKatakanaWordLength = 0;[m
[32m+[m[32m        var sjisMaxDoubleBytesWordLength = 0;[m
[32m+[m[32m        // int isoLowChars = 0[m
[32m+[m[32m        // int isoHighChars = 0[m
[32m+[m[32m        var isoHighOther = 0;[m
[32m+[m[32m        var utf8bom = bytes.length > 3 &&[m
[32m+[m[32m            bytes[0] === /*(byte) */ 0xEF &&[m
[32m+[m[32m            bytes[1] === /*(byte) */ 0xBB &&[m
[32m+[m[32m            bytes[2] === /*(byte) */ 0xBF;[m
[32m+[m[32m        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {[m
[32m+[m[32m            var value = bytes[i] & 0xFF;[m
[32m+[m[32m            // UTF-8 stuff[m
[32m+[m[32m            if (canBeUTF8) {[m
[32m+[m[32m                if (utf8BytesLeft > 0) {[m
[32m+[m[32m                    if ((value & 0x80) === 0) {[m
[32m+[m[32m                        canBeUTF8 = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        utf8BytesLeft--;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else if ((value & 0x80) !== 0) {[m
[32m+[m[32m                    if ((value & 0x40) === 0) {[m
[32m+[m[32m                        canBeUTF8 = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        utf8BytesLeft++;[m
[32m+[m[32m                        if ((value & 0x20) === 0) {[m
[32m+[m[32m                            utf2BytesChars++;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            utf8BytesLeft++;[m
[32m+[m[32m                            if ((value & 0x10) === 0) {[m
[32m+[m[32m                                utf3BytesChars++;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                utf8BytesLeft++;[m
[32m+[m[32m                                if ((value & 0x08) === 0) {[m
[32m+[m[32m                                    utf4BytesChars++;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else {[m
[32m+[m[32m                                    canBeUTF8 = false;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                } // else {[m
[32m+[m[32m                // utf8LowChars++[m
[32m+[m[32m                // }[m
[32m+[m[32m            }[m
[32m+[m[32m            // ISO-8859-1 stuff[m
[32m+[m[32m            if (canBeISO88591) {[m
[32m+[m[32m                if (value > 0x7F && value < 0xA0) {[m
[32m+[m[32m                    canBeISO88591 = false;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (value > 0x9F) {[m
[32m+[m[32m                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {[m
[32m+[m[32m                        isoHighOther++;[m
[32m+[m[32m                    } // else {[m
[32m+[m[32m                    // isoHighChars++[m
[32m+[m[32m                    // }[m
[32m+[m[32m                } // else {[m
[32m+[m[32m                // isoLowChars++[m
[32m+[m[32m                // }[m
[32m+[m[32m            }[m
[32m+[m[32m            // Shift_JIS stuff[m
[32m+[m[32m            if (canBeShiftJIS) {[m
[32m+[m[32m                if (sjisBytesLeft > 0) {[m
[32m+[m[32m                    if (value < 0x40 || value === 0x7F || value > 0xFC) {[m
[32m+[m[32m                        canBeShiftJIS = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        sjisBytesLeft--;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {[m
[32m+[m[32m                    canBeShiftJIS = false;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (value > 0xA0 && value < 0xE0) {[m
[32m+[m[32m                    sjisKatakanaChars++;[m
[32m+[m[32m                    sjisCurDoubleBytesWordLength = 0;[m
[32m+[m[32m                    sjisCurKatakanaWordLength++;[m
[32m+[m[32m                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {[m
[32m+[m[32m                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (value > 0x7F) {[m
[32m+[m[32m                    sjisBytesLeft++;[m
[32m+[m[32m                    // sjisDoubleBytesChars++[m
[32m+[m[32m                    sjisCurKatakanaWordLength = 0;[m
[32m+[m[32m                    sjisCurDoubleBytesWordLength++;[m
[32m+[m[32m                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {[m
[32m+[m[32m                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    // sjisLowChars++[m
[32m+[m[32m                    sjisCurKatakanaWordLength = 0;[m
[32m+[m[32m                    sjisCurDoubleBytesWordLength = 0;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (canBeUTF8 && utf8BytesLeft > 0) {[m
[32m+[m[32m            canBeUTF8 = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (canBeShiftJIS && sjisBytesLeft > 0) {[m
[32m+[m[32m            canBeShiftJIS = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done[m
[32m+[m[32m        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {[m
[32m+[m[32m            return StringUtils.UTF8;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done[m
[32m+[m[32m        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {[m
[32m+[m[32m            return StringUtils.SHIFT_JIS;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:[m
[32m+[m[32m        // - If we saw[m
[32m+[m[32m        //   - only two consecutive katakana chars in the whole text, or[m
[32m+[m[32m        //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,[m
[32m+[m[32m        // - then we conclude Shift_JIS, else ISO-8859-1[m
[32m+[m[32m        if (canBeISO88591 && canBeShiftJIS) {[m
[32m+[m[32m            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length[m
[32m+[m[32m                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding[m
[32m+[m[32m        if (canBeISO88591) {[m
[32m+[m[32m            return StringUtils.ISO88591;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (canBeShiftJIS) {[m
[32m+[m[32m            return StringUtils.SHIFT_JIS;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (canBeUTF8) {[m
[32m+[m[32m            return StringUtils.UTF8;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Otherwise, we take a wild guess with platform encoding[m
[32m+[m[32m        return StringUtils.PLATFORM_DEFAULT_ENCODING;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see https://stackoverflow.com/a/13439711/4367683[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param append The new string to append.[m
[32m+[m[32m     * @param args Argumets values to be formated.[m
[32m+[m[32m     */[m
[32m+[m[32m    StringUtils.format = function (append) {[m
[32m+[m[32m        var args = [];[m
[32m+[m[32m        for (var _i = 1; _i < arguments.length; _i++) {[m
[32m+[m[32m            args[_i - 1] = arguments[_i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var i = -1;[m
[32m+[m[32m        function callback(exp, p0, p1, p2, p3, p4) {[m
[32m+[m[32m            if (exp === '%%')[m
[32m+[m[32m                return '%';[m
[32m+[m[32m            if (args[++i] === undefined)[m
[32m+[m[32m                return undefined;[m
[32m+[m[32m            exp = p2 ? parseInt(p2.substr(1)) : undefined;[m
[32m+[m[32m            var base = p3 ? parseInt(p3.substr(1)) : undefined;[m
[32m+[m[32m            var val;[m
[32m+[m[32m            switch (p4) {[m
[32m+[m[32m                case 's':[m
[32m+[m[32m                    val = args[i];[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'c':[m
[32m+[m[32m                    val = args[i][0];[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'f':[m
[32m+[m[32m                    val = parseFloat(args[i]).toFixed(exp);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'p':[m
[32m+[m[32m                    val = parseFloat(args[i]).toPrecision(exp);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'e':[m
[32m+[m[32m                    val = parseFloat(args[i]).toExponential(exp);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'x':[m
[32m+[m[32m                    val = parseInt(args[i]).toString(base ? base : 16);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 'd':[m
[32m+[m[32m                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);[m
[32m+[m[32m                    break;[m
[32m+[m[32m            }[m
[32m+[m[32m            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);[m
[32m+[m[32m            var size = parseInt(p1); /* padding size */[m
[32m+[m[32m            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */[m
[32m+[m[32m            while (val.length < size)[m
[32m+[m[32m                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */[m
[32m+[m[32m            return val;[m
[32m+[m[32m        }[m
[32m+[m[32m        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;[m
[32m+[m[32m        return append.replace(regex, callback);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     */[m
[32m+[m[32m    StringUtils.getBytes = function (str, encoding) {[m
[32m+[m[32m        return StringEncoding_1.default.encode(str, encoding);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the charcode at the specified index or at index zero.[m
[32m+[m[32m     */[m
[32m+[m[32m    StringUtils.getCharCode = function (str, index) {[m
[32m+[m[32m        if (index === void 0) { index = 0; }[m
[32m+[m[32m        return str.charCodeAt(index);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns char for given charcode[m
[32m+[m[32m     */[m
[32m+[m[32m    StringUtils.getCharAt = function (charCode) {[m
[32m+[m[32m        return String.fromCharCode(charCode);[m
[32m+[m[32m    };[m
[32m+[m[32m    StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // "SJIS"[m
[32m+[m[32m    StringUtils.GB2312 = 'GB2312';[m
[32m+[m[32m    StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // "ISO8859_1"[m
[32m+[m[32m    StringUtils.EUC_JP = 'EUC_JP';[m
[32m+[m[32m    StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // "UTF8"[m
[32m+[m[32m    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // "UTF8"//Charset.defaultCharset().name()[m
[32m+[m[32m    StringUtils.ASSUME_SHIFT_JIS = false;[m
[32m+[m[32m    return StringUtils;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = StringUtils;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..35156d3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.d.ts[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Mariusz DƒÖbrowski[m
[32m+[m[32m */[m
[32m+[m[32mexport default class CornerDetector {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private leftInit;[m
[32m+[m[32m    private rightInit;[m
[32m+[m[32m    private downInit;[m
[32m+[m[32m    private upInit;[m
[32m+[m[32m    private targetMatrixSize;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException if image is too small to accommodate {@code initSize}[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(image: BitMatrix, initSize: number, x: number, y: number, targetMatrixSize: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    detect(): ResultPoint[];[m
[32m+[m[32m    private findCorners;[m
[32m+[m[32m    private getCornerFromArea;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines whether a segment contains a black point[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a          min value of the scanned coordinate[m
[32m+[m[32m     * @param b          max value of the scanned coordinate[m
[32m+[m[32m     * @param fixed      value of fixed coordinate[m
[32m+[m[32m     * @param horizontal set to true if scan must be horizontal, false if vertical[m
[32m+[m[32m     * @return true if a black point has been found, else false.[m
[32m+[m[32m     */[m
[32m+[m[32m    private containsBlackPoint;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.js b/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c5e418b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/CornerDetector.js[m
[36m@@ -0,0 +1,260 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Mariusz DƒÖbrowski[m
[32m+[m[32m */[m
[32m+[m[32mvar CornerDetector = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException if image is too small to accommodate {@code initSize}[m
[32m+[m[32m     */[m
[32m+[m[32m    function CornerDetector(image, initSize, x, y, targetMatrixSize) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.height = image.getHeight();[m
[32m+[m[32m        this.width = image.getWidth();[m
[32m+[m[32m        var halfsize = initSize / 2;[m
[32m+[m[32m        this.leftInit = x - halfsize;[m
[32m+[m[32m        this.rightInit = x + halfsize;[m
[32m+[m[32m        this.upInit = y - halfsize;[m
[32m+[m[32m        this.downInit = y + halfsize;[m
[32m+[m[32m        this.targetMatrixSize = targetMatrixSize * 2;[m
[32m+[m[32m        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    CornerDetector.prototype.detect = function () {[m
[32m+[m[32m        var left = this.leftInit;[m
[32m+[m[32m        var right = this.rightInit;[m
[32m+[m[32m        var up = this.upInit;[m
[32m+[m[32m        var down = this.downInit;[m
[32m+[m[32m        var sizeExceeded = false;[m
[32m+[m[32m        var aBlackPointFoundOnBorder = true;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnBorder = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnRight = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnBottom = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnLeft = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnTop = false;[m
[32m+[m[32m        while (aBlackPointFoundOnBorder) {[m
[32m+[m[32m            aBlackPointFoundOnBorder = false;[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // . |[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var rightBorderNotWhite = true;[m
[32m+[m[32m            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < this.width) {[m
[32m+[m[32m                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);[m
[32m+[m[32m                if (rightBorderNotWhite) {[m
[32m+[m[32m                    right++;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnRight = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnRight) {[m
[32m+[m[32m                    right++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (right >= this.width) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // . .[m
[32m+[m[32m            // .___.[m
[32m+[m[32m            var bottomBorderNotWhite = true;[m
[32m+[m[32m            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < this.height) {[m
[32m+[m[32m                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);[m
[32m+[m[32m                if (bottomBorderNotWhite) {[m
[32m+[m[32m                    down++;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnBottom = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnBottom) {[m
[32m+[m[32m                    down++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (down >= this.height) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // | .[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var leftBorderNotWhite = true;[m
[32m+[m[32m            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {[m
[32m+[m[32m                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);[m
[32m+[m[32m                if (leftBorderNotWhite) {[m
[32m+[m[32m                    left--;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnLeft = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnLeft) {[m
[32m+[m[32m                    left--;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (left < 0) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .___.[m
[32m+[m[32m            // . .[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var topBorderNotWhite = true;[m
[32m+[m[32m            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {[m
[32m+[m[32m                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);[m
[32m+[m[32m                if (topBorderNotWhite) {[m
[32m+[m[32m                    up--;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnTop = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnTop) {[m
[32m+[m[32m                    up--;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (up < 0) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (aBlackPointFoundOnBorder) {[m
[32m+[m[32m                atLeastOneBlackPointFoundOnBorder = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {[m
[32m+[m[32m            return this.findCorners(right, left, down, up);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    CornerDetector.prototype.findCorners = function (right, left, down, up) {[m
[32m+[m[32m        //[m
[32m+[m[32m        //      A------------              ------------B[m
[32m+[m[32m        //      |           |      up      |           |[m
[32m+[m[32m        //      |    -------|--------------|-------    |[m
[32m+[m[32m        //      |    |      |              |      |    |[m
[32m+[m[32m        //      |    |      |              |      |    |[m
[32m+[m[32m        //      ------------AP            BP------------[m
[32m+[m[32m        //           |                            |[m
[32m+[m[32m        //           |                            |[m
[32m+[m[32m        //      left |                            | right[m
[32m+[m[32m        //           |                            |[m
[32m+[m[32m        //           |                            |[m
[32m+[m[32m        //      ------------DP            CP------------[m
[32m+[m[32m        //      |    |      |             |       |    |[m
[32m+[m[32m        //      |    |      |   down      |       |    |[m
[32m+[m[32m        //      |    -------|-------------|--------    |[m
[32m+[m[32m        //      |           |             |            |[m
[32m+[m[32m        //      D-----------|             |------------C[m
[32m+[m[32m        //[m
[32m+[m[32m        var width = right - left;[m
[32m+[m[32m        var height = down - up;[m
[32m+[m[32m        var sampler = 16 / this.targetMatrixSize;[m
[32m+[m[32m        var sampler2 = 4 / this.targetMatrixSize;[m
[32m+[m[32m        var deltaX = width * sampler2;[m
[32m+[m[32m        var deltaY = height * sampler2;[m
[32m+[m[32m        var areaWidth = deltaX + (right - left) * sampler;[m
[32m+[m[32m        var areaHeight = deltaY + (down - up) * sampler;[m
[32m+[m[32m        var a = new ResultPoint_1.default(left - deltaX, up - deltaY);[m
[32m+[m[32m        var b = new ResultPoint_1.default(right + deltaX, up - deltaY);[m
[32m+[m[32m        var c = new ResultPoint_1.default(right + deltaX, down + deltaY);[m
[32m+[m[32m        var d = new ResultPoint_1.default(left - deltaX, down + deltaY);[m
[32m+[m[32m        var ap = new ResultPoint_1.default(a.getX() + areaWidth, a.getY() + areaHeight);[m
[32m+[m[32m        var bp = new ResultPoint_1.default(b.getX() - areaWidth, b.getY() + areaHeight);[m
[32m+[m[32m        var cp = new ResultPoint_1.default(c.getX() - areaWidth, c.getY() - areaHeight);[m
[32m+[m[32m        var dp = new ResultPoint_1.default(d.getX() + areaWidth, d.getY() - areaHeight);[m
[32m+[m[32m        var topLeftCorner = this.getCornerFromArea(a.getX(), ap.getX(), a.getY(), ap.getY(), false, false);[m
[32m+[m[32m        var topRightCorner = this.getCornerFromArea(bp.getX(), b.getX(), b.getY(), bp.getY(), true, false);[m
[32m+[m[32m        var bottomRightCorner = this.getCornerFromArea(cp.getX(), c.getX(), cp.getY(), c.getY(), true, true);[m
[32m+[m[32m        var bottomLeftCorner = this.getCornerFromArea(d.getX(), dp.getX(), dp.getY(), d.getY(), false, true);[m
[32m+[m[32m        var xCorrection = (topRightCorner.getX() - topLeftCorner.getX()) / this.targetMatrixSize;[m
[32m+[m[32m        var yCorrection = (bottomRightCorner.getY() - topRightCorner.getY()) / this.targetMatrixSize;[m
[32m+[m[32m        var topLeftCornerCenter = new ResultPoint_1.default(topLeftCorner.getX() + xCorrection, topLeftCorner.getY() + yCorrection);[m
[32m+[m[32m        var topRightCornerCenter = new ResultPoint_1.default(topRightCorner.getX() - xCorrection, topRightCorner.getY() + yCorrection);[m
[32m+[m[32m        var bottomRightCornerCenter = new ResultPoint_1.default(bottomRightCorner.getX() - xCorrection, bottomRightCorner.getY() - yCorrection);[m
[32m+[m[32m        var bottomLeftCornerCenter = new ResultPoint_1.default(bottomLeftCorner.getX() + xCorrection, bottomLeftCorner.getY() - yCorrection);[m
[32m+[m[32m        var result = [topLeftCornerCenter, topRightCornerCenter, bottomRightCornerCenter, bottomLeftCornerCenter];[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    CornerDetector.prototype.getCornerFromArea = function (left, right, top, bottom, maximizeX, maximizeY) {[m
[32m+[m[32m        var resX = maximizeX ? 0 : Number.MAX_VALUE;[m
[32m+[m[32m        var resY = maximizeY ? 0 : Number.MAX_VALUE;[m
[32m+[m[32m        for (var x = left; x < right; x++) {[m
[32m+[m[32m            for (var y = top; y < bottom; y++) {[m
[32m+[m[32m                if (x > 0 && y > 0 && x < this.image.getWidth() && y < this.image.getHeight()) {[m
[32m+[m[32m                    if (this.image.get(x, y)) {[m
[32m+[m[32m                        if (maximizeX) {[m
[32m+[m[32m                            if (x > resX) {[m
[32m+[m[32m                                resX = x;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            if (x < resX) {[m
[32m+[m[32m                                resX = x;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (maximizeY) {[m
[32m+[m[32m                            if (y > resY) {[m
[32m+[m[32m                                resY = y;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            if (y < resY) {[m
[32m+[m[32m                                resY = y;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (resX === 0 || resY === 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return new ResultPoint_1.default(resX, resY);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines whether a segment contains a black point[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a          min value of the scanned coordinate[m
[32m+[m[32m     * @param b          max value of the scanned coordinate[m
[32m+[m[32m     * @param fixed      value of fixed coordinate[m
[32m+[m[32m     * @param horizontal set to true if scan must be horizontal, false if vertical[m
[32m+[m[32m     * @return true if a black point has been found, else false.[m
[32m+[m[32m     */[m
[32m+[m[32m    CornerDetector.prototype.containsBlackPoint = function (a, b, fixed, horizontal) {[m
[32m+[m[32m        if (horizontal) {[m
[32m+[m[32m            for (var x = a; x <= b; x++) {[m
[32m+[m[32m                if (this.image.get(x, fixed)) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            for (var y = a; y <= b; y++) {[m
[32m+[m[32m                if (this.image.get(fixed, y)) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    return CornerDetector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = CornerDetector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0a5e2e3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.d.ts[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * General math-related and numeric utility functions.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MathUtils {[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its[m
[32m+[m[32m     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut[m
[32m+[m[32m     * differ slightly from {@link Math#round(float)} in that half rounds down for negative[m
[32m+[m[32m     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param d real value to round[m
[32m+[m[32m     * @return nearest {@code int}[m
[32m+[m[32m     */[m
[32m+[m[32m    static round(d: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param aX point A x coordinate[m
[32m+[m[32m     * @param aY point A y coordinate[m
[32m+[m[32m     * @param bX point B x coordinate[m
[32m+[m[32m     * @param bY point B y coordinate[m
[32m+[m[32m     * @return Euclidean distance between points A and B[m
[32m+[m[32m     */[m
[32m+[m[32m    static distance(aX: number, aY: number, bX: number, bY: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param aX point A x coordinate[m
[32m+[m[32m     * @param aY point A y coordinate[m
[32m+[m[32m     * @param bX point B x coordinate[m
[32m+[m[32m     * @param bY point B y coordinate[m
[32m+[m[32m     * @return Euclidean distance between points A and B[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param array values to sum[m
[32m+[m[32m     * @return sum of values in array[m
[32m+[m[32m     */[m
[32m+[m[32m    static sum(array: Int32Array): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f425a5d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MathUtils.js[m
[36m@@ -0,0 +1,82 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2012 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.detector {*/[m
[32m+[m[32m/**[m
[32m+[m[32m * General math-related and numeric utility functions.[m
[32m+[m[32m */[m
[32m+[m[32mvar MathUtils = /** @class */ (function () {[m
[32m+[m[32m    function MathUtils() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its[m
[32m+[m[32m     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut[m
[32m+[m[32m     * differ slightly from {@link Math#round(float)} in that half rounds down for negative[m
[32m+[m[32m     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param d real value to round[m
[32m+[m[32m     * @return nearest {@code int}[m
[32m+[m[32m     */[m
[32m+[m[32m    MathUtils.round = function (d /*float*/) {[m
[32m+[m[32m        if (isNaN(d))[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        if (d <= Number.MIN_SAFE_INTEGER)[m
[32m+[m[32m            return Number.MIN_SAFE_INTEGER;[m
[32m+[m[32m        if (d >= Number.MAX_SAFE_INTEGER)[m
[32m+[m[32m            return Number.MAX_SAFE_INTEGER;[m
[32m+[m[32m        return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param aX point A x coordinate[m
[32m+[m[32m     * @param aY point A y coordinate[m
[32m+[m[32m     * @param bX point B x coordinate[m
[32m+[m[32m     * @param bY point B y coordinate[m
[32m+[m[32m     * @return Euclidean distance between points A and B[m
[32m+[m[32m     */[m
[32m+[m[32m    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {[m
[32m+[m[32m        var xDiff = aX - bX;[m
[32m+[m[32m        var yDiff = aY - bY;[m
[32m+[m[32m        return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param aX point A x coordinate[m
[32m+[m[32m     * @param aY point A y coordinate[m
[32m+[m[32m     * @param bX point B x coordinate[m
[32m+[m[32m     * @param bY point B y coordinate[m
[32m+[m[32m     * @return Euclidean distance between points A and B[m
[32m+[m[32m     */[m
[32m+[m[32m    // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {[m
[32m+[m[32m    //   const xDiff = aX - bX[m
[32m+[m[32m    //   const yDiff = aY - bY[m
[32m+[m[32m    //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param array values to sum[m
[32m+[m[32m     * @return sum of values in array[m
[32m+[m[32m     */[m
[32m+[m[32m    MathUtils.sum = function (array) {[m
[32m+[m[32m        var count = 0;[m
[32m+[m[32m        for (var i = 0, length_1 = array.length; i !== length_1; i++) {[m
[32m+[m[32m            var a = array[i];[m
[32m+[m[32m            count += a;[m
[32m+[m[32m        }[m
[32m+[m[32m        return count;[m
[32m+[m[32m    };[m
[32m+[m[32m    return MathUtils;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = MathUtils;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/MonochromeRectangleDetector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MonochromeRectangleDetector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/MonochromeRectangleDetector.js b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MonochromeRectangleDetector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..065762f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/MonochromeRectangleDetector.js[m
[36m@@ -0,0 +1,200 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m// /*[m
[32m+[m[32m//  * Copyright 2009 ZXing authors[m
[32m+[m[32m//  *[m
[32m+[m[32m//  * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m//  * you may not use this file except in compliance with the License.[m
[32m+[m[32m//  * You may obtain a copy of the License at[m
[32m+[m[32m//  *[m
[32m+[m[32m//  *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m//  *[m
[32m+[m[32m//  * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m//  * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m//  * See the License for the specific language governing permissions and[m
[32m+[m[32m//  * limitations under the License.[m
[32m+[m[32m//  */[m
[32m+[m[32m// /*namespace com.google.zxing.common.detector {*/[m
[32m+[m[32m// import ResultPoint from '../../ResultPoint'[m
[32m+[m[32m// import BitMatrix from '../BitMatrix'[m
[32m+[m[32m// /**[m
[32m+[m[32m//  * <p>A somewhat generic detector that looks for a barcode-like rectangular region within an image.[m
[32m+[m[32m//  * It looks within a mostly white region of an image for a region of black and white, but mostly[m
[32m+[m[32m//  * black. It returns the four corners of the region, as best it can determine.</p>[m
[32m+[m[32m//  *[m
[32m+[m[32m//  * @author Sean Owen[m
[32m+[m[32m//  * @deprecated without replacement since 3.3.0[m
[32m+[m[32m//  */[m
[32m+[m[32m// @Deprecated[m
[32m+[m[32m// export default class MonochromeRectangleDetector {[m
[32m+[m[32m//   private 32: static final int MAX_MODULES =[m
[32m+[m[32m//   private image: BitMatrix[m
[32m+[m[32m//   public constructor(image: BitMatrix) {[m
[32m+[m[32m//     this.image = image[m
[32m+[m[32m//   }[m
[32m+[m[32m//   /**[m
[32m+[m[32m//    * <p>Detects a rectangular region of black and white -- mostly black -- with a region of mostly[m
[32m+[m[32m//    * white, in an image.</p>[m
[32m+[m[32m//    *[m
[32m+[m[32m//    * @return {@link ResultPoint}[] describing the corners of the rectangular region. The first and[m
[32m+[m[32m//    *  last points are opposed on the diagonal, as are the second and third. The first point will be[m
[32m+[m[32m//    *  the topmost point and the last, the bottommost. The second point will be leftmost and the[m
[32m+[m[32m//    *  third, the rightmost[m
[32m+[m[32m//    * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m//    */[m
[32m+[m[32m//   public detect(): ResultPoInt32Array /*throws NotFoundException*/ {[m
[32m+[m[32m//     height: number /*int*/ = image.getHeight();[m
[32m+[m[32m//     width: number /*int*/ = image.getWidth();[m
[32m+[m[32m//     const halfHeight = height / 2[m
[32m+[m[32m//     const halfWidth = width / 2[m
[32m+[m[32m//     const deltaY = Math.max(1, height / (MAX_MODULES * 8));[m
[32m+[m[32m//     const deltaX = Math.max(1, width / (MAX_MODULES * 8));[m
[32m+[m[32m//     const top = 0[m
[32m+[m[32m//     const bottom = height[m
[32m+[m[32m//     const left = 0[m
[32m+[m[32m//     const right = width[m
[32m+[m[32m//     ResultPoint pointA = findCornerFromCenter(halfWidth, 0, left, right,[m
[32m+[m[32m//         halfHeight, -deltaY, top, bottom, halfWidth / 2)[m
[32m+[m[32m//     top = (int) pointA.getY() - 1[m
[32m+[m[32m//     ResultPoint pointB = findCornerFromCenter(halfWidth, -deltaX, left, right,[m
[32m+[m[32m//         halfHeight, 0, top, bottom, halfHeight / 2)[m
[32m+[m[32m//     left = (int) pointB.getX() - 1[m
[32m+[m[32m//     ResultPoint pointC = findCornerFromCenter(halfWidth, deltaX, left, right,[m
[32m+[m[32m//         halfHeight, 0, top, bottom, halfHeight / 2)[m
[32m+[m[32m//     right = (int) pointC.getX() + 1[m
[32m+[m[32m//     ResultPoint pointD = findCornerFromCenter(halfWidth, 0, left, right,[m
[32m+[m[32m//         halfHeight, deltaY, top, bottom, halfWidth / 2)[m
[32m+[m[32m//     bottom = (int) pointD.getY() + 1[m
[32m+[m[32m//     // Go try to find point A again with better information -- might have been off at first.[m
[32m+[m[32m//     pointA = findCornerFromCenter(halfWidth, 0, left, right,[m
[32m+[m[32m//         halfHeight, -deltaY, top, bottom, halfWidth / 4)[m
[32m+[m[32m//     return new ResultPoInt32Array { pointA, pointB, pointC, pointD }[m
[32m+[m[32m//   }[m
[32m+[m[32m//   /**[m
[32m+[m[32m//    * Attempts to locate a corner of the barcode by scanning up, down, left or right from a center[m
[32m+[m[32m//    * point which should be within the barcode.[m
[32m+[m[32m//    *[m
[32m+[m[32m//    * @param centerX center's x component (horizontal)[m
[32m+[m[32m//    * @param deltaX same as deltaY but change in x per step instead[m
[32m+[m[32m//    * @param left minimum value of x[m
[32m+[m[32m//    * @param right maximum value of x[m
[32m+[m[32m//    * @param centerY center's y component (vertical)[m
[32m+[m[32m//    * @param deltaY change in y per step. If scanning up this is negative; down, positive;[m
[32m+[m[32m//    *  left or right, 0[m
[32m+[m[32m//    * @param top minimum value of y to search through (meaningless when di == 0)[m
[32m+[m[32m//    * @param bottom maximum value of y[m
[32m+[m[32m//    * @param maxWhiteRun maximum run of white pixels that can still be considered to be within[m
[32m+[m[32m//    *  the barcode[m
[32m+[m[32m//    * @return a {@link ResultPoint} encapsulating the corner that was found[m
[32m+[m[32m//    * @throws NotFoundException if such a point cannot be found[m
[32m+[m[32m//    */[m
[32m+[m[32m//   private ResultPoint findCornerFromCenter(centerX: number /*int*/,[m
[32m+[m[32m//                                            deltaX: number /*int*/,[m
[32m+[m[32m//                                            left: number /*int*/,[m
[32m+[m[32m//                                            right: number /*int*/,[m
[32m+[m[32m//                                            centerY: number /*int*/,[m
[32m+[m[32m//                                            deltaY: number /*int*/,[m
[32m+[m[32m//                                            top: number /*int*/,[m
[32m+[m[32m//                                            bottom: number /*int*/,[m
[32m+[m[32m//                                            maxWhiteRun: number /*int*/) /*throws NotFoundException*/ {[m
[32m+[m[32m//     const lastRange: Int32Array = null[m
[32m+[m[32m//     for (let y = centerY, x = centerX[m
[32m+[m[32m//          y < bottom && y >= top && x < right && x >= left[m
[32m+[m[32m//          y += deltaY, x += deltaX) {[m
[32m+[m[32m//       const range: Int32Array[m
[32m+[m[32m//       if (deltaX == 0) {[m
[32m+[m[32m//         // horizontal slices, up and down[m
[32m+[m[32m//         range = blackWhiteRange(y, maxWhiteRun, left, right, true)[m
[32m+[m[32m//       } else {[m
[32m+[m[32m//         // vertical slices, left and right[m
[32m+[m[32m//         range = blackWhiteRange(x, maxWhiteRun, top, bottom, false)[m
[32m+[m[32m//       }[m
[32m+[m[32m//       if (range == null) {[m
[32m+[m[32m//         if (lastRange == null) {[m
[32m+[m[32m//           throw NotFoundException.getNotFoundInstance()[m
[32m+[m[32m//         }[m
[32m+[m[32m//         // lastRange was found[m
[32m+[m[32m//         if (deltaX == 0) {[m
[32m+[m[32m//           const lastY = y - deltaY[m
[32m+[m[32m//           if (lastRange[0] < centerX) {[m
[32m+[m[32m//             if (lastRange[1] > centerX) {[m
[32m+[m[32m//               // straddle, choose one or the other based on direction[m
[32m+[m[32m//               return new ResultPoint(lastRange[deltaY > 0 ? 0 : 1], lastY)[m
[32m+[m[32m//             }[m
[32m+[m[32m//             return new ResultPoint(lastRange[0], lastY)[m
[32m+[m[32m//           } else {[m
[32m+[m[32m//             return new ResultPoint(lastRange[1], lastY)[m
[32m+[m[32m//           }[m
[32m+[m[32m//         } else {[m
[32m+[m[32m//           const lastX = x - deltaX[m
[32m+[m[32m//           if (lastRange[0] < centerY) {[m
[32m+[m[32m//             if (lastRange[1] > centerY) {[m
[32m+[m[32m//               return new ResultPoint(lastX, lastRange[deltaX < 0 ? 0 : 1])[m
[32m+[m[32m//             }[m
[32m+[m[32m//             return new ResultPoint(lastX, lastRange[0])[m
[32m+[m[32m//           } else {[m
[32m+[m[32m//             return new ResultPoint(lastX, lastRange[1])[m
[32m+[m[32m//           }[m
[32m+[m[32m//         }[m
[32m+[m[32m//       }[m
[32m+[m[32m//       lastRange = range[m
[32m+[m[32m//     }[m
[32m+[m[32m//     throw NotFoundException.getNotFoundInstance()[m
[32m+[m[32m//   }[m
[32m+[m[32m//   /**[m
[32m+[m[32m//    * Computes the start and end of a region of pixels, either horizontally or vertically, that could[m
[32m+[m[32m//    * be part of a Data Matrix barcode.[m
[32m+[m[32m//    *[m
[32m+[m[32m//    * @param fixedDimension if scanning horizontally, this is the row (the fixed vertical location)[m
[32m+[m[32m//    *  where we are scanning. If scanning vertically it's the column, the fixed horizontal location[m
[32m+[m[32m//    * @param maxWhiteRun largest run of white pixels that can still be considered part of the[m
[32m+[m[32m//    *  barcode region[m
[32m+[m[32m//    * @param minDim minimum pixel location, horizontally or vertically, to consider[m
[32m+[m[32m//    * @param maxDim maximum pixel location, horizontally or vertically, to consider[m
[32m+[m[32m//    * @param horizontal if true, we're scanning left-right, instead of up-down[m
[32m+[m[32m//    * @return const with: Int32Array start and end of found range, or null if no such range is found[m
[32m+[m[32m//    *  (e.g. only white was found)[m
[32m+[m[32m//    */[m
[32m+[m[32m//   private const blackWhiteRange: Int32Array(fixedDimension: number /*int*/, maxWhiteRun: number /*int*/, minDim: number /*int*/, maxDim: number /*int*/, boolean horizontal) {[m
[32m+[m[32m//     const center = (minDim + maxDim) / 2[m
[32m+[m[32m//     // Scan left/up first[m
[32m+[m[32m//     const start = center[m
[32m+[m[32m//     while (start >= minDim) {[m
[32m+[m[32m//       if (horizontal ? image.get(start, fixedDimension) : image.get(fixedDimension, start)) {[m
[32m+[m[32m//         start--[m
[32m+[m[32m//       } else {[m
[32m+[m[32m//         const whiteRunStart = start[m
[32m+[m[32m//         do {[m
[32m+[m[32m//           start--[m
[32m+[m[32m//         } while (start >= minDim && !(horizontal ? image.get(start, fixedDimension) :[m
[32m+[m[32m//             image.get(fixedDimension, start)))[m
[32m+[m[32m//         const whiteRunSize = whiteRunStart - start[m
[32m+[m[32m//         if (start < minDim || whiteRunSize > maxWhiteRun) {[m
[32m+[m[32m//           start = whiteRunStart[m
[32m+[m[32m//           break[m
[32m+[m[32m//         }[m
[32m+[m[32m//       }[m
[32m+[m[32m//     }[m
[32m+[m[32m//     start++[m
[32m+[m[32m//     // Then try right/down[m
[32m+[m[32m//     const end = center[m
[32m+[m[32m//     while (end < maxDim) {[m
[32m+[m[32m//       if (horizontal ? image.get(end, fixedDimension) : image.get(fixedDimension, end)) {[m
[32m+[m[32m//         end++[m
[32m+[m[32m//       } else {[m
[32m+[m[32m//         const whiteRunStart = end[m
[32m+[m[32m//         do {[m
[32m+[m[32m//           end++[m
[32m+[m[32m//         } while (end < maxDim && !(horizontal ? image.get(end, fixedDimension) :[m
[32m+[m[32m//             image.get(fixedDimension, end)))[m
[32m+[m[32m//         const whiteRunSize = end - whiteRunStart[m
[32m+[m[32m//         if (end >= maxDim || whiteRunSize > maxWhiteRun) {[m
[32m+[m[32m//           end = whiteRunStart[m
[32m+[m[32m//           break[m
[32m+[m[32m//         }[m
[32m+[m[32m//       }[m
[32m+[m[32m//     }[m
[32m+[m[32m//     end--[m
[32m+[m[32m//     return end > start ? new Int32Array{start, end} : null[m
[32m+[m[32m//   }[m
[32m+[m[32m// }[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..fc9bd76[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.d.ts[m
[36m@@ -0,0 +1,71 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>[m
[32m+[m[32m * Detects a candidate barcode-like rectangular region within an image. It[m
[32m+[m[32m * starts around the center of the image, increases the size of the candidate[m
[32m+[m[32m * region until it finds a white rectangular region. By keeping track of the[m
[32m+[m[32m * last black points it encountered, it determines the corners of the barcode.[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mexport default class WhiteRectangleDetector {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private static INIT_SIZE;[m
[32m+[m[32m    private static CORR;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private leftInit;[m
[32m+[m[32m    private rightInit;[m
[32m+[m[32m    private downInit;[m
[32m+[m[32m    private upInit;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param image barcode image to find a rectangle in[m
[32m+[m[32m     * @param initSize initial size of search area around center[m
[32m+[m[32m     * @param x x position of search center[m
[32m+[m[32m     * @param y y position of search center[m
[32m+[m[32m     * @throws NotFoundException if image is too small to accommodate {@code initSize}[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(image: BitMatrix, initSize?: number, x?: number, y?: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>[m
[32m+[m[32m     * Detects a candidate barcode-like rectangular region within an image. It[m
[32m+[m[32m     * starts around the center of the image, increases the size of the candidate[m
[32m+[m[32m     * region until it finds a white rectangular region.[m
[32m+[m[32m     * </p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link ResultPoint}[] describing the corners of the rectangular[m
[32m+[m[32m     *         region. The first and last points are opposed on the diagonal, as[m
[32m+[m[32m     *         are the second and third. The first point will be the topmost[m
[32m+[m[32m     *         point and the last, the bottommost. The second point will be[m
[32m+[m[32m     *         leftmost and the third, the rightmost[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    detect(): Array<ResultPoint>;[m
[32m+[m[32m    private getBlackPointOnSegment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * recenters the points of a constant distance towards the center[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y bottom most point[m
[32m+[m[32m     * @param z left most point[m
[32m+[m[32m     * @param x right most point[m
[32m+[m[32m     * @param t top most point[m
[32m+[m[32m     * @return {@link ResultPoint}[] describing the corners of the rectangular[m
[32m+[m[32m     *         region. The first and last points are opposed on the diagonal, as[m
[32m+[m[32m     *         are the second and third. The first point will be the topmost[m
[32m+[m[32m     *         point and the last, the bottommost. The second point will be[m
[32m+[m[32m     *         leftmost and the third, the rightmost[m
[32m+[m[32m     */[m
[32m+[m[32m    private centerEdges;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines whether a segment contains a black point[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a          min value of the scanned coordinate[m
[32m+[m[32m     * @param b          max value of the scanned coordinate[m
[32m+[m[32m     * @param fixed      value of fixed coordinate[m
[32m+[m[32m     * @param horizontal set to true if scan must be horizontal, false if vertical[m
[32m+[m[32m     * @return true if a black point has been found, else false.[m
[32m+[m[32m     */[m
[32m+[m[32m    private containsBlackPoint;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js b/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bbe8285[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js[m
[36m@@ -0,0 +1,305 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.detector {*/[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar MathUtils_1 = require("./MathUtils");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>[m
[32m+[m[32m * Detects a candidate barcode-like rectangular region within an image. It[m
[32m+[m[32m * starts around the center of the image, increases the size of the candidate[m
[32m+[m[32m * region until it finds a white rectangular region. By keeping track of the[m
[32m+[m[32m * last black points it encountered, it determines the corners of the barcode.[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mvar WhiteRectangleDetector = /** @class */ (function () {[m
[32m+[m[32m    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {[m
[32m+[m[32m    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param image barcode image to find a rectangle in[m
[32m+[m[32m     * @param initSize initial size of search area around center[m
[32m+[m[32m     * @param x x position of search center[m
[32m+[m[32m     * @param y y position of search center[m
[32m+[m[32m     * @throws NotFoundException if image is too small to accommodate {@code initSize}[m
[32m+[m[32m     */[m
[32m+[m[32m    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.height = image.getHeight();[m
[32m+[m[32m        this.width = image.getWidth();[m
[32m+[m[32m        if (undefined === initSize || null === initSize) {[m
[32m+[m[32m            initSize = WhiteRectangleDetector.INIT_SIZE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === x || null === x) {[m
[32m+[m[32m            x = image.getWidth() / 2 | 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (undefined === y || null === y) {[m
[32m+[m[32m            y = image.getHeight() / 2 | 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var halfsize = initSize / 2 | 0;[m
[32m+[m[32m        this.leftInit = x - halfsize;[m
[32m+[m[32m        this.rightInit = x + halfsize;[m
[32m+[m[32m        this.upInit = y - halfsize;[m
[32m+[m[32m        this.downInit = y + halfsize;[m
[32m+[m[32m        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>[m
[32m+[m[32m     * Detects a candidate barcode-like rectangular region within an image. It[m
[32m+[m[32m     * starts around the center of the image, increases the size of the candidate[m
[32m+[m[32m     * region until it finds a white rectangular region.[m
[32m+[m[32m     * </p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link ResultPoint}[] describing the corners of the rectangular[m
[32m+[m[32m     *         region. The first and last points are opposed on the diagonal, as[m
[32m+[m[32m     *         are the second and third. The first point will be the topmost[m
[32m+[m[32m     *         point and the last, the bottommost. The second point will be[m
[32m+[m[32m     *         leftmost and the third, the rightmost[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    WhiteRectangleDetector.prototype.detect = function () {[m
[32m+[m[32m        var left = this.leftInit;[m
[32m+[m[32m        var right = this.rightInit;[m
[32m+[m[32m        var up = this.upInit;[m
[32m+[m[32m        var down = this.downInit;[m
[32m+[m[32m        var sizeExceeded = false;[m
[32m+[m[32m        var aBlackPointFoundOnBorder = true;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnBorder = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnRight = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnBottom = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnLeft = false;[m
[32m+[m[32m        var atLeastOneBlackPointFoundOnTop = false;[m
[32m+[m[32m        var width = this.width;[m
[32m+[m[32m        var height = this.height;[m
[32m+[m[32m        while (aBlackPointFoundOnBorder) {[m
[32m+[m[32m            aBlackPointFoundOnBorder = false;[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // .   |[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var rightBorderNotWhite = true;[m
[32m+[m[32m            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {[m
[32m+[m[32m                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);[m
[32m+[m[32m                if (rightBorderNotWhite) {[m
[32m+[m[32m                    right++;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnRight = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnRight) {[m
[32m+[m[32m                    right++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (right >= width) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // .   .[m
[32m+[m[32m            // .___.[m
[32m+[m[32m            var bottomBorderNotWhite = true;[m
[32m+[m[32m            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {[m
[32m+[m[32m                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);[m
[32m+[m[32m                if (bottomBorderNotWhite) {[m
[32m+[m[32m                    down++;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnBottom = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnBottom) {[m
[32m+[m[32m                    down++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (down >= height) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .....[m
[32m+[m[32m            // |   .[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var leftBorderNotWhite = true;[m
[32m+[m[32m            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {[m
[32m+[m[32m                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);[m
[32m+[m[32m                if (leftBorderNotWhite) {[m
[32m+[m[32m                    left--;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnLeft = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnLeft) {[m
[32m+[m[32m                    left--;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (left < 0) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // .___.[m
[32m+[m[32m            // .   .[m
[32m+[m[32m            // .....[m
[32m+[m[32m            var topBorderNotWhite = true;[m
[32m+[m[32m            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {[m
[32m+[m[32m                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);[m
[32m+[m[32m                if (topBorderNotWhite) {[m
[32m+[m[32m                    up--;[m
[32m+[m[32m                    aBlackPointFoundOnBorder = true;[m
[32m+[m[32m                    atLeastOneBlackPointFoundOnTop = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (!atLeastOneBlackPointFoundOnTop) {[m
[32m+[m[32m                    up--;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (up < 0) {[m
[32m+[m[32m                sizeExceeded = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (aBlackPointFoundOnBorder) {[m
[32m+[m[32m                atLeastOneBlackPointFoundOnBorder = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {[m
[32m+[m[32m            var maxSize = right - left;[m
[32m+[m[32m            var z = null;[m
[32m+[m[32m            for (var i = 1; z === null && i < maxSize; i++) {[m
[32m+[m[32m                z = this.getBlackPointOnSegment(left, down - i, left + i, down);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (z == null) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var t = null;[m
[32m+[m[32m            // go down right[m
[32m+[m[32m            for (var i = 1; t === null && i < maxSize; i++) {[m
[32m+[m[32m                t = this.getBlackPointOnSegment(left, up + i, left + i, up);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (t == null) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var x = null;[m
[32m+[m[32m            // go down left[m
[32m+[m[32m            for (var i = 1; x === null && i < maxSize; i++) {[m
[32m+[m[32m                x = this.getBlackPointOnSegment(right, up + i, right - i, up);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (x == null) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var y = null;[m
[32m+[m[32m            // go up left[m
[32m+[m[32m            for (var i = 1; y === null && i < maxSize; i++) {[m
[32m+[m[32m                y = this.getBlackPointOnSegment(right, down - i, right - i, down);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (y == null) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            return this.centerEdges(y, z, x, t);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {[m
[32m+[m[32m        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));[m
[32m+[m[32m        var xStep = (bX - aX) / dist;[m
[32m+[m[32m        var yStep = (bY - aY) / dist;[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        for (var i = 0; i < dist; i++) {[m
[32m+[m[32m            var x = MathUtils_1.default.round(aX + i * xStep);[m
[32m+[m[32m            var y = MathUtils_1.default.round(aY + i * yStep);[m
[32m+[m[32m            if (image.get(x, y)) {[m
[32m+[m[32m                return new ResultPoint_1.default(x, y);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * recenters the points of a constant distance towards the center[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param y bottom most point[m
[32m+[m[32m     * @param z left most point[m
[32m+[m[32m     * @param x right most point[m
[32m+[m[32m     * @param t top most point[m
[32m+[m[32m     * @return {@link ResultPoint}[] describing the corners of the rectangular[m
[32m+[m[32m     *         region. The first and last points are opposed on the diagonal, as[m
[32m+[m[32m     *         are the second and third. The first point will be the topmost[m
[32m+[m[32m     *         point and the last, the bottommost. The second point will be[m
[32m+[m[32m     *         leftmost and the third, the rightmost[m
[32m+[m[32m     */[m
[32m+[m[32m    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {[m
[32m+[m[32m        //[m
[32m+[m[32m        //       t            t[m
[32m+[m[32m        //  z                      x[m
[32m+[m[32m        //        x    OR    z[m
[32m+[m[32m        //   y                    y[m
[32m+[m[32m        //[m
[32m+[m[32m        var yi = y.getX();[m
[32m+[m[32m        var yj = y.getY();[m
[32m+[m[32m        var zi = z.getX();[m
[32m+[m[32m        var zj = z.getY();[m
[32m+[m[32m        var xi = x.getX();[m
[32m+[m[32m        var xj = x.getY();[m
[32m+[m[32m        var ti = t.getX();[m
[32m+[m[32m        var tj = t.getY();[m
[32m+[m[32m        var CORR = WhiteRectangleDetector.CORR;[m
[32m+[m[32m        if (yi < this.width / 2.0) {[m
[32m+[m[32m            return [[m
[32m+[m[32m                new ResultPoint_1.default(ti - CORR, tj + CORR),[m
[32m+[m[32m                new ResultPoint_1.default(zi + CORR, zj + CORR),[m
[32m+[m[32m                new ResultPoint_1.default(xi - CORR, xj - CORR),[m
[32m+[m[32m                new ResultPoint_1.default(yi + CORR, yj - CORR)[m
[32m+[m[32m            ];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return [[m
[32m+[m[32m                new ResultPoint_1.default(ti + CORR, tj + CORR),[m
[32m+[m[32m                new ResultPoint_1.default(zi + CORR, zj - CORR),[m
[32m+[m[32m                new ResultPoint_1.default(xi - CORR, xj + CORR),[m
[32m+[m[32m                new ResultPoint_1.default(yi - CORR, yj - CORR)[m
[32m+[m[32m            ];[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines whether a segment contains a black point[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a          min value of the scanned coordinate[m
[32m+[m[32m     * @param b          max value of the scanned coordinate[m
[32m+[m[32m     * @param fixed      value of fixed coordinate[m
[32m+[m[32m     * @param horizontal set to true if scan must be horizontal, false if vertical[m
[32m+[m[32m     * @return true if a black point has been found, else false.[m
[32m+[m[32m     */[m
[32m+[m[32m    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        if (horizontal) {[m
[32m+[m[32m            for (var x = a; x <= b; x++) {[m
[32m+[m[32m                if (image.get(x, fixed)) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            for (var y = a; y <= b; y++) {[m
[32m+[m[32m                if (image.get(fixed, y)) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    WhiteRectangleDetector.INIT_SIZE = 10;[m
[32m+[m[32m    WhiteRectangleDetector.CORR = 1;[m
[32m+[m[32m    return WhiteRectangleDetector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = WhiteRectangleDetector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..162f474[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.d.ts[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains utility methods for performing mathematical operations over[m
[32m+[m[32m * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Throughout this package, elements of the GF are represented as an {@code int}[m
[32m+[m[32m * for convenience and speed (but at the cost of memory).[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mexport default abstract class AbstractGenericGF {[m
[32m+[m[32m    protected expTable: Int32Array;[m
[32m+[m[32m    protected logTable: Int32Array;[m
[32m+[m[32m    abstract getZero(): any;[m
[32m+[m[32m    abstract buildMonomial(degree: number, coefficient: number): any;[m
[32m+[m[32m    abstract equals(o: Object): boolean;[m
[32m+[m[32m    abstract multiply(a: number, b: number): number;[m
[32m+[m[32m    abstract inverse(a: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return 2 to the power of a in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    exp(a: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return base 2 log of a in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    log(a: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Implements both addition and subtraction -- they are the same in GF(size).[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return sum/difference of a and b[m
[32m+[m[32m     */[m
[32m+[m[32m    static addOrSubtract(a: number, b: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d51aaf0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGF.js[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains utility methods for performing mathematical operations over[m
[32m+[m[32m * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Throughout this package, elements of the GF are represented as an {@code int}[m
[32m+[m[32m * for convenience and speed (but at the cost of memory).[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mvar AbstractGenericGF = /** @class */ (function () {[m
[32m+[m[32m    function AbstractGenericGF() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return 2 to the power of a in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGF.prototype.exp = function (a) {[m
[32m+[m[32m        return this.expTable[a];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return base 2 log of a in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGF.prototype.log = function (a /*int*/) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.logTable[a];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Implements both addition and subtraction -- they are the same in GF(size).[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return sum/difference of a and b[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGF.addOrSubtract = function (a /*int*/, b /*int*/) {[m
[32m+[m[32m        return a ^ b;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AbstractGenericGF;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AbstractGenericGF;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..8a4aee2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.d.ts[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32mimport AbstractGenericGF from './AbstractGenericGF';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a polynomial whose coefficients are elements of a GF.[m
[32m+[m[32m * Instances of this class are immutable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default abstract class AbstractGenericGFPoly {[m
[32m+[m[32m    protected field: AbstractGenericGF;[m
[32m+[m[32m    protected coefficients: Int32Array;[m
[32m+[m[32m    getCoefficients(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getDegree(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    isZero(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getCoefficient(degree: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    evaluateAt(a: number): number;[m
[32m+[m[32m    abstract addOrSubtract(other: AbstractGenericGFPoly): AbstractGenericGFPoly;[m
[32m+[m[32m    abstract multiply(other: AbstractGenericGFPoly): AbstractGenericGFPoly;[m
[32m+[m[32m    abstract multiplyScalar(scalar: number): AbstractGenericGFPoly;[m
[32m+[m[32m    abstract multiplyByMonomial(degree: number, coefficient: number): AbstractGenericGFPoly;[m
[32m+[m[32m    abstract divide(other: AbstractGenericGFPoly): AbstractGenericGFPoly[];[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.js[m
[1mnew file mode 100644[m
[1mindex 0000000..776b04a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/AbstractGenericGFPoly.js[m
[36m@@ -0,0 +1,124 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.reedsolomon {*/[m
[32m+[m[32m// import GenericGF from './GenericGF';[m
[32m+[m[32mvar AbstractGenericGF_1 = require("./AbstractGenericGF");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a polynomial whose coefficients are elements of a GF.[m
[32m+[m[32m * Instances of this class are immutable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar AbstractGenericGFPoly = /** @class */ (function () {[m
[32m+[m[32m    function AbstractGenericGFPoly() {[m
[32m+[m[32m    }[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.getCoefficients = function () {[m
[32m+[m[32m        return this.coefficients;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.getDegree = function () {[m
[32m+[m[32m        return this.coefficients.length - 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.isZero = function () {[m
[32m+[m[32m        return this.coefficients[0] === 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {[m
[32m+[m[32m        return this.coefficients[this.coefficients.length - 1 - degree];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.evaluateAt = function (a /*int*/) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            // Just return the x^0 coefficient[m
[32m+[m[32m            return this.getCoefficient(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        var coefficients = this.coefficients;[m
[32m+[m[32m        var result;[m
[32m+[m[32m        if (a === 1) {[m
[32m+[m[32m            // Just the sum of the coefficients[m
[32m+[m[32m            result = 0;[m
[32m+[m[32m            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {[m
[32m+[m[32m                var coefficient = coefficients[i];[m
[32m+[m[32m                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);[m
[32m+[m[32m            }[m
[32m+[m[32m            return result;[m
[32m+[m[32m        }[m
[32m+[m[32m        result = coefficients[0];[m
[32m+[m[32m        var size = coefficients.length;[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 1; i < size; i++) {[m
[32m+[m[32m            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    AbstractGenericGFPoly.prototype.toString = function () {[m
[32m+[m[32m        var result = '';[m
[32m+[m[32m        for (var degree = this.getDegree(); degree >= 0; degree--) {[m
[32m+[m[32m            var coefficient = this.getCoefficient(degree);[m
[32m+[m[32m            if (coefficient !== 0) {[m
[32m+[m[32m                if (coefficient < 0) {[m
[32m+[m[32m                    result += ' - ';[m
[32m+[m[32m                    coefficient = -coefficient;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    if (result.length > 0) {[m
[32m+[m[32m                        result += ' + ';[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree === 0 || coefficient !== 1) {[m
[32m+[m[32m                    var alphaPower = this.field.log(coefficient);[m
[32m+[m[32m                    if (alphaPower === 0) {[m
[32m+[m[32m                        result += '1';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (alphaPower === 1) {[m
[32m+[m[32m                        result += 'a';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        result += 'a^';[m
[32m+[m[32m                        result += alphaPower;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree !== 0) {[m
[32m+[m[32m                    if (degree === 1) {[m
[32m+[m[32m                        result += 'x';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        result += 'x^';[m
[32m+[m[32m                        result += degree;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AbstractGenericGFPoly;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AbstractGenericGFPoly;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b70c7a3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.d.ts[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32mimport GenericGFPoly from './GenericGFPoly';[m
[32m+[m[32mimport AbstractGenericGF from './AbstractGenericGF';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains utility methods for performing mathematical operations over[m
[32m+[m[32m * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Throughout this package, elements of the GF are represented as an {@code int}[m
[32m+[m[32m * for convenience and speed (but at the cost of memory).[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mexport default class GenericGF extends AbstractGenericGF {[m
[32m+[m[32m    private primitive;[m
[32m+[m[32m    private size;[m
[32m+[m[32m    private generatorBase;[m
[32m+[m[32m    static AZTEC_DATA_12: GenericGF;[m
[32m+[m[32m    static AZTEC_DATA_10: GenericGF;[m
[32m+[m[32m    static AZTEC_DATA_6: GenericGF;[m
[32m+[m[32m    static AZTEC_PARAM: GenericGF;[m
[32m+[m[32m    static QR_CODE_FIELD_256: GenericGF;[m
[32m+[m[32m    static DATA_MATRIX_FIELD_256: GenericGF;[m
[32m+[m[32m    static AZTEC_DATA_8: GenericGF;[m
[32m+[m[32m    static MAXICODE_FIELD_64: GenericGF;[m
[32m+[m[32m    private zero;[m
[32m+[m[32m    private one;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Create a representation of GF(size) using the given primitive polynomial.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param primitive irreducible polynomial whose coefficients are represented by[m
[32m+[m[32m     *  the bits of an int, where the least-significant bit represents the constant[m
[32m+[m[32m     *  coefficient[m
[32m+[m[32m     * @param size the size of the field[m
[32m+[m[32m     * @param b the factor b in the generator polynomial can be 0- or 1-based[m
[32m+[m[32m     *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).[m
[32m+[m[32m     *  In most cases it should be 1, but for QR code it is 0.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(primitive: number, size: number, generatorBase: number);[m
[32m+[m[32m    getZero(): GenericGFPoly;[m
[32m+[m[32m    getOne(): GenericGFPoly;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the monomial representing coefficient * x^degree[m
[32m+[m[32m     */[m
[32m+[m[32m    buildMonomial(degree: number, coefficient: number): GenericGFPoly;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return multiplicative inverse of a[m
[32m+[m[32m     */[m
[32m+[m[32m    inverse(a: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return product of a and b in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    multiply(a: number, b: number): number;[m
[32m+[m[32m    getSize(): number;[m
[32m+[m[32m    getGeneratorBase(): number;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    equals(o: Object): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0b1000c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGF.js[m
[36m@@ -0,0 +1,148 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.reedsolomon {*/[m
[32m+[m[32mvar GenericGFPoly_1 = require("./GenericGFPoly");[m
[32m+[m[32mvar AbstractGenericGF_1 = require("./AbstractGenericGF");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32mvar ArithmeticException_1 = require("../../ArithmeticException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains utility methods for performing mathematical operations over[m
[32m+[m[32m * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Throughout this package, elements of the GF are represented as an {@code int}[m
[32m+[m[32m * for convenience and speed (but at the cost of memory).[m
[32m+[m[32m * </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author David Olivier[m
[32m+[m[32m */[m
[32m+[m[32mvar GenericGF = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(GenericGF, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Create a representation of GF(size) using the given primitive polynomial.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param primitive irreducible polynomial whose coefficients are represented by[m
[32m+[m[32m     *  the bits of an int, where the least-significant bit represents the constant[m
[32m+[m[32m     *  coefficient[m
[32m+[m[32m     * @param size the size of the field[m
[32m+[m[32m     * @param b the factor b in the generator polynomial can be 0- or 1-based[m
[32m+[m[32m     *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).[m
[32m+[m[32m     *  In most cases it should be 1, but for QR code it is 0.[m
[32m+[m[32m     */[m
[32m+[m[32m    function GenericGF(primitive /*int*/, size /*int*/, generatorBase /*int*/) {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.primitive = primitive;[m
[32m+[m[32m        _this.size = size;[m
[32m+[m[32m        _this.generatorBase = generatorBase;[m
[32m+[m[32m        var expTable = new Int32Array(size);[m
[32m+[m[32m        var x = 1;[m
[32m+[m[32m        for (var i = 0; i < size; i++) {[m
[32m+[m[32m            expTable[i] = x;[m
[32m+[m[32m            x *= 2; // we're assuming the generator alpha is 2[m
[32m+[m[32m            if (x >= size) {[m
[32m+[m[32m                x ^= primitive;[m
[32m+[m[32m                x &= size - 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.expTable = expTable;[m
[32m+[m[32m        var logTable = new Int32Array(size);[m
[32m+[m[32m        for (var i = 0; i < size - 1; i++) {[m
[32m+[m[32m            logTable[expTable[i]] = i;[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.logTable = logTable;[m
[32m+[m[32m        // logTable[0] == 0 but this should never be used[m
[32m+[m[32m        _this.zero = new GenericGFPoly_1.default(_this, Int32Array.from([0]));[m
[32m+[m[32m        _this.one = new GenericGFPoly_1.default(_this, Int32Array.from([1]));[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    GenericGF.prototype.getZero = function () {[m
[32m+[m[32m        return this.zero;[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGF.prototype.getOne = function () {[m
[32m+[m[32m        return this.one;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the monomial representing coefficient * x^degree[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGF.prototype.buildMonomial = function (degree /*int*/, coefficient /*int*/) {[m
[32m+[m[32m        if (degree < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (coefficient === 0) {[m
[32m+[m[32m            return this.zero;[m
[32m+[m[32m        }[m
[32m+[m[32m        var coefficients = new Int32Array(degree + 1);[m
[32m+[m[32m        coefficients[0] = coefficient;[m
[32m+[m[32m        return new GenericGFPoly_1.default(this, coefficients);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return multiplicative inverse of a[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGF.prototype.inverse = function (a /*int*/) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            throw new ArithmeticException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.expTable[this.size - this.logTable[a] - 1];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return product of a and b in GF(size)[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGF.prototype.multiply = function (a /*int*/, b /*int*/) {[m
[32m+[m[32m        if (a === 0 || b === 0) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGF.prototype.getSize = function () {[m
[32m+[m[32m        return this.size;[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGF.prototype.getGeneratorBase = function () {[m
[32m+[m[32m        return this.generatorBase;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    GenericGF.prototype.toString = function () {[m
[32m+[m[32m        return ('GF(0x' + Integer_1.default.toHexString(this.primitive) + ',' + this.size + ')');[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGF.prototype.equals = function (o) {[m
[32m+[m[32m        return o === this;[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1[m
[32m+[m[32m    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1[m
[32m+[m[32m    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1[m
[32m+[m[32m    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1[m
[32m+[m[32m    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1[m
[32m+[m[32m    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1[m
[32m+[m[32m    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;[m
[32m+[m[32m    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;[m
[32m+[m[32m    return GenericGF;[m
[32m+[m[32m}(AbstractGenericGF_1.default));[m
[32m+[m[32mexports.default = GenericGF;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b623dc1[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.d.ts[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32mimport AbstractGenericGF from './AbstractGenericGF';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a polynomial whose coefficients are elements of a GF.[m
[32m+[m[32m * Instances of this class are immutable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class GenericGFPoly {[m
[32m+[m[32m    private field;[m
[32m+[m[32m    private coefficients;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param field the {@link GenericGF} instance representing the field to use[m
[32m+[m[32m     * to perform computations[m
[32m+[m[32m     * @param coefficients coefficients as ints representing elements of GF(size), arranged[m
[32m+[m[32m     * from most significant (highest-power term) coefficient to least significant[m
[32m+[m[32m     * @throws IllegalArgumentException if argument is null or empty,[m
[32m+[m[32m     * or if leading coefficient is 0 and this is not a[m
[32m+[m[32m     * constant polynomial (that is, it is not the monomial "0")[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(field: AbstractGenericGF, coefficients: Int32Array);[m
[32m+[m[32m    getCoefficients(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getDegree(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    isZero(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getCoefficient(degree: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    evaluateAt(a: number): number;[m
[32m+[m[32m    addOrSubtract(other: GenericGFPoly): GenericGFPoly;[m
[32m+[m[32m    multiply(other: GenericGFPoly): GenericGFPoly;[m
[32m+[m[32m    multiplyScalar(scalar: number): GenericGFPoly;[m
[32m+[m[32m    multiplyByMonomial(degree: number, coefficient: number): GenericGFPoly;[m
[32m+[m[32m    divide(other: GenericGFPoly): GenericGFPoly[];[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c2d8691[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/GenericGFPoly.js[m
[36m@@ -0,0 +1,257 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.reedsolomon {*/[m
[32m+[m[32mvar AbstractGenericGF_1 = require("./AbstractGenericGF");[m
[32m+[m[32mvar System_1 = require("../../util/System");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Represents a polynomial whose coefficients are elements of a GF.[m
[32m+[m[32m * Instances of this class are immutable.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar GenericGFPoly = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param field the {@link GenericGF} instance representing the field to use[m
[32m+[m[32m     * to perform computations[m
[32m+[m[32m     * @param coefficients coefficients as ints representing elements of GF(size), arranged[m
[32m+[m[32m     * from most significant (highest-power term) coefficient to least significant[m
[32m+[m[32m     * @throws IllegalArgumentException if argument is null or empty,[m
[32m+[m[32m     * or if leading coefficient is 0 and this is not a[m
[32m+[m[32m     * constant polynomial (that is, it is not the monomial "0")[m
[32m+[m[32m     */[m
[32m+[m[32m    function GenericGFPoly(field, coefficients) {[m
[32m+[m[32m        if (coefficients.length === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.field = field;[m
[32m+[m[32m        var coefficientsLength = coefficients.length;[m
[32m+[m[32m        if (coefficientsLength > 1 && coefficients[0] === 0) {[m
[32m+[m[32m            // Leading term must be non-zero for anything except the constant polynomial "0"[m
[32m+[m[32m            var firstNonZero = 1;[m
[32m+[m[32m            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {[m
[32m+[m[32m                firstNonZero++;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (firstNonZero === coefficientsLength) {[m
[32m+[m[32m                this.coefficients = Int32Array.from([0]);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);[m
[32m+[m[32m                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.coefficients = coefficients;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    GenericGFPoly.prototype.getCoefficients = function () {[m
[32m+[m[32m        return this.coefficients;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGFPoly.prototype.getDegree = function () {[m
[32m+[m[32m        return this.coefficients.length - 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGFPoly.prototype.isZero = function () {[m
[32m+[m[32m        return this.coefficients[0] === 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {[m
[32m+[m[32m        return this.coefficients[this.coefficients.length - 1 - degree];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            // Just return the x^0 coefficient[m
[32m+[m[32m            return this.getCoefficient(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        var coefficients = this.coefficients;[m
[32m+[m[32m        var result;[m
[32m+[m[32m        if (a === 1) {[m
[32m+[m[32m            // Just the sum of the coefficients[m
[32m+[m[32m            result = 0;[m
[32m+[m[32m            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {[m
[32m+[m[32m                var coefficient = coefficients[i];[m
[32m+[m[32m                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);[m
[32m+[m[32m            }[m
[32m+[m[32m            return result;[m
[32m+[m[32m        }[m
[32m+[m[32m        result = coefficients[0];[m
[32m+[m[32m        var size = coefficients.length;[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 1; i < size; i++) {[m
[32m+[m[32m            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGFPoly.prototype.addOrSubtract = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isZero()) {[m
[32m+[m[32m            return other;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (other.isZero()) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        var smallerCoefficients = this.coefficients;[m
[32m+[m[32m        var largerCoefficients = other.coefficients;[m
[32m+[m[32m        if (smallerCoefficients.length > largerCoefficients.length) {[m
[32m+[m[32m            var temp = smallerCoefficients;[m
[32m+[m[32m            smallerCoefficients = largerCoefficients;[m
[32m+[m[32m            largerCoefficients = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var sumDiff = new Int32Array(largerCoefficients.length);[m
[32m+[m[32m        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;[m
[32m+[m[32m        // Copy high-order terms only found in higher-degree polynomial's coefficients[m
[32m+[m[32m        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);[m
[32m+[m[32m        for (var i = lengthDiff; i < largerCoefficients.length; i++) {[m
[32m+[m[32m            sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new GenericGFPoly(this.field, sumDiff);[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGFPoly.prototype.multiply = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isZero() || other.isZero()) {[m
[32m+[m[32m            return this.field.getZero();[m
[32m+[m[32m        }[m
[32m+[m[32m        var aCoefficients = this.coefficients;[m
[32m+[m[32m        var aLength = aCoefficients.length;[m
[32m+[m[32m        var bCoefficients = other.coefficients;[m
[32m+[m[32m        var bLength = bCoefficients.length;[m
[32m+[m[32m        var product = new Int32Array(aLength + bLength - 1);[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 0; i < aLength; i++) {[m
[32m+[m[32m            var aCoeff = aCoefficients[i];[m
[32m+[m[32m            for (var j = 0; j < bLength; j++) {[m
[32m+[m[32m                product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return new GenericGFPoly(field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {[m
[32m+[m[32m        if (scalar === 0) {[m
[32m+[m[32m            return this.field.getZero();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (scalar === 1) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        var size = this.coefficients.length;[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        var product = new Int32Array(size);[m
[32m+[m[32m        var coefficients = this.coefficients;[m
[32m+[m[32m        for (var i = 0; i < size; i++) {[m
[32m+[m[32m            product[i] = field.multiply(coefficients[i], scalar);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new GenericGFPoly(field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {[m
[32m+[m[32m        if (degree < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (coefficient === 0) {[m
[32m+[m[32m            return this.field.getZero();[m
[32m+[m[32m        }[m
[32m+[m[32m        var coefficients = this.coefficients;[m
[32m+[m[32m        var size = coefficients.length;[m
[32m+[m[32m        var product = new Int32Array(size + degree);[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 0; i < size; i++) {[m
[32m+[m[32m            product[i] = field.multiply(coefficients[i], coefficient);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new GenericGFPoly(field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    GenericGFPoly.prototype.divide = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (other.isZero()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Divide by 0');[m
[32m+[m[32m        }[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        var quotient = field.getZero();[m
[32m+[m[32m        var remainder = this;[m
[32m+[m[32m        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());[m
[32m+[m[32m        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);[m
[32m+[m[32m        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {[m
[32m+[m[32m            var degreeDifference = remainder.getDegree() - other.getDegree();[m
[32m+[m[32m            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);[m
[32m+[m[32m            var term = other.multiplyByMonomial(degreeDifference, scale);[m
[32m+[m[32m            var iterationQuotient = field.buildMonomial(degreeDifference, scale);[m
[32m+[m[32m            quotient = quotient.addOrSubtract(iterationQuotient);[m
[32m+[m[32m            remainder = remainder.addOrSubtract(term);[m
[32m+[m[32m        }[m
[32m+[m[32m        return [quotient, remainder];[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    GenericGFPoly.prototype.toString = function () {[m
[32m+[m[32m        var result = '';[m
[32m+[m[32m        for (var degree = this.getDegree(); degree >= 0; degree--) {[m
[32m+[m[32m            var coefficient = this.getCoefficient(degree);[m
[32m+[m[32m            if (coefficient !== 0) {[m
[32m+[m[32m                if (coefficient < 0) {[m
[32m+[m[32m                    result += ' - ';[m
[32m+[m[32m                    coefficient = -coefficient;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    if (result.length > 0) {[m
[32m+[m[32m                        result += ' + ';[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree === 0 || coefficient !== 1) {[m
[32m+[m[32m                    var alphaPower = this.field.log(coefficient);[m
[32m+[m[32m                    if (alphaPower === 0) {[m
[32m+[m[32m                        result += '1';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (alphaPower === 1) {[m
[32m+[m[32m                        result += 'a';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        result += 'a^';[m
[32m+[m[32m                        result += alphaPower;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree !== 0) {[m
[32m+[m[32m                    if (degree === 1) {[m
[32m+[m[32m                        result += 'x';[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        result += 'x^';[m
[32m+[m[32m                        result += degree;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return GenericGFPoly;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = GenericGFPoly;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5aea531[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.d.ts[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32mimport GenericGF from './GenericGF';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements Reed-Solomon decoding, as the name implies.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>The algorithm will not be explained here, but the following references were helpful[m
[32m+[m[32m * in creating this implementation:</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <ul>[m
[32m+[m[32m * <li>Bruce Maggs.[m
[32m+[m[32m * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">[m
[32m+[m[32m * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>[m
[32m+[m[32m * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">[m
[32m+[m[32m * "Chapter 5. Generalized Reed-Solomon Codes"</a>[m
[32m+[m[32m * (see discussion of Euclidean algorithm)</li>[m
[32m+[m[32m * </ul>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author William Rucklidge[m
[32m+[m[32m * @author sanfordsquires[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ReedSolomonDecoder {[m
[32m+[m[32m    private field;[m
[32m+[m[32m    constructor(field: GenericGF);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes given set of received codewords, which include both data and error-correction[m
[32m+[m[32m     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,[m
[32m+[m[32m     * in the input.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param received data and error-correction codewords[m
[32m+[m[32m     * @param twoS number of error-correction codewords available[m
[32m+[m[32m     * @throws ReedSolomonException if decoding fails for any reason[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(received: Int32Array, twoS: number): void;[m
[32m+[m[32m    private runEuclideanAlgorithm;[m
[32m+[m[32m    private findErrorLocations;[m
[32m+[m[32m    private findErrorMagnitudes;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1d54eb5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonDecoder.js[m
[36m@@ -0,0 +1,182 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.common.reedsolomon {*/[m
[32m+[m[32mvar GenericGF_1 = require("./GenericGF");[m
[32m+[m[32mvar GenericGFPoly_1 = require("./GenericGFPoly");[m
[32m+[m[32mvar ReedSolomonException_1 = require("../../ReedSolomonException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../../IllegalStateException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements Reed-Solomon decoding, as the name implies.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>The algorithm will not be explained here, but the following references were helpful[m
[32m+[m[32m * in creating this implementation:</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <ul>[m
[32m+[m[32m * <li>Bruce Maggs.[m
[32m+[m[32m * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">[m
[32m+[m[32m * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>[m
[32m+[m[32m * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">[m
[32m+[m[32m * "Chapter 5. Generalized Reed-Solomon Codes"</a>[m
[32m+[m[32m * (see discussion of Euclidean algorithm)</li>[m
[32m+[m[32m * </ul>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Much credit is due to William Rucklidge since portions of this code are an indirect[m
[32m+[m[32m * port of his C++ Reed-Solomon implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author William Rucklidge[m
[32m+[m[32m * @author sanfordsquires[m
[32m+[m[32m */[m
[32m+[m[32mvar ReedSolomonDecoder = /** @class */ (function () {[m
[32m+[m[32m    function ReedSolomonDecoder(field) {[m
[32m+[m[32m        this.field = field;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes given set of received codewords, which include both data and error-correction[m
[32m+[m[32m     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,[m
[32m+[m[32m     * in the input.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param received data and error-correction codewords[m
[32m+[m[32m     * @param twoS number of error-correction codewords available[m
[32m+[m[32m     * @throws ReedSolomonException if decoding fails for any reason[m
[32m+[m[32m     */[m
[32m+[m[32m    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        var poly = new GenericGFPoly_1.default(field, received);[m
[32m+[m[32m        var syndromeCoefficients = new Int32Array(twoS);[m
[32m+[m[32m        var noError = true;[m
[32m+[m[32m        for (var i = 0; i < twoS; i++) {[m
[32m+[m[32m            var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));[m
[32m+[m[32m            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;[m
[32m+[m[32m            if (evalResult !== 0) {[m
[32m+[m[32m                noError = false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (noError) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);[m
[32m+[m[32m        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);[m
[32m+[m[32m        var sigma = sigmaOmega[0];[m
[32m+[m[32m        var omega = sigmaOmega[1];[m
[32m+[m[32m        var errorLocations = this.findErrorLocations(sigma);[m
[32m+[m[32m        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);[m
[32m+[m[32m        for (var i = 0; i < errorLocations.length; i++) {[m
[32m+[m[32m            var position = received.length - 1 - field.log(errorLocations[i]);[m
[32m+[m[32m            if (position < 0) {[m
[32m+[m[32m                throw new ReedSolomonException_1.default('Bad error location');[m
[32m+[m[32m            }[m
[32m+[m[32m            received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {[m
[32m+[m[32m        // Assume a's degree is >= b's[m
[32m+[m[32m        if (a.getDegree() < b.getDegree()) {[m
[32m+[m[32m            var temp = a;[m
[32m+[m[32m            a = b;[m
[32m+[m[32m            b = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        var rLast = a;[m
[32m+[m[32m        var r = b;[m
[32m+[m[32m        var tLast = field.getZero();[m
[32m+[m[32m        var t = field.getOne();[m
[32m+[m[32m        // Run Euclidean algorithm until r's degree is less than R/2[m
[32m+[m[32m        while (r.getDegree() >= (R / 2 | 0)) {[m
[32m+[m[32m            var rLastLast = rLast;[m
[32m+[m[32m            var tLastLast = tLast;[m
[32m+[m[32m            rLast = r;[m
[32m+[m[32m            tLast = t;[m
[32m+[m[32m            // Divide rLastLast by rLast, with quotient in q and remainder in r[m
[32m+[m[32m            if (rLast.isZero()) {[m
[32m+[m[32m                // Oops, Euclidean algorithm already terminated?[m
[32m+[m[32m                throw new ReedSolomonException_1.default('r_{i-1} was zero');[m
[32m+[m[32m            }[m
[32m+[m[32m            r = rLastLast;[m
[32m+[m[32m            var q = field.getZero();[m
[32m+[m[32m            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());[m
[32m+[m[32m            var dltInverse = field.inverse(denominatorLeadingTerm);[m
[32m+[m[32m            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {[m
[32m+[m[32m                var degreeDiff = r.getDegree() - rLast.getDegree();[m
[32m+[m[32m                var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);[m
[32m+[m[32m                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));[m
[32m+[m[32m                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));[m
[32m+[m[32m            }[m
[32m+[m[32m            t = q.multiply(tLast).addOrSubtract(tLastLast);[m
[32m+[m[32m            if (r.getDegree() >= rLast.getDegree()) {[m
[32m+[m[32m                throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var sigmaTildeAtZero = t.getCoefficient(0);[m
[32m+[m[32m        if (sigmaTildeAtZero === 0) {[m
[32m+[m[32m            throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');[m
[32m+[m[32m        }[m
[32m+[m[32m        var inverse = field.inverse(sigmaTildeAtZero);[m
[32m+[m[32m        var sigma = t.multiplyScalar(inverse);[m
[32m+[m[32m        var omega = r.multiplyScalar(inverse);[m
[32m+[m[32m        return [sigma, omega];[m
[32m+[m[32m    };[m
[32m+[m[32m    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {[m
[32m+[m[32m        // This is a direct application of Chien's search[m
[32m+[m[32m        var numErrors = errorLocator.getDegree();[m
[32m+[m[32m        if (numErrors === 1) { // shortcut[m
[32m+[m[32m            return Int32Array.from([errorLocator.getCoefficient(1)]);[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Int32Array(numErrors);[m
[32m+[m[32m        var e = 0;[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 1; i < field.getSize() && e < numErrors; i++) {[m
[32m+[m[32m            if (errorLocator.evaluateAt(i) === 0) {[m
[32m+[m[32m                result[e] = field.inverse(i);[m
[32m+[m[32m                e++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (e !== numErrors) {[m
[32m+[m[32m            throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {[m
[32m+[m[32m        // This is directly applying Forney's Formula[m
[32m+[m[32m        var s = errorLocations.length;[m
[32m+[m[32m        var result = new Int32Array(s);[m
[32m+[m[32m        var field = this.field;[m
[32m+[m[32m        for (var i = 0; i < s; i++) {[m
[32m+[m[32m            var xiInverse = field.inverse(errorLocations[i]);[m
[32m+[m[32m            var denominator = 1;[m
[32m+[m[32m            for (var j = 0; j < s; j++) {[m
[32m+[m[32m                if (i !== j) {[m
[32m+[m[32m                    // denominator = field.multiply(denominator,[m
[32m+[m[32m                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))[m
[32m+[m[32m                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.[m
[32m+[m[32m                    // Below is a funny-looking workaround from Steven Parkes[m
[32m+[m[32m                    var term = field.multiply(errorLocations[j], xiInverse);[m
[32m+[m[32m                    var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;[m
[32m+[m[32m                    denominator = field.multiply(denominator, termPlus1);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));[m
[32m+[m[32m            if (field.getGeneratorBase() !== 0) {[m
[32m+[m[32m                result[i] = field.multiply(result[i], xiInverse);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ReedSolomonDecoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ReedSolomonDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..73aed55[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.d.ts[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32mimport GenericGF from './GenericGF';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements Reed-Solomon encoding, as the name implies.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author William Rucklidge[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ReedSolomonEncoder {[m
[32m+[m[32m    private field;[m
[32m+[m[32m    private cachedGenerators;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A reed solomon error-correcting encoding constructor is created by[m
[32m+[m[32m     * passing as Galois Field with of size equal to the number of code[m
[32m+[m[32m     * words (symbols) in the alphabet (the number of values in each[m
[32m+[m[32m     * element of arrays that are encoded/decoded).[m
[32m+[m[32m     * @param field A galois field with a number of elements equal to the size[m
[32m+[m[32m     * of the alphabet of symbols to encode.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(field: GenericGF);[m
[32m+[m[32m    private buildGenerator;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders[m
[32m+[m[32m     * to detect and correct errors that may have been introduced when the resulting[m
[32m+[m[32m     * data is stored or transmitted.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param toEncode array used for both and output. Caller initializes the array with[m
[32m+[m[32m     * the code words (symbols) to be encoded followed by empty elements allocated to make[m
[32m+[m[32m     * space for error-correction code words in the encoded output. The array contains[m
[32m+[m[32m     * the encdoded output when encode returns. Code words are encoded as numbers from[m
[32m+[m[32m     * 0 to n-1, where n is the number of possible code words (symbols), as determined[m
[32m+[m[32m     * by the size of the Galois Field passed in the constructor of this object.[m
[32m+[m[32m     * @param ecBytes the number of elements reserved in the array (first parameter)[m
[32m+[m[32m     * to store error-correction code words. Thus, the number of code words (symbols)[m
[32m+[m[32m     * to encode in the first parameter is thus toEncode.length - ecBytes.[m
[32m+[m[32m     * Note, the use of "bytes" in the name of this parameter is misleading, as there may[m
[32m+[m[32m     * be more or fewer than 256 symbols being encoded, as determined by the number of[m
[32m+[m[32m     * elements in the Galois Field passed as a constructor to this object.[m
[32m+[m[32m     * @throws IllegalArgumentException thrown in response to validation errros.[m
[32m+[m[32m     */[m
[32m+[m[32m    encode(toEncode: Int32Array, ecBytes: number): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d71a13d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/common/reedsolomon/ReedSolomonEncoder.js[m
[36m@@ -0,0 +1,96 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar GenericGFPoly_1 = require("./GenericGFPoly");[m
[32m+[m[32mvar System_1 = require("../../util/System");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements Reed-Solomon encoding, as the name implies.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author William Rucklidge[m
[32m+[m[32m */[m
[32m+[m[32mvar ReedSolomonEncoder = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A reed solomon error-correcting encoding constructor is created by[m
[32m+[m[32m     * passing as Galois Field with of size equal to the number of code[m
[32m+[m[32m     * words (symbols) in the alphabet (the number of values in each[m
[32m+[m[32m     * element of arrays that are encoded/decoded).[m
[32m+[m[32m     * @param field A galois field with a number of elements equal to the size[m
[32m+[m[32m     * of the alphabet of symbols to encode.[m
[32m+[m[32m     */[m
[32m+[m[32m    function ReedSolomonEncoder(field) {[m
[32m+[m[32m        this.field = field;[m
[32m+[m[32m        this.cachedGenerators = [];[m
[32m+[m[32m        this.cachedGenerators.push(new GenericGFPoly_1.default(field, Int32Array.from([1])));[m
[32m+[m[32m    }[m
[32m+[m[32m    ReedSolomonEncoder.prototype.buildGenerator = function (degree /*int*/) {[m
[32m+[m[32m        var cachedGenerators = this.cachedGenerators;[m
[32m+[m[32m        if (degree >= cachedGenerators.length) {[m
[32m+[m[32m            var lastGenerator = cachedGenerators[cachedGenerators.length - 1];[m
[32m+[m[32m            var field = this.field;[m
[32m+[m[32m            for (var d = cachedGenerators.length; d <= degree; d++) {[m
[32m+[m[32m                var nextGenerator = lastGenerator.multiply(new GenericGFPoly_1.default(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));[m
[32m+[m[32m                cachedGenerators.push(nextGenerator);[m
[32m+[m[32m                lastGenerator = nextGenerator;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return cachedGenerators[degree];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders[m
[32m+[m[32m     * to detect and correct errors that may have been introduced when the resulting[m
[32m+[m[32m     * data is stored or transmitted.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param toEncode array used for both and output. Caller initializes the array with[m
[32m+[m[32m     * the code words (symbols) to be encoded followed by empty elements allocated to make[m
[32m+[m[32m     * space for error-correction code words in the encoded output. The array contains[m
[32m+[m[32m     * the encdoded output when encode returns. Code words are encoded as numbers from[m
[32m+[m[32m     * 0 to n-1, where n is the number of possible code words (symbols), as determined[m
[32m+[m[32m     * by the size of the Galois Field passed in the constructor of this object.[m
[32m+[m[32m     * @param ecBytes the number of elements reserved in the array (first parameter)[m
[32m+[m[32m     * to store error-correction code words. Thus, the number of code words (symbols)[m
[32m+[m[32m     * to encode in the first parameter is thus toEncode.length - ecBytes.[m
[32m+[m[32m     * Note, the use of "bytes" in the name of this parameter is misleading, as there may[m
[32m+[m[32m     * be more or fewer than 256 symbols being encoded, as determined by the number of[m
[32m+[m[32m     * elements in the Galois Field passed as a constructor to this object.[m
[32m+[m[32m     * @throws IllegalArgumentException thrown in response to validation errros.[m
[32m+[m[32m     */[m
[32m+[m[32m    ReedSolomonEncoder.prototype.encode = function (toEncode, ecBytes /*int*/) {[m
[32m+[m[32m        if (ecBytes === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('No error correction bytes');[m
[32m+[m[32m        }[m
[32m+[m[32m        var dataBytes = toEncode.length - ecBytes;[m
[32m+[m[32m        if (dataBytes <= 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('No data bytes provided');[m
[32m+[m[32m        }[m
[32m+[m[32m        var generator = this.buildGenerator(ecBytes);[m
[32m+[m[32m        var infoCoefficients = new Int32Array(dataBytes);[m
[32m+[m[32m        System_1.default.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);[m
[32m+[m[32m        var info = new GenericGFPoly_1.default(this.field, infoCoefficients);[m
[32m+[m[32m        info = info.multiplyByMonomial(ecBytes, 1);[m
[32m+[m[32m        var remainder = info.divide(generator)[1];[m
[32m+[m[32m        var coefficients = remainder.getCoefficients();[m
[32m+[m[32m        var numZeroCoefficients = ecBytes - coefficients.length;[m
[32m+[m[32m        for (var i = 0; i < numZeroCoefficients; i++) {[m
[32m+[m[32m            toEncode[dataBytes + i] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        System_1.default.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);[m
[32m+[m[32m    };[m
[32m+[m[32m    return ReedSolomonEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ReedSolomonEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e188386[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.d.ts[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Reader from '../Reader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode Data Matrix codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DataMatrixReader implements Reader {[m
[32m+[m[32m    private static NO_POINTS;[m
[32m+[m[32m    private decoder;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a Data Matrix code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the Data Matrix code[m
[32m+[m[32m     * @throws NotFoundException if a Data Matrix code cannot be found[m
[32m+[m[32m     * @throws FormatException if a Data Matrix code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any> | null): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method detects a code in a "pure" image -- that is, pure monochrome image[m
[32m+[m[32m     * which contains only an unrotated, unskewed, image of a code, with some white border[m
[32m+[m[32m     * around it. This is a specialized method that works exceptionally fast in this special[m
[32m+[m[32m     * case.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)[m
[32m+[m[32m     */[m
[32m+[m[32m    private static extractPureBits;[m
[32m+[m[32m    private static moduleSize;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..31de342[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js[m
[36m@@ -0,0 +1,140 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar BitMatrix_1 = require("../common/BitMatrix");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar System_1 = require("../util/System");[m
[32m+[m[32mvar Decoder_1 = require("./decoder/Decoder");[m
[32m+[m[32mvar Detector_1 = require("./detector/Detector");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode Data Matrix codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mvar DataMatrixReader = /** @class */ (function () {[m
[32m+[m[32m    function DataMatrixReader() {[m
[32m+[m[32m        this.decoder = new Decoder_1.default();[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a Data Matrix code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the Data Matrix code[m
[32m+[m[32m     * @throws NotFoundException if a Data Matrix code cannot be found[m
[32m+[m[32m     * @throws FormatException if a Data Matrix code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {[m
[32m+[m[32m    //   return decode(image, null);[m
[32m+[m[32m    // }[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    DataMatrixReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        var decoderResult;[m
[32m+[m[32m        var points;[m
[32m+[m[32m        if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {[m
[32m+[m[32m            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());[m
[32m+[m[32m            decoderResult = this.decoder.decode(bits);[m
[32m+[m[32m            points = DataMatrixReader.NO_POINTS;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();[m
[32m+[m[32m            decoderResult = this.decoder.decode(detectorResult.getBits());[m
[32m+[m[32m            points = detectorResult.getPoints();[m
[32m+[m[32m        }[m
[32m+[m[32m        var rawBytes = decoderResult.getRawBytes();[m
[32m+[m[32m        var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());[m
[32m+[m[32m        var byteSegments = decoderResult.getByteSegments();[m
[32m+[m[32m        if (byteSegments != null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);[m
[32m+[m[32m        }[m
[32m+[m[32m        var ecLevel = decoderResult.getECLevel();[m
[32m+[m[32m        if (ecLevel != null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    DataMatrixReader.prototype.reset = function () {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method detects a code in a "pure" image -- that is, pure monochrome image[m
[32m+[m[32m     * which contains only an unrotated, unskewed, image of a code, with some white border[m
[32m+[m[32m     * around it. This is a specialized method that works exceptionally fast in this special[m
[32m+[m[32m     * case.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)[m
[32m+[m[32m     */[m
[32m+[m[32m    DataMatrixReader.extractPureBits = function (image) {[m
[32m+[m[32m        var leftTopBlack = image.getTopLeftOnBit();[m
[32m+[m[32m        var rightBottomBlack = image.getBottomRightOnBit();[m
[32m+[m[32m        if (leftTopBlack == null || rightBottomBlack == null) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var moduleSize = this.moduleSize(leftTopBlack, image);[m
[32m+[m[32m        var top = leftTopBlack[1];[m
[32m+[m[32m        var bottom = rightBottomBlack[1];[m
[32m+[m[32m        var left = leftTopBlack[0];[m
[32m+[m[32m        var right = rightBottomBlack[0];[m
[32m+[m[32m        var matrixWidth = (right - left + 1) / moduleSize;[m
[32m+[m[32m        var matrixHeight = (bottom - top + 1) / moduleSize;[m
[32m+[m[32m        if (matrixWidth <= 0 || matrixHeight <= 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Push in the "border" by half the module width so that we start[m
[32m+[m[32m        // sampling in the middle of the module. Just in case the image is a[m
[32m+[m[32m        // little off, this will help recover.[m
[32m+[m[32m        var nudge = moduleSize / 2;[m
[32m+[m[32m        top += nudge;[m
[32m+[m[32m        left += nudge;[m
[32m+[m[32m        // Now just read off the bits[m
[32m+[m[32m        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);[m
[32m+[m[32m        for (var y = 0; y < matrixHeight; y++) {[m
[32m+[m[32m            var iOffset = top + y * moduleSize;[m
[32m+[m[32m            for (var x = 0; x < matrixWidth; x++) {[m
[32m+[m[32m                if (image.get(left + x * moduleSize, iOffset)) {[m
[32m+[m[32m                    bits.set(x, y);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataMatrixReader.moduleSize = function (leftTopBlack, image) {[m
[32m+[m[32m        var width = image.getWidth();[m
[32m+[m[32m        var x = leftTopBlack[0];[m
[32m+[m[32m        var y = leftTopBlack[1];[m
[32m+[m[32m        while (x < width && image.get(x, y)) {[m
[32m+[m[32m            x++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (x === width) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var moduleSize = x - leftTopBlack[0];[m
[32m+[m[32m        if (moduleSize === 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return moduleSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataMatrixReader.NO_POINTS = [];[m
[32m+[m[32m    return DataMatrixReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataMatrixReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..38c96ca[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.d.ts[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport BitMatrix from '../common/BitMatrix';[m
[32m+[m[32mimport EncodeHintType from '../EncodeHintType';[m
[32m+[m[32mimport Writer from '../Writer';[m
[32m+[m[32mexport default class DataMatrixWriter implements Writer {[m
[32m+[m[32m    encode(contents: string, format: BarcodeFormat, width: number, height: number, hints?: Map<EncodeHintType, unknown>): BitMatrix;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encode the given symbol info to a bit matrix.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param placement  The DataMatrix placement.[m
[32m+[m[32m     * @param symbolInfo The symbol info to encode.[m
[32m+[m[32m     * @return The bit matrix generated.[m
[32m+[m[32m     */[m
[32m+[m[32m    private encodeLowLevel;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Convert the ByteMatrix to BitMatrix.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param reqHeight The requested height of the image (in pixels) with the Datamatrix code[m
[32m+[m[32m     * @param reqWidth The requested width of the image (in pixels) with the Datamatrix code[m
[32m+[m[32m     * @param matrix The input matrix.[m
[32m+[m[32m     * @return The output matrix.[m
[32m+[m[32m     */[m
[32m+[m[32m    private convertByteMatrixToBitMatrix;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b49294e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixWriter.js[m
[36m@@ -0,0 +1,161 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar BitMatrix_1 = require("../common/BitMatrix");[m
[32m+[m[32mvar EncodeHintType_1 = require("../EncodeHintType");[m
[32m+[m[32mvar ByteMatrix_1 = require("../qrcode/encoder/ByteMatrix");[m
[32m+[m[32mvar Charset_1 = require("../util/Charset");[m
[32m+[m[32mvar encoder_1 = require("./encoder");[m
[32m+[m[32mvar DataMatrixWriter = /** @class */ (function () {[m
[32m+[m[32m    function DataMatrixWriter() {[m
[32m+[m[32m    }[m
[32m+[m[32m    DataMatrixWriter.prototype.encode = function (contents, format, width, height, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        if (contents.trim() === '') {[m
[32m+[m[32m            throw new Error('Found empty contents');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (format !== BarcodeFormat_1.default.DATA_MATRIX) {[m
[32m+[m[32m            throw new Error('Can only encode DATA_MATRIX, but got ' + format);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (width < 0 || height < 0) {[m
[32m+[m[32m            throw new Error('Requested dimensions can\'t be negative: ' + width + 'x' + height);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Try to get force shape & min / max size[m
[32m+[m[32m        var shape = 0 /* FORCE_NONE */;[m
[32m+[m[32m        var minSize = null;[m
[32m+[m[32m        var maxSize = null;[m
[32m+[m[32m        if (hints != null) {[m
[32m+[m[32m            var requestedShape = hints.get(EncodeHintType_1.default.DATA_MATRIX_SHAPE);[m
[32m+[m[32m            if (requestedShape != null) {[m
[32m+[m[32m                shape = requestedShape;[m
[32m+[m[32m            }[m
[32m+[m[32m            var requestedMinSize = hints.get(EncodeHintType_1.default.MIN_SIZE);[m
[32m+[m[32m            if (requestedMinSize != null) {[m
[32m+[m[32m                minSize = requestedMinSize;[m
[32m+[m[32m            }[m
[32m+[m[32m            var requestedMaxSize = hints.get(EncodeHintType_1.default.MAX_SIZE);[m
[32m+[m[32m            if (requestedMaxSize != null) {[m
[32m+[m[32m                maxSize = requestedMaxSize;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // 1. step: Data encodation[m
[32m+[m[32m        var encoded;[m
[32m+[m[32m        var hasCompactionHint = hints != null &&[m
[32m+[m[32m            hints.has(EncodeHintType_1.default.DATA_MATRIX_COMPACT) &&[m
[32m+[m[32m            Boolean(hints.get(EncodeHintType_1.default.DATA_MATRIX_COMPACT).toString());[m
[32m+[m[32m        if (hasCompactionHint) {[m
[32m+[m[32m            var hasGS1FormatHint = hints.has(EncodeHintType_1.default.GS1_FORMAT) &&[m
[32m+[m[32m                Boolean(hints.get(EncodeHintType_1.default.GS1_FORMAT).toString());[m
[32m+[m[32m            var charset = null;[m
[32m+[m[32m            var hasEncodingHint = hints.has(EncodeHintType_1.default.CHARACTER_SET);[m
[32m+[m[32m            if (hasEncodingHint) {[m
[32m+[m[32m                charset = Charset_1.default.forName(hints.get(EncodeHintType_1.default.CHARACTER_SET).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m            encoded = encoder_1.MinimalEncoder.encodeHighLevel(contents, charset, hasGS1FormatHint ? 0x1d : -1, shape);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var hasForceC40Hint = hints != null &&[m
[32m+[m[32m                hints.has(EncodeHintType_1.default.FORCE_C40) &&[m
[32m+[m[32m                Boolean(hints.get(EncodeHintType_1.default.FORCE_C40).toString());[m
[32m+[m[32m            encoded = encoder_1.HighLevelEncoder.encodeHighLevel(contents, shape, minSize, maxSize, hasForceC40Hint);[m
[32m+[m[32m        }[m
[32m+[m[32m        var symbolInfo = encoder_1.SymbolInfo.lookup(encoded.length, shape, minSize, maxSize, true);[m
[32m+[m[32m        // 2. step: ECC generation[m
[32m+[m[32m        var codewords = encoder_1.ErrorCorrection.encodeECC200(encoded, symbolInfo);[m
[32m+[m[32m        // 3. step: Module placement in Matrix[m
[32m+[m[32m        var placement = new encoder_1.DefaultPlacement(codewords, symbolInfo.getSymbolDataWidth(), symbolInfo.getSymbolDataHeight());[m
[32m+[m[32m        placement.place();[m
[32m+[m[32m        // 4. step: low-level encoding[m
[32m+[m[32m        return this.encodeLowLevel(placement, symbolInfo, width, height);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encode the given symbol info to a bit matrix.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param placement  The DataMatrix placement.[m
[32m+[m[32m     * @param symbolInfo The symbol info to encode.[m
[32m+[m[32m     * @return The bit matrix generated.[m
[32m+[m[32m     */[m
[32m+[m[32m    DataMatrixWriter.prototype.encodeLowLevel = function (placement, symbolInfo, width, height) {[m
[32m+[m[32m        var symbolWidth = symbolInfo.getSymbolDataWidth();[m
[32m+[m[32m        var symbolHeight = symbolInfo.getSymbolDataHeight();[m
[32m+[m[32m        var matrix = new ByteMatrix_1.default(symbolInfo.getSymbolWidth(), symbolInfo.getSymbolHeight());[m
[32m+[m[32m        var matrixY = 0;[m
[32m+[m[32m        for (var y = 0; y < symbolHeight; y++) {[m
[32m+[m[32m            // Fill the top edge with alternate 0 / 1[m
[32m+[m[32m            var matrixX = void 0;[m
[32m+[m[32m            if (y % symbolInfo.matrixHeight === 0) {[m
[32m+[m[32m                matrixX = 0;[m
[32m+[m[32m                for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {[m
[32m+[m[32m                    matrix.setBoolean(matrixX, matrixY, x % 2 === 0);[m
[32m+[m[32m                    matrixX++;[m
[32m+[m[32m                }[m
[32m+[m[32m                matrixY++;[m
[32m+[m[32m            }[m
[32m+[m[32m            matrixX = 0;[m
[32m+[m[32m            for (var x = 0; x < symbolWidth; x++) {[m
[32m+[m[32m                // Fill the right edge with full 1[m
[32m+[m[32m                if (x % symbolInfo.matrixWidth === 0) {[m
[32m+[m[32m                    matrix.setBoolean(matrixX, matrixY, true);[m
[32m+[m[32m                    matrixX++;[m
[32m+[m[32m                }[m
[32m+[m[32m                matrix.setBoolean(matrixX, matrixY, placement.getBit(x, y));[m
[32m+[m[32m                matrixX++;[m
[32m+[m[32m                // Fill the right edge with alternate 0 / 1[m
[32m+[m[32m                if (x % symbolInfo.matrixWidth === symbolInfo.matrixWidth - 1) {[m
[32m+[m[32m                    matrix.setBoolean(matrixX, matrixY, y % 2 === 0);[m
[32m+[m[32m                    matrixX++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            matrixY++;[m
[32m+[m[32m            // Fill the bottom edge with full 1[m
[32m+[m[32m            if (y % symbolInfo.matrixHeight === symbolInfo.matrixHeight - 1) {[m
[32m+[m[32m                matrixX = 0;[m
[32m+[m[32m                for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {[m
[32m+[m[32m                    matrix.setBoolean(matrixX, matrixY, true);[m
[32m+[m[32m                    matrixX++;[m
[32m+[m[32m                }[m
[32m+[m[32m                matrixY++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.convertByteMatrixToBitMatrix(matrix, width, height);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Convert the ByteMatrix to BitMatrix.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param reqHeight The requested height of the image (in pixels) with the Datamatrix code[m
[32m+[m[32m     * @param reqWidth The requested width of the image (in pixels) with the Datamatrix code[m
[32m+[m[32m     * @param matrix The input matrix.[m
[32m+[m[32m     * @return The output matrix.[m
[32m+[m[32m     */[m
[32m+[m[32m    DataMatrixWriter.prototype.convertByteMatrixToBitMatrix = function (matrix, reqWidth, reqHeight) {[m
[32m+[m[32m        var matrixWidth = matrix.getWidth();[m
[32m+[m[32m        var matrixHeight = matrix.getHeight();[m
[32m+[m[32m        var outputWidth = Math.max(reqWidth, matrixWidth);[m
[32m+[m[32m        var outputHeight = Math.max(reqHeight, matrixHeight);[m
[32m+[m[32m        var multiple = Math.min(outputWidth / matrixWidth, outputHeight / matrixHeight);[m
[32m+[m[32m        var leftPadding = (outputWidth - matrixWidth * multiple) / 2;[m
[32m+[m[32m        var topPadding = (outputHeight - matrixHeight * multiple) / 2;[m
[32m+[m[32m        var output;[m
[32m+[m[32m        // remove padding if requested width and height are too small[m
[32m+[m[32m        if (reqHeight < matrixHeight || reqWidth < matrixWidth) {[m
[32m+[m[32m            leftPadding = 0;[m
[32m+[m[32m            topPadding = 0;[m
[32m+[m[32m            output = new BitMatrix_1.default(matrixWidth, matrixHeight);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            output = new BitMatrix_1.default(reqWidth, reqHeight);[m
[32m+[m[32m        }[m
[32m+[m[32m        output.clear();[m
[32m+[m[32m        for (var inputY = 0, outputY = topPadding; inputY < matrixHeight; inputY++, outputY += multiple) {[m
[32m+[m[32m            // Write the contents of this row of the bytematrix[m
[32m+[m[32m            for (var inputX = 0, outputX = leftPadding; inputX < matrixWidth; inputX++, outputX += multiple) {[m
[32m+[m[32m                if (matrix.get(inputX, inputY) === 1) {[m
[32m+[m[32m                    output.setRegion(outputX, outputY, multiple, multiple);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return output;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DataMatrixWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataMatrixWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f74164a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.d.ts[m
[36m@@ -0,0 +1,107 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BitMatrixParser {[m
[32m+[m[32m    private mappingBitMatrix;[m
[32m+[m[32m    private readMappingMatrix;[m
[32m+[m[32m    private version;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bitMatrix {@link BitMatrix} to parse[m
[32m+[m[32m     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(bitMatrix: BitMatrix);[m
[32m+[m[32m    getVersion(): Version;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates the version object based on the dimension of the original bit matrix from[m
[32m+[m[32m     * the datamatrix code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitMatrix Original {@link BitMatrix} including alignment patterns[m
[32m+[m[32m     * @return {@link Version} encapsulating the Data Matrix Code's "version"[m
[32m+[m[32m     * @throws FormatException if the dimensions of the mapping matrix are not valid[m
[32m+[m[32m     * Data Matrix dimensions.[m
[32m+[m[32m     */[m
[32m+[m[32m    static readVersion(bitMatrix: BitMatrix): Version;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)[m
[32m+[m[32m     * in the correct order in order to reconstitute the codewords bytes contained within the[m
[32m+[m[32m     * Data Matrix Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return bytes encoded within the Data Matrix Code[m
[32m+[m[32m     * @throws FormatException if the exact number of bytes expected is not read[m
[32m+[m[32m     */[m
[32m+[m[32m    readCodewords(): Int8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row Row to read in the mapping matrix[m
[32m+[m[32m     * @param column Column to read in the mapping matrix[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return value of the given bit in the mapping matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    private readModule;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern[m
[32m+[m[32m     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the utah shape[m
[32m+[m[32m     */[m
[32m+[m[32m    private readUtah;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 1.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.3</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 1[m
[32m+[m[32m     */[m
[32m+[m[32m    private readCorner1;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 2.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.4</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 2[m
[32m+[m[32m     */[m
[32m+[m[32m    private readCorner2;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 3.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.5</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 3[m
[32m+[m[32m     */[m
[32m+[m[32m    private readCorner3;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 4.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.6</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 4[m
[32m+[m[32m     */[m
[32m+[m[32m    private readCorner4;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Extracts the data region from a {@link BitMatrix} that contains[m
[32m+[m[32m     * alignment patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitMatrix Original {@link BitMatrix} with alignment patterns[m
[32m+[m[32m     * @return BitMatrix that has the alignment patterns removed[m
[32m+[m[32m     */[m
[32m+[m[32m    private extractDataRegion;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..19f3842[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/BitMatrixParser.js[m
[36m@@ -0,0 +1,417 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BitMatrix_1 = require("../../common/BitMatrix");[m
[32m+[m[32mvar Version_1 = require("./Version");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mvar BitMatrixParser = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bitMatrix {@link BitMatrix} to parse[m
[32m+[m[32m     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2[m
[32m+[m[32m     */[m
[32m+[m[32m    function BitMatrixParser(bitMatrix) {[m
[32m+[m[32m        var dimension = bitMatrix.getHeight();[m
[32m+[m[32m        if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.version = BitMatrixParser.readVersion(bitMatrix);[m
[32m+[m[32m        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);[m
[32m+[m[32m        this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());[m
[32m+[m[32m    }[m
[32m+[m[32m    BitMatrixParser.prototype.getVersion = function () {[m
[32m+[m[32m        return this.version;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates the version object based on the dimension of the original bit matrix from[m
[32m+[m[32m     * the datamatrix code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitMatrix Original {@link BitMatrix} including alignment patterns[m
[32m+[m[32m     * @return {@link Version} encapsulating the Data Matrix Code's "version"[m
[32m+[m[32m     * @throws FormatException if the dimensions of the mapping matrix are not valid[m
[32m+[m[32m     * Data Matrix dimensions.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.readVersion = function (bitMatrix) {[m
[32m+[m[32m        var numRows = bitMatrix.getHeight();[m
[32m+[m[32m        var numColumns = bitMatrix.getWidth();[m
[32m+[m[32m        return Version_1.default.getVersionForDimensions(numRows, numColumns);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)[m
[32m+[m[32m     * in the correct order in order to reconstitute the codewords bytes contained within the[m
[32m+[m[32m     * Data Matrix Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return bytes encoded within the Data Matrix Code[m
[32m+[m[32m     * @throws FormatException if the exact number of bytes expected is not read[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCodewords = function () {[m
[32m+[m[32m        var result = new Int8Array(this.version.getTotalCodewords());[m
[32m+[m[32m        var resultOffset = 0;[m
[32m+[m[32m        var row = 4;[m
[32m+[m[32m        var column = 0;[m
[32m+[m[32m        var numRows = this.mappingBitMatrix.getHeight();[m
[32m+[m[32m        var numColumns = this.mappingBitMatrix.getWidth();[m
[32m+[m[32m        var corner1Read = false;[m
[32m+[m[32m        var corner2Read = false;[m
[32m+[m[32m        var corner3Read = false;[m
[32m+[m[32m        var corner4Read = false;[m
[32m+[m[32m        // Read all of the codewords[m
[32m+[m[32m        do {[m
[32m+[m[32m            // Check the four corner cases[m
[32m+[m[32m            if ((row === numRows) && (column === 0) && !corner1Read) {[m
[32m+[m[32m                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;[m
[32m+[m[32m                row -= 2;[m
[32m+[m[32m                column += 2;[m
[32m+[m[32m                corner1Read = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {[m
[32m+[m[32m                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;[m
[32m+[m[32m                row -= 2;[m
[32m+[m[32m                column += 2;[m
[32m+[m[32m                corner2Read = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {[m
[32m+[m[32m                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;[m
[32m+[m[32m                row -= 2;[m
[32m+[m[32m                column += 2;[m
[32m+[m[32m                corner3Read = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {[m
[32m+[m[32m                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;[m
[32m+[m[32m                row -= 2;[m
[32m+[m[32m                column += 2;[m
[32m+[m[32m                corner4Read = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Sweep upward diagonally to the right[m
[32m+[m[32m                do {[m
[32m+[m[32m                    if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {[m
[32m+[m[32m                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    row -= 2;[m
[32m+[m[32m                    column += 2;[m
[32m+[m[32m                } while ((row >= 0) && (column < numColumns));[m
[32m+[m[32m                row += 1;[m
[32m+[m[32m                column += 3;[m
[32m+[m[32m                // Sweep downward diagonally to the left[m
[32m+[m[32m                do {[m
[32m+[m[32m                    if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {[m
[32m+[m[32m                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    row += 2;[m
[32m+[m[32m                    column -= 2;[m
[32m+[m[32m                } while ((row < numRows) && (column >= 0));[m
[32m+[m[32m                row += 3;[m
[32m+[m[32m                column += 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        } while ((row < numRows) || (column < numColumns));[m
[32m+[m[32m        if (resultOffset !== this.version.getTotalCodewords()) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row Row to read in the mapping matrix[m
[32m+[m[32m     * @param column Column to read in the mapping matrix[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return value of the given bit in the mapping matrix[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {[m
[32m+[m[32m        // Adjust the row and column indices based on boundary wrapping[m
[32m+[m[32m        if (row < 0) {[m
[32m+[m[32m            row += numRows;[m
[32m+[m[32m            column += 4 - ((numRows + 4) & 0x07);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (column < 0) {[m
[32m+[m[32m            column += numColumns;[m
[32m+[m[32m            row += 4 - ((numColumns + 4) & 0x07);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.readMappingMatrix.set(column, row);[m
[32m+[m[32m        return this.mappingBitMatrix.get(column, row);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern[m
[32m+[m[32m     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the utah shape[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row - 1, column, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row, column - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row, column - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(row, column, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentByte;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 1.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.3</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 1[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentByte;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 2.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.4</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 2[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentByte;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 3.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.5</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 3[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentByte;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the 8 bits of the special corner condition 4.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>See ISO 16022:2006, Figure F.6</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in the mapping matrix[m
[32m+[m[32m     * @param numColumns Number of columns in the mapping matrix[m
[32m+[m[32m     * @return byte from the Corner condition 4[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        currentByte <<= 1;[m
[32m+[m[32m        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {[m
[32m+[m[32m            currentByte |= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentByte;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Extracts the data region from a {@link BitMatrix} that contains[m
[32m+[m[32m     * alignment patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bitMatrix Original {@link BitMatrix} with alignment patterns[m
[32m+[m[32m     * @return BitMatrix that has the alignment patterns removed[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {[m
[32m+[m[32m        var symbolSizeRows = this.version.getSymbolSizeRows();[m
[32m+[m[32m        var symbolSizeColumns = this.version.getSymbolSizeColumns();[m
[32m+[m[32m        if (bitMatrix.getHeight() !== symbolSizeRows) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');[m
[32m+[m[32m        }[m
[32m+[m[32m        var dataRegionSizeRows = this.version.getDataRegionSizeRows();[m
[32m+[m[32m        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();[m
[32m+[m[32m        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;[m
[32m+[m[32m        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;[m
[32m+[m[32m        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;[m
[32m+[m[32m        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;[m
[32m+[m[32m        var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);[m
[32m+[m[32m        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {[m
[32m+[m[32m            var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;[m
[32m+[m[32m            for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {[m
[32m+[m[32m                var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;[m
[32m+[m[32m                for (var i = 0; i < dataRegionSizeRows; ++i) {[m
[32m+[m[32m                    var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;[m
[32m+[m[32m                    var writeRowOffset = dataRegionRowOffset + i;[m
[32m+[m[32m                    for (var j = 0; j < dataRegionSizeColumns; ++j) {[m
[32m+[m[32m                        var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;[m
[32m+[m[32m                        if (bitMatrix.get(readColumnOffset, readRowOffset)) {[m
[32m+[m[32m                            var writeColumnOffset = dataRegionColumnOffset + j;[m
[32m+[m[32m                            bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bitMatrixWithoutAlignment;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitMatrixParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitMatrixParser;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d7cb95c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into[m
[32m+[m[32m * multiple blocks, each of which is a unit of data and error-correction codewords. Each[m
[32m+[m[32m * is represented by an instance of this class.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DataBlock {[m
[32m+[m[32m    private numDataCodewords;[m
[32m+[m[32m    private codewords;[m
[32m+[m[32m    constructor(numDataCodewords: number, codewords: Uint8Array);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.[m
[32m+[m[32m     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This[m
[32m+[m[32m     * method will separate the data into original blocks.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rawCodewords bytes as read directly from the Data Matrix Code[m
[32m+[m[32m     * @param version version of the Data Matrix Code[m
[32m+[m[32m     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the[m
[32m+[m[32m     *         Data Matrix Code[m
[32m+[m[32m     */[m
[32m+[m[32m    static getDataBlocks(rawCodewords: Int8Array, version: Version): DataBlock[];[m
[32m+[m[32m    getNumDataCodewords(): number;[m
[32m+[m[32m    getCodewords(): Uint8Array;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ce26902[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DataBlock.js[m
[36m@@ -0,0 +1,135 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into[m
[32m+[m[32m * multiple blocks, each of which is a unit of data and error-correction codewords. Each[m
[32m+[m[32m * is represented by an instance of this class.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mvar DataBlock = /** @class */ (function () {[m
[32m+[m[32m    function DataBlock(numDataCodewords, codewords) {[m
[32m+[m[32m        this.numDataCodewords = numDataCodewords;[m
[32m+[m[32m        this.codewords = codewords;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.[m
[32m+[m[32m     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This[m
[32m+[m[32m     * method will separate the data into original blocks.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rawCodewords bytes as read directly from the Data Matrix Code[m
[32m+[m[32m     * @param version version of the Data Matrix Code[m
[32m+[m[32m     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the[m
[32m+[m[32m     *         Data Matrix Code[m
[32m+[m[32m     */[m
[32m+[m[32m    DataBlock.getDataBlocks = function (rawCodewords, version) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        // Figure out the number and size of data blocks used by this version[m
[32m+[m[32m        var ecBlocks = version.getECBlocks();[m
[32m+[m[32m        // First count the total number of data blocks[m
[32m+[m[32m        var totalBlocks = 0;[m
[32m+[m[32m        var ecBlockArray = ecBlocks.getECBlocks();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {[m
[32m+[m[32m                var ecBlock = ecBlockArray_1_1.value;[m
[32m+[m[32m                totalBlocks += ecBlock.getCount();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now establish DataBlocks of the appropriate size and number of data codewords[m
[32m+[m[32m        var result = new Array(totalBlocks);[m
[32m+[m[32m        var numResultBlocks = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {[m
[32m+[m[32m                var ecBlock = ecBlockArray_2_1.value;[m
[32m+[m[32m                for (var i = 0; i < ecBlock.getCount(); i++) {[m
[32m+[m[32m                    var numDataCodewords = ecBlock.getDataCodewords();[m
[32m+[m[32m                    var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;[m
[32m+[m[32m                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // All blocks have the same amount of data, except that the last n[m
[32m+[m[32m        // (where n may be 0) have 1 less byte. Figure out where these start.[m
[32m+[m[32m        // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144[m
[32m+[m[32m        var longerBlocksTotalCodewords = result[0].codewords.length;[m
[32m+[m[32m        // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;[m
[32m+[m[32m        var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();[m
[32m+[m[32m        var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;[m
[32m+[m[32m        // The last elements of result may be 1 element shorter for 144 matrix[m
[32m+[m[32m        // first fill out as many elements as all of them have minus 1[m
[32m+[m[32m        var rawCodewordsOffset = 0;[m
[32m+[m[32m        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {[m
[32m+[m[32m            for (var j = 0; j < numResultBlocks; j++) {[m
[32m+[m[32m                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Fill out the last data block in the longer ones[m
[32m+[m[32m        var specialVersion = version.getVersionNumber() === 24;[m
[32m+[m[32m        var numLongerBlocks = specialVersion ? 8 : numResultBlocks;[m
[32m+[m[32m        for (var j = 0; j < numLongerBlocks; j++) {[m
[32m+[m[32m            result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now add in error correction blocks[m
[32m+[m[32m        var max = result[0].codewords.length;[m
[32m+[m[32m        for (var i = longerBlocksNumDataCodewords; i < max; i++) {[m
[32m+[m[32m            for (var j = 0; j < numResultBlocks; j++) {[m
[32m+[m[32m                var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;[m
[32m+[m[32m                var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;[m
[32m+[m[32m                result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (rawCodewordsOffset !== rawCodewords.length) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataBlock.prototype.getNumDataCodewords = function () {[m
[32m+[m[32m        return this.numDataCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataBlock.prototype.getCodewords = function () {[m
[32m+[m[32m        return this.codewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DataBlock;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataBlock;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0bd1eb5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.d.ts[m
[36m@@ -0,0 +1,55 @@[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes[m
[32m+[m[32m * in one Data Matrix Code. This class decodes the bits back into text.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DecodedBitStreamParser {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex C Table C.1[m
[32m+[m[32m     * The C40 Basic Character Set (*'s used for placeholders for the shift values)[m
[32m+[m[32m     */[m
[32m+[m[32m    private static C40_BASIC_SET_CHARS;[m
[32m+[m[32m    private static C40_SHIFT2_SET_CHARS;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex C Table C.2[m
[32m+[m[32m     * The Text Basic Character Set (*'s used for placeholders for the shift values)[m
[32m+[m[32m     */[m
[32m+[m[32m    private static TEXT_BASIC_SET_CHARS;[m
[32m+[m[32m    private static TEXT_SHIFT2_SET_CHARS;[m
[32m+[m[32m    private static TEXT_SHIFT3_SET_CHARS;[m
[32m+[m[32m    static decode(bytes: Uint8Array): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeAsciiSegment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeC40Segment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeTextSegment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.7[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeAnsiX12Segment;[m
[32m+[m[32m    private static parseTwoBytes;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.8 and Annex C Table C.3[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeEdifactSegment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.9 and Annex B, B.2[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeBase256Segment;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex B, B.2[m
[32m+[m[32m     */[m
[32m+[m[32m    private static unrandomize255State;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..33d3340[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js[m
[36m@@ -0,0 +1,511 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecoderResult_1 = require("../../common/DecoderResult");[m
[32m+[m[32mvar BitSource_1 = require("../../common/BitSource");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar StringEncoding_1 = require("../../util/StringEncoding");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../../IllegalStateException");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar Mode;[m
[32m+[m[32m(function (Mode) {[m
[32m+[m[32m    Mode[Mode["PAD_ENCODE"] = 0] = "PAD_ENCODE";[m
[32m+[m[32m    Mode[Mode["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";[m
[32m+[m[32m    Mode[Mode["C40_ENCODE"] = 2] = "C40_ENCODE";[m
[32m+[m[32m    Mode[Mode["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";[m
[32m+[m[32m    Mode[Mode["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";[m
[32m+[m[32m    Mode[Mode["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";[m
[32m+[m[32m    Mode[Mode["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";[m
[32m+[m[32m})(Mode || (Mode = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes[m
[32m+[m[32m * in one Data Matrix Code. This class decodes the bits back into text.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DecodedBitStreamParser = /** @class */ (function () {[m
[32m+[m[32m    function DecodedBitStreamParser() {[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedBitStreamParser.decode = function (bytes) {[m
[32m+[m[32m        var bits = new BitSource_1.default(bytes);[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        var resultTrailer = new StringBuilder_1.default();[m
[32m+[m[32m        var byteSegments = new Array();[m
[32m+[m[32m        var mode = Mode.ASCII_ENCODE;[m
[32m+[m[32m        do {[m
[32m+[m[32m            if (mode === Mode.ASCII_ENCODE) {[m
[32m+[m[32m                mode = this.decodeAsciiSegment(bits, result, resultTrailer);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                switch (mode) {[m
[32m+[m[32m                    case Mode.C40_ENCODE:[m
[32m+[m[32m                        this.decodeC40Segment(bits, result);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode.TEXT_ENCODE:[m
[32m+[m[32m                        this.decodeTextSegment(bits, result);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode.ANSIX12_ENCODE:[m
[32m+[m[32m                        this.decodeAnsiX12Segment(bits, result);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode.EDIFACT_ENCODE:[m
[32m+[m[32m                        this.decodeEdifactSegment(bits, result);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode.BASE256_ENCODE:[m
[32m+[m[32m                        this.decodeBase256Segment(bits, result, byteSegments);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new FormatException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                mode = Mode.ASCII_ENCODE;[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);[m
[32m+[m[32m        if (resultTrailer.length() > 0) {[m
[32m+[m[32m            result.append(resultTrailer.toString());[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeAsciiSegment = function (bits, result, resultTrailer) {[m
[32m+[m[32m        var upperShift = false;[m
[32m+[m[32m        do {[m
[32m+[m[32m            var oneByte = bits.readBits(8);[m
[32m+[m[32m            if (oneByte === 0) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (oneByte <= 128) { // ASCII data (ASCII value + 1)[m
[32m+[m[32m                if (upperShift) {[m
[32m+[m[32m                    oneByte += 128;[m
[32m+[m[32m                    // upperShift = false;[m
[32m+[m[32m                }[m
[32m+[m[32m                result.append(String.fromCharCode(oneByte - 1));[m
[32m+[m[32m                return Mode.ASCII_ENCODE;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (oneByte === 129) { // Pad[m
[32m+[m[32m                return Mode.PAD_ENCODE;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)[m
[32m+[m[32m                var value = oneByte - 130;[m
[32m+[m[32m                if (value < 10) { // pad with '0' for single digit values[m
[32m+[m[32m                    result.append('0');[m
[32m+[m[32m                }[m
[32m+[m[32m                result.append('' + value);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                switch (oneByte) {[m
[32m+[m[32m                    case 230: // Latch to C40 encodation[m
[32m+[m[32m                        return Mode.C40_ENCODE;[m
[32m+[m[32m                    case 231: // Latch to Base 256 encodation[m
[32m+[m[32m                        return Mode.BASE256_ENCODE;[m
[32m+[m[32m                    case 232: // FNC1[m
[32m+[m[32m                        result.append(String.fromCharCode(29)); // translate as ASCII 29[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 233: // Structured Append[m
[32m+[m[32m                    case 234: // Reader Programming[m
[32m+[m[32m                        // Ignore these symbols for now[m
[32m+[m[32m                        // throw ReaderException.getInstance();[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 235: // Upper Shift (shift to Extended ASCII)[m
[32m+[m[32m                        upperShift = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 236: // 05 Macro[m
[32m+[m[32m                        result.append('[)>\u001E05\u001D');[m
[32m+[m[32m                        resultTrailer.insert(0, '\u001E\u0004');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 237: // 06 Macro[m
[32m+[m[32m                        result.append('[)>\u001E06\u001D');[m
[32m+[m[32m                        resultTrailer.insert(0, '\u001E\u0004');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 238: // Latch to ANSI X12 encodation[m
[32m+[m[32m                        return Mode.ANSIX12_ENCODE;[m
[32m+[m[32m                    case 239: // Latch to Text encodation[m
[32m+[m[32m                        return Mode.TEXT_ENCODE;[m
[32m+[m[32m                    case 240: // Latch to EDIFACT encodation[m
[32m+[m[32m                        return Mode.EDIFACT_ENCODE;[m
[32m+[m[32m                    case 241: // ECI Character[m
[32m+[m[32m                        // TODO(bbrown): I think we need to support ECI[m
[32m+[m[32m                        // throw ReaderException.getInstance();[m
[32m+[m[32m                        // Ignore this symbol for now[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        // Not to be used in ASCII encodation[m
[32m+[m[32m                        // but work around encoders that end with 254, latch back to ASCII[m
[32m+[m[32m                        if (oneByte !== 254 || bits.available() !== 0) {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (bits.available() > 0);[m
[32m+[m[32m        return Mode.ASCII_ENCODE;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeC40Segment = function (bits, result) {[m
[32m+[m[32m        // Three C40 values are encoded in a 16-bit value as[m
[32m+[m[32m        // (1600 * C1) + (40 * C2) + C3 + 1[m
[32m+[m[32m        // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time[m
[32m+[m[32m        var upperShift = false;[m
[32m+[m[32m        var cValues = [];[m
[32m+[m[32m        var shift = 0;[m
[32m+[m[32m        do {[m
[32m+[m[32m            // If there is only one byte left then it will be encoded as ASCII[m
[32m+[m[32m            if (bits.available() === 8) {[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            var firstByte = bits.readBits(8);[m
[32m+[m[32m            if (firstByte === 254) { // Unlatch codeword[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);[m
[32m+[m[32m            for (var i = 0; i < 3; i++) {[m
[32m+[m[32m                var cValue = cValues[i];[m
[32m+[m[32m                switch (shift) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        if (cValue < 3) {[m
[32m+[m[32m                            shift = cValue + 1;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (cValue < this.C40_BASIC_SET_CHARS.length) {[m
[32m+[m[32m                            var c40char = this.C40_BASIC_SET_CHARS[cValue];[m
[32m+[m[32m                            if (upperShift) {[m
[32m+[m[32m                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));[m
[32m+[m[32m                                upperShift = false;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                result.append(c40char);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        if (upperShift) {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 128));[m
[32m+[m[32m                            upperShift = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shift = 0;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 2:[m
[32m+[m[32m                        if (cValue < this.C40_SHIFT2_SET_CHARS.length) {[m
[32m+[m[32m                            var c40char = this.C40_SHIFT2_SET_CHARS[cValue];[m
[32m+[m[32m                            if (upperShift) {[m
[32m+[m[32m                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));[m
[32m+[m[32m                                upperShift = false;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                result.append(c40char);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            switch (cValue) {[m
[32m+[m[32m                                case 27: // FNC1[m
[32m+[m[32m                                    result.append(String.fromCharCode(29)); // translate as ASCII 29[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                case 30: // Upper Shift[m
[32m+[m[32m                                    upperShift = true;[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                default:[m
[32m+[m[32m                                    throw new FormatException_1.default();[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shift = 0;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 3:[m
[32m+[m[32m                        if (upperShift) {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 224));[m
[32m+[m[32m                            upperShift = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 96));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shift = 0;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new FormatException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (bits.available() > 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeTextSegment = function (bits, result) {[m
[32m+[m[32m        // Three Text values are encoded in a 16-bit value as[m
[32m+[m[32m        // (1600 * C1) + (40 * C2) + C3 + 1[m
[32m+[m[32m        // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time[m
[32m+[m[32m        var upperShift = false;[m
[32m+[m[32m        var cValues = [];[m
[32m+[m[32m        var shift = 0;[m
[32m+[m[32m        do {[m
[32m+[m[32m            // If there is only one byte left then it will be encoded as ASCII[m
[32m+[m[32m            if (bits.available() === 8) {[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            var firstByte = bits.readBits(8);[m
[32m+[m[32m            if (firstByte === 254) { // Unlatch codeword[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);[m
[32m+[m[32m            for (var i = 0; i < 3; i++) {[m
[32m+[m[32m                var cValue = cValues[i];[m
[32m+[m[32m                switch (shift) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        if (cValue < 3) {[m
[32m+[m[32m                            shift = cValue + 1;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {[m
[32m+[m[32m                            var textChar = this.TEXT_BASIC_SET_CHARS[cValue];[m
[32m+[m[32m                            if (upperShift) {[m
[32m+[m[32m                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));[m
[32m+[m[32m                                upperShift = false;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                result.append(textChar);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        if (upperShift) {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 128));[m
[32m+[m[32m                            upperShift = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shift = 0;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 2:[m
[32m+[m[32m                        // Shift 2 for Text is the same encoding as C40[m
[32m+[m[32m                        if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {[m
[32m+[m[32m                            var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];[m
[32m+[m[32m                            if (upperShift) {[m
[32m+[m[32m                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));[m
[32m+[m[32m                                upperShift = false;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                result.append(textChar);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            switch (cValue) {[m
[32m+[m[32m                                case 27: // FNC1[m
[32m+[m[32m                                    result.append(String.fromCharCode(29)); // translate as ASCII 29[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                case 30: // Upper Shift[m
[32m+[m[32m                                    upperShift = true;[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                default:[m
[32m+[m[32m                                    throw new FormatException_1.default();[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shift = 0;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 3:[m
[32m+[m[32m                        if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {[m
[32m+[m[32m                            var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];[m
[32m+[m[32m                            if (upperShift) {[m
[32m+[m[32m                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));[m
[32m+[m[32m                                upperShift = false;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else {[m
[32m+[m[32m                                result.append(textChar);[m
[32m+[m[32m                            }[m
[32m+[m[32m                            shift = 0;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new FormatException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (bits.available() > 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.7[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeAnsiX12Segment = function (bits, result) {[m
[32m+[m[32m        // Three ANSI X12 values are encoded in a 16-bit value as[m
[32m+[m[32m        // (1600 * C1) + (40 * C2) + C3 + 1[m
[32m+[m[32m        var cValues = [];[m
[32m+[m[32m        do {[m
[32m+[m[32m            // If there is only one byte left then it will be encoded as ASCII[m
[32m+[m[32m            if (bits.available() === 8) {[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            var firstByte = bits.readBits(8);[m
[32m+[m[32m            if (firstByte === 254) { // Unlatch codeword[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);[m
[32m+[m[32m            for (var i = 0; i < 3; i++) {[m
[32m+[m[32m                var cValue = cValues[i];[m
[32m+[m[32m                switch (cValue) {[m
[32m+[m[32m                    case 0: // X12 segment terminator <CR>[m
[32m+[m[32m                        result.append('\r');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 1: // X12 segment separator *[m
[32m+[m[32m                        result.append('*');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 2: // X12 sub-element separator >[m
[32m+[m[32m                        result.append('>');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 3: // space[m
[32m+[m[32m                        result.append(' ');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        if (cValue < 14) { // 0 - 9[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 44));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (cValue < 40) { // A - Z[m
[32m+[m[32m                            result.append(String.fromCharCode(cValue + 51));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (bits.available() > 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.parseTwoBytes = function (firstByte, secondByte, result) {[m
[32m+[m[32m        var fullBitValue = (firstByte << 8) + secondByte - 1;[m
[32m+[m[32m        var temp = Math.floor(fullBitValue / 1600);[m
[32m+[m[32m        result[0] = temp;[m
[32m+[m[32m        fullBitValue -= temp * 1600;[m
[32m+[m[32m        temp = Math.floor(fullBitValue / 40);[m
[32m+[m[32m        result[1] = temp;[m
[32m+[m[32m        result[2] = fullBitValue - temp * 40;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.8 and Annex C Table C.3[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeEdifactSegment = function (bits, result) {[m
[32m+[m[32m        do {[m
[32m+[m[32m            // If there is only two or less bytes left then it will be encoded as ASCII[m
[32m+[m[32m            if (bits.available() <= 16) {[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m            for (var i = 0; i < 4; i++) {[m
[32m+[m[32m                var edifactValue = bits.readBits(6);[m
[32m+[m[32m                // Check for the unlatch character[m
[32m+[m[32m                if (edifactValue === 0x1F) { // 011111[m
[32m+[m[32m                    // Read rest of byte, which should be 0, and stop[m
[32m+[m[32m                    var bitsLeft = 8 - bits.getBitOffset();[m
[32m+[m[32m                    if (bitsLeft !== 8) {[m
[32m+[m[32m                        bits.readBits(bitsLeft);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit[m
[32m+[m[32m                    edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value[m
[32m+[m[32m                }[m
[32m+[m[32m                result.append(String.fromCharCode(edifactValue));[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (bits.available() > 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, 5.2.9 and Annex B, B.2[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeBase256Segment = function (bits, result, byteSegments) {[m
[32m+[m[32m        // Figure out how long the Base 256 Segment is.[m
[32m+[m[32m        var codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed[m
[32m+[m[32m        var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);[m
[32m+[m[32m        var count;[m
[32m+[m[32m        if (d1 === 0) { // Read the remainder of the symbol[m
[32m+[m[32m            count = bits.available() / 8 | 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (d1 < 250) {[m
[32m+[m[32m            count = d1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);[m
[32m+[m[32m        }[m
[32m+[m[32m        // We're seeing NegativeArraySizeException errors from users.[m
[32m+[m[32m        if (count < 0) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var bytes = new Uint8Array(count);[m
[32m+[m[32m        for (var i = 0; i < count; i++) {[m
[32m+[m[32m            // Have seen this particular error in the wild, such as at[m
[32m+[m[32m            // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2[m
[32m+[m[32m            if (bits.available() < 8) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);[m
[32m+[m[32m        }[m
[32m+[m[32m        byteSegments.push(bytes);[m
[32m+[m[32m        try {[m
[32m+[m[32m            result.append(StringEncoding_1.default.decode(bytes, StringUtils_1.default.ISO88591));[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (uee) {[m
[32m+[m[32m            throw new IllegalStateException_1.default('Platform does not support required encoding: ' + uee.message);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex B, B.2[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.unrandomize255State = function (randomizedBase256Codeword, base256CodewordPosition) {[m
[32m+[m[32m        var pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;[m
[32m+[m[32m        var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;[m
[32m+[m[32m        return tempVariable >= 0 ? tempVariable : tempVariable + 256;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex C Table C.1[m
[32m+[m[32m     * The C40 Basic Character Set (*'s used for placeholders for the shift values)[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [[m
[32m+[m[32m        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',[m
[32m+[m[32m        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',[m
[32m+[m[32m        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'[m
[32m+[m[32m    ];[m
[32m+[m[32m    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [[m
[32m+[m[32m        '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.',[m
[32m+[m[32m        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_'[m
[32m+[m[32m    ];[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006, Annex C Table C.2[m
[32m+[m[32m     * The Text Basic Character Set (*'s used for placeholders for the shift values)[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [[m
[32m+[m[32m        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',[m
[32m+[m[32m        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',[m
[32m+[m[32m        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'[m
[32m+[m[32m    ];[m
[32m+[m[32m    // Shift 2 for Text is the same encoding as C40[m
[32m+[m[32m    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;[m
[32m+[m[32m    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [[m
[32m+[m[32m        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',[m
[32m+[m[32m        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)[m
[32m+[m[32m    ];[m
[32m+[m[32m    return DecodedBitStreamParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DecodedBitStreamParser;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f01587a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.d.ts[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the Data Matrix Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Decoder {[m
[32m+[m[32m    private rsDecoder;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken[m
[32m+[m[32m     * to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits booleans representing white/black Data Matrix Code modules[m
[32m+[m[32m     * @return text and bytes encoded within the Data Matrix Code[m
[32m+[m[32m     * @throws FormatException if the Data Matrix Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(bits: BitMatrix): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place using Reed-Solomon error correction.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewordBytes data and error correction codewords[m
[32m+[m[32m     * @param numDataCodewords number of codewords that are data bytes[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    private correctErrors;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..423707a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js[m
[36m@@ -0,0 +1,123 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ChecksumException_1 = require("../../ChecksumException");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar ReedSolomonDecoder_1 = require("../../common/reedsolomon/ReedSolomonDecoder");[m
[32m+[m[32mvar BitMatrixParser_1 = require("./BitMatrixParser");[m
[32m+[m[32mvar DataBlock_1 = require("./DataBlock");[m
[32m+[m[32mvar DecodedBitStreamParser_1 = require("./DecodedBitStreamParser");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the Data Matrix Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mvar Decoder = /** @class */ (function () {[m
[32m+[m[32m    function Decoder() {[m
[32m+[m[32m        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.DATA_MATRIX_FIELD_256);[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken[m
[32m+[m[32m     * to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits booleans representing white/black Data Matrix Code modules[m
[32m+[m[32m     * @return text and bytes encoded within the Data Matrix Code[m
[32m+[m[32m     * @throws FormatException if the Data Matrix Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.decode = function (bits) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        // Construct a parser and read version, error-correction level[m
[32m+[m[32m        var parser = new BitMatrixParser_1.default(bits);[m
[32m+[m[32m        var version = parser.getVersion();[m
[32m+[m[32m        // Read codewords[m
[32m+[m[32m        var codewords = parser.readCodewords();[m
[32m+[m[32m        // Separate into data blocks[m
[32m+[m[32m        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version);[m
[32m+[m[32m        // Count total number of data bytes[m
[32m+[m[32m        var totalBytes = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {[m
[32m+[m[32m                var db = dataBlocks_1_1.value;[m
[32m+[m[32m                totalBytes += db.getNumDataCodewords();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var resultBytes = new Uint8Array(totalBytes);[m
[32m+[m[32m        var dataBlocksCount = dataBlocks.length;[m
[32m+[m[32m        // Error-correct and copy data blocks together into a stream of bytes[m
[32m+[m[32m        for (var j = 0; j < dataBlocksCount; j++) {[m
[32m+[m[32m            var dataBlock = dataBlocks[j];[m
[32m+[m[32m            var codewordBytes = dataBlock.getCodewords();[m
[32m+[m[32m            var numDataCodewords = dataBlock.getNumDataCodewords();[m
[32m+[m[32m            this.correctErrors(codewordBytes, numDataCodewords);[m
[32m+[m[32m            for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m                // De-interlace data blocks.[m
[32m+[m[32m                resultBytes[i * dataBlocksCount + j] = codewordBytes[i];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Decode the contents of that stream of bytes[m
[32m+[m[32m        return DecodedBitStreamParser_1.default.decode(resultBytes);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place using Reed-Solomon error correction.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewordBytes data and error correction codewords[m
[32m+[m[32m     * @param numDataCodewords number of codewords that are data bytes[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords) {[m
[32m+[m[32m        // const numCodewords = codewordBytes.length;[m
[32m+[m[32m        // First read into an array of ints[m
[32m+[m[32m        var codewordsInts = new Int32Array(codewordBytes);[m
[32m+[m[32m        // for (let i = 0; i < numCodewords; i++) {[m
[32m+[m[32m        //   codewordsInts[i] = codewordBytes[i] & 0xFF;[m
[32m+[m[32m        // }[m
[32m+[m[32m        try {[m
[32m+[m[32m            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /* ReedSolomonException */) {[m
[32m+[m[32m            throw new ChecksumException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Copy back into array of bytes -- only need to worry about the bytes that were data[m
[32m+[m[32m        // We don't care about errors in the error-correction codewords[m
[32m+[m[32m        for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m            codewordBytes[i] = codewordsInts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return Decoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Decoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ee81884[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.d.ts[m
[36m@@ -0,0 +1,63 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will[m
[32m+[m[32m * use blocks of differing sizes within one version, so, this encapsulates the parameters for[m
[32m+[m[32m * each set of blocks. It also holds the number of error-correction codewords per block since it[m
[32m+[m[32m * will be the same across all blocks within one version.</p>[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class ECBlocks {[m
[32m+[m[32m    private ecCodewords;[m
[32m+[m[32m    private ecBlocks;[m
[32m+[m[32m    constructor(ecCodewords: number, ecBlocks1: ECB, ecBlocks2?: ECB);[m
[32m+[m[32m    getECCodewords(): number;[m
[32m+[m[32m    getECBlocks(): ECB[];[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the parameters for one error-correction block in one symbol version.[m
[32m+[m[32m * This includes the number of data codewords, and the number of times a block with these[m
[32m+[m[32m * parameters is used consecutively in the Data Matrix code version's format.</p>[m
[32m+[m[32m */[m
[32m+[m[32mexport declare class ECB {[m
[32m+[m[32m    private count;[m
[32m+[m[32m    private dataCodewords;[m
[32m+[m[32m    constructor(count: number, dataCodewords: number);[m
[32m+[m[32m    getCount(): number;[m
[32m+[m[32m    getDataCodewords(): number;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * The Version object encapsulates attributes about a particular[m
[32m+[m[32m * size Data Matrix Code.[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Version {[m
[32m+[m[32m    private static VERSIONS;[m
[32m+[m[32m    private versionNumber;[m
[32m+[m[32m    private symbolSizeRows;[m
[32m+[m[32m    private symbolSizeColumns;[m
[32m+[m[32m    private dataRegionSizeRows;[m
[32m+[m[32m    private dataRegionSizeColumns;[m
[32m+[m[32m    private ecBlocks;[m
[32m+[m[32m    private totalCodewords;[m
[32m+[m[32m    constructor(versionNumber: any, symbolSizeRows: any, symbolSizeColumns: any, dataRegionSizeRows: any, dataRegionSizeColumns: any, ecBlocks: ECBlocks);[m
[32m+[m[32m    getVersionNumber(): number;[m
[32m+[m[32m    getSymbolSizeRows(): number;[m
[32m+[m[32m    getSymbolSizeColumns(): number;[m
[32m+[m[32m    getDataRegionSizeRows(): number;[m
[32m+[m[32m    getDataRegionSizeColumns(): number;[m
[32m+[m[32m    getTotalCodewords(): number;[m
[32m+[m[32m    getECBlocks(): ECBlocks;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Deduces version information from Data Matrix dimensions.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in modules[m
[32m+[m[32m     * @param numColumns Number of columns in modules[m
[32m+[m[32m     * @return Version for a Data Matrix Code of those dimensions[m
[32m+[m[32m     * @throws FormatException if dimensions do correspond to a valid Data Matrix size[m
[32m+[m[32m     */[m
[32m+[m[32m    static getVersionForDimensions(numRows: number, numColumns: number): Version;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006 5.5.1 Table 7[m
[32m+[m[32m     */[m
[32m+[m[32m    private static buildVersions;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a141881[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/decoder/Version.js[m
[36m@@ -0,0 +1,200 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.ECB = exports.ECBlocks = void 0;[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will[m
[32m+[m[32m * use blocks of differing sizes within one version, so, this encapsulates the parameters for[m
[32m+[m[32m * each set of blocks. It also holds the number of error-correction codewords per block since it[m
[32m+[m[32m * will be the same across all blocks within one version.</p>[m
[32m+[m[32m */[m
[32m+[m[32mvar ECBlocks = /** @class */ (function () {[m
[32m+[m[32m    function ECBlocks(ecCodewords, ecBlocks1, ecBlocks2) {[m
[32m+[m[32m        this.ecCodewords = ecCodewords;[m
[32m+[m[32m        this.ecBlocks = [ecBlocks1];[m
[32m+[m[32m        ecBlocks2 && this.ecBlocks.push(ecBlocks2);[m
[32m+[m[32m    }[m
[32m+[m[32m    ECBlocks.prototype.getECCodewords = function () {[m
[32m+[m[32m        return this.ecCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECBlocks.prototype.getECBlocks = function () {[m
[32m+[m[32m        return this.ecBlocks;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ECBlocks;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.ECBlocks = ECBlocks;[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the parameters for one error-correction block in one symbol version.[m
[32m+[m[32m * This includes the number of data codewords, and the number of times a block with these[m
[32m+[m[32m * parameters is used consecutively in the Data Matrix code version's format.</p>[m
[32m+[m[32m */[m
[32m+[m[32mvar ECB = /** @class */ (function () {[m
[32m+[m[32m    function ECB(count, dataCodewords) {[m
[32m+[m[32m        this.count = count;[m
[32m+[m[32m        this.dataCodewords = dataCodewords;[m
[32m+[m[32m    }[m
[32m+[m[32m    ECB.prototype.getCount = function () {[m
[32m+[m[32m        return this.count;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECB.prototype.getDataCodewords = function () {[m
[32m+[m[32m        return this.dataCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ECB;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.ECB = ECB;[m
[32m+[m[32m/**[m
[32m+[m[32m * The Version object encapsulates attributes about a particular[m
[32m+[m[32m * size Data Matrix Code.[m
[32m+[m[32m *[m
[32m+[m[32m * @author bbrown@google.com (Brian Brown)[m
[32m+[m[32m */[m
[32m+[m[32mvar Version = /** @class */ (function () {[m
[32m+[m[32m    function Version(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        this.versionNumber = versionNumber;[m
[32m+[m[32m        this.symbolSizeRows = symbolSizeRows;[m
[32m+[m[32m        this.symbolSizeColumns = symbolSizeColumns;[m
[32m+[m[32m        this.dataRegionSizeRows = dataRegionSizeRows;[m
[32m+[m[32m        this.dataRegionSizeColumns = dataRegionSizeColumns;[m
[32m+[m[32m        this.ecBlocks = ecBlocks;[m
[32m+[m[32m        // Calculate the total number of codewords[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        var ecCodewords = ecBlocks.getECCodewords();[m
[32m+[m[32m        var ecbArray = ecBlocks.getECBlocks();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {[m
[32m+[m[32m                var ecBlock = ecbArray_1_1.value;[m
[32m+[m[32m                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.totalCodewords = total;[m
[32m+[m[32m    }[m
[32m+[m[32m    Version.prototype.getVersionNumber = function () {[m
[32m+[m[32m        return this.versionNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getSymbolSizeRows = function () {[m
[32m+[m[32m        return this.symbolSizeRows;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getSymbolSizeColumns = function () {[m
[32m+[m[32m        return this.symbolSizeColumns;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getDataRegionSizeRows = function () {[m
[32m+[m[32m        return this.dataRegionSizeRows;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getDataRegionSizeColumns = function () {[m
[32m+[m[32m        return this.dataRegionSizeColumns;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getTotalCodewords = function () {[m
[32m+[m[32m        return this.totalCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getECBlocks = function () {[m
[32m+[m[32m        return this.ecBlocks;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Deduces version information from Data Matrix dimensions.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param numRows Number of rows in modules[m
[32m+[m[32m     * @param numColumns Number of columns in modules[m
[32m+[m[32m     * @return Version for a Data Matrix Code of those dimensions[m
[32m+[m[32m     * @throws FormatException if dimensions do correspond to a valid Data Matrix size[m
[32m+[m[32m     */[m
[32m+[m[32m    Version.getVersionForDimensions = function (numRows, numColumns) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(Version.VERSIONS), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var version = _c.value;[m
[32m+[m[32m                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {[m
[32m+[m[32m                    return version;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new FormatException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    //  @Override[m
[32m+[m[32m    Version.prototype.toString = function () {[m
[32m+[m[32m        return '' + this.versionNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 16022:2006 5.5.1 Table 7[m
[32m+[m[32m     */[m
[32m+[m[32m    Version.buildVersions = function () {[m
[32m+[m[32m        return [[m
[32m+[m[32m            new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),[m
[32m+[m[32m            new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),[m
[32m+[m[32m            new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),[m
[32m+[m[32m            new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),[m
[32m+[m[32m            new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),[m
[32m+[m[32m            new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),[m
[32m+[m[32m            new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),[m
[32m+[m[32m            new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),[m
[32m+[m[32m            new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),[m
[32m+[m[32m            new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),[m
[32m+[m[32m            new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),[m
[32m+[m[32m            new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),[m
[32m+[m[32m            new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),[m
[32m+[m[32m            new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),[m
[32m+[m[32m            new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),[m
[32m+[m[32m            new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),[m
[32m+[m[32m            new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),[m
[32m+[m[32m            new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),[m
[32m+[m[32m            new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),[m
[32m+[m[32m            new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),[m
[32m+[m[32m            new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),[m
[32m+[m[32m            new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),[m
[32m+[m[32m            new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),[m
[32m+[m[32m            new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),[m
[32m+[m[32m            new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),[m
[32m+[m[32m            new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),[m
[32m+[m[32m            new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),[m
[32m+[m[32m            new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),[m
[32m+[m[32m            new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),[m
[32m+[m[32m            new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))[m
[32m+[m[32m        ];[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.VERSIONS = Version.buildVersions();[m
[32m+[m[32m    return Version;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Version;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..7b0fcae[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.d.ts[m
[36m@@ -0,0 +1,44 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport DetectorResult from '../../common/DetectorResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Detector {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private rectangleDetector;[m
[32m+[m[32m    constructor(image: BitMatrix);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a Data Matrix Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    detect(): DetectorResult;[m
[32m+[m[32m    private static shiftPoint;[m
[32m+[m[32m    private static moveAway;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detect a solid side which has minimum transition.[m
[32m+[m[32m     */[m
[32m+[m[32m    private detectSolid1;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detect a second solid side next to first solid side.[m
[32m+[m[32m     */[m
[32m+[m[32m    private detectSolid2;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates the corner position of the white top right module.[m
[32m+[m[32m     */[m
[32m+[m[32m    private correctTopRight;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Shift the edge points to the module center.[m
[32m+[m[32m     */[m
[32m+[m[32m    private shiftToModuleCenter;[m
[32m+[m[32m    private isValid;[m
[32m+[m[32m    private static sampleGrid;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.[m
[32m+[m[32m     */[m
[32m+[m[32m    private transitionsBetween;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c70540b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/detector/Detector.js[m
[36m@@ -0,0 +1,304 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar WhiteRectangleDetector_1 = require("../../common/detector/WhiteRectangleDetector");[m
[32m+[m[32mvar DetectorResult_1 = require("../../common/DetectorResult");[m
[32m+[m[32mvar GridSamplerInstance_1 = require("../../common/GridSamplerInstance");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Detector = /** @class */ (function () {[m
[32m+[m[32m    function Detector(image) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a Data Matrix Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code[m
[32m+[m[32m     * @throws NotFoundException if no Data Matrix Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.detect = function () {[m
[32m+[m[32m        var cornerPoints = this.rectangleDetector.detect();[m
[32m+[m[32m        var points = this.detectSolid1(cornerPoints);[m
[32m+[m[32m        points = this.detectSolid2(points);[m
[32m+[m[32m        points[3] = this.correctTopRight(points);[m
[32m+[m[32m        if (!points[3]) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        points = this.shiftToModuleCenter(points);[m
[32m+[m[32m        var topLeft = points[0];[m
[32m+[m[32m        var bottomLeft = points[1];[m
[32m+[m[32m        var bottomRight = points[2];[m
[32m+[m[32m        var topRight = points[3];[m
[32m+[m[32m        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;[m
[32m+[m[32m        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;[m
[32m+[m[32m        if ((dimensionTop & 0x01) === 1) {[m
[32m+[m[32m            dimensionTop += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ((dimensionRight & 0x01) === 1) {[m
[32m+[m[32m            dimensionRight += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {[m
[32m+[m[32m            // The matrix is square[m
[32m+[m[32m            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);[m
[32m+[m[32m        }[m
[32m+[m[32m        var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);[m
[32m+[m[32m        return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.shiftPoint = function (point, to, div) {[m
[32m+[m[32m        var x = (to.getX() - point.getX()) / (div + 1);[m
[32m+[m[32m        var y = (to.getY() - point.getY()) / (div + 1);[m
[32m+[m[32m        return new ResultPoint_1.default(point.getX() + x, point.getY() + y);[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.moveAway = function (point, fromX, fromY) {[m
[32m+[m[32m        var x = point.getX();[m
[32m+[m[32m        var y = point.getY();[m
[32m+[m[32m        if (x < fromX) {[m
[32m+[m[32m            x -= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            x += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (y < fromY) {[m
[32m+[m[32m            y -= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            y += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ResultPoint_1.default(x, y);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detect a solid side which has minimum transition.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.detectSolid1 = function (cornerPoints) {[m
[32m+[m[32m        // 0  2[m
[32m+[m[32m        // 1  3[m
[32m+[m[32m        var pointA = cornerPoints[0];[m
[32m+[m[32m        var pointB = cornerPoints[1];[m
[32m+[m[32m        var pointC = cornerPoints[3];[m
[32m+[m[32m        var pointD = cornerPoints[2];[m
[32m+[m[32m        var trAB = this.transitionsBetween(pointA, pointB);[m
[32m+[m[32m        var trBC = this.transitionsBetween(pointB, pointC);[m
[32m+[m[32m        var trCD = this.transitionsBetween(pointC, pointD);[m
[32m+[m[32m        var trDA = this.transitionsBetween(pointD, pointA);[m
[32m+[m[32m        // 0..3[m
[32m+[m[32m        // :  :[m
[32m+[m[32m        // 1--2[m
[32m+[m[32m        var min = trAB;[m
[32m+[m[32m        var points = [pointD, pointA, pointB, pointC];[m
[32m+[m[32m        if (min > trBC) {[m
[32m+[m[32m            min = trBC;[m
[32m+[m[32m            points[0] = pointA;[m
[32m+[m[32m            points[1] = pointB;[m
[32m+[m[32m            points[2] = pointC;[m
[32m+[m[32m            points[3] = pointD;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (min > trCD) {[m
[32m+[m[32m            min = trCD;[m
[32m+[m[32m            points[0] = pointB;[m
[32m+[m[32m            points[1] = pointC;[m
[32m+[m[32m            points[2] = pointD;[m
[32m+[m[32m            points[3] = pointA;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (min > trDA) {[m
[32m+[m[32m            points[0] = pointC;[m
[32m+[m[32m            points[1] = pointD;[m
[32m+[m[32m            points[2] = pointA;[m
[32m+[m[32m            points[3] = pointB;[m
[32m+[m[32m        }[m
[32m+[m[32m        return points;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detect a second solid side next to first solid side.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.detectSolid2 = function (points) {[m
[32m+[m[32m        // A..D[m
[32m+[m[32m        // :  :[m
[32m+[m[32m        // B--C[m
[32m+[m[32m        var pointA = points[0];[m
[32m+[m[32m        var pointB = points[1];[m
[32m+[m[32m        var pointC = points[2];[m
[32m+[m[32m        var pointD = points[3];[m
[32m+[m[32m        // Transition detection on the edge is not stable.[m
[32m+[m[32m        // To safely detect, shift the points to the module center.[m
[32m+[m[32m        var tr = this.transitionsBetween(pointA, pointD);[m
[32m+[m[32m        var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);[m
[32m+[m[32m        var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);[m
[32m+[m[32m        var trBA = this.transitionsBetween(pointBs, pointA);[m
[32m+[m[32m        var trCD = this.transitionsBetween(pointCs, pointD);[m
[32m+[m[32m        // 0..3[m
[32m+[m[32m        // |  :[m
[32m+[m[32m        // 1--2[m
[32m+[m[32m        if (trBA < trCD) {[m
[32m+[m[32m            // solid sides: A-B-C[m
[32m+[m[32m            points[0] = pointA;[m
[32m+[m[32m            points[1] = pointB;[m
[32m+[m[32m            points[2] = pointC;[m
[32m+[m[32m            points[3] = pointD;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // solid sides: B-C-D[m
[32m+[m[32m            points[0] = pointB;[m
[32m+[m[32m            points[1] = pointC;[m
[32m+[m[32m            points[2] = pointD;[m
[32m+[m[32m            points[3] = pointA;[m
[32m+[m[32m        }[m
[32m+[m[32m        return points;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Calculates the corner position of the white top right module.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.correctTopRight = function (points) {[m
[32m+[m[32m        // A..D[m
[32m+[m[32m        // |  :[m
[32m+[m[32m        // B--C[m
[32m+[m[32m        var pointA = points[0];[m
[32m+[m[32m        var pointB = points[1];[m
[32m+[m[32m        var pointC = points[2];[m
[32m+[m[32m        var pointD = points[3];[m
[32m+[m[32m        // shift points for safe transition detection.[m
[32m+[m[32m        var trTop = this.transitionsBetween(pointA, pointD);[m
[32m+[m[32m        var trRight = this.transitionsBetween(pointB, pointD);[m
[32m+[m[32m        var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);[m
[32m+[m[32m        var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);[m
[32m+[m[32m        trTop = this.transitionsBetween(pointAs, pointD);[m
[32m+[m[32m        trRight = this.transitionsBetween(pointCs, pointD);[m
[32m+[m[32m        var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));[m
[32m+[m[32m        var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));[m
[32m+[m[32m        if (!this.isValid(candidate1)) {[m
[32m+[m[32m            if (this.isValid(candidate2)) {[m
[32m+[m[32m                return candidate2;[m
[32m+[m[32m            }[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!this.isValid(candidate2)) {[m
[32m+[m[32m            return candidate1;[m
[32m+[m[32m        }[m
[32m+[m[32m        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);[m
[32m+[m[32m        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);[m
[32m+[m[32m        if (sumc1 > sumc2) {[m
[32m+[m[32m            return candidate1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return candidate2;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Shift the edge points to the module center.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.shiftToModuleCenter = function (points) {[m
[32m+[m[32m        // A..D[m
[32m+[m[32m        // |  :[m
[32m+[m[32m        // B--C[m
[32m+[m[32m        var pointA = points[0];[m
[32m+[m[32m        var pointB = points[1];[m
[32m+[m[32m        var pointC = points[2];[m
[32m+[m[32m        var pointD = points[3];[m
[32m+[m[32m        // calculate pseudo dimensions[m
[32m+[m[32m        var dimH = this.transitionsBetween(pointA, pointD) + 1;[m
[32m+[m[32m        var dimV = this.transitionsBetween(pointC, pointD) + 1;[m
[32m+[m[32m        // shift points for safe dimension detection[m
[32m+[m[32m        var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);[m
[32m+[m[32m        var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);[m
[32m+[m[32m        //  calculate more precise dimensions[m
[32m+[m[32m        dimH = this.transitionsBetween(pointAs, pointD) + 1;[m
[32m+[m[32m        dimV = this.transitionsBetween(pointCs, pointD) + 1;[m
[32m+[m[32m        if ((dimH & 0x01) === 1) {[m
[32m+[m[32m            dimH += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ((dimV & 0x01) === 1) {[m
[32m+[m[32m            dimV += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        // WhiteRectangleDetector returns points inside of the rectangle.[m
[32m+[m[32m        // I want points on the edges.[m
[32m+[m[32m        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;[m
[32m+[m[32m        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;[m
[32m+[m[32m        pointA = Detector.moveAway(pointA, centerX, centerY);[m
[32m+[m[32m        pointB = Detector.moveAway(pointB, centerX, centerY);[m
[32m+[m[32m        pointC = Detector.moveAway(pointC, centerX, centerY);[m
[32m+[m[32m        pointD = Detector.moveAway(pointD, centerX, centerY);[m
[32m+[m[32m        var pointBs;[m
[32m+[m[32m        var pointDs;[m
[32m+[m[32m        // shift points to the center of each modules[m
[32m+[m[32m        pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);[m
[32m+[m[32m        pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);[m
[32m+[m[32m        pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);[m
[32m+[m[32m        pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);[m
[32m+[m[32m        pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);[m
[32m+[m[32m        pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);[m
[32m+[m[32m        pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);[m
[32m+[m[32m        pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);[m
[32m+[m[32m        return [pointAs, pointBs, pointCs, pointDs];[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.isValid = function (p) {[m
[32m+[m[32m        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {[m
[32m+[m[32m        var sampler = GridSamplerInstance_1.default.getInstance();[m
[32m+[m[32m        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.transitionsBetween = function (from, to) {[m
[32m+[m[32m        // See QR Code Detector, sizeOfBlackWhiteBlackRun()[m
[32m+[m[32m        var fromX = Math.trunc(from.getX());[m
[32m+[m[32m        var fromY = Math.trunc(from.getY());[m
[32m+[m[32m        var toX = Math.trunc(to.getX());[m
[32m+[m[32m        var toY = Math.trunc(to.getY());[m
[32m+[m[32m        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);[m
[32m+[m[32m        if (steep) {[m
[32m+[m[32m            var temp = fromX;[m
[32m+[m[32m            fromX = fromY;[m
[32m+[m[32m            fromY = temp;[m
[32m+[m[32m            temp = toX;[m
[32m+[m[32m            toX = toY;[m
[32m+[m[32m            toY = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var dx = Math.abs(toX - fromX);[m
[32m+[m[32m        var dy = Math.abs(toY - fromY);[m
[32m+[m[32m        var error = -dx / 2;[m
[32m+[m[32m        var ystep = fromY < toY ? 1 : -1;[m
[32m+[m[32m        var xstep = fromX < toX ? 1 : -1;[m
[32m+[m[32m        var transitions = 0;[m
[32m+[m[32m        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);[m
[32m+[m[32m        for (var x = fromX, y = fromY; x !== toX; x += xstep) {[m
[32m+[m[32m            var isBlack = this.image.get(steep ? y : x, steep ? x : y);[m
[32m+[m[32m            if (isBlack !== inBlack) {[m
[32m+[m[32m                transitions++;[m
[32m+[m[32m                inBlack = isBlack;[m
[32m+[m[32m            }[m
[32m+[m[32m            error += dy;[m
[32m+[m[32m            if (error > 0) {[m
[32m+[m[32m                if (y === toY) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                y += ystep;[m
[32m+[m[32m                error -= dx;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return transitions;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Detector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Detector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2fe894b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport { Encoder } from './Encoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport declare class ASCIIEncoder implements Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m    private encodeASCIIDigits;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fb93dfd[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ASCIIEncoder.js[m
[36m@@ -0,0 +1,69 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.ASCIIEncoder = void 0;[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar ASCIIEncoder = /** @class */ (function () {[m
[32m+[m[32m    function ASCIIEncoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    ASCIIEncoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.ASCII_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    ASCIIEncoder.prototype.encode = function (context) {[m
[32m+[m[32m        // step B[m
[32m+[m[32m        var n = HighLevelEncoder_1.default.determineConsecutiveDigitCount(context.getMessage(), context.pos);[m
[32m+[m[32m        if (n >= 2) {[m
[32m+[m[32m            context.writeCodeword(this.encodeASCIIDigits(context.getMessage().charCodeAt(context.pos), context.getMessage().charCodeAt(context.pos + 1)));[m
[32m+[m[32m            context.pos += 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());[m
[32m+[m[32m            if (newMode !== this.getEncodingMode()) {[m
[32m+[m[32m                switch (newMode) {[m
[32m+[m[32m                    case constants_1.BASE256_ENCODATION:[m
[32m+[m[32m                        context.writeCodeword(constants_1.LATCH_TO_BASE256);[m
[32m+[m[32m                        context.signalEncoderChange(constants_1.BASE256_ENCODATION);[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    case constants_1.C40_ENCODATION:[m
[32m+[m[32m                        context.writeCodeword(constants_1.LATCH_TO_C40);[m
[32m+[m[32m                        context.signalEncoderChange(constants_1.C40_ENCODATION);[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    case constants_1.X12_ENCODATION:[m
[32m+[m[32m                        context.writeCodeword(constants_1.LATCH_TO_ANSIX12);[m
[32m+[m[32m                        context.signalEncoderChange(constants_1.X12_ENCODATION);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case constants_1.TEXT_ENCODATION:[m
[32m+[m[32m                        context.writeCodeword(constants_1.LATCH_TO_TEXT);[m
[32m+[m[32m                        context.signalEncoderChange(constants_1.TEXT_ENCODATION);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case constants_1.EDIFACT_ENCODATION:[m
[32m+[m[32m                        context.writeCodeword(constants_1.LATCH_TO_EDIFACT);[m
[32m+[m[32m                        context.signalEncoderChange(constants_1.EDIFACT_ENCODATION);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new Error('Illegal mode: ' + newMode);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (HighLevelEncoder_1.default.isExtendedASCII(c)) {[m
[32m+[m[32m                context.writeCodeword(constants_1.UPPER_SHIFT);[m
[32m+[m[32m                context.writeCodeword(c - 128 + 1);[m
[32m+[m[32m                context.pos++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                context.writeCodeword(c + 1);[m
[32m+[m[32m                context.pos++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    ASCIIEncoder.prototype.encodeASCIIDigits = function (digit1, digit2) {[m
[32m+[m[32m        if (HighLevelEncoder_1.default.isDigit(digit1) && HighLevelEncoder_1.default.isDigit(digit2)) {[m
[32m+[m[32m            var num = (digit1 - 48) * 10 + (digit2 - 48);[m
[32m+[m[32m            return num + 130;[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new Error('not digits: ' + digit1 + digit2);[m
[32m+[m[32m    };[m
[32m+[m[32m    return ASCIIEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.ASCIIEncoder = ASCIIEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4e01f7a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport { Encoder } from './Encoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport declare class Base256Encoder implements Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m    private randomize255State;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..925010c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Base256Encoder.js[m
[36m@@ -0,0 +1,61 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.Base256Encoder = void 0;[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar Base256Encoder = /** @class */ (function () {[m
[32m+[m[32m    function Base256Encoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    Base256Encoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.BASE256_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    Base256Encoder.prototype.encode = function (context) {[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        buffer.append(0); // Initialize length field[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            buffer.append(c);[m
[32m+[m[32m            context.pos++;[m
[32m+[m[32m            var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());[m
[32m+[m[32m            if (newMode !== this.getEncodingMode()) {[m
[32m+[m[32m                // Return to ASCII encodation, which will actually handle latch to new mode[m
[32m+[m[32m                context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var dataCount = buffer.length() - 1;[m
[32m+[m[32m        var lengthFieldSize = 1;[m
[32m+[m[32m        var currentSize = context.getCodewordCount() + dataCount + lengthFieldSize;[m
[32m+[m[32m        context.updateSymbolInfo(currentSize);[m
[32m+[m[32m        var mustPad = context.getSymbolInfo().getDataCapacity() - currentSize > 0;[m
[32m+[m[32m        if (context.hasMoreCharacters() || mustPad) {[m
[32m+[m[32m            if (dataCount <= 249) {[m
[32m+[m[32m                buffer.setCharAt(0, StringUtils_1.default.getCharAt(dataCount));[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (dataCount <= 1555) {[m
[32m+[m[32m                buffer.setCharAt(0, StringUtils_1.default.getCharAt(Math.floor(dataCount / 250) + 249));[m
[32m+[m[32m                buffer.insert(1, StringUtils_1.default.getCharAt(dataCount % 250));[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                throw new Error('Message length not in valid ranges: ' + dataCount);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0, c = buffer.length(); i < c; i++) {[m
[32m+[m[32m            context.writeCodeword(this.randomize255State(buffer.charAt(i).charCodeAt(0), context.getCodewordCount() + 1));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Base256Encoder.prototype.randomize255State = function (ch, codewordPosition) {[m
[32m+[m[32m        var pseudoRandom = ((149 * codewordPosition) % 255) + 1;[m
[32m+[m[32m        var tempVariable = ch + pseudoRandom;[m
[32m+[m[32m        if (tempVariable <= 255) {[m
[32m+[m[32m            return tempVariable;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return tempVariable - 256;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return Base256Encoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.Base256Encoder = Base256Encoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4302eba[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.d.ts[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32mimport StringBuilder from '../../util/StringBuilder';[m
[32m+[m[32mimport { char } from '../../../customTypings';[m
[32m+[m[32mimport { Encoder } from './Encoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport declare class C40Encoder implements Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encodeMaximal(context: EncoderContext): void;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m    backtrackOneCharacter(context: EncoderContext, buffer: StringBuilder, removed: StringBuilder, lastCharSize: number): number;[m
[32m+[m[32m    writeNextTriplet(context: EncoderContext, buffer: StringBuilder): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle "end of data" situations[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param context the encoder context[m
[32m+[m[32m     * @param buffer  the buffer with the remaining encoded characters[m
[32m+[m[32m     */[m
[32m+[m[32m    handleEOD(context: EncoderContext, buffer: StringBuilder): void;[m
[32m+[m[32m    encodeChar(c: char, sb: StringBuilder): number;[m
[32m+[m[32m    private encodeToCodewords;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7119076[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/C40Encoder.js[m
[36m@@ -0,0 +1,202 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.C40Encoder = void 0;[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar C40Encoder = /** @class */ (function () {[m
[32m+[m[32m    function C40Encoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    C40Encoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.C40_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.encodeMaximal = function (context) {[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        var lastCharSize = 0;[m
[32m+[m[32m        var backtrackStartPosition = context.pos;[m
[32m+[m[32m        var backtrackBufferLength = 0;[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            context.pos++;[m
[32m+[m[32m            lastCharSize = this.encodeChar(c, buffer);[m
[32m+[m[32m            if (buffer.length() % 3 === 0) {[m
[32m+[m[32m                backtrackStartPosition = context.pos;[m
[32m+[m[32m                backtrackBufferLength = buffer.length();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (backtrackBufferLength !== buffer.length()) {[m
[32m+[m[32m            var unwritten = Math.floor((buffer.length() / 3) * 2);[m
[32m+[m[32m            var curCodewordCount = Math.floor(context.getCodewordCount() + unwritten + 1); // +1 for the latch to C40[m
[32m+[m[32m            context.updateSymbolInfo(curCodewordCount);[m
[32m+[m[32m            var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;[m
[32m+[m[32m            var rest = Math.floor(buffer.length() % 3);[m
[32m+[m[32m            if ((rest === 2 && available !== 2) ||[m
[32m+[m[32m                (rest === 1 && (lastCharSize > 3 || available !== 1))) {[m
[32m+[m[32m                // buffer.setLength(backtrackBufferLength);[m
[32m+[m[32m                context.pos = backtrackStartPosition;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (buffer.length() > 0) {[m
[32m+[m[32m            context.writeCodeword(constants_1.LATCH_TO_C40);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.handleEOD(context, buffer);[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.encode = function (context) {[m
[32m+[m[32m        // step C[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            context.pos++;[m
[32m+[m[32m            var lastCharSize = this.encodeChar(c, buffer);[m
[32m+[m[32m            var unwritten = Math.floor(buffer.length() / 3) * 2;[m
[32m+[m[32m            var curCodewordCount = context.getCodewordCount() + unwritten;[m
[32m+[m[32m            context.updateSymbolInfo(curCodewordCount);[m
[32m+[m[32m            var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;[m
[32m+[m[32m            if (!context.hasMoreCharacters()) {[m
[32m+[m[32m                // Avoid having a single C40 value in the last triplet[m
[32m+[m[32m                var removed = new StringBuilder_1.default();[m
[32m+[m[32m                if (buffer.length() % 3 === 2 && available !== 2) {[m
[32m+[m[32m                    lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);[m
[32m+[m[32m                }[m
[32m+[m[32m                while (buffer.length() % 3 === 1 &&[m
[32m+[m[32m                    (lastCharSize > 3 || available !== 1)) {[m
[32m+[m[32m                    lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            var count = buffer.length();[m
[32m+[m[32m            if (count % 3 === 0) {[m
[32m+[m[32m                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());[m
[32m+[m[32m                if (newMode !== this.getEncodingMode()) {[m
[32m+[m[32m                    // Return to ASCII encodation, which will actually handle latch to new mode[m
[32m+[m[32m                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.handleEOD(context, buffer);[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.backtrackOneCharacter = function (context, buffer, removed, lastCharSize) {[m
[32m+[m[32m        var count = buffer.length();[m
[32m+[m[32m        var test = buffer.toString().substring(0, count - lastCharSize);[m
[32m+[m[32m        buffer.setLengthToZero();[m
[32m+[m[32m        buffer.append(test);[m
[32m+[m[32m        // buffer.delete(count - lastCharSize, count);[m
[32m+[m[32m        /*for (let i = count - lastCharSize; i < count; i++) {[m
[32m+[m[32m          buffer.deleteCharAt(i);[m
[32m+[m[32m        }*/[m
[32m+[m[32m        context.pos--;[m
[32m+[m[32m        var c = context.getCurrentChar();[m
[32m+[m[32m        lastCharSize = this.encodeChar(c, removed);[m
[32m+[m[32m        context.resetSymbolInfo(); // Deal with possible reduction in symbol size[m
[32m+[m[32m        return lastCharSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.writeNextTriplet = function (context, buffer) {[m
[32m+[m[32m        context.writeCodewords(this.encodeToCodewords(buffer.toString()));[m
[32m+[m[32m        var test = buffer.toString().substring(3);[m
[32m+[m[32m        buffer.setLengthToZero();[m
[32m+[m[32m        buffer.append(test);[m
[32m+[m[32m        // buffer.delete(0, 3);[m
[32m+[m[32m        /*for (let i = 0; i < 3; i++) {[m
[32m+[m[32m          buffer.deleteCharAt(i);[m
[32m+[m[32m        }*/[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle "end of data" situations[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param context the encoder context[m
[32m+[m[32m     * @param buffer  the buffer with the remaining encoded characters[m
[32m+[m[32m     */[m
[32m+[m[32m    C40Encoder.prototype.handleEOD = function (context, buffer) {[m
[32m+[m[32m        var unwritten = Math.floor((buffer.length() / 3) * 2);[m
[32m+[m[32m        var rest = buffer.length() % 3;[m
[32m+[m[32m        var curCodewordCount = context.getCodewordCount() + unwritten;[m
[32m+[m[32m        context.updateSymbolInfo(curCodewordCount);[m
[32m+[m[32m        var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;[m
[32m+[m[32m        if (rest === 2) {[m
[32m+[m[32m            buffer.append('\0'); // Shift 1[m
[32m+[m[32m            while (buffer.length() >= 3) {[m
[32m+[m[32m                this.writeNextTriplet(context, buffer);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (context.hasMoreCharacters()) {[m
[32m+[m[32m                context.writeCodeword(constants_1.C40_UNLATCH);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (available === 1 && rest === 1) {[m
[32m+[m[32m            while (buffer.length() >= 3) {[m
[32m+[m[32m                this.writeNextTriplet(context, buffer);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (context.hasMoreCharacters()) {[m
[32m+[m[32m                context.writeCodeword(constants_1.C40_UNLATCH);[m
[32m+[m[32m            }[m
[32m+[m[32m            // else no unlatch[m
[32m+[m[32m            context.pos--;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (rest === 0) {[m
[32m+[m[32m            while (buffer.length() >= 3) {[m
[32m+[m[32m                this.writeNextTriplet(context, buffer);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (available > 0 || context.hasMoreCharacters()) {[m
[32m+[m[32m                context.writeCodeword(constants_1.C40_UNLATCH);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new Error('Unexpected case. Please report!');[m
[32m+[m[32m        }[m
[32m+[m[32m        context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.encodeChar = function (c, sb) {[m
[32m+[m[32m        if (c === ' '.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(3);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(c - 48 + 4);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(c - 65 + 14);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c < ' '.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(0); // Shift 1 Set[m
[32m+[m[32m            sb.append(c);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= '/'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 33);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= '@'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 58 + 15);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= '_'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 91 + 22);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= 127) {[m
[32m+[m[32m            sb.append(2); // Shift 3 Set[m
[32m+[m[32m            sb.append(c - 96);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        sb.append(1 + "\u001E"); // Shift 2, Upper Shift[m
[32m+[m[32m        var len = 2;[m
[32m+[m[32m        len += this.encodeChar(c - 128, sb);[m
[32m+[m[32m        return len;[m
[32m+[m[32m    };[m
[32m+[m[32m    C40Encoder.prototype.encodeToCodewords = function (sb) {[m
[32m+[m[32m        var v = 1600 * sb.charCodeAt(0) + 40 * sb.charCodeAt(1) + sb.charCodeAt(2) + 1;[m
[32m+[m[32m        var cw1 = v / 256;[m
[32m+[m[32m        var cw2 = v % 256;[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        result.append(cw1);[m
[32m+[m[32m        result.append(cw2);[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    return C40Encoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.C40Encoder = C40Encoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3824eac[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.d.ts[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Symbol Character Placement Program. Adapted from Annex M.1 in ISO/IEC 16022:2000(E).[m
[32m+[m[32m */[m
[32m+[m[32mdeclare class DefaultPlacement {[m
[32m+[m[32m    private readonly codewords;[m
[32m+[m[32m    private readonly numcols;[m
[32m+[m[32m    private readonly numrows;[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Main constructor[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords the codewords to place[m
[32m+[m[32m     * @param numcols   the number of columns[m
[32m+[m[32m     * @param numrows   the number of rows[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(codewords: string, numcols: number, numrows: number);[m
[32m+[m[32m    getNumrows(): number;[m
[32m+[m[32m    getNumcols(): number;[m
[32m+[m[32m    getBits(): Uint8Array;[m
[32m+[m[32m    getBit(col: number, row: number): boolean;[m
[32m+[m[32m    private setBit;[m
[32m+[m[32m    private noBit;[m
[32m+[m[32m    place(): void;[m
[32m+[m[32m    private module;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Places the 8 bits of a utah-shaped symbol character in ECC200.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row the row[m
[32m+[m[32m     * @param col the column[m
[32m+[m[32m     * @param pos character position[m
[32m+[m[32m     */[m
[32m+[m[32m    private utah;[m
[32m+[m[32m    private corner1;[m
[32m+[m[32m    private corner2;[m
[32m+[m[32m    private corner3;[m
[32m+[m[32m    private corner4;[m
[32m+[m[32m}[m
[32m+[m[32mexport default DefaultPlacement;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bac9776[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/DefaultPlacement.js[m
[36m@@ -0,0 +1,159 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32m/**[m
[32m+[m[32m * Symbol Character Placement Program. Adapted from Annex M.1 in ISO/IEC 16022:2000(E).[m
[32m+[m[32m */[m
[32m+[m[32mvar DefaultPlacement = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Main constructor[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords the codewords to place[m
[32m+[m[32m     * @param numcols   the number of columns[m
[32m+[m[32m     * @param numrows   the number of rows[m
[32m+[m[32m     */[m
[32m+[m[32m    function DefaultPlacement(codewords, numcols, numrows) {[m
[32m+[m[32m        this.codewords = codewords;[m
[32m+[m[32m        this.numcols = numcols;[m
[32m+[m[32m        this.numrows = numrows;[m
[32m+[m[32m        this.bits = new Uint8Array(numcols * numrows);[m
[32m+[m[32m        Arrays_1.default.fill(this.bits, 2); // Initialize with "not set" value[m
[32m+[m[32m    }[m
[32m+[m[32m    DefaultPlacement.prototype.getNumrows = function () {[m
[32m+[m[32m        return this.numrows;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.getNumcols = function () {[m
[32m+[m[32m        return this.numcols;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.getBits = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.getBit = function (col, row) {[m
[32m+[m[32m        return this.bits[row * this.numcols + col] === 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.setBit = function (col, row, bit) {[m
[32m+[m[32m        this.bits[row * this.numcols + col] = bit ? 1 : 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.noBit = function (col, row) {[m
[32m+[m[32m        return this.bits[row * this.numcols + col] === 2;[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.place = function () {[m
[32m+[m[32m        var pos = 0;[m
[32m+[m[32m        var row = 4;[m
[32m+[m[32m        var col = 0;[m
[32m+[m[32m        do {[m
[32m+[m[32m            // repeatedly first check for one of the special corner cases, then...[m
[32m+[m[32m            if (row === this.numrows && col === 0) {[m
[32m+[m[32m                this.corner1(pos++);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (row === this.numrows - 2 && col === 0 && this.numcols % 4 !== 0) {[m
[32m+[m[32m                this.corner2(pos++);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (row === this.numrows - 2 && col === 0 && this.numcols % 8 === 4) {[m
[32m+[m[32m                this.corner3(pos++);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (row === this.numrows + 4 && col === 2 && this.numcols % 8 === 0) {[m
[32m+[m[32m                this.corner4(pos++);[m
[32m+[m[32m            }[m
[32m+[m[32m            // sweep upward diagonally, inserting successive characters...[m
[32m+[m[32m            do {[m
[32m+[m[32m                if (row < this.numrows && col >= 0 && this.noBit(col, row)) {[m
[32m+[m[32m                    this.utah(row, col, pos++);[m
[32m+[m[32m                }[m
[32m+[m[32m                row -= 2;[m
[32m+[m[32m                col += 2;[m
[32m+[m[32m            } while (row >= 0 && col < this.numcols);[m
[32m+[m[32m            row++;[m
[32m+[m[32m            col += 3;[m
[32m+[m[32m            // and then sweep downward diagonally, inserting successive characters, ...[m
[32m+[m[32m            do {[m
[32m+[m[32m                if (row >= 0 && col < this.numcols && this.noBit(col, row)) {[m
[32m+[m[32m                    this.utah(row, col, pos++);[m
[32m+[m[32m                }[m
[32m+[m[32m                row += 2;[m
[32m+[m[32m                col -= 2;[m
[32m+[m[32m            } while (row < this.numrows && col >= 0);[m
[32m+[m[32m            row += 3;[m
[32m+[m[32m            col++;[m
[32m+[m[32m            // ...until the entire array is scanned[m
[32m+[m[32m        } while (row < this.numrows || col < this.numcols);[m
[32m+[m[32m        // Lastly, if the lower right-hand corner is untouched, fill in fixed pattern[m
[32m+[m[32m        if (this.noBit(this.numcols - 1, this.numrows - 1)) {[m
[32m+[m[32m            this.setBit(this.numcols - 1, this.numrows - 1, true);[m
[32m+[m[32m            this.setBit(this.numcols - 2, this.numrows - 2, true);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.module = function (row, col, pos, bit) {[m
[32m+[m[32m        if (row < 0) {[m
[32m+[m[32m            row += this.numrows;[m
[32m+[m[32m            col += 4 - ((this.numrows + 4) % 8);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (col < 0) {[m
[32m+[m[32m            col += this.numcols;[m
[32m+[m[32m            row += 4 - ((this.numcols + 4) % 8);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Note the conversion:[m
[32m+[m[32m        var v = this.codewords.charCodeAt(pos);[m
[32m+[m[32m        v &= 1 << (8 - bit);[m
[32m+[m[32m        this.setBit(col, row, v !== 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Places the 8 bits of a utah-shaped symbol character in ECC200.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row the row[m
[32m+[m[32m     * @param col the column[m
[32m+[m[32m     * @param pos character position[m
[32m+[m[32m     */[m
[32m+[m[32m    DefaultPlacement.prototype.utah = function (row, col, pos) {[m
[32m+[m[32m        this.module(row - 2, col - 2, pos, 1);[m
[32m+[m[32m        this.module(row - 2, col - 1, pos, 2);[m
[32m+[m[32m        this.module(row - 1, col - 2, pos, 3);[m
[32m+[m[32m        this.module(row - 1, col - 1, pos, 4);[m
[32m+[m[32m        this.module(row - 1, col, pos, 5);[m
[32m+[m[32m        this.module(row, col - 2, pos, 6);[m
[32m+[m[32m        this.module(row, col - 1, pos, 7);[m
[32m+[m[32m        this.module(row, col, pos, 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.corner1 = function (pos) {[m
[32m+[m[32m        this.module(this.numrows - 1, 0, pos, 1);[m
[32m+[m[32m        this.module(this.numrows - 1, 1, pos, 2);[m
[32m+[m[32m        this.module(this.numrows - 1, 2, pos, 3);[m
[32m+[m[32m        this.module(0, this.numcols - 2, pos, 4);[m
[32m+[m[32m        this.module(0, this.numcols - 1, pos, 5);[m
[32m+[m[32m        this.module(1, this.numcols - 1, pos, 6);[m
[32m+[m[32m        this.module(2, this.numcols - 1, pos, 7);[m
[32m+[m[32m        this.module(3, this.numcols - 1, pos, 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.corner2 = function (pos) {[m
[32m+[m[32m        this.module(this.numrows - 3, 0, pos, 1);[m
[32m+[m[32m        this.module(this.numrows - 2, 0, pos, 2);[m
[32m+[m[32m        this.module(this.numrows - 1, 0, pos, 3);[m
[32m+[m[32m        this.module(0, this.numcols - 4, pos, 4);[m
[32m+[m[32m        this.module(0, this.numcols - 3, pos, 5);[m
[32m+[m[32m        this.module(0, this.numcols - 2, pos, 6);[m
[32m+[m[32m        this.module(0, this.numcols - 1, pos, 7);[m
[32m+[m[32m        this.module(1, this.numcols - 1, pos, 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.corner3 = function (pos) {[m
[32m+[m[32m        this.module(this.numrows - 3, 0, pos, 1);[m
[32m+[m[32m        this.module(this.numrows - 2, 0, pos, 2);[m
[32m+[m[32m        this.module(this.numrows - 1, 0, pos, 3);[m
[32m+[m[32m        this.module(0, this.numcols - 2, pos, 4);[m
[32m+[m[32m        this.module(0, this.numcols - 1, pos, 5);[m
[32m+[m[32m        this.module(1, this.numcols - 1, pos, 6);[m
[32m+[m[32m        this.module(2, this.numcols - 1, pos, 7);[m
[32m+[m[32m        this.module(3, this.numcols - 1, pos, 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    DefaultPlacement.prototype.corner4 = function (pos) {[m
[32m+[m[32m        this.module(this.numrows - 1, 0, pos, 1);[m
[32m+[m[32m        this.module(this.numrows - 1, this.numcols - 1, pos, 2);[m
[32m+[m[32m        this.module(0, this.numcols - 3, pos, 3);[m
[32m+[m[32m        this.module(0, this.numcols - 2, pos, 4);[m
[32m+[m[32m        this.module(0, this.numcols - 1, pos, 5);[m
[32m+[m[32m        this.module(1, this.numcols - 3, pos, 6);[m
[32m+[m[32m        this.module(1, this.numcols - 2, pos, 7);[m
[32m+[m[32m        this.module(1, this.numcols - 1, pos, 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    return DefaultPlacement;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DefaultPlacement;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..66ecb99[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.d.ts[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32mimport { Encoder } from './Encoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport declare class EdifactEncoder implements Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle "end of data" situations[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param context the encoder context[m
[32m+[m[32m     * @param buffer  the buffer with the remaining encoded characters[m
[32m+[m[32m     */[m
[32m+[m[32m    private handleEOD;[m
[32m+[m[32m    private encodeChar;[m
[32m+[m[32m    private encodeToCodewords;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b78d658[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EdifactEncoder.js[m
[36m@@ -0,0 +1,136 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.EdifactEncoder = void 0;[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar EdifactEncoder = /** @class */ (function () {[m
[32m+[m[32m    function EdifactEncoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    EdifactEncoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.EDIFACT_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    EdifactEncoder.prototype.encode = function (context) {[m
[32m+[m[32m        // step F[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            this.encodeChar(c, buffer);[m
[32m+[m[32m            context.pos++;[m
[32m+[m[32m            var count = buffer.length();[m
[32m+[m[32m            if (count >= 4) {[m
[32m+[m[32m                context.writeCodewords(this.encodeToCodewords(buffer.toString()));[m
[32m+[m[32m                var test_1 = buffer.toString().substring(4);[m
[32m+[m[32m                buffer.setLengthToZero();[m
[32m+[m[32m                buffer.append(test_1);[m
[32m+[m[32m                // buffer.delete(0, 4);[m
[32m+[m[32m                // for (let i = 0; i < 4; i++) {[m
[32m+[m[32m                //  buffer.deleteCharAt(i);[m
[32m+[m[32m                // }[m
[32m+[m[32m                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());[m
[32m+[m[32m                if (newMode !== this.getEncodingMode()) {[m
[32m+[m[32m                    // Return to ASCII encodation, which will actually handle latch to new mode[m
[32m+[m[32m                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        buffer.append(StringUtils_1.default.getCharAt(31)); // Unlatch[m
[32m+[m[32m        this.handleEOD(context, buffer);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle "end of data" situations[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param context the encoder context[m
[32m+[m[32m     * @param buffer  the buffer with the remaining encoded characters[m
[32m+[m[32m     */[m
[32m+[m[32m    EdifactEncoder.prototype.handleEOD = function (context, buffer) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            var count = buffer.length();[m
[32m+[m[32m            if (count === 0) {[m
[32m+[m[32m                return; // Already finished[m
[32m+[m[32m            }[m
[32m+[m[32m            if (count === 1) {[m
[32m+[m[32m                // Only an unlatch at the end[m
[32m+[m[32m                context.updateSymbolInfo();[m
[32m+[m[32m                var available = context.getSymbolInfo().getDataCapacity() -[m
[32m+[m[32m                    context.getCodewordCount();[m
[32m+[m[32m                var remaining = context.getRemainingCharacters();[m
[32m+[m[32m                // The following two lines are a hack inspired by the 'fix' from https://sourceforge.net/p/barcode4j/svn/221/[m
[32m+[m[32m                if (remaining > available) {[m
[32m+[m[32m                    context.updateSymbolInfo(context.getCodewordCount() + 1);[m
[32m+[m[32m                    available =[m
[32m+[m[32m                        context.getSymbolInfo().getDataCapacity() -[m
[32m+[m[32m                            context.getCodewordCount();[m
[32m+[m[32m                }[m
[32m+[m[32m                if (remaining <= available && available <= 2) {[m
[32m+[m[32m                    return; // No unlatch[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (count > 4) {[m
[32m+[m[32m                throw new Error('Count must not exceed 4');[m
[32m+[m[32m            }[m
[32m+[m[32m            var restChars = count - 1;[m
[32m+[m[32m            var encoded = this.encodeToCodewords(buffer.toString());[m
[32m+[m[32m            var endOfSymbolReached = !context.hasMoreCharacters();[m
[32m+[m[32m            var restInAscii = endOfSymbolReached && restChars <= 2;[m
[32m+[m[32m            if (restChars <= 2) {[m
[32m+[m[32m                context.updateSymbolInfo(context.getCodewordCount() + restChars);[m
[32m+[m[32m                var available = context.getSymbolInfo().getDataCapacity() -[m
[32m+[m[32m                    context.getCodewordCount();[m
[32m+[m[32m                if (available >= 3) {[m
[32m+[m[32m                    restInAscii = false;[m
[32m+[m[32m                    context.updateSymbolInfo(context.getCodewordCount() + encoded.length);[m
[32m+[m[32m                    // available = context.symbolInfo.dataCapacity - context.getCodewordCount();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (restInAscii) {[m
[32m+[m[32m                context.resetSymbolInfo();[m
[32m+[m[32m                context.pos -= restChars;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                context.writeCodewords(encoded);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    EdifactEncoder.prototype.encodeChar = function (c, sb) {[m
[32m+[m[32m        if (c >= ' '.charCodeAt(0) && c <= '?'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(c);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (c >= '@'.charCodeAt(0) && c <= '^'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(StringUtils_1.default.getCharAt(c - 64));[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            HighLevelEncoder_1.default.illegalCharacter(StringUtils_1.default.getCharAt(c));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    EdifactEncoder.prototype.encodeToCodewords = function (sb) {[m
[32m+[m[32m        var len = sb.length;[m
[32m+[m[32m        if (len === 0) {[m
[32m+[m[32m            throw new Error('StringBuilder must not be empty');[m
[32m+[m[32m        }[m
[32m+[m[32m        var c1 = sb.charAt(0).charCodeAt(0);[m
[32m+[m[32m        var c2 = len >= 2 ? sb.charAt(1).charCodeAt(0) : 0;[m
[32m+[m[32m        var c3 = len >= 3 ? sb.charAt(2).charCodeAt(0) : 0;[m
[32m+[m[32m        var c4 = len >= 4 ? sb.charAt(3).charCodeAt(0) : 0;[m
[32m+[m[32m        var v = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4;[m
[32m+[m[32m        var cw1 = (v >> 16) & 255;[m
[32m+[m[32m        var cw2 = (v >> 8) & 255;[m
[32m+[m[32m        var cw3 = v & 255;[m
[32m+[m[32m        var res = new StringBuilder_1.default();[m
[32m+[m[32m        res.append(cw1);[m
[32m+[m[32m        if (len >= 2) {[m
[32m+[m[32m            res.append(cw2);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (len >= 3) {[m
[32m+[m[32m            res.append(cw3);[m
[32m+[m[32m        }[m
[32m+[m[32m        return res.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    return EdifactEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.EdifactEncoder = EdifactEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..78e62a4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.d.ts[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport interface Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c8ad2e5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/Encoder.js[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c17650e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.d.ts[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32mimport StringBuilder from '../../util/StringBuilder';[m
[32m+[m[32mimport Dimension from '../../Dimension';[m
[32m+[m[32mimport { SymbolShapeHint } from './constants';[m
[32m+[m[32mimport SymbolInfo from './SymbolInfo';[m
[32m+[m[32mexport declare class EncoderContext {[m
[32m+[m[32m    private readonly msg;[m
[32m+[m[32m    private shape;[m
[32m+[m[32m    private minSize;[m
[32m+[m[32m    private maxSize;[m
[32m+[m[32m    private codewords;[m
[32m+[m[32m    pos: number;[m
[32m+[m[32m    private newEncoding;[m
[32m+[m[32m    private symbolInfo;[m
[32m+[m[32m    private skipAtEnd;[m
[32m+[m[32m    constructor(msg: string);[m
[32m+[m[32m    setSymbolShape(shape: SymbolShapeHint): void;[m
[32m+[m[32m    setSizeConstraints(minSize: Dimension, maxSize: Dimension): void;[m
[32m+[m[32m    getMessage(): string;[m
[32m+[m[32m    setSkipAtEnd(count: number): void;[m
[32m+[m[32m    getCurrentChar(): number;[m
[32m+[m[32m    getCurrent(): number;[m
[32m+[m[32m    getCodewords(): StringBuilder;[m
[32m+[m[32m    writeCodewords(codewords: string): void;[m
[32m+[m[32m    writeCodeword(codeword: number | string): void;[m
[32m+[m[32m    getCodewordCount(): number;[m
[32m+[m[32m    getNewEncoding(): number;[m
[32m+[m[32m    signalEncoderChange(encoding: number): void;[m
[32m+[m[32m    resetEncoderSignal(): void;[m
[32m+[m[32m    hasMoreCharacters(): boolean;[m
[32m+[m[32m    private getTotalMessageCharCount;[m
[32m+[m[32m    getRemainingCharacters(): number;[m
[32m+[m[32m    getSymbolInfo(): SymbolInfo;[m
[32m+[m[32m    updateSymbolInfo(len?: number): void;[m
[32m+[m[32m    resetSymbolInfo(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bb8d07a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/EncoderContext.js[m
[36m@@ -0,0 +1,89 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.EncoderContext = void 0;[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar SymbolInfo_1 = require("./SymbolInfo");[m
[32m+[m[32mvar EncoderContext = /** @class */ (function () {[m
[32m+[m[32m    function EncoderContext(msg) {[m
[32m+[m[32m        this.msg = msg;[m
[32m+[m[32m        this.pos = 0;[m
[32m+[m[32m        this.skipAtEnd = 0;[m
[32m+[m[32m        // From this point on Strings are not Unicode anymore![m
[32m+[m[32m        var msgBinary = msg.split('').map(function (c) { return c.charCodeAt(0); });[m
[32m+[m[32m        var sb = new StringBuilder_1.default();[m
[32m+[m[32m        for (var i = 0, c = msgBinary.length; i < c; i++) {[m
[32m+[m[32m            var ch = String.fromCharCode(msgBinary[i] & 0xff);[m
[32m+[m[32m            if (ch === '?' && msg.charAt(i) !== '?') {[m
[32m+[m[32m                throw new Error('Message contains characters outside ISO-8859-1 encoding.');[m
[32m+[m[32m            }[m
[32m+[m[32m            sb.append(ch);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.msg = sb.toString(); // Not Unicode here![m
[32m+[m[32m        this.shape = 0 /* FORCE_NONE */;[m
[32m+[m[32m        this.codewords = new StringBuilder_1.default();[m
[32m+[m[32m        this.newEncoding = -1;[m
[32m+[m[32m    }[m
[32m+[m[32m    EncoderContext.prototype.setSymbolShape = function (shape) {[m
[32m+[m[32m        this.shape = shape;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.setSizeConstraints = function (minSize, maxSize) {[m
[32m+[m[32m        this.minSize = minSize;[m
[32m+[m[32m        this.maxSize = maxSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getMessage = function () {[m
[32m+[m[32m        return this.msg;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.setSkipAtEnd = function (count) {[m
[32m+[m[32m        this.skipAtEnd = count;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getCurrentChar = function () {[m
[32m+[m[32m        return this.msg.charCodeAt(this.pos);[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getCurrent = function () {[m
[32m+[m[32m        return this.msg.charCodeAt(this.pos);[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getCodewords = function () {[m
[32m+[m[32m        return this.codewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.writeCodewords = function (codewords) {[m
[32m+[m[32m        this.codewords.append(codewords);[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.writeCodeword = function (codeword) {[m
[32m+[m[32m        this.codewords.append(codeword);[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getCodewordCount = function () {[m
[32m+[m[32m        return this.codewords.length();[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getNewEncoding = function () {[m
[32m+[m[32m        return this.newEncoding;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.signalEncoderChange = function (encoding) {[m
[32m+[m[32m        this.newEncoding = encoding;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.resetEncoderSignal = function () {[m
[32m+[m[32m        this.newEncoding = -1;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.hasMoreCharacters = function () {[m
[32m+[m[32m        return this.pos < this.getTotalMessageCharCount();[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getTotalMessageCharCount = function () {[m
[32m+[m[32m        return this.msg.length - this.skipAtEnd;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getRemainingCharacters = function () {[m
[32m+[m[32m        return this.getTotalMessageCharCount() - this.pos;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.getSymbolInfo = function () {[m
[32m+[m[32m        return this.symbolInfo;[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.updateSymbolInfo = function (len) {[m
[32m+[m[32m        if (len === void 0) { len = this.getCodewordCount(); }[m
[32m+[m[32m        if (this.symbolInfo == null || len > this.symbolInfo.getDataCapacity()) {[m
[32m+[m[32m            this.symbolInfo = SymbolInfo_1.default.lookup(len, this.shape, this.minSize, this.maxSize, true);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    EncoderContext.prototype.resetSymbolInfo = function () {[m
[32m+[m[32m        this.symbolInfo = null;[m
[32m+[m[32m    };[m
[32m+[m[32m    return EncoderContext;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.EncoderContext = EncoderContext;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a8abf0f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.d.ts[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mimport SymbolInfo from './SymbolInfo';[m
[32m+[m[32m/**[m
[32m+[m[32m * Error Correction Code for ECC200.[m
[32m+[m[32m */[m
[32m+[m[32mdeclare class ErrorCorrection {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates the ECC200 error correction for an encoded message.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords  the codewords[m
[32m+[m[32m     * @param symbolInfo information about the symbol to be encoded[m
[32m+[m[32m     * @return the codewords with interleaved error correction.[m
[32m+[m[32m     */[m
[32m+[m[32m    static encodeECC200(codewords: string, symbolInfo: SymbolInfo): string;[m
[32m+[m[32m    private static createECCBlock;[m
[32m+[m[32m}[m
[32m+[m[32mexport default ErrorCorrection;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1c41dfb[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/ErrorCorrection.js[m
[36m@@ -0,0 +1,92 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32m/**[m
[32m+[m[32m * Error Correction Code for ECC200.[m
[32m+[m[32m */[m
[32m+[m[32mvar ErrorCorrection = /** @class */ (function () {[m
[32m+[m[32m    function ErrorCorrection() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates the ECC200 error correction for an encoded message.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords  the codewords[m
[32m+[m[32m     * @param symbolInfo information about the symbol to be encoded[m
[32m+[m[32m     * @return the codewords with interleaved error correction.[m
[32m+[m[32m     */[m
[32m+[m[32m    ErrorCorrection.encodeECC200 = function (codewords, symbolInfo) {[m
[32m+[m[32m        if (codewords.length !== symbolInfo.getDataCapacity()) {[m
[32m+[m[32m            throw new Error('The number of codewords does not match the selected symbol');[m
[32m+[m[32m        }[m
[32m+[m[32m        var sb = new StringBuilder_1.default();[m
[32m+[m[32m        sb.append(codewords);[m
[32m+[m[32m        var blockCount = symbolInfo.getInterleavedBlockCount();[m
[32m+[m[32m        if (blockCount === 1) {[m
[32m+[m[32m            var ecc = this.createECCBlock(codewords, symbolInfo.getErrorCodewords());[m
[32m+[m[32m            sb.append(ecc);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // sb.setLength(sb.capacity());[m
[32m+[m[32m            var dataSizes = [];[m
[32m+[m[32m            var errorSizes = [];[m
[32m+[m[32m            for (var i = 0; i < blockCount; i++) {[m
[32m+[m[32m                dataSizes[i] = symbolInfo.getDataLengthForInterleavedBlock(i + 1);[m
[32m+[m[32m                errorSizes[i] = symbolInfo.getErrorLengthForInterleavedBlock(i + 1);[m
[32m+[m[32m            }[m
[32m+[m[32m            for (var block = 0; block < blockCount; block++) {[m
[32m+[m[32m                var temp = new StringBuilder_1.default();[m
[32m+[m[32m                for (var d = block; d < symbolInfo.getDataCapacity(); d += blockCount) {[m
[32m+[m[32m                    temp.append(codewords.charAt(d));[m
[32m+[m[32m                }[m
[32m+[m[32m                var ecc = this.createECCBlock(temp.toString(), errorSizes[block]);[m
[32m+[m[32m                var pos = 0;[m
[32m+[m[32m                for (var e = block; e < errorSizes[block] * blockCount; e += blockCount) {[m
[32m+[m[32m                    sb.setCharAt(symbolInfo.getDataCapacity() + e, ecc.charAt(pos++));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return sb.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrection.createECCBlock = function (codewords, numECWords) {[m
[32m+[m[32m        var table = -1;[m
[32m+[m[32m        for (var i = 0; i < constants_1.FACTOR_SETS.length; i++) {[m
[32m+[m[32m            if (constants_1.FACTOR_SETS[i] === numECWords) {[m
[32m+[m[32m                table = i;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (table < 0) {[m
[32m+[m[32m            throw new Error('Illegal number of error correction codewords specified: ' + numECWords);[m
[32m+[m[32m        }[m
[32m+[m[32m        var poly = constants_1.FACTORS[table];[m
[32m+[m[32m        var ecc = [];[m
[32m+[m[32m        for (var i = 0; i < numECWords; i++) {[m
[32m+[m[32m            ecc[i] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < codewords.length; i++) {[m
[32m+[m[32m            var m = ecc[numECWords - 1] ^ codewords.charAt(i).charCodeAt(0);[m
[32m+[m[32m            for (var k = numECWords - 1; k > 0; k--) {[m
[32m+[m[32m                if (m !== 0 && poly[k] !== 0) {[m
[32m+[m[32m                    ecc[k] = ecc[k - 1] ^ constants_1.ALOG[(constants_1.LOG[m] + constants_1.LOG[poly[k]]) % 255];[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    ecc[k] = ecc[k - 1];[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (m !== 0 && poly[0] !== 0) {[m
[32m+[m[32m                ecc[0] = constants_1.ALOG[(constants_1.LOG[m] + constants_1.LOG[poly[0]]) % 255];[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                ecc[0] = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var eccReversed = [];[m
[32m+[m[32m        for (var i = 0; i < numECWords; i++) {[m
[32m+[m[32m            eccReversed[i] = ecc[numECWords - i - 1];[m
[32m+[m[32m        }[m
[32m+[m[32m        return eccReversed.map(function (c) { return String.fromCharCode(c); }).join('');[m
[32m+[m[32m    };[m
[32m+[m[32m    return ErrorCorrection;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ErrorCorrection;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..58ddfe8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.d.ts[m
[36m@@ -0,0 +1,45 @@[m
[32m+[m[32mimport { SymbolShapeHint } from './constants';[m
[32m+[m[32mimport Dimension from '../../Dimension';[m
[32m+[m[32m/**[m
[32m+[m[32m * DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in[m
[32m+[m[32m * annex S.[m
[32m+[m[32m */[m
[32m+[m[32mdeclare class HighLevelEncoder {[m
[32m+[m[32m    private static randomize253State;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Performs message encoding of a DataMatrix message using the algorithm described in annex P[m
[32m+[m[32m     * of ISO/IEC 16022:2000(E).[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg     the message[m
[32m+[m[32m     * @param shape   requested shape. May be {@code SymbolShapeHint.FORCE_NONE},[m
[32m+[m[32m     *                {@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.[m
[32m+[m[32m     * @param minSize the minimum symbol size constraint or null for no constraint[m
[32m+[m[32m     * @param maxSize the maximum symbol size constraint or null for no constraint[m
[32m+[m[32m     * @param forceC40 enforce C40 encoding[m
[32m+[m[32m     * @return the encoded message (the char values range from 0 to 255)[m
[32m+[m[32m     */[m
[32m+[m[32m    static encodeHighLevel(msg: string, shape?: SymbolShapeHint, minSize?: Dimension, maxSize?: Dimension, forceC40?: boolean): string;[m
[32m+[m[32m    static lookAheadTest(msg: string, startpos: number, currentMode: number): number;[m
[32m+[m[32m    static lookAheadTestIntern(msg: string, startpos: number, currentMode: number): number;[m
[32m+[m[32m    private static min;[m
[32m+[m[32m    private static findMinimums;[m
[32m+[m[32m    private static getMinimumCount;[m
[32m+[m[32m    static isDigit(ch: number): boolean;[m
[32m+[m[32m    static isExtendedASCII(ch: number): boolean;[m
[32m+[m[32m    static isNativeC40(ch: number): boolean;[m
[32m+[m[32m    static isNativeText(ch: number): boolean;[m
[32m+[m[32m    static isNativeX12(ch: number): boolean;[m
[32m+[m[32m    private static isX12TermSep;[m
[32m+[m[32m    static isNativeEDIFACT(ch: number): boolean;[m
[32m+[m[32m    private static isSpecialB256;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines the number of consecutive characters that are encodable using numeric compaction.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg      the message[m
[32m+[m[32m     * @param startpos the start position within the message[m
[32m+[m[32m     * @return the requested character count[m
[32m+[m[32m     */[m
[32m+[m[32m    static determineConsecutiveDigitCount(msg: string, startpos?: number): number;[m
[32m+[m[32m    static illegalCharacter(singleCharacter: string): void;[m
[32m+[m[32m}[m
[32m+[m[32mexport default HighLevelEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..37613f7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/HighLevelEncoder.js[m
[36m@@ -0,0 +1,361 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar ASCIIEncoder_1 = require("./ASCIIEncoder");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar Base256Encoder_1 = require("./Base256Encoder");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar C40Encoder_1 = require("./C40Encoder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar EdifactEncoder_1 = require("./EdifactEncoder");[m
[32m+[m[32mvar EncoderContext_1 = require("./EncoderContext");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar X12Encoder_1 = require("./X12Encoder");[m
[32m+[m[32m// tslint:disable-next-line:no-circular-imports[m
[32m+[m[32mvar TextEncoder_1 = require("./TextEncoder");[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32m/**[m
[32m+[m[32m * DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in[m
[32m+[m[32m * annex S.[m
[32m+[m[32m */[m
[32m+[m[32mvar HighLevelEncoder = /** @class */ (function () {[m
[32m+[m[32m    function HighLevelEncoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    HighLevelEncoder.randomize253State = function (codewordPosition) {[m
[32m+[m[32m        var pseudoRandom = ((149 * codewordPosition) % 253) + 1;[m
[32m+[m[32m        var tempVariable = constants_1.PAD + pseudoRandom;[m
[32m+[m[32m        return tempVariable <= 254 ? tempVariable : tempVariable - 254;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Performs message encoding of a DataMatrix message using the algorithm described in annex P[m
[32m+[m[32m     * of ISO/IEC 16022:2000(E).[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg     the message[m
[32m+[m[32m     * @param shape   requested shape. May be {@code SymbolShapeHint.FORCE_NONE},[m
[32m+[m[32m     *                {@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.[m
[32m+[m[32m     * @param minSize the minimum symbol size constraint or null for no constraint[m
[32m+[m[32m     * @param maxSize the maximum symbol size constraint or null for no constraint[m
[32m+[m[32m     * @param forceC40 enforce C40 encoding[m
[32m+[m[32m     * @return the encoded message (the char values range from 0 to 255)[m
[32m+[m[32m     */[m
[32m+[m[32m    HighLevelEncoder.encodeHighLevel = function (msg, shape, minSize, maxSize, forceC40) {[m
[32m+[m[32m        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }[m
[32m+[m[32m        if (minSize === void 0) { minSize = null; }[m
[32m+[m[32m        if (maxSize === void 0) { maxSize = null; }[m
[32m+[m[32m        if (forceC40 === void 0) { forceC40 = false; }[m
[32m+[m[32m        // the codewords 0..255 are encoded as Unicode characters[m
[32m+[m[32m        var c40Encoder = new C40Encoder_1.C40Encoder();[m
[32m+[m[32m        var encoders = [[m
[32m+[m[32m            new ASCIIEncoder_1.ASCIIEncoder(),[m
[32m+[m[32m            c40Encoder,[m
[32m+[m[32m            new TextEncoder_1.TextEncoder(),[m
[32m+[m[32m            new X12Encoder_1.X12Encoder(),[m
[32m+[m[32m            new EdifactEncoder_1.EdifactEncoder(),[m
[32m+[m[32m            new Base256Encoder_1.Base256Encoder(),[m
[32m+[m[32m        ];[m
[32m+[m[32m        var context = new EncoderContext_1.EncoderContext(msg);[m
[32m+[m[32m        context.setSymbolShape(shape);[m
[32m+[m[32m        context.setSizeConstraints(minSize, maxSize);[m
[32m+[m[32m        if (msg.startsWith(constants_1.MACRO_05_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {[m
[32m+[m[32m            context.writeCodeword(constants_1.MACRO_05);[m
[32m+[m[32m            context.setSkipAtEnd(2);[m
[32m+[m[32m            context.pos += constants_1.MACRO_05_HEADER.length;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (msg.startsWith(constants_1.MACRO_06_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {[m
[32m+[m[32m            context.writeCodeword(constants_1.MACRO_06);[m
[32m+[m[32m            context.setSkipAtEnd(2);[m
[32m+[m[32m            context.pos += constants_1.MACRO_06_HEADER.length;[m
[32m+[m[32m        }[m
[32m+[m[32m        var encodingMode = constants_1.ASCII_ENCODATION; // Default mode[m
[32m+[m[32m        if (forceC40) {[m
[32m+[m[32m            c40Encoder.encodeMaximal(context);[m
[32m+[m[32m            encodingMode = context.getNewEncoding();[m
[32m+[m[32m            context.resetEncoderSignal();[m
[32m+[m[32m        }[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            encoders[encodingMode].encode(context);[m
[32m+[m[32m            if (context.getNewEncoding() >= 0) {[m
[32m+[m[32m                encodingMode = context.getNewEncoding();[m
[32m+[m[32m                context.resetEncoderSignal();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var len = context.getCodewordCount();[m
[32m+[m[32m        context.updateSymbolInfo();[m
[32m+[m[32m        var capacity = context.getSymbolInfo().getDataCapacity();[m
[32m+[m[32m        if (len < capacity &&[m
[32m+[m[32m            encodingMode !== constants_1.ASCII_ENCODATION &&[m
[32m+[m[32m            encodingMode !== constants_1.BASE256_ENCODATION &&[m
[32m+[m[32m            encodingMode !== constants_1.EDIFACT_ENCODATION) {[m
[32m+[m[32m            context.writeCodeword('\u00fe'); // Unlatch (254)[m
[32m+[m[32m        }[m
[32m+[m[32m        // Padding[m
[32m+[m[32m        var codewords = context.getCodewords();[m
[32m+[m[32m        if (codewords.length() < capacity) {[m
[32m+[m[32m            codewords.append(constants_1.PAD);[m
[32m+[m[32m        }[m
[32m+[m[32m        while (codewords.length() < capacity) {[m
[32m+[m[32m            codewords.append(this.randomize253State(codewords.length() + 1));[m
[32m+[m[32m        }[m
[32m+[m[32m        return context.getCodewords().toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.lookAheadTest = function (msg, startpos, currentMode) {[m
[32m+[m[32m        var newMode = this.lookAheadTestIntern(msg, startpos, currentMode);[m
[32m+[m[32m        if (currentMode === constants_1.X12_ENCODATION && newMode === constants_1.X12_ENCODATION) {[m
[32m+[m[32m            var endpos = Math.min(startpos + 3, msg.length);[m
[32m+[m[32m            for (var i = startpos; i < endpos; i++) {[m
[32m+[m[32m                if (!this.isNativeX12(msg.charCodeAt(i))) {[m
[32m+[m[32m                    return constants_1.ASCII_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (currentMode === constants_1.EDIFACT_ENCODATION &&[m
[32m+[m[32m            newMode === constants_1.EDIFACT_ENCODATION) {[m
[32m+[m[32m            var endpos = Math.min(startpos + 4, msg.length);[m
[32m+[m[32m            for (var i = startpos; i < endpos; i++) {[m
[32m+[m[32m                if (!this.isNativeEDIFACT(msg.charCodeAt(i))) {[m
[32m+[m[32m                    return constants_1.ASCII_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return newMode;[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.lookAheadTestIntern = function (msg, startpos, currentMode) {[m
[32m+[m[32m        if (startpos >= msg.length) {[m
[32m+[m[32m            return currentMode;[m
[32m+[m[32m        }[m
[32m+[m[32m        var charCounts;[m
[32m+[m[32m        // step J[m
[32m+[m[32m        if (currentMode === constants_1.ASCII_ENCODATION) {[m
[32m+[m[32m            charCounts = [0, 1, 1, 1, 1, 1.25];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            charCounts = [1, 2, 2, 2, 2, 2.25];[m
[32m+[m[32m            charCounts[currentMode] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var charsProcessed = 0;[m
[32m+[m[32m        var mins = new Uint8Array(6);[m
[32m+[m[32m        var intCharCounts = [];[m
[32m+[m[32m        while (true) {[m
[32m+[m[32m            // step K[m
[32m+[m[32m            if (startpos + charsProcessed === msg.length) {[m
[32m+[m[32m                Arrays_1.default.fill(mins, 0);[m
[32m+[m[32m                Arrays_1.default.fill(intCharCounts, 0);[m
[32m+[m[32m                var min = this.findMinimums(charCounts, intCharCounts, Integer_1.default.MAX_VALUE, mins);[m
[32m+[m[32m                var minCount = this.getMinimumCount(mins);[m
[32m+[m[32m                if (intCharCounts[constants_1.ASCII_ENCODATION] === min) {[m
[32m+[m[32m                    return constants_1.ASCII_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (minCount === 1) {[m
[32m+[m[32m                    if (mins[constants_1.BASE256_ENCODATION] > 0) {[m
[32m+[m[32m                        return constants_1.BASE256_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (mins[constants_1.EDIFACT_ENCODATION] > 0) {[m
[32m+[m[32m                        return constants_1.EDIFACT_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (mins[constants_1.TEXT_ENCODATION] > 0) {[m
[32m+[m[32m                        return constants_1.TEXT_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (mins[constants_1.X12_ENCODATION] > 0) {[m
[32m+[m[32m                        return constants_1.X12_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return constants_1.C40_ENCODATION;[m
[32m+[m[32m            }[m
[32m+[m[32m            var c = msg.charCodeAt(startpos + charsProcessed);[m
[32m+[m[32m            charsProcessed++;[m
[32m+[m[32m            // step L[m
[32m+[m[32m            if (this.isDigit(c)) {[m
[32m+[m[32m                charCounts[constants_1.ASCII_ENCODATION] += 0.5;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.isExtendedASCII(c)) {[m
[32m+[m[32m                charCounts[constants_1.ASCII_ENCODATION] = Math.ceil(charCounts[constants_1.ASCII_ENCODATION]);[m
[32m+[m[32m                charCounts[constants_1.ASCII_ENCODATION] += 2.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.ASCII_ENCODATION] = Math.ceil(charCounts[constants_1.ASCII_ENCODATION]);[m
[32m+[m[32m                charCounts[constants_1.ASCII_ENCODATION]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step M[m
[32m+[m[32m            if (this.isNativeC40(c)) {[m
[32m+[m[32m                charCounts[constants_1.C40_ENCODATION] += 2.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.isExtendedASCII(c)) {[m
[32m+[m[32m                charCounts[constants_1.C40_ENCODATION] += 8.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.C40_ENCODATION] += 4.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step N[m
[32m+[m[32m            if (this.isNativeText(c)) {[m
[32m+[m[32m                charCounts[constants_1.TEXT_ENCODATION] += 2.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.isExtendedASCII(c)) {[m
[32m+[m[32m                charCounts[constants_1.TEXT_ENCODATION] += 8.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.TEXT_ENCODATION] += 4.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step O[m
[32m+[m[32m            if (this.isNativeX12(c)) {[m
[32m+[m[32m                charCounts[constants_1.X12_ENCODATION] += 2.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.isExtendedASCII(c)) {[m
[32m+[m[32m                charCounts[constants_1.X12_ENCODATION] += 13.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.X12_ENCODATION] += 10.0 / 3.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step P[m
[32m+[m[32m            if (this.isNativeEDIFACT(c)) {[m
[32m+[m[32m                charCounts[constants_1.EDIFACT_ENCODATION] += 3.0 / 4.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.isExtendedASCII(c)) {[m
[32m+[m[32m                charCounts[constants_1.EDIFACT_ENCODATION] += 17.0 / 4.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.EDIFACT_ENCODATION] += 13.0 / 4.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step Q[m
[32m+[m[32m            if (this.isSpecialB256(c)) {[m
[32m+[m[32m                charCounts[constants_1.BASE256_ENCODATION] += 4.0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                charCounts[constants_1.BASE256_ENCODATION]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            // step R[m
[32m+[m[32m            if (charsProcessed >= 4) {[m
[32m+[m[32m                Arrays_1.default.fill(mins, 0);[m
[32m+[m[32m                Arrays_1.default.fill(intCharCounts, 0);[m
[32m+[m[32m                this.findMinimums(charCounts, intCharCounts, Integer_1.default.MAX_VALUE, mins);[m
[32m+[m[32m                if (intCharCounts[constants_1.ASCII_ENCODATION] <[m
[32m+[m[32m                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION])) {[m
[32m+[m[32m                    return constants_1.ASCII_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (intCharCounts[constants_1.BASE256_ENCODATION] < intCharCounts[constants_1.ASCII_ENCODATION] ||[m
[32m+[m[32m                    intCharCounts[constants_1.BASE256_ENCODATION] + 1 <[m
[32m+[m[32m                        this.min(intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION])) {[m
[32m+[m[32m                    return constants_1.BASE256_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (intCharCounts[constants_1.EDIFACT_ENCODATION] + 1 <[m
[32m+[m[32m                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {[m
[32m+[m[32m                    return constants_1.EDIFACT_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (intCharCounts[constants_1.TEXT_ENCODATION] + 1 <[m
[32m+[m[32m                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.X12_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {[m
[32m+[m[32m                    return constants_1.TEXT_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (intCharCounts[constants_1.X12_ENCODATION] + 1 <[m
[32m+[m[32m                    this.min(intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.C40_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION], intCharCounts[constants_1.ASCII_ENCODATION])) {[m
[32m+[m[32m                    return constants_1.X12_ENCODATION;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (intCharCounts[constants_1.C40_ENCODATION] + 1 <[m
[32m+[m[32m                    this.min(intCharCounts[constants_1.ASCII_ENCODATION], intCharCounts[constants_1.BASE256_ENCODATION], intCharCounts[constants_1.EDIFACT_ENCODATION], intCharCounts[constants_1.TEXT_ENCODATION])) {[m
[32m+[m[32m                    if (intCharCounts[constants_1.C40_ENCODATION] < intCharCounts[constants_1.X12_ENCODATION]) {[m
[32m+[m[32m                        return constants_1.C40_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (intCharCounts[constants_1.C40_ENCODATION] === intCharCounts[constants_1.X12_ENCODATION]) {[m
[32m+[m[32m                        var p = startpos + charsProcessed + 1;[m
[32m+[m[32m                        while (p < msg.length) {[m
[32m+[m[32m                            var tc = msg.charCodeAt(p);[m
[32m+[m[32m                            if (this.isX12TermSep(tc)) {[m
[32m+[m[32m                                return constants_1.X12_ENCODATION;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            if (!this.isNativeX12(tc)) {[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            p++;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        return constants_1.C40_ENCODATION;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.min = function (f1, f2, f3, f4, f5) {[m
[32m+[m[32m        var val = Math.min(f1, Math.min(f2, Math.min(f3, f4)));[m
[32m+[m[32m        if (f5 === undefined) {[m
[32m+[m[32m            return val;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return Math.min(val, f5);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.findMinimums = function (charCounts, intCharCounts, min, mins) {[m
[32m+[m[32m        for (var i = 0; i < 6; i++) {[m
[32m+[m[32m            var current = (intCharCounts[i] = Math.ceil(charCounts[i]));[m
[32m+[m[32m            if (min > current) {[m
[32m+[m[32m                min = current;[m
[32m+[m[32m                Arrays_1.default.fill(mins, 0);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (min === current) {[m
[32m+[m[32m                mins[i] = mins[i] + 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return min;[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.getMinimumCount = function (mins) {[m
[32m+[m[32m        var minCount = 0;[m
[32m+[m[32m        for (var i = 0; i < 6; i++) {[m
[32m+[m[32m            minCount += mins[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return minCount || 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isDigit = function (ch) {[m
[32m+[m[32m        return ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0);[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isExtendedASCII = function (ch) {[m
[32m+[m[32m        return ch >= 128 && ch <= 255;[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isNativeC40 = function (ch) {[m
[32m+[m[32m        return (ch === ' '.charCodeAt(0) ||[m
[32m+[m[32m            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||[m
[32m+[m[32m            (ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0)));[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isNativeText = function (ch) {[m
[32m+[m[32m        return (ch === ' '.charCodeAt(0) ||[m
[32m+[m[32m            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||[m
[32m+[m[32m            (ch >= 'a'.charCodeAt(0) && ch <= 'z'.charCodeAt(0)));[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isNativeX12 = function (ch) {[m
[32m+[m[32m        return (this.isX12TermSep(ch) ||[m
[32m+[m[32m            ch === ' '.charCodeAt(0) ||[m
[32m+[m[32m            (ch >= '0'.charCodeAt(0) && ch <= '9'.charCodeAt(0)) ||[m
[32m+[m[32m            (ch >= 'A'.charCodeAt(0) && ch <= 'Z'.charCodeAt(0)));[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isX12TermSep = function (ch) {[m
[32m+[m[32m        return (ch === 13 || // CR[m
[32m+[m[32m            ch === '*'.charCodeAt(0) ||[m
[32m+[m[32m            ch === '>'.charCodeAt(0));[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isNativeEDIFACT = function (ch) {[m
[32m+[m[32m        return ch >= ' '.charCodeAt(0) && ch <= '^'.charCodeAt(0);[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.isSpecialB256 = function (ch) {[m
[32m+[m[32m        return false; // TODO NOT IMPLEMENTED YET!!![m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines the number of consecutive characters that are encodable using numeric compaction.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg      the message[m
[32m+[m[32m     * @param startpos the start position within the message[m
[32m+[m[32m     * @return the requested character count[m
[32m+[m[32m     */[m
[32m+[m[32m    HighLevelEncoder.determineConsecutiveDigitCount = function (msg, startpos) {[m
[32m+[m[32m        if (startpos === void 0) { startpos = 0; }[m
[32m+[m[32m        var len = msg.length;[m
[32m+[m[32m        var idx = startpos;[m
[32m+[m[32m        while (idx < len && this.isDigit(msg.charCodeAt(idx))) {[m
[32m+[m[32m            idx++;[m
[32m+[m[32m        }[m
[32m+[m[32m        return idx - startpos;[m
[32m+[m[32m    };[m
[32m+[m[32m    HighLevelEncoder.illegalCharacter = function (singleCharacter) {[m
[32m+[m[32m        var hex = Integer_1.default.toHexString(singleCharacter.charCodeAt(0));[m
[32m+[m[32m        hex = '0000'.substring(0, 4 - hex.length) + hex;[m
[32m+[m[32m        throw new Error('Illegal character: ' + singleCharacter + ' (0x' + hex + ')');[m
[32m+[m[32m    };[m
[32m+[m[32m    return HighLevelEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = HighLevelEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..af97667[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.d.ts[m
[36m@@ -0,0 +1,121 @@[m
[32m+[m[32mimport Charset from '../../util/Charset';[m
[32m+[m[32mimport { char } from '../../../customTypings';[m
[32m+[m[32mimport { SymbolShapeHint } from './constants';[m
[32m+[m[32mimport { MinimalECIInput } from '../../common/MinimalECIInput';[m
[32m+[m[32mdeclare enum Mode {[m
[32m+[m[32m    ASCII = 0,[m
[32m+[m[32m    C40 = 1,[m
[32m+[m[32m    TEXT = 2,[m
[32m+[m[32m    X12 = 3,[m
[32m+[m[32m    EDF = 4,[m
[32m+[m[32m    B256 = 5[m
[32m+[m[32m}[m
[32m+[m[32mexport declare class MinimalEncoder {[m
[32m+[m[32m    static isExtendedASCII(ch: char, fnc1: number): boolean;[m
[32m+[m[32m    static isInC40Shift1Set(ch: char): boolean;[m
[32m+[m[32m    static isInC40Shift2Set(ch: char, fnc1: number): boolean;[m
[32m+[m[32m    static isInTextShift1Set(ch: char): boolean;[m
[32m+[m[32m    static isInTextShift2Set(ch: char, fnc1: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Performs message encoding of a DataMatrix message[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg the message[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1[m
[32m+[m[32m     *   bar code. If the value is not -1 then a FNC1 is also prepended.[m
[32m+[m[32m     * @param shape requested shape.[m
[32m+[m[32m     * @return the encoded message (the char values range from 0 to 255)[m
[32m+[m[32m     */[m
[32m+[m[32m    static encodeHighLevel(msg: string, priorityCharset?: Charset, fnc1?: number, shape?: SymbolShapeHint): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes input minimally and returns an array of the codewords[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param input The string to encode[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1[m
[32m+[m[32m     *   bar code. If the value is not -1 then a FNC1 is also prepended.[m
[32m+[m[32m     * @param shape requested shape.[m
[32m+[m[32m     * @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.[m
[32m+[m[32m     * @return An array of bytes representing the codewords of a minimal encoding.[m
[32m+[m[32m     */[m
[32m+[m[32m    static encode(input: string, priorityCharset: Charset, fnc1: number, shape: SymbolShapeHint, macroId: number): Uint8Array;[m
[32m+[m[32m    static addEdge(edges: Edge[][], edge: Edge): void;[m
[32m+[m[32m    /** @return the number of words in which the string starting at from can be encoded in c40 or text mode.[m
[32m+[m[32m     *  The number of characters encoded is returned in characterLength.[m
[32m+[m[32m     *  The number of characters encoded is also minimal in the sense that the algorithm stops as soon[m
[32m+[m[32m     *  as a character encoding fills a C40 word competely (three C40 values). An exception is at the[m
[32m+[m[32m     *  end of the string where two C40 values are allowed (according to the spec the third c40 value[m
[32m+[m[32m     *  is filled  with 0 (Shift 1) in this case).[m
[32m+[m[32m     */[m
[32m+[m[32m    static getNumberOfC40Words(input: Input, from: number, c40: boolean, characterLength: number[]): number;[m
[32m+[m[32m    static addEdges(input: Input, edges: Edge[][], from: number, previous: Edge): void;[m
[32m+[m[32m    static encodeMinimally(input: Input): Result;[m
[32m+[m[32m}[m
[32m+[m[32mdeclare class Result {[m
[32m+[m[32m    private bytes;[m
[32m+[m[32m    constructor(solution: Edge);[m
[32m+[m[32m    prepend(bytes: Uint8Array, into: number[]): number;[m
[32m+[m[32m    randomize253State(codewordPosition: number): number;[m
[32m+[m[32m    applyRandomPattern(bytesAL: number[], startPosition: number, length: number): void;[m
[32m+[m[32m    getBytes(): Uint8Array;[m
[32m+[m[32m}[m
[32m+[m[32mdeclare class Edge {[m
[32m+[m[32m    readonly input: Input;[m
[32m+[m[32m    readonly mode: Mode;[m
[32m+[m[32m    readonly fromPosition: number;[m
[32m+[m[32m    readonly characterLength: number;[m
[32m+[m[32m    readonly previous: Edge;[m
[32m+[m[32m    private allCodewordCapacities;[m
[32m+[m[32m    private squareCodewordCapacities;[m
[32m+[m[32m    private rectangularCodewordCapacities;[m
[32m+[m[32m    cachedTotalSize: number;[m
[32m+[m[32m    constructor(input: Input, mode: Mode, fromPosition: number, characterLength: number, previous: Edge);[m
[32m+[m[32m    getB256Size(): number;[m
[32m+[m[32m    getPreviousStartMode(): Mode;[m
[32m+[m[32m    getPreviousMode(): Mode;[m
[32m+[m[32m    /** Returns Mode.ASCII in case that:[m
[32m+[m[32m     *  - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2[m
[32m+[m[32m     *    ASCII bytes.[m
[32m+[m[32m     *  - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.[m
[32m+[m[32m     *  Returns mode in all other cases.[m
[32m+[m[32m     * */[m
[32m+[m[32m    getEndMode(): Mode;[m
[32m+[m[32m    getMode(): Mode;[m
[32m+[m[32m    /** Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly[m
[32m+[m[32m     *  two consecutive digits and a non extended character or of 4 digits.[m
[32m+[m[32m     *  Returns 0 in any other case[m
[32m+[m[32m     **/[m
[32m+[m[32m    getLastASCII(): number;[m
[32m+[m[32m    /** Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal[m
[32m+[m[32m     * number of codewords.[m
[32m+[m[32m     **/[m
[32m+[m[32m    getMinSymbolSize(minimum: number): number;[m
[32m+[m[32m    /** Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given[m
[32m+[m[32m     * minimal number of codewords.[m
[32m+[m[32m     **/[m
[32m+[m[32m    getCodewordsRemaining(minimum: number): number;[m
[32m+[m[32m    static getBytes(c1: number, c2?: number): Uint8Array;[m
[32m+[m[32m    setC40Word(bytes: Uint8Array, offset: number, c1: number, c2: number, c3: number): void;[m
[32m+[m[32m    getX12Value(c: number): number;[m
[32m+[m[32m    getX12Words(): Uint8Array;[m
[32m+[m[32m    getShiftValue(c: number, c40: boolean, fnc1: number): number;[m
[32m+[m[32m    getC40Value(c40: boolean, setIndex: number, c: number, fnc1: number): number;[m
[32m+[m[32m    getC40Words(c40: boolean, fnc1: number): Uint8Array;[m
[32m+[m[32m    getEDFBytes(): Uint8Array;[m
[32m+[m[32m    getLatchBytes(): Uint8Array;[m
[32m+[m[32m    getDataBytes(): Uint8Array;[m
[32m+[m[32m}[m
[32m+[m[32mdeclare class Input extends MinimalECIInput {[m
[32m+[m[32m    private readonly shape;[m
[32m+[m[32m    private readonly macroId;[m
[32m+[m[32m    constructor(stringToEncode: string, priorityCharset: Charset, fnc1: number, shape: SymbolShapeHint, macroId: number);[m
[32m+[m[32m    getMacroId(): number;[m
[32m+[m[32m    getShapeHint(): SymbolShapeHint;[m
[32m+[m[32m}[m
[32m+[m[32mexport {};[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f4982f5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/MinimalEncoder.js[m
[36m@@ -0,0 +1,1126 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mvar __read = (this && this.__read) || function (o, n) {[m
[32m+[m[32m    var m = typeof Symbol === "function" && o[Symbol.iterator];[m
[32m+[m[32m    if (!m) return o;[m
[32m+[m[32m    var i = m.call(o), r, ar = [], e;[m
[32m+[m[32m    try {[m
[32m+[m[32m        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);[m
[32m+[m[32m    }[m
[32m+[m[32m    catch (error) { e = { error: error }; }[m
[32m+[m[32m    finally {[m
[32m+[m[32m        try {[m
[32m+[m[32m            if (r && !r.done && (m = i["return"])) m.call(i);[m
[32m+[m[32m        }[m
[32m+[m[32m        finally { if (e) throw e.error; }[m
[32m+[m[32m    }[m
[32m+[m[32m    return ar;[m
[32m+[m[32m};[m
[32m+[m[32mvar __spread = (this && this.__spread) || function () {[m
[32m+[m[32m    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));[m
[32m+[m[32m    return ar;[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.MinimalEncoder = void 0;[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar MinimalECIInput_1 = require("../../common/MinimalECIInput");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar Mode;[m
[32m+[m[32m(function (Mode) {[m
[32m+[m[32m    Mode[Mode["ASCII"] = 0] = "ASCII";[m
[32m+[m[32m    Mode[Mode["C40"] = 1] = "C40";[m
[32m+[m[32m    Mode[Mode["TEXT"] = 2] = "TEXT";[m
[32m+[m[32m    Mode[Mode["X12"] = 3] = "X12";[m
[32m+[m[32m    Mode[Mode["EDF"] = 4] = "EDF";[m
[32m+[m[32m    Mode[Mode["B256"] = 5] = "B256";[m
[32m+[m[32m})(Mode || (Mode = {}));[m
[32m+[m[32mvar C40_SHIFT2_CHARS = [[m
[32m+[m[32m    '!',[m
[32m+[m[32m    '"',[m
[32m+[m[32m    '#',[m
[32m+[m[32m    '$',[m
[32m+[m[32m    '%',[m
[32m+[m[32m    '&',[m
[32m+[m[32m    "'",[m
[32m+[m[32m    '(',[m
[32m+[m[32m    ')',[m
[32m+[m[32m    '*',[m
[32m+[m[32m    '+',[m
[32m+[m[32m    ',',[m
[32m+[m[32m    '-',[m
[32m+[m[32m    '.',[m
[32m+[m[32m    '/',[m
[32m+[m[32m    ':',[m
[32m+[m[32m    ';',[m
[32m+[m[32m    '<',[m
[32m+[m[32m    '=',[m
[32m+[m[32m    '>',[m
[32m+[m[32m    '?',[m
[32m+[m[32m    '@',[m
[32m+[m[32m    '[',[m
[32m+[m[32m    '\\',[m
[32m+[m[32m    ']',[m
[32m+[m[32m    '^',[m
[32m+[m[32m    '_',[m
[32m+[m[32m];[m
[32m+[m[32mvar MinimalEncoder = /** @class */ (function () {[m
[32m+[m[32m    function MinimalEncoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    MinimalEncoder.isExtendedASCII = function (ch, fnc1) {[m
[32m+[m[32m        return ch !== fnc1 && ch >= 128 && ch <= 255;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.isInC40Shift1Set = function (ch) {[m
[32m+[m[32m        return ch <= 31;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.isInC40Shift2Set = function (ch, fnc1) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var C40_SHIFT2_CHARS_1 = __values(C40_SHIFT2_CHARS), C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next(); !C40_SHIFT2_CHARS_1_1.done; C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next()) {[m
[32m+[m[32m                var c40Shift2Char = C40_SHIFT2_CHARS_1_1.value;[m
[32m+[m[32m                if (c40Shift2Char.charCodeAt(0) === ch) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (C40_SHIFT2_CHARS_1_1 && !C40_SHIFT2_CHARS_1_1.done && (_a = C40_SHIFT2_CHARS_1.return)) _a.call(C40_SHIFT2_CHARS_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return ch === fnc1;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.isInTextShift1Set = function (ch) {[m
[32m+[m[32m        return this.isInC40Shift1Set(ch);[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.isInTextShift2Set = function (ch, fnc1) {[m
[32m+[m[32m        return this.isInC40Shift2Set(ch, fnc1);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Performs message encoding of a DataMatrix message[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param msg the message[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1[m
[32m+[m[32m     *   bar code. If the value is not -1 then a FNC1 is also prepended.[m
[32m+[m[32m     * @param shape requested shape.[m
[32m+[m[32m     * @return the encoded message (the char values range from 0 to 255)[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalEncoder.encodeHighLevel = function (msg, priorityCharset, fnc1, shape) {[m
[32m+[m[32m        if (priorityCharset === void 0) { priorityCharset = null; }[m
[32m+[m[32m        if (fnc1 === void 0) { fnc1 = -1; }[m
[32m+[m[32m        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }[m
[32m+[m[32m        var macroId = 0;[m
[32m+[m[32m        if (msg.startsWith(constants_1.MACRO_05_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {[m
[32m+[m[32m            macroId = 5;[m
[32m+[m[32m            msg = msg.substring(constants_1.MACRO_05_HEADER.length, msg.length - 2);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (msg.startsWith(constants_1.MACRO_06_HEADER) && msg.endsWith(constants_1.MACRO_TRAILER)) {[m
[32m+[m[32m            macroId = 6;[m
[32m+[m[32m            msg = msg.substring(constants_1.MACRO_06_HEADER.length, msg.length - 2);[m
[32m+[m[32m        }[m
[32m+[m[32m        return decodeURIComponent(escape(String.fromCharCode.apply(String, __spread(this.encode(msg, priorityCharset, fnc1, shape, macroId)))));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Encodes input minimally and returns an array of the codewords[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param input The string to encode[m
[32m+[m[32m     * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm[m
[32m+[m[32m     *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority[m
[32m+[m[32m     *   charset to encode any character in the input that can be encoded by it if the charset is among the[m
[32m+[m[32m     *   supported charsets.[m
[32m+[m[32m     * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1[m
[32m+[m[32m     *   bar code. If the value is not -1 then a FNC1 is also prepended.[m
[32m+[m[32m     * @param shape requested shape.[m
[32m+[m[32m     * @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.[m
[32m+[m[32m     * @return An array of bytes representing the codewords of a minimal encoding.[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalEncoder.encode = function (input, priorityCharset, fnc1, shape, macroId) {[m
[32m+[m[32m        return this.encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.addEdge = function (edges, edge) {[m
[32m+[m[32m        var vertexIndex = edge.fromPosition + edge.characterLength;[m
[32m+[m[32m        if (edges[vertexIndex][edge.getEndMode()] === null ||[m
[32m+[m[32m            edges[vertexIndex][edge.getEndMode()].cachedTotalSize >[m
[32m+[m[32m                edge.cachedTotalSize) {[m
[32m+[m[32m            edges[vertexIndex][edge.getEndMode()] = edge;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /** @return the number of words in which the string starting at from can be encoded in c40 or text mode.[m
[32m+[m[32m     *  The number of characters encoded is returned in characterLength.[m
[32m+[m[32m     *  The number of characters encoded is also minimal in the sense that the algorithm stops as soon[m
[32m+[m[32m     *  as a character encoding fills a C40 word competely (three C40 values). An exception is at the[m
[32m+[m[32m     *  end of the string where two C40 values are allowed (according to the spec the third c40 value[m
[32m+[m[32m     *  is filled  with 0 (Shift 1) in this case).[m
[32m+[m[32m     */[m
[32m+[m[32m    MinimalEncoder.getNumberOfC40Words = function (input, from, c40, characterLength) {[m
[32m+[m[32m        var thirdsCount = 0;[m
[32m+[m[32m        for (var i = from; i < input.length(); i++) {[m
[32m+[m[32m            if (input.isECI(i)) {[m
[32m+[m[32m                characterLength[0] = 0;[m
[32m+[m[32m                return 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            var ci = input.charAt(i);[m
[32m+[m[32m            if ((c40 && HighLevelEncoder_1.default.isNativeC40(ci)) ||[m
[32m+[m[32m                (!c40 && HighLevelEncoder_1.default.isNativeText(ci))) {[m
[32m+[m[32m                thirdsCount++; // native[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (!MinimalEncoder.isExtendedASCII(ci, input.getFNC1Character())) {[m
[32m+[m[32m                thirdsCount += 2; // shift[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                var asciiValue = ci & 0xff;[m
[32m+[m[32m                if (asciiValue >= 128 &&[m
[32m+[m[32m                    ((c40 && HighLevelEncoder_1.default.isNativeC40(asciiValue - 128)) ||[m
[32m+[m[32m                        (!c40 && HighLevelEncoder_1.default.isNativeText(asciiValue - 128)))) {[m
[32m+[m[32m                    thirdsCount += 3; // shift, Upper shift[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    thirdsCount += 4; // shift, Upper shift, shift[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (thirdsCount % 3 === 0 ||[m
[32m+[m[32m                ((thirdsCount - 2) % 3 === 0 && i + 1 === input.length())) {[m
[32m+[m[32m                characterLength[0] = i - from + 1;[m
[32m+[m[32m                return Math.ceil(thirdsCount / 3.0);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        characterLength[0] = 0;[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.addEdges = function (input, edges, from, previous) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        if (input.isECI(from)) {[m
[32m+[m[32m            this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var ch = input.charAt(from);[m
[32m+[m[32m        if (previous === null || previous.getEndMode() !== Mode.EDF) {[m
[32m+[m[32m            // not possible to unlatch a full EDF edge to something[m
[32m+[m[32m            // else[m
[32m+[m[32m            if (HighLevelEncoder_1.default.isDigit(ch) &&[m
[32m+[m[32m                input.haveNCharacters(from, 2) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isDigit(input.charAt(from + 1))) {[m
[32m+[m[32m                // two digits ASCII encoded[m
[32m+[m[32m                this.addEdge(edges, new Edge(input, Mode.ASCII, from, 2, previous));[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // one ASCII encoded character or an extended character via Upper Shift[m
[32m+[m[32m                this.addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));[m
[32m+[m[32m            }[m
[32m+[m[32m            var modes = [Mode.C40, Mode.TEXT];[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var modes_1 = __values(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {[m
[32m+[m[32m                    var mode = modes_1_1.value;[m
[32m+[m[32m                    var characterLength = [];[m
[32m+[m[32m                    if (MinimalEncoder.getNumberOfC40Words(input, from, mode === Mode.C40, characterLength) > 0) {[m
[32m+[m[32m                        this.addEdge(edges, new Edge(input, mode, from, characterLength[0], previous));[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (modes_1_1 && !modes_1_1.done && (_a = modes_1.return)) _a.call(modes_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (input.haveNCharacters(from, 3) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isNativeX12(input.charAt(from)) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isNativeX12(input.charAt(from + 1)) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isNativeX12(input.charAt(from + 2))) {[m
[32m+[m[32m                this.addEdge(edges, new Edge(input, Mode.X12, from, 3, previous));[m
[32m+[m[32m            }[m
[32m+[m[32m            this.addEdge(edges, new Edge(input, Mode.B256, from, 1, previous));[m
[32m+[m[32m        }[m
[32m+[m[32m        // We create 4 EDF edges,  with 1, 2 3 or 4 characters length. The fourth normally doesn't have a latch to ASCII[m
[32m+[m[32m        // unless it is 2 characters away from the end of the input.[m
[32m+[m[32m        var i;[m
[32m+[m[32m        for (i = 0; i < 3; i++) {[m
[32m+[m[32m            var pos = from + i;[m
[32m+[m[32m            if (input.haveNCharacters(pos, 1) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isNativeEDIFACT(input.charAt(pos))) {[m
[32m+[m[32m                this.addEdge(edges, new Edge(input, Mode.EDF, from, i + 1, previous));[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (i === 3 &&[m
[32m+[m[32m            input.haveNCharacters(from, 4) &&[m
[32m+[m[32m            HighLevelEncoder_1.default.isNativeEDIFACT(input.charAt(from + 3))) {[m
[32m+[m[32m            this.addEdge(edges, new Edge(input, Mode.EDF, from, 4, previous));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MinimalEncoder.encodeMinimally = function (input) {[m
[32m+[m[32m        /* The minimal encoding is computed by Dijkstra. The acyclic graph is modeled as follows:[m
[32m+[m[32m         * A vertex represents a combination of a position in the input and an encoding mode where position 0[m
[32m+[m[32m         * denotes the position left of the first character, 1 the position left of the second character and so on.[m
[32m+[m[32m         * Likewise the end vertices are located after the last character at position input.length().[m
[32m+[m[32m         * For any position there might be up to six vertices, one for each of the encoding types ASCII, C40, TEXT, X12,[m
[32m+[m[32m         * EDF and B256.[m
[32m+[m[32m         *[m
[32m+[m[32m         * As an example consider the input string "ABC123" then at position 0 there is only one vertex with the default[m
[32m+[m[32m         * ASCII encodation. At position 3 there might be vertices for the types ASCII, C40, X12, EDF and B256.[m
[32m+[m[32m         *[m
[32m+[m[32m         * An edge leading to such a vertex encodes one or more of the characters left of the position that the vertex[m
[32m+[m[32m         * represents. It encodes the characters in the encoding mode of the vertex that it ends on. In other words,[m
[32m+[m[32m         * all edges leading to a particular vertex encode the same characters (the length of the suffix can vary) using the same[m
[32m+[m[32m         * encoding mode.[m
[32m+[m[32m         * As an example consider the input string "ABC123" and the vertex (4,EDF). Possible edges leading to this vertex[m
[32m+[m[32m         * are:[m
[32m+[m[32m         *   (0,ASCII)  --EDF(ABC1)--> (4,EDF)[m
[32m+[m[32m         *   (1,ASCII)  --EDF(BC1)-->  (4,EDF)[m
[32m+[m[32m         *   (1,B256)   --EDF(BC1)-->  (4,EDF)[m
[32m+[m[32m         *   (1,EDF)    --EDF(BC1)-->  (4,EDF)[m
[32m+[m[32m         *   (2,ASCII)  --EDF(C1)-->   (4,EDF)[m
[32m+[m[32m         *   (2,B256)   --EDF(C1)-->   (4,EDF)[m
[32m+[m[32m         *   (2,EDF)    --EDF(C1)-->   (4,EDF)[m
[32m+[m[32m         *   (3,ASCII)  --EDF(1)-->    (4,EDF)[m
[32m+[m[32m         *   (3,B256)   --EDF(1)-->    (4,EDF)[m
[32m+[m[32m         *   (3,EDF)    --EDF(1)-->    (4,EDF)[m
[32m+[m[32m         *   (3,C40)    --EDF(1)-->    (4,EDF)[m
[32m+[m[32m         *   (3,X12)    --EDF(1)-->    (4,EDF)[m
[32m+[m[32m         *[m
[32m+[m[32m         * The edges leading to a vertex are stored in such a way that there is a fast way to enumerate the edges ending[m
[32m+[m[32m         * on a particular vertex.[m
[32m+[m[32m         *[m
[32m+[m[32m         * The algorithm processes the vertices in order of their position thereby performing the following:[m
[32m+[m[32m         *[m
[32m+[m[32m         * For every vertex at position i the algorithm enumerates the edges ending on the vertex and removes all but the[m
[32m+[m[32m         * shortest from that list.[m
[32m+[m[32m         * Then it processes the vertices for the position i+1. If i+1 == input.length() then the algorithm ends[m
[32m+[m[32m         * and chooses the the edge with the smallest size from any of the edges leading to vertices at this position.[m
[32m+[m[32m         * Otherwise the algorithm computes all possible outgoing edges for the vertices at the position i+1[m
[32m+[m[32m         *[m
[32m+[m[32m         * Examples:[m
[32m+[m[32m         * The process is illustrated by showing the graph (edges) after each iteration from left to right over the input:[m
[32m+[m[32m         * An edge is drawn as follows "(" + fromVertex + ") -- " + encodingMode + "(" + encodedInput + ") (" +[m
[32m+[m[32m         * accumulatedSize + ") --> (" + toVertex + ")"[m
[32m+[m[32m         *[m
[32m+[m[32m         * Example 1 encoding the string "ABCDEFG":[m
[32m+[m[32m         *[m
[32m+[m[32m         *[m
[32m+[m[32m         * Situation after adding edges to the start vertex (0,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF)[m
[32m+[m[32m         * (0,ASCII) C40(ABC) (3) --> (3,C40)[m
[32m+[m[32m         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)[m
[32m+[m[32m         * (0,ASCII) X12(ABC) (3) --> (3,X12)[m
[32m+[m[32m         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)[m
[32m+[m[32m         *[m
[32m+[m[32m         * Situation after adding edges to vertices at position 1[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF)[m
[32m+[m[32m         * (0,ASCII) C40(ABC) (3) --> (3,C40)[m
[32m+[m[32m         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)[m
[32m+[m[32m         * (0,ASCII) X12(ABC) (3) --> (3,X12)[m
[32m+[m[32m         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) B256(B) (4) --> (2,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) ASCII(B) (4) --> (2,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)[m
[32m+[m[32m         *[m
[32m+[m[32m         * Edge "(1,ASCII) ASCII(B) (2) --> (2,ASCII)" is minimal for the vertex (2,ASCII) so that edge "(1,B256) ASCII(B) (4) --> (2,ASCII)" is removed.[m
[32m+[m[32m         * Edge "(1,B256) B256(B) (3) --> (2,B256)" is minimal for the vertext (2,B256) so that the edge "(1,ASCII) B256(B) (4) --> (2,B256)" is removed.[m
[32m+[m[32m         *[m
[32m+[m[32m         * Situation after adding edges to vertices at position 2[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF)[m
[32m+[m[32m         * (0,ASCII) C40(ABC) (3) --> (3,C40)[m
[32m+[m[32m         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)[m
[32m+[m[32m         * (0,ASCII) X12(ABC) (3) --> (3,X12)[m
[32m+[m[32m         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BC) (5) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCD) (5) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BC) (6) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) C40(BCD) (5) --> (4,C40)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) TEXT(BCD) (7) --> (4,TEXT)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) X12(BCD) (5) --> (4,X12)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCD) (6) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) EDF(BCDE) (6) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) ASCII(C) (5) --> (3,ASCII)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) B256(C) (6) --> (3,B256)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CD) (7) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) C40(CDE) (6) --> (5,C40)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) TEXT(CDE) (8) --> (5,TEXT)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) X12(CDE) (6) --> (5,X12)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDE) (7) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF) EDF(CDEF) (7) --> (6,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) B256(C) (5) --> (3,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CD) (6) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDE) (6) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) ASCII(C) (4) --> (3,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CD) (6) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) C40(CDE) (5) --> (5,C40)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) TEXT(CDE) (7) --> (5,TEXT)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) X12(CDE) (5) --> (5,X12)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDE) (6) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) EDF(CDEF) (6) --> (6,EDF)[m
[32m+[m[32m         *[m
[32m+[m[32m         * Edge "(2,ASCII) ASCII(C) (3) --> (3,ASCII)" is minimal for the vertex (3,ASCII) so that edges "(2,EDF) ASCII(C) (5) --> (3,ASCII)"[m
[32m+[m[32m         * and "(2,B256) ASCII(C) (4) --> (3,ASCII)" can be removed.[m
[32m+[m[32m         * Edge "(0,ASCII) EDF(ABC) (4) --> (3,EDF)" is minimal for the vertex (3,EDF) so that edges "(1,ASCII) EDF(BC) (5) --> (3,EDF)"[m
[32m+[m[32m         * and "(1,B256) EDF(BC) (6) --> (3,EDF)" can be removed.[m
[32m+[m[32m         * Edge "(2,B256) B256(C) (4) --> (3,B256)" is minimal for the vertex (3,B256) so that edges "(2,ASCII) B256(C) (5) --> (3,B256)"[m
[32m+[m[32m         * and "(2,EDF) B256(C) (6) --> (3,B256)" can be removed.[m
[32m+[m[32m         *[m
[32m+[m[32m         * This continues for vertices 3 thru 7[m
[32m+[m[32m         *[m
[32m+[m[32m         * Situation after adding edges to vertices at position 7[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256)[m
[32m+[m[32m         * (0,ASCII) EDF(AB) (4) --> (2,EDF)[m
[32m+[m[32m         * (0,ASCII) C40(ABC) (3) --> (3,C40)[m
[32m+[m[32m         * (0,ASCII) TEXT(ABC) (5) --> (3,TEXT)[m
[32m+[m[32m         * (0,ASCII) X12(ABC) (3) --> (3,X12)[m
[32m+[m[32m         * (0,ASCII) EDF(ABC) (4) --> (3,EDF)[m
[32m+[m[32m         * (0,ASCII) EDF(ABCD) (4) --> (4,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) TEXT(BCD) (6) --> (4,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) EDF(BCDE) (5) --> (5,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256)[m
[32m+[m[32m         * (0,ASCII) C40(ABC) (3) --> (3,C40) C40(DEF) (5) --> (6,C40)[m
[32m+[m[32m         * (0,ASCII) X12(ABC) (3) --> (3,X12) X12(DEF) (5) --> (6,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) C40(CDE) (5) --> (5,C40)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) TEXT(CDE) (7) --> (5,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) X12(CDE) (5) --> (5,X12)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) EDF(CDEF) (6) --> (6,EDF)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) C40(BCD) (4) --> (4,C40) C40(EFG) (6) --> (7,C40)    //Solution 1[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) X12(BCD) (4) --> (4,X12) X12(EFG) (6) --> (7,X12)    //Solution 2[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) TEXT(DEF) (8) --> (6,TEXT)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) EDF(DEFG) (7) --> (7,EDF)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) TEXT(EFG) (9) --> (7,TEXT)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256)[m
[32m+[m[32m         * (0,ASCII) ASCII(A) (1) --> (1,ASCII) ASCII(B) (2) --> (2,ASCII) ASCII(C) (3) --> (3,ASCII) ASCII(D) (4) --> (4,ASCII) ASCII(E) (5) --> (5,ASCII) ASCII(F) (6) --> (6,ASCII) ASCII(G) (7) --> (7,ASCII)[m
[32m+[m[32m         * (0,ASCII) B256(A) (3) --> (1,B256) B256(B) (3) --> (2,B256) B256(C) (4) --> (3,B256) B256(D) (5) --> (4,B256) B256(E) (6) --> (5,B256) B256(F) (7) --> (6,B256) B256(G) (8) --> (7,B256)[m
[32m+[m[32m         *[m
[32m+[m[32m         * Hence a minimal encoding of "ABCDEFG" is either ASCII(A),C40(BCDEFG) or ASCII(A), X12(BCDEFG) with a size of 5 bytes.[m
[32m+[m[32m         */[m
[32m+[m[32m        var inputLength = input.length();[m
[32m+[m[32m        // Array that represents vertices. There is a vertex for every character and mode.[m
[32m+[m[32m        // The last dimension in the array below encodes the 6 modes ASCII, C40, TEXT, X12, EDF and B256[m
[32m+[m[32m        var edges = Array(inputLength + 1)[m
[32m+[m[32m            .fill(null)[m
[32m+[m[32m            .map(function () { return Array(6).fill(0); });[m
[32m+[m[32m        this.addEdges(input, edges, 0, null);[m
[32m+[m[32m        for (var i = 1; i <= inputLength; i++) {[m
[32m+[m[32m            for (var j = 0; j < 6; j++) {[m
[32m+[m[32m                if (edges[i][j] !== null && i < inputLength) {[m
[32m+[m[32m                    this.addEdges(input, edges, i, edges[i][j]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            // optimize memory by removing edges that have been passed.[m
[32m+[m[32m            for (var j = 0; j < 6; j++) {[m
[32m+[m[32m                edges[i - 1][j] = null;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var minimalJ = -1;[m
[32m+[m[32m        var minimalSize = Integer_1.default.MAX_VALUE;[m
[32m+[m[32m        for (var j = 0; j < 6; j++) {[m
[32m+[m[32m            if (edges[inputLength][j] !== null) {[m
[32m+[m[32m                var edge = edges[inputLength][j];[m
[32m+[m[32m                var size = j >= 1 && j <= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize; // C40, TEXT and X12 need an[m
[32m+[m[32m                // extra unlatch at the end[m
[32m+[m[32m                if (size < minimalSize) {[m
[32m+[m[32m                    minimalSize = size;[m
[32m+[m[32m                    minimalJ = j;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (minimalJ < 0) {[m
[32m+[m[32m            throw new Error('Failed to encode "' + input + '"');[m
[32m+[m[32m        }[m
[32m+[m[32m        return new Result(edges[inputLength][minimalJ]);[m
[32m+[m[32m    };[m
[32m+[m[32m    return MinimalEncoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.MinimalEncoder = MinimalEncoder;[m
[32m+[m[32mvar Result = /** @class */ (function () {[m
[32m+[m[32m    function Result(solution) {[m
[32m+[m[32m        var input = solution.input;[m
[32m+[m[32m        var size = 0;[m
[32m+[m[32m        var bytesAL = [];[m
[32m+[m[32m        var randomizePostfixLength = [];[m
[32m+[m[32m        var randomizeLengths = [];[m
[32m+[m[32m        if ((solution.mode === Mode.C40 ||[m
[32m+[m[32m            solution.mode === Mode.TEXT ||[m
[32m+[m[32m            solution.mode === Mode.X12) &&[m
[32m+[m[32m            solution.getEndMode() !== Mode.ASCII) {[m
[32m+[m[32m            size += this.prepend(Edge.getBytes(254), bytesAL);[m
[32m+[m[32m        }[m
[32m+[m[32m        var current = solution;[m
[32m+[m[32m        while (current !== null) {[m
[32m+[m[32m            size += this.prepend(current.getDataBytes(), bytesAL);[m
[32m+[m[32m            if (current.previous === null ||[m
[32m+[m[32m                current.getPreviousStartMode() !== current.getMode()) {[m
[32m+[m[32m                if (current.getMode() === Mode.B256) {[m
[32m+[m[32m                    if (size <= 249) {[m
[32m+[m[32m                        bytesAL.unshift(size);[m
[32m+[m[32m                        size++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        bytesAL.unshift(size % 250);[m
[32m+[m[32m                        bytesAL.unshift(size / 250 + 249);[m
[32m+[m[32m                        size += 2;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    randomizePostfixLength.push(bytesAL.length);[m
[32m+[m[32m                    randomizeLengths.push(size);[m
[32m+[m[32m                }[m
[32m+[m[32m                this.prepend(current.getLatchBytes(), bytesAL);[m
[32m+[m[32m                size = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            current = current.previous;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (input.getMacroId() === 5) {[m
[32m+[m[32m            size += this.prepend(Edge.getBytes(236), bytesAL);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (input.getMacroId() === 6) {[m
[32m+[m[32m            size += this.prepend(Edge.getBytes(237), bytesAL);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (input.getFNC1Character() > 0) {[m
[32m+[m[32m            size += this.prepend(Edge.getBytes(232), bytesAL);[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < randomizePostfixLength.length; i++) {[m
[32m+[m[32m            this.applyRandomPattern(bytesAL, bytesAL.length - randomizePostfixLength[i], randomizeLengths[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        // add padding[m
[32m+[m[32m        var capacity = solution.getMinSymbolSize(bytesAL.length);[m
[32m+[m[32m        if (bytesAL.length < capacity) {[m
[32m+[m[32m            bytesAL.push(129);[m
[32m+[m[32m        }[m
[32m+[m[32m        while (bytesAL.length < capacity) {[m
[32m+[m[32m            bytesAL.push(this.randomize253State(bytesAL.length + 1));[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bytes = new Uint8Array(bytesAL.length);[m
[32m+[m[32m        for (var i = 0; i < this.bytes.length; i++) {[m
[32m+[m[32m            this.bytes[i] = bytesAL[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    Result.prototype.prepend = function (bytes, into) {[m
[32m+[m[32m        for (var i = bytes.length - 1; i >= 0; i--) {[m
[32m+[m[32m            into.unshift(bytes[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return bytes.length;[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.randomize253State = function (codewordPosition) {[m
[32m+[m[32m        var pseudoRandom = ((149 * codewordPosition) % 253) + 1;[m
[32m+[m[32m        var tempVariable = 129 + pseudoRandom;[m
[32m+[m[32m        return tempVariable <= 254 ? tempVariable : tempVariable - 254;[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.applyRandomPattern = function (bytesAL, startPosition, length) {[m
[32m+[m[32m        for (var i = 0; i < length; i++) {[m
[32m+[m[32m            // See "B.1 253-state algorithm[m
[32m+[m[32m            var Pad_codeword_position = startPosition + i;[m
[32m+[m[32m            var Pad_codeword_value = bytesAL[Pad_codeword_position] & 0xff;[m
[32m+[m[32m            var pseudo_random_number = ((149 * (Pad_codeword_position + 1)) % 255) + 1;[m
[32m+[m[32m            var temp_variable = Pad_codeword_value + pseudo_random_number;[m
[32m+[m[32m            bytesAL[Pad_codeword_position] =[m
[32m+[m[32m                temp_variable <= 255 ? temp_variable : temp_variable - 256;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Result.prototype.getBytes = function () {[m
[32m+[m[32m        return this.bytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Result;[m
[32m+[m[32m}());[m
[32m+[m[32mvar Edge = /** @class */ (function () {[m
[32m+[m[32m    function Edge(input, mode, fromPosition, characterLength, previous) {[m
[32m+[m[32m        this.input = input;[m
[32m+[m[32m        this.mode = mode;[m
[32m+[m[32m        this.fromPosition = fromPosition;[m
[32m+[m[32m        this.characterLength = characterLength;[m
[32m+[m[32m        this.previous = previous;[m
[32m+[m[32m        this.allCodewordCapacities = [[m
[32m+[m[32m            3, 5, 8, 10, 12, 16, 18, 22, 30, 32, 36, 44, 49, 62, 86, 114, 144, 174, 204,[m
[32m+[m[32m            280, 368, 456, 576, 696, 816, 1050, 1304, 1558,[m
[32m+[m[32m        ];[m
[32m+[m[32m        this.squareCodewordCapacities = [[m
[32m+[m[32m            3, 5, 8, 12, 18, 22, 30, 36, 44, 62, 86, 114, 144, 174, 204, 280, 368, 456,[m
[32m+[m[32m            576, 696, 816, 1050, 1304, 1558,[m
[32m+[m[32m        ];[m
[32m+[m[32m        this.rectangularCodewordCapacities = [5, 10, 16, 33, 32, 49];[m
[32m+[m[32m        if (!(fromPosition + characterLength <= input.length())) {[m
[32m+[m[32m            throw new Error('Invalid edge');[m
[32m+[m[32m        }[m
[32m+[m[32m        var size = previous !== null ? previous.cachedTotalSize : 0;[m
[32m+[m[32m        var previousMode = this.getPreviousMode();[m
[32m+[m[32m        /*[m
[32m+[m[32m         * Switching modes[m
[32m+[m[32m         * ASCII -> C40: latch 230[m
[32m+[m[32m         * ASCII -> TEXT: latch 239[m
[32m+[m[32m         * ASCII -> X12: latch 238[m
[32m+[m[32m         * ASCII -> EDF: latch 240[m
[32m+[m[32m         * ASCII -> B256: latch 231[m
[32m+[m[32m         * C40 -> ASCII: word(c1,c2,c3), 254[m
[32m+[m[32m         * TEXT -> ASCII: word(c1,c2,c3), 254[m
[32m+[m[32m         * X12 -> ASCII: word(c1,c2,c3), 254[m
[32m+[m[32m         * EDIFACT -> ASCII: Unlatch character,0,0,0 or c1,Unlatch character,0,0 or c1,c2,Unlatch character,0 or[m
[32m+[m[32m         * c1,c2,c3,Unlatch character[m
[32m+[m[32m         * B256 -> ASCII: without latch after n bytes[m
[32m+[m[32m         */[m
[32m+[m[32m        switch (mode) {[m
[32m+[m[32m            case Mode.ASCII:[m
[32m+[m[32m                size++;[m
[32m+[m[32m                if (input.isECI(fromPosition) ||[m
[32m+[m[32m                    MinimalEncoder.isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {[m
[32m+[m[32m                    size++;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (previousMode === Mode.C40 ||[m
[32m+[m[32m                    previousMode === Mode.TEXT ||[m
[32m+[m[32m                    previousMode === Mode.X12) {[m
[32m+[m[32m                    size++; // unlatch 254 to ASCII[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode.B256:[m
[32m+[m[32m                size++;[m
[32m+[m[32m                if (previousMode !== Mode.B256) {[m
[32m+[m[32m                    size++; // byte count[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (this.getB256Size() === 250) {[m
[32m+[m[32m                    size++; // extra byte count[m
[32m+[m[32m                }[m
[32m+[m[32m                if (previousMode === Mode.ASCII) {[m
[32m+[m[32m                    size++; // latch to B256[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (previousMode === Mode.C40 ||[m
[32m+[m[32m                    previousMode === Mode.TEXT ||[m
[32m+[m[32m                    previousMode === Mode.X12) {[m
[32m+[m[32m                    size += 2; // unlatch to ASCII, latch to B256[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode.C40:[m
[32m+[m[32m            case Mode.TEXT:[m
[32m+[m[32m            case Mode.X12:[m
[32m+[m[32m                if (mode === Mode.X12) {[m
[32m+[m[32m                    size += 2;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    var charLen = [];[m
[32m+[m[32m                    size +=[m
[32m+[m[32m                        MinimalEncoder.getNumberOfC40Words(input, fromPosition, mode === Mode.C40, charLen) * 2;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (previousMode === Mode.ASCII || previousMode === Mode.B256) {[m
[32m+[m[32m                    size++; // additional byte for latch from ASCII to this mode[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (previousMode !== mode &&[m
[32m+[m[32m                    (previousMode === Mode.C40 ||[m
[32m+[m[32m                        previousMode === Mode.TEXT ||[m
[32m+[m[32m                        previousMode === Mode.X12)) {[m
[32m+[m[32m                    size += 2; // unlatch 254 to ASCII followed by latch to this mode[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode.EDF:[m
[32m+[m[32m                size += 3;[m
[32m+[m[32m                if (previousMode === Mode.ASCII || previousMode === Mode.B256) {[m
[32m+[m[32m                    size++; // additional byte for latch from ASCII to this mode[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (previousMode === Mode.C40 ||[m
[32m+[m[32m                    previousMode === Mode.TEXT ||[m
[32m+[m[32m                    previousMode === Mode.X12) {[m
[32m+[m[32m                    size += 2; // unlatch 254 to ASCII followed by latch to this mode[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.cachedTotalSize = size;[m
[32m+[m[32m    }[m
[32m+[m[32m    // does not count beyond 250[m
[32m+[m[32m    Edge.prototype.getB256Size = function () {[m
[32m+[m[32m        var cnt = 0;[m
[32m+[m[32m        var current = this;[m
[32m+[m[32m        while (current !== null && current.mode === Mode.B256 && cnt <= 250) {[m
[32m+[m[32m            cnt++;[m
[32m+[m[32m            current = current.previous;[m
[32m+[m[32m        }[m
[32m+[m[32m        return cnt;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getPreviousStartMode = function () {[m
[32m+[m[32m        return this.previous === null ? Mode.ASCII : this.previous.mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getPreviousMode = function () {[m
[32m+[m[32m        return this.previous === null ? Mode.ASCII : this.previous.getEndMode();[m
[32m+[m[32m    };[m
[32m+[m[32m    /** Returns Mode.ASCII in case that:[m
[32m+[m[32m     *  - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2[m
[32m+[m[32m     *    ASCII bytes.[m
[32m+[m[32m     *  - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.[m
[32m+[m[32m     *  Returns mode in all other cases.[m
[32m+[m[32m     * */[m
[32m+[m[32m    Edge.prototype.getEndMode = function () {[m
[32m+[m[32m        if (this.mode === Mode.EDF) {[m
[32m+[m[32m            if (this.characterLength < 4) {[m
[32m+[m[32m                return Mode.ASCII;[m
[32m+[m[32m            }[m
[32m+[m[32m            var lastASCII = this.getLastASCII(); // see 5.2.8.2 EDIFACT encodation Rules[m
[32m+[m[32m            if (lastASCII > 0 &&[m
[32m+[m[32m                this.getCodewordsRemaining(this.cachedTotalSize + lastASCII) <=[m
[32m+[m[32m                    2 - lastASCII) {[m
[32m+[m[32m                return Mode.ASCII;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.mode === Mode.C40 ||[m
[32m+[m[32m            this.mode === Mode.TEXT ||[m
[32m+[m[32m            this.mode === Mode.X12) {[m
[32m+[m[32m            // see 5.2.5.2 C40 encodation rules and 5.2.7.2 ANSI X12 encodation rules[m
[32m+[m[32m            if (this.fromPosition + this.characterLength >= this.input.length() &&[m
[32m+[m[32m                this.getCodewordsRemaining(this.cachedTotalSize) === 0) {[m
[32m+[m[32m                return Mode.ASCII;[m
[32m+[m[32m            }[m
[32m+[m[32m            var lastASCII = this.getLastASCII();[m
[32m+[m[32m            if (lastASCII === 1 &&[m
[32m+[m[32m                this.getCodewordsRemaining(this.cachedTotalSize + 1) === 0) {[m
[32m+[m[32m                return Mode.ASCII;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getMode = function () {[m
[32m+[m[32m        return this.mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    /** Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly[m
[32m+[m[32m     *  two consecutive digits and a non extended character or of 4 digits.[m
[32m+[m[32m     *  Returns 0 in any other case[m
[32m+[m[32m     **/[m
[32m+[m[32m    Edge.prototype.getLastASCII = function () {[m
[32m+[m[32m        var length = this.input.length();[m
[32m+[m[32m        var from = this.fromPosition + this.characterLength;[m
[32m+[m[32m        if (length - from > 4 || from >= length) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (length - from === 1) {[m
[32m+[m[32m            if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {[m
[32m+[m[32m                return 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (length - from === 2) {[m
[32m+[m[32m            if (MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character()) ||[m
[32m+[m[32m                MinimalEncoder.isExtendedASCII(this.input.charAt(from + 1), this.input.getFNC1Character())) {[m
[32m+[m[32m                return 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1))) {[m
[32m+[m[32m                return 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (length - from === 3) {[m
[32m+[m[32m            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&[m
[32m+[m[32m                !MinimalEncoder.isExtendedASCII(this.input.charAt(from + 2), this.input.getFNC1Character())) {[m
[32m+[m[32m                return 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&[m
[32m+[m[32m                HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 2)) &&[m
[32m+[m[32m                !MinimalEncoder.isExtendedASCII(this.input.charAt(from), this.input.getFNC1Character())) {[m
[32m+[m[32m                return 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (HighLevelEncoder_1.default.isDigit(this.input.charAt(from)) &&[m
[32m+[m[32m            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 1)) &&[m
[32m+[m[32m            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 2)) &&[m
[32m+[m[32m            HighLevelEncoder_1.default.isDigit(this.input.charAt(from + 3))) {[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /** Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal[m
[32m+[m[32m     * number of codewords.[m
[32m+[m[32m     **/[m
[32m+[m[32m    Edge.prototype.getMinSymbolSize = function (minimum) {[m
[32m+[m[32m        var e_3, _a, e_4, _b, e_5, _c;[m
[32m+[m[32m        switch (this.input.getShapeHint()) {[m
[32m+[m[32m            case 1 /* FORCE_SQUARE */:[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var _d = __values(this.squareCodewordCapacities), _e = _d.next(); !_e.done; _e = _d.next()) {[m
[32m+[m[32m                        var capacity = _e.value;[m
[32m+[m[32m                        if (capacity >= minimum) {[m
[32m+[m[32m                            return capacity;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 2 /* FORCE_RECTANGLE */:[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var _f = __values(this.rectangularCodewordCapacities), _g = _f.next(); !_g.done; _g = _f.next()) {[m
[32m+[m[32m                        var capacity = _g.value;[m
[32m+[m[32m                        if (capacity >= minimum) {[m
[32m+[m[32m                            return capacity;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _h = __values(this.allCodewordCapacities), _j = _h.next(); !_j.done; _j = _h.next()) {[m
[32m+[m[32m                var capacity = _j.value;[m
[32m+[m[32m                if (capacity >= minimum) {[m
[32m+[m[32m                    return capacity;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_5_1) { e_5 = { error: e_5_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_5) throw e_5.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.allCodewordCapacities[this.allCodewordCapacities.length - 1];[m
[32m+[m[32m    };[m
[32m+[m[32m    /** Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given[m
[32m+[m[32m     * minimal number of codewords.[m
[32m+[m[32m     **/[m
[32m+[m[32m    Edge.prototype.getCodewordsRemaining = function (minimum) {[m
[32m+[m[32m        return this.getMinSymbolSize(minimum) - minimum;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.getBytes = function (c1, c2) {[m
[32m+[m[32m        var result = new Uint8Array(c2 ? 2 : 1);[m
[32m+[m[32m        result[0] = c1;[m
[32m+[m[32m        if (c2) {[m
[32m+[m[32m            result[1] = c2;[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.setC40Word = function (bytes, offset, c1, c2, c3) {[m
[32m+[m[32m        var val16 = 1600 * (c1 & 0xff) + 40 * (c2 & 0xff) + (c3 & 0xff) + 1;[m
[32m+[m[32m        bytes[offset] = val16 / 256;[m
[32m+[m[32m        bytes[offset + 1] = val16 % 256;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getX12Value = function (c) {[m
[32m+[m[32m        return c === 13[m
[32m+[m[32m            ? 0[m
[32m+[m[32m            : c === 42[m
[32m+[m[32m                ? 1[m
[32m+[m[32m                : c === 62[m
[32m+[m[32m                    ? 2[m
[32m+[m[32m                    : c === 32[m
[32m+[m[32m                        ? 3[m
[32m+[m[32m                        : c >= 48 && c <= 57[m
[32m+[m[32m                            ? c - 44[m
[32m+[m[32m                            : c >= 65 && c <= 90[m
[32m+[m[32m                                ? c - 51[m
[32m+[m[32m                                : c;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getX12Words = function () {[m
[32m+[m[32m        if (!(this.characterLength % 3 === 0)) {[m
[32m+[m[32m            throw new Error('X12 words must be a multiple of 3');[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Uint8Array((this.characterLength / 3) * 2);[m
[32m+[m[32m        for (var i = 0; i < result.length; i += 2) {[m
[32m+[m[32m            this.setC40Word(result, i, this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3)), this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3 + 1)), this.getX12Value(this.input.charAt(this.fromPosition + (i / 2) * 3 + 2)));[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getShiftValue = function (c, c40, fnc1) {[m
[32m+[m[32m        return (c40 && MinimalEncoder.isInC40Shift1Set(c)) ||[m
[32m+[m[32m            (!c40 && MinimalEncoder.isInTextShift1Set(c))[m
[32m+[m[32m            ? 0[m
[32m+[m[32m            : (c40 && MinimalEncoder.isInC40Shift2Set(c, fnc1)) ||[m
[32m+[m[32m                (!c40 && MinimalEncoder.isInTextShift2Set(c, fnc1))[m
[32m+[m[32m                ? 1[m
[32m+[m[32m                : 2;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getC40Value = function (c40, setIndex, c, fnc1) {[m
[32m+[m[32m        if (c === fnc1) {[m
[32m+[m[32m            if (!(setIndex === 2)) {[m
[32m+[m[32m                throw new Error('FNC1 cannot be used in C40 shift 2');[m
[32m+[m[32m            }[m
[32m+[m[32m            return 27;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c40) {[m
[32m+[m[32m            return c <= 31[m
[32m+[m[32m                ? c[m
[32m+[m[32m                : c === 32[m
[32m+[m[32m                    ? 3[m
[32m+[m[32m                    : c <= 47[m
[32m+[m[32m                        ? c - 33[m
[32m+[m[32m                        : c <= 57[m
[32m+[m[32m                            ? c - 44[m
[32m+[m[32m                            : c <= 64[m
[32m+[m[32m                                ? c - 43[m
[32m+[m[32m                                : c <= 90[m
[32m+[m[32m                                    ? c - 51[m
[32m+[m[32m                                    : c <= 95[m
[32m+[m[32m                                        ? c - 69[m
[32m+[m[32m                                        : c <= 127[m
[32m+[m[32m                                            ? c - 96[m
[32m+[m[32m                                            : c;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            return c === 0[m
[32m+[m[32m                ? 0[m
[32m+[m[32m                : setIndex === 0 && c <= 3[m
[32m+[m[32m                    ? c - 1 // is this a bug in the spec?[m
[32m+[m[32m                    : setIndex === 1 && c <= 31[m
[32m+[m[32m                        ? c[m
[32m+[m[32m                        : c === 32[m
[32m+[m[32m                            ? 3[m
[32m+[m[32m                            : c >= 33 && c <= 47[m
[32m+[m[32m                                ? c - 33[m
[32m+[m[32m                                : c >= 48 && c <= 57[m
[32m+[m[32m                                    ? c - 44[m
[32m+[m[32m                                    : c >= 58 && c <= 64[m
[32m+[m[32m                                        ? c - 43[m
[32m+[m[32m                                        : c >= 65 && c <= 90[m
[32m+[m[32m                                            ? c - 64[m
[32m+[m[32m                                            : c >= 91 && c <= 95[m
[32m+[m[32m                                                ? c - 69[m
[32m+[m[32m                                                : c === 96[m
[32m+[m[32m                                                    ? 0[m
[32m+[m[32m                                                    : c >= 97 && c <= 122[m
[32m+[m[32m                                                        ? c - 83[m
[32m+[m[32m                                                        : c >= 123 && c <= 127[m
[32m+[m[32m                                                            ? c - 96[m
[32m+[m[32m                                                            : c;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getC40Words = function (c40, fnc1) {[m
[32m+[m[32m        var c40Values = [];[m
[32m+[m[32m        for (var i = 0; i < this.characterLength; i++) {[m
[32m+[m[32m            var ci = this.input.charAt(this.fromPosition + i);[m
[32m+[m[32m            if ((c40 && HighLevelEncoder_1.default.isNativeC40(ci)) ||[m
[32m+[m[32m                (!c40 && HighLevelEncoder_1.default.isNativeText(ci))) {[m
[32m+[m[32m                c40Values.push(this.getC40Value(c40, 0, ci, fnc1));[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (!MinimalEncoder.isExtendedASCII(ci, fnc1)) {[m
[32m+[m[32m                var shiftValue = this.getShiftValue(ci, c40, fnc1);[m
[32m+[m[32m                c40Values.push(shiftValue); // Shift[123][m
[32m+[m[32m                c40Values.push(this.getC40Value(c40, shiftValue, ci, fnc1));[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                var asciiValue = (ci & 0xff) - 128;[m
[32m+[m[32m                if ((c40 && HighLevelEncoder_1.default.isNativeC40(asciiValue)) ||[m
[32m+[m[32m                    (!c40 && HighLevelEncoder_1.default.isNativeText(asciiValue))) {[m
[32m+[m[32m                    c40Values.push(1); // Shift 2[m
[32m+[m[32m                    c40Values.push(30); // Upper Shift[m
[32m+[m[32m                    c40Values.push(this.getC40Value(c40, 0, asciiValue, fnc1));[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    c40Values.push(1); // Shift 2[m
[32m+[m[32m                    c40Values.push(30); // Upper Shift[m
[32m+[m[32m                    var shiftValue = this.getShiftValue(asciiValue, c40, fnc1);[m
[32m+[m[32m                    c40Values.push(shiftValue); // Shift[123][m
[32m+[m[32m                    c40Values.push(this.getC40Value(c40, shiftValue, asciiValue, fnc1));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c40Values.length % 3 !== 0) {[m
[32m+[m[32m            if (!((c40Values.length - 2) % 3 === 0 &&[m
[32m+[m[32m                this.fromPosition + this.characterLength === this.input.length())) {[m
[32m+[m[32m                throw new Error('C40 words must be a multiple of 3');[m
[32m+[m[32m            }[m
[32m+[m[32m            c40Values.push(0); // pad with 0 (Shift 1)[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Uint8Array((c40Values.length / 3) * 2);[m
[32m+[m[32m        var byteIndex = 0;[m
[32m+[m[32m        for (var i = 0; i < c40Values.length; i += 3) {[m
[32m+[m[32m            this.setC40Word(result, byteIndex, c40Values[i] & 0xff, c40Values[i + 1] & 0xff, c40Values[i + 2] & 0xff);[m
[32m+[m[32m            byteIndex += 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getEDFBytes = function () {[m
[32m+[m[32m        var numberOfThirds = Math.ceil(this.characterLength / 4.0);[m
[32m+[m[32m        var result = new Uint8Array(numberOfThirds * 3);[m
[32m+[m[32m        var pos = this.fromPosition;[m
[32m+[m[32m        var endPos = Math.min(this.fromPosition + this.characterLength - 1, this.input.length() - 1);[m
[32m+[m[32m        for (var i = 0; i < numberOfThirds; i += 3) {[m
[32m+[m[32m            var edfValues = [];[m
[32m+[m[32m            for (var j = 0; j < 4; j++) {[m
[32m+[m[32m                if (pos <= endPos) {[m
[32m+[m[32m                    edfValues[j] = this.input.charAt(pos++) & 0x3f;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    edfValues[j] = pos === endPos + 1 ? 0x1f : 0;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            var val24 = edfValues[0] << 18;[m
[32m+[m[32m            val24 |= edfValues[1] << 12;[m
[32m+[m[32m            val24 |= edfValues[2] << 6;[m
[32m+[m[32m            val24 |= edfValues[3];[m
[32m+[m[32m            result[i] = (val24 >> 16) & 0xff;[m
[32m+[m[32m            result[i + 1] = (val24 >> 8) & 0xff;[m
[32m+[m[32m            result[i + 2] = val24 & 0xff;[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Edge.prototype.getLatchBytes = function () {[m
[32m+[m[32m        switch (this.getPreviousMode()) {[m
[32m+[m[32m            case Mode.ASCII:[m
[32m+[m[32m            case Mode.B256: // after B256 ends (via length) we are back to ASCII[m
[32m+[m[32m                switch (this.mode) {[m
[32m+[m[32m                    case Mode.B256:[m
[32m+[m[32m                        return Edge.getBytes(231);[m
[32m+[m[32m                    case Mode.C40:[m
[32m+[m[32m                        return Edge.getBytes(230);[m
[32m+[m[32m                    case Mode.TEXT:[m
[32m+[m[32m                        return Edge.getBytes(239);[m
[32m+[m[32m                    case Mode.X12:[m
[32m+[m[32m                        return Edge.getBytes(238);[m
[32m+[m[32m                    case Mode.EDF:[m
[32m+[m[32m                        return Edge.getBytes(240);[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode.C40:[m
[32m+[m[32m            case Mode.TEXT:[m
[32m+[m[32m            case Mode.X12:[m
[32m+[m[32m                if (this.mode !== this.getPreviousMode()) {[m
[32m+[m[32m                    switch (this.mode) {[m
[32m+[m[32m                        case Mode.ASCII:[m
[32m+[m[32m                            return Edge.getBytes(254);[m
[32m+[m[32m                        case Mode.B256:[m
[32m+[m[32m                            return Edge.getBytes(254, 231);[m
[32m+[m[32m                        case Mode.C40:[m
[32m+[m[32m                            return Edge.getBytes(254, 230);[m
[32m+[m[32m                        case Mode.TEXT:[m
[32m+[m[32m                            return Edge.getBytes(254, 239);[m
[32m+[m[32m                        case Mode.X12:[m
[32m+[m[32m                            return Edge.getBytes(254, 238);[m
[32m+[m[32m                        case Mode.EDF:[m
[32m+[m[32m                            return Edge.getBytes(254, 240);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode.EDF:[m
[32m+[m[32m                // The rightmost EDIFACT edge always contains an unlatch character[m
[32m+[m[32m                if (this.mode !== Mode.EDF) {[m
[32m+[m[32m                    throw new Error('Cannot switch from EDF to ' + this.mode);[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new Uint8Array(0);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Important: The function does not return the length bytes (one or two) in case of B256 encoding[m
[32m+[m[32m    Edge.prototype.getDataBytes = function () {[m
[32m+[m[32m        switch (this.mode) {[m
[32m+[m[32m            case Mode.ASCII:[m
[32m+[m[32m                if (this.input.isECI(this.fromPosition)) {[m
[32m+[m[32m                    return Edge.getBytes(241, this.input.getECIValue(this.fromPosition) + 1);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (MinimalEncoder.isExtendedASCII(this.input.charAt(this.fromPosition), this.input.getFNC1Character())) {[m
[32m+[m[32m                    return Edge.getBytes(235, this.input.charAt(this.fromPosition) - 127);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (this.characterLength === 2) {[m
[32m+[m[32m                    return Edge.getBytes(this.input.charAt(this.fromPosition) * 10 +[m
[32m+[m[32m                        this.input.charAt(this.fromPosition + 1) +[m
[32m+[m[32m                        130);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (this.input.isFNC1(this.fromPosition)) {[m
[32m+[m[32m                    return Edge.getBytes(232);[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    return Edge.getBytes(this.input.charAt(this.fromPosition) + 1);[m
[32m+[m[32m                }[m
[32m+[m[32m            case Mode.B256:[m
[32m+[m[32m                return Edge.getBytes(this.input.charAt(this.fromPosition));[m
[32m+[m[32m            case Mode.C40:[m
[32m+[m[32m                return this.getC40Words(true, this.input.getFNC1Character());[m
[32m+[m[32m            case Mode.TEXT:[m
[32m+[m[32m                return this.getC40Words(false, this.input.getFNC1Character());[m
[32m+[m[32m            case Mode.X12:[m
[32m+[m[32m                return this.getX12Words();[m
[32m+[m[32m            case Mode.EDF:[m
[32m+[m[32m                return this.getEDFBytes();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return Edge;[m
[32m+[m[32m}());[m
[32m+[m[32mvar Input = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Input, _super);[m
[32m+[m[32m    function Input(stringToEncode, priorityCharset, fnc1, shape, macroId) {[m
[32m+[m[32m        var _this = _super.call(this, stringToEncode, priorityCharset, fnc1) || this;[m
[32m+[m[32m        _this.shape = shape;[m
[32m+[m[32m        _this.macroId = macroId;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Input.prototype.getMacroId = function () {[m
[32m+[m[32m        return this.macroId;[m
[32m+[m[32m    };[m
[32m+[m[32m    Input.prototype.getShapeHint = function () {[m
[32m+[m[32m        return this.shape;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Input;[m
[32m+[m[32m}(MinimalECIInput_1.MinimalECIInput));[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..16ca4e3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.d.ts[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32mimport Dimension from '../../Dimension';[m
[32m+[m[32mimport { SymbolShapeHint } from './constants';[m
[32m+[m[32m/**[m
[32m+[m[32m * Symbol info table for DataMatrix.[m
[32m+[m[32m */[m
[32m+[m[32mdeclare class SymbolInfo {[m
[32m+[m[32m    private readonly rectangular;[m
[32m+[m[32m    private readonly dataCapacity;[m
[32m+[m[32m    private readonly errorCodewords;[m
[32m+[m[32m    readonly matrixWidth: number;[m
[32m+[m[32m    readonly matrixHeight: number;[m
[32m+[m[32m    private readonly dataRegions;[m
[32m+[m[32m    private readonly rsBlockData;[m
[32m+[m[32m    private readonly rsBlockError;[m
[32m+[m[32m    constructor(rectangular: boolean, dataCapacity: number, errorCodewords: number, matrixWidth: number, matrixHeight: number, dataRegions: number, rsBlockData?: number, rsBlockError?: number);[m
[32m+[m[32m    static lookup(dataCodewords: number, shape?: SymbolShapeHint, minSize?: Dimension, maxSize?: Dimension, fail?: boolean): SymbolInfo;[m
[32m+[m[32m    private getHorizontalDataRegions;[m
[32m+[m[32m    private getVerticalDataRegions;[m
[32m+[m[32m    getSymbolDataWidth(): number;[m
[32m+[m[32m    getSymbolDataHeight(): number;[m
[32m+[m[32m    getSymbolWidth(): number;[m
[32m+[m[32m    getSymbolHeight(): number;[m
[32m+[m[32m    getCodewordCount(): number;[m
[32m+[m[32m    getInterleavedBlockCount(): number;[m
[32m+[m[32m    getDataCapacity(): number;[m
[32m+[m[32m    getErrorCodewords(): number;[m
[32m+[m[32m    getDataLengthForInterleavedBlock(index: number): number;[m
[32m+[m[32m    getErrorLengthForInterleavedBlock(index: number): number;[m
[32m+[m[32m}[m
[32m+[m[32mexport default SymbolInfo;[m
[32m+[m[32mexport declare const PROD_SYMBOLS: SymbolInfo[];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d2fd8f0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/SymbolInfo.js[m
[36m@@ -0,0 +1,196 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.PROD_SYMBOLS = void 0;[m
[32m+[m[32m/**[m
[32m+[m[32m * Symbol info table for DataMatrix.[m
[32m+[m[32m */[m
[32m+[m[32mvar SymbolInfo = /** @class */ (function () {[m
[32m+[m[32m    function SymbolInfo(rectangular, dataCapacity, errorCodewords, matrixWidth, matrixHeight, dataRegions, rsBlockData, rsBlockError) {[m
[32m+[m[32m        if (rsBlockData === void 0) { rsBlockData = 0; }[m
[32m+[m[32m        if (rsBlockError === void 0) { rsBlockError = 0; }[m
[32m+[m[32m        this.rectangular = rectangular;[m
[32m+[m[32m        this.dataCapacity = dataCapacity;[m
[32m+[m[32m        this.errorCodewords = errorCodewords;[m
[32m+[m[32m        this.matrixWidth = matrixWidth;[m
[32m+[m[32m        this.matrixHeight = matrixHeight;[m
[32m+[m[32m        this.dataRegions = dataRegions;[m
[32m+[m[32m        this.rsBlockData = rsBlockData;[m
[32m+[m[32m        this.rsBlockError = rsBlockError;[m
[32m+[m[32m    }[m
[32m+[m[32m    SymbolInfo.lookup = function (dataCodewords, shape, minSize, maxSize, fail) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (shape === void 0) { shape = 0 /* FORCE_NONE */; }[m
[32m+[m[32m        if (minSize === void 0) { minSize = null; }[m
[32m+[m[32m        if (maxSize === void 0) { maxSize = null; }[m
[32m+[m[32m        if (fail === void 0) { fail = true; }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var PROD_SYMBOLS_1 = __values(exports.PROD_SYMBOLS), PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next(); !PROD_SYMBOLS_1_1.done; PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next()) {[m
[32m+[m[32m                var symbol = PROD_SYMBOLS_1_1.value;[m
[32m+[m[32m                if (shape === 1 /* FORCE_SQUARE */ && symbol.rectangular) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (shape === 2 /* FORCE_RECTANGLE */ && !symbol.rectangular) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (minSize != null &&[m
[32m+[m[32m                    (symbol.getSymbolWidth() < minSize.getWidth() ||[m
[32m+[m[32m                        symbol.getSymbolHeight() < minSize.getHeight())) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (maxSize != null &&[m
[32m+[m[32m                    (symbol.getSymbolWidth() > maxSize.getWidth() ||[m
[32m+[m[32m                        symbol.getSymbolHeight() > maxSize.getHeight())) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (dataCodewords <= symbol.dataCapacity) {[m
[32m+[m[32m                    return symbol;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (PROD_SYMBOLS_1_1 && !PROD_SYMBOLS_1_1.done && (_a = PROD_SYMBOLS_1.return)) _a.call(PROD_SYMBOLS_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (fail) {[m
[32m+[m[32m            throw new Error("Can't find a symbol arrangement that matches the message. Data codewords: " +[m
[32m+[m[32m                dataCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getHorizontalDataRegions = function () {[m
[32m+[m[32m        switch (this.dataRegions) {[m
[32m+[m[32m            case 1:[m
[32m+[m[32m                return 1;[m
[32m+[m[32m            case 2:[m
[32m+[m[32m            case 4:[m
[32m+[m[32m                return 2;[m
[32m+[m[32m            case 16:[m
[32m+[m[32m                return 4;[m
[32m+[m[32m            case 36:[m
[32m+[m[32m                return 6;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new Error('Cannot handle this number of data regions');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getVerticalDataRegions = function () {[m
[32m+[m[32m        switch (this.dataRegions) {[m
[32m+[m[32m            case 1:[m
[32m+[m[32m            case 2:[m
[32m+[m[32m                return 1;[m
[32m+[m[32m            case 4:[m
[32m+[m[32m                return 2;[m
[32m+[m[32m            case 16:[m
[32m+[m[32m                return 4;[m
[32m+[m[32m            case 36:[m
[32m+[m[32m                return 6;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new Error('Cannot handle this number of data regions');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getSymbolDataWidth = function () {[m
[32m+[m[32m        return this.getHorizontalDataRegions() * this.matrixWidth;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getSymbolDataHeight = function () {[m
[32m+[m[32m        return this.getVerticalDataRegions() * this.matrixHeight;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getSymbolWidth = function () {[m
[32m+[m[32m        return this.getSymbolDataWidth() + this.getHorizontalDataRegions() * 2;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getSymbolHeight = function () {[m
[32m+[m[32m        return this.getSymbolDataHeight() + this.getVerticalDataRegions() * 2;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getCodewordCount = function () {[m
[32m+[m[32m        return this.dataCapacity + this.errorCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getInterleavedBlockCount = function () {[m
[32m+[m[32m        if (!this.rsBlockData)[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        return this.dataCapacity / this.rsBlockData;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getDataCapacity = function () {[m
[32m+[m[32m        return this.dataCapacity;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getErrorCodewords = function () {[m
[32m+[m[32m        return this.errorCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getDataLengthForInterleavedBlock = function (index) {[m
[32m+[m[32m        return this.rsBlockData;[m
[32m+[m[32m    };[m
[32m+[m[32m    SymbolInfo.prototype.getErrorLengthForInterleavedBlock = function (index) {[m
[32m+[m[32m        return this.rsBlockError;[m
[32m+[m[32m    };[m
[32m+[m[32m    return SymbolInfo;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = SymbolInfo;[m
[32m+[m[32mvar DataMatrixSymbolInfo144 = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DataMatrixSymbolInfo144, _super);[m
[32m+[m[32m    function DataMatrixSymbolInfo144() {[m
[32m+[m[32m        return _super.call(this, false, 1558, 620, 22, 22, 36, -1, 62) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    DataMatrixSymbolInfo144.prototype.getInterleavedBlockCount = function () {[m
[32m+[m[32m        return 10;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataMatrixSymbolInfo144.prototype.getDataLengthForInterleavedBlock = function (index) {[m
[32m+[m[32m        return index <= 8 ? 156 : 155;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DataMatrixSymbolInfo144;[m
[32m+[m[32m}(SymbolInfo));[m
[32m+[m[32mexports.PROD_SYMBOLS = [[m
[32m+[m[32m    new SymbolInfo(false, 3, 5, 8, 8, 1),[m
[32m+[m[32m    new SymbolInfo(false, 5, 7, 10, 10, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 5, 7, 16, 6, 1),[m
[32m+[m[32m    new SymbolInfo(false, 8, 10, 12, 12, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 10, 11, 14, 6, 2),[m
[32m+[m[32m    new SymbolInfo(false, 12, 12, 14, 14, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 16, 14, 24, 10, 1),[m
[32m+[m[32m    new SymbolInfo(false, 18, 14, 16, 16, 1),[m
[32m+[m[32m    new SymbolInfo(false, 22, 18, 18, 18, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 22, 18, 16, 10, 2),[m
[32m+[m[32m    new SymbolInfo(false, 30, 20, 20, 20, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 32, 24, 16, 14, 2),[m
[32m+[m[32m    new SymbolInfo(false, 36, 24, 22, 22, 1),[m
[32m+[m[32m    new SymbolInfo(false, 44, 28, 24, 24, 1),[m
[32m+[m[32m    /*rect*/ new SymbolInfo(true, 49, 28, 22, 14, 2),[m
[32m+[m[32m    new SymbolInfo(false, 62, 36, 14, 14, 4),[m
[32m+[m[32m    new SymbolInfo(false, 86, 42, 16, 16, 4),[m
[32m+[m[32m    new SymbolInfo(false, 114, 48, 18, 18, 4),[m
[32m+[m[32m    new SymbolInfo(false, 144, 56, 20, 20, 4),[m
[32m+[m[32m    new SymbolInfo(false, 174, 68, 22, 22, 4),[m
[32m+[m[32m    new SymbolInfo(false, 204, 84, 24, 24, 4, 102, 42),[m
[32m+[m[32m    new SymbolInfo(false, 280, 112, 14, 14, 16, 140, 56),[m
[32m+[m[32m    new SymbolInfo(false, 368, 144, 16, 16, 16, 92, 36),[m
[32m+[m[32m    new SymbolInfo(false, 456, 192, 18, 18, 16, 114, 48),[m
[32m+[m[32m    new SymbolInfo(false, 576, 224, 20, 20, 16, 144, 56),[m
[32m+[m[32m    new SymbolInfo(false, 696, 272, 22, 22, 16, 174, 68),[m
[32m+[m[32m    new SymbolInfo(false, 816, 336, 24, 24, 16, 136, 56),[m
[32m+[m[32m    new SymbolInfo(false, 1050, 408, 18, 18, 36, 175, 68),[m
[32m+[m[32m    new SymbolInfo(false, 1304, 496, 20, 20, 36, 163, 62),[m
[32m+[m[32m    new DataMatrixSymbolInfo144(),[m
[32m+[m[32m];[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..6fa3bcc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport StringBuilder from '../../util/StringBuilder';[m
[32m+[m[32mimport { char } from '../../../customTypings';[m
[32m+[m[32mimport { C40Encoder } from './C40Encoder';[m
[32m+[m[32mexport declare class TextEncoder extends C40Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encodeChar(c: char, sb: StringBuilder): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..cc8b0b5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/TextEncoder.js[m
[36m@@ -0,0 +1,82 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.TextEncoder = void 0;[m
[32m+[m[32mvar C40Encoder_1 = require("./C40Encoder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar TextEncoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(TextEncoder, _super);[m
[32m+[m[32m    function TextEncoder() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    TextEncoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.TEXT_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    TextEncoder.prototype.encodeChar = function (c, sb) {[m
[32m+[m[32m        if (c === ' '.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(3);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(c - 48 + 4);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(c - 97 + 14);[m
[32m+[m[32m            return 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c < ' '.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(0); // Shift 1 Set[m
[32m+[m[32m            sb.append(c);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= '/'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 33);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= '@'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 58 + 15);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c >= '['.charCodeAt(0) && c <= '_'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(1); // Shift 2 Set[m
[32m+[m[32m            sb.append(c - 91 + 22);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c === '`'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(2); // Shift 3 Set[m
[32m+[m[32m            sb.append(0); // '`' - 96 == 0[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= 'Z'.charCodeAt(0)) {[m
[32m+[m[32m            sb.append(2); // Shift 3 Set[m
[32m+[m[32m            sb.append(c - 65 + 1);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c <= 127) {[m
[32m+[m[32m            sb.append(2); // Shift 3 Set[m
[32m+[m[32m            sb.append(c - 123 + 27);[m
[32m+[m[32m            return 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        sb.append(1 + "\u001E"); // Shift 2, Upper Shift[m
[32m+[m[32m        var len = 2;[m
[32m+[m[32m        len += this.encodeChar(c - 128, sb);[m
[32m+[m[32m        return len;[m
[32m+[m[32m    };[m
[32m+[m[32m    return TextEncoder;[m
[32m+[m[32m}(C40Encoder_1.C40Encoder));[m
[32m+[m[32mexports.TextEncoder = TextEncoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..db2b7f4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport { char } from '../../../customTypings';[m
[32m+[m[32mimport StringBuilder from '../../util/StringBuilder';[m
[32m+[m[32mimport { C40Encoder } from './C40Encoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mexport declare class X12Encoder extends C40Encoder {[m
[32m+[m[32m    getEncodingMode(): number;[m
[32m+[m[32m    encode(context: EncoderContext): void;[m
[32m+[m[32m    encodeChar(c: char, sb: StringBuilder): number;[m
[32m+[m[32m    handleEOD(context: EncoderContext, buffer: StringBuilder): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ee6dc8a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/X12Encoder.js[m
[36m@@ -0,0 +1,94 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.X12Encoder = void 0;[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar C40Encoder_1 = require("./C40Encoder");[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mvar constants_1 = require("./constants");[m
[32m+[m[32mvar X12Encoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(X12Encoder, _super);[m
[32m+[m[32m    function X12Encoder() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    X12Encoder.prototype.getEncodingMode = function () {[m
[32m+[m[32m        return constants_1.X12_ENCODATION;[m
[32m+[m[32m    };[m
[32m+[m[32m    X12Encoder.prototype.encode = function (context) {[m
[32m+[m[32m        // step C[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        while (context.hasMoreCharacters()) {[m
[32m+[m[32m            var c = context.getCurrentChar();[m
[32m+[m[32m            context.pos++;[m
[32m+[m[32m            this.encodeChar(c, buffer);[m
[32m+[m[32m            var count = buffer.length();[m
[32m+[m[32m            if (count % 3 === 0) {[m
[32m+[m[32m                this.writeNextTriplet(context, buffer);[m
[32m+[m[32m                var newMode = HighLevelEncoder_1.default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());[m
[32m+[m[32m                if (newMode !== this.getEncodingMode()) {[m
[32m+[m[32m                    // Return to ASCII encodation, which will actually handle latch to new mode[m
[32m+[m[32m                    context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.handleEOD(context, buffer);[m
[32m+[m[32m    };[m
[32m+[m[32m    X12Encoder.prototype.encodeChar = function (c, sb) {[m
[32m+[m[32m        switch (c) {[m
[32m+[m[32m            case 13: // CR (Carriage return)[m
[32m+[m[32m                sb.append(0);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case '*'.charCodeAt(0):[m
[32m+[m[32m                sb.append(1);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case '>'.charCodeAt(0):[m
[32m+[m[32m                sb.append(2);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ' '.charCodeAt(0):[m
[32m+[m[32m                sb.append(3);[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                if (c >= '0'.charCodeAt(0) && c <= '9'.charCodeAt(0)) {[m
[32m+[m[32m                    sb.append(c - 48 + 4);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (c >= 'A'.charCodeAt(0) && c <= 'Z'.charCodeAt(0)) {[m
[32m+[m[32m                    sb.append(c - 65 + 14);[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    HighLevelEncoder_1.default.illegalCharacter(StringUtils_1.default.getCharAt(c));[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        return 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    X12Encoder.prototype.handleEOD = function (context, buffer) {[m
[32m+[m[32m        context.updateSymbolInfo();[m
[32m+[m[32m        var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();[m
[32m+[m[32m        var count = buffer.length();[m
[32m+[m[32m        context.pos -= count;[m
[32m+[m[32m        if (context.getRemainingCharacters() > 1 ||[m
[32m+[m[32m            available > 1 ||[m
[32m+[m[32m            context.getRemainingCharacters() !== available) {[m
[32m+[m[32m            context.writeCodeword(constants_1.X12_UNLATCH);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (context.getNewEncoding() < 0) {[m
[32m+[m[32m            context.signalEncoderChange(constants_1.ASCII_ENCODATION);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return X12Encoder;[m
[32m+[m[32m}(C40Encoder_1.C40Encoder));[m
[32m+[m[32mexports.X12Encoder = X12Encoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2b687c7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.d.ts[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * Lookup table which factors to use for which number of error correction codewords.[m
[32m+[m[32m * See FACTORS.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const FACTOR_SETS: number[];[m
[32m+[m[32m/**[m
[32m+[m[32m * Precomputed polynomial factors for ECC 200.[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const FACTORS: number[][];[m
[32m+[m[32mexport declare const /*final*/ MODULO_VALUE: number;[m
[32m+[m[32mexport declare const LOG: number[], ALOG: number[];[m
[32m+[m[32mexport declare const enum SymbolShapeHint {[m
[32m+[m[32m    FORCE_NONE = 0,[m
[32m+[m[32m    FORCE_SQUARE = 1,[m
[32m+[m[32m    FORCE_RECTANGLE = 2[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * Padding character[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const PAD = 129;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to C40 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const LATCH_TO_C40 = 230;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to Base 256 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const LATCH_TO_BASE256 = 231;[m
[32m+[m[32m/**[m
[32m+[m[32m * FNC1 Codeword[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * Structured Append Codeword[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * Reader Programming[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * Upper Shift[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const UPPER_SHIFT = 235;[m
[32m+[m[32m/**[m
[32m+[m[32m * 05 Macro[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const MACRO_05 = 236;[m
[32m+[m[32m/**[m
[32m+[m[32m * 06 Macro[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const MACRO_06 = 237;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to ANSI X.12 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const LATCH_TO_ANSIX12 = 238;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to Text encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const LATCH_TO_TEXT = 239;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to EDIFACT encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const LATCH_TO_EDIFACT = 240;[m
[32m+[m[32m/**[m
[32m+[m[32m * ECI character (Extended Channel Interpretation)[m
[32m+[m[32m */[m
[32m+[m[32m/**[m
[32m+[m[32m * Unlatch from C40 encodation[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const C40_UNLATCH = 254;[m
[32m+[m[32m/**[m
[32m+[m[32m * Unlatch from X12 encodation[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const X12_UNLATCH = 254;[m
[32m+[m[32m/**[m
[32m+[m[32m * 05 Macro header[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const MACRO_05_HEADER = "[)>\u001E05\u001D";[m
[32m+[m[32m/**[m
[32m+[m[32m * 06 Macro header[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const MACRO_06_HEADER = "[)>\u001E06\u001D";[m
[32m+[m[32m/**[m
[32m+[m[32m * Macro trailer[m
[32m+[m[32m */[m
[32m+[m[32mexport declare const MACRO_TRAILER = "\u001E\u0004";[m
[32m+[m[32mexport declare const ASCII_ENCODATION = 0;[m
[32m+[m[32mexport declare const C40_ENCODATION = 1;[m
[32m+[m[32mexport declare const TEXT_ENCODATION = 2;[m
[32m+[m[32mexport declare const X12_ENCODATION = 3;[m
[32m+[m[32mexport declare const EDIFACT_ENCODATION = 4;[m
[32m+[m[32mexport declare const BASE256_ENCODATION = 5;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0a912ab[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/constants.js[m
[36m@@ -0,0 +1,173 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar _a;[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.BASE256_ENCODATION = exports.EDIFACT_ENCODATION = exports.X12_ENCODATION = exports.TEXT_ENCODATION = exports.C40_ENCODATION = exports.ASCII_ENCODATION = exports.MACRO_TRAILER = exports.MACRO_06_HEADER = exports.MACRO_05_HEADER = exports.X12_UNLATCH = exports.C40_UNLATCH = exports.LATCH_TO_EDIFACT = exports.LATCH_TO_TEXT = exports.LATCH_TO_ANSIX12 = exports.MACRO_06 = exports.MACRO_05 = exports.UPPER_SHIFT = exports.LATCH_TO_BASE256 = exports.LATCH_TO_C40 = exports.PAD = exports.SymbolShapeHint = exports.ALOG = exports.LOG = exports.MODULO_VALUE = exports.FACTORS = exports.FACTOR_SETS = void 0;[m
[32m+[m[32m/**[m
[32m+[m[32m * Lookup table which factors to use for which number of error correction codewords.[m
[32m+[m[32m * See FACTORS.[m
[32m+[m[32m */[m
[32m+[m[32mexports.FACTOR_SETS = [[m
[32m+[m[32m    5, 7, 10, 11, 12, 14, 18, 20, 24, 28, 36, 42, 48, 56, 62, 68,[m
[32m+[m[32m];[m
[32m+[m[32m/**[m
[32m+[m[32m * Precomputed polynomial factors for ECC 200.[m
[32m+[m[32m */[m
[32m+[m[32mexports.FACTORS = [[m
[32m+[m[32m    [228, 48, 15, 111, 62],[m
[32m+[m[32m    [23, 68, 144, 134, 240, 92, 254],[m
[32m+[m[32m    [28, 24, 185, 166, 223, 248, 116, 255, 110, 61],[m
[32m+[m[32m    [175, 138, 205, 12, 194, 168, 39, 245, 60, 97, 120],[m
[32m+[m[32m    [41, 153, 158, 91, 61, 42, 142, 213, 97, 178, 100, 242],[m
[32m+[m[32m    [156, 97, 192, 252, 95, 9, 157, 119, 138, 45, 18, 186, 83, 185],[m
[32m+[m[32m    [[m
[32m+[m[32m        83, 195, 100, 39, 188, 75, 66, 61, 241, 213, 109, 129, 94, 254, 225, 48, 90,[m
[32m+[m[32m        188,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        15, 195, 244, 9, 233, 71, 168, 2, 188, 160, 153, 145, 253, 79, 108, 82, 27,[m
[32m+[m[32m        174, 186, 172,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        52, 190, 88, 205, 109, 39, 176, 21, 155, 197, 251, 223, 155, 21, 5, 172,[m
[32m+[m[32m        254, 124, 12, 181, 184, 96, 50, 193,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        211, 231, 43, 97, 71, 96, 103, 174, 37, 151, 170, 53, 75, 34, 249, 121, 17,[m
[32m+[m[32m        138, 110, 213, 141, 136, 120, 151, 233, 168, 93, 255,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        245, 127, 242, 218, 130, 250, 162, 181, 102, 120, 84, 179, 220, 251, 80,[m
[32m+[m[32m        182, 229, 18, 2, 4, 68, 33, 101, 137, 95, 119, 115, 44, 175, 184, 59, 25,[m
[32m+[m[32m        225, 98, 81, 112,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        77, 193, 137, 31, 19, 38, 22, 153, 247, 105, 122, 2, 245, 133, 242, 8, 175,[m
[32m+[m[32m        95, 100, 9, 167, 105, 214, 111, 57, 121, 21, 1, 253, 57, 54, 101, 248, 202,[m
[32m+[m[32m        69, 50, 150, 177, 226, 5, 9, 5,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        245, 132, 172, 223, 96, 32, 117, 22, 238, 133, 238, 231, 205, 188, 237, 87,[m
[32m+[m[32m        191, 106, 16, 147, 118, 23, 37, 90, 170, 205, 131, 88, 120, 100, 66, 138,[m
[32m+[m[32m        186, 240, 82, 44, 176, 87, 187, 147, 160, 175, 69, 213, 92, 253, 225, 19,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        175, 9, 223, 238, 12, 17, 220, 208, 100, 29, 175, 170, 230, 192, 215, 235,[m
[32m+[m[32m        150, 159, 36, 223, 38, 200, 132, 54, 228, 146, 218, 234, 117, 203, 29, 232,[m
[32m+[m[32m        144, 238, 22, 150, 201, 117, 62, 207, 164, 13, 137, 245, 127, 67, 247, 28,[m
[32m+[m[32m        155, 43, 203, 107, 233, 53, 143, 46,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        242, 93, 169, 50, 144, 210, 39, 118, 202, 188, 201, 189, 143, 108, 196, 37,[m
[32m+[m[32m        185, 112, 134, 230, 245, 63, 197, 190, 250, 106, 185, 221, 175, 64, 114, 71,[m
[32m+[m[32m        161, 44, 147, 6, 27, 218, 51, 63, 87, 10, 40, 130, 188, 17, 163, 31, 176,[m
[32m+[m[32m        170, 4, 107, 232, 7, 94, 166, 224, 124, 86, 47, 11, 204,[m
[32m+[m[32m    ],[m
[32m+[m[32m    [[m
[32m+[m[32m        220, 228, 173, 89, 251, 149, 159, 56, 89, 33, 147, 244, 154, 36, 73, 127,[m
[32m+[m[32m        213, 136, 248, 180, 234, 197, 158, 177, 68, 122, 93, 213, 15, 160, 227, 236,[m
[32m+[m[32m        66, 139, 153, 185, 202, 167, 179, 25, 220, 232, 96, 210, 231, 136, 223, 239,[m
[32m+[m[32m        181, 241, 59, 52, 172, 25, 49, 232, 211, 189, 64, 54, 108, 153, 132, 63, 96,[m
[32m+[m[32m        103, 82, 186,[m
[32m+[m[32m    ],[m
[32m+[m[32m];[m
[32m+[m[32mexports.MODULO_VALUE = 0x12d;[m
[32m+[m[32mvar static_LOG = function (LOG, ALOG) {[m
[32m+[m[32m    var p = 1;[m
[32m+[m[32m    for (var i = 0; i < 255; i++) {[m
[32m+[m[32m        ALOG[i] = p;[m
[32m+[m[32m        LOG[p] = i;[m
[32m+[m[32m        p *= 2;[m
[32m+[m[32m        if (p >= 256) {[m
[32m+[m[32m            p ^= exports.MODULO_VALUE;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return {[m
[32m+[m[32m        LOG: LOG,[m
[32m+[m[32m        ALOG: ALOG,[m
[32m+[m[32m    };[m
[32m+[m[32m};[m
[32m+[m[32mexports.LOG = (_a = static_LOG([], []), _a.LOG), exports.ALOG = _a.ALOG;[m
[32m+[m[32mvar SymbolShapeHint;[m
[32m+[m[32m(function (SymbolShapeHint) {[m
[32m+[m[32m    SymbolShapeHint[SymbolShapeHint["FORCE_NONE"] = 0] = "FORCE_NONE";[m
[32m+[m[32m    SymbolShapeHint[SymbolShapeHint["FORCE_SQUARE"] = 1] = "FORCE_SQUARE";[m
[32m+[m[32m    SymbolShapeHint[SymbolShapeHint["FORCE_RECTANGLE"] = 2] = "FORCE_RECTANGLE";[m
[32m+[m[32m})(SymbolShapeHint = exports.SymbolShapeHint || (exports.SymbolShapeHint = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * Padding character[m
[32m+[m[32m */[m
[32m+[m[32mexports.PAD = 129;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to C40 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexports.LATCH_TO_C40 = 230;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to Base 256 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexports.LATCH_TO_BASE256 = 231;[m
[32m+[m[32m/**[m
[32m+[m[32m * FNC1 Codeword[m
[32m+[m[32m */[m
[32m+[m[32m// private static FNC1 = 232;[m
[32m+[m[32m/**[m
[32m+[m[32m * Structured Append Codeword[m
[32m+[m[32m */[m
[32m+[m[32m// private static STRUCTURED_APPEND = 233;[m
[32m+[m[32m/**[m
[32m+[m[32m * Reader Programming[m
[32m+[m[32m */[m
[32m+[m[32m// private static READER_PROGRAMMING = 234;[m
[32m+[m[32m/**[m
[32m+[m[32m * Upper Shift[m
[32m+[m[32m */[m
[32m+[m[32mexports.UPPER_SHIFT = 235;[m
[32m+[m[32m/**[m
[32m+[m[32m * 05 Macro[m
[32m+[m[32m */[m
[32m+[m[32mexports.MACRO_05 = 236;[m
[32m+[m[32m/**[m
[32m+[m[32m * 06 Macro[m
[32m+[m[32m */[m
[32m+[m[32mexports.MACRO_06 = 237;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to ANSI X.12 encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexports.LATCH_TO_ANSIX12 = 238;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to Text encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexports.LATCH_TO_TEXT = 239;[m
[32m+[m[32m/**[m
[32m+[m[32m * mode latch to EDIFACT encodation mode[m
[32m+[m[32m */[m
[32m+[m[32mexports.LATCH_TO_EDIFACT = 240;[m
[32m+[m[32m/**[m
[32m+[m[32m * ECI character (Extended Channel Interpretation)[m
[32m+[m[32m */[m
[32m+[m[32m// private export const ECI = 241;[m
[32m+[m[32m/**[m
[32m+[m[32m * Unlatch from C40 encodation[m
[32m+[m[32m */[m
[32m+[m[32mexports.C40_UNLATCH = 254;[m
[32m+[m[32m/**[m
[32m+[m[32m * Unlatch from X12 encodation[m
[32m+[m[32m */[m
[32m+[m[32mexports.X12_UNLATCH = 254;[m
[32m+[m[32m/**[m
[32m+[m[32m * 05 Macro header[m
[32m+[m[32m */[m
[32m+[m[32mexports.MACRO_05_HEADER = '[)>\u001E05\u001D';[m
[32m+[m[32m/**[m
[32m+[m[32m * 06 Macro header[m
[32m+[m[32m */[m
[32m+[m[32mexports.MACRO_06_HEADER = '[)>\u001E06\u001D';[m
[32m+[m[32m/**[m
[32m+[m[32m * Macro trailer[m
[32m+[m[32m */[m
[32m+[m[32mexports.MACRO_TRAILER = '\u001E\u0004';[m
[32m+[m[32mexports.ASCII_ENCODATION = 0;[m
[32m+[m[32mexports.C40_ENCODATION = 1;[m
[32m+[m[32mexports.TEXT_ENCODATION = 2;[m
[32m+[m[32mexports.X12_ENCODATION = 3;[m
[32m+[m[32mexports.EDIFACT_ENCODATION = 4;[m
[32m+[m[32mexports.BASE256_ENCODATION = 5;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.d.ts b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..776992a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport { ASCIIEncoder } from './ASCIIEncoder';[m
[32m+[m[32mimport { Base256Encoder } from './Base256Encoder';[m
[32m+[m[32mimport { C40Encoder } from './C40Encoder';[m
[32m+[m[32mimport DefaultPlacement from './DefaultPlacement';[m
[32m+[m[32mimport { EdifactEncoder } from './EdifactEncoder';[m
[32m+[m[32mimport { EncoderContext } from './EncoderContext';[m
[32m+[m[32mimport ErrorCorrection from './ErrorCorrection';[m
[32m+[m[32mimport HighLevelEncoder from './HighLevelEncoder';[m
[32m+[m[32mimport { MinimalEncoder } from './MinimalEncoder';[m
[32m+[m[32mimport SymbolInfo from './SymbolInfo';[m
[32m+[m[32mimport { TextEncoder } from './TextEncoder';[m
[32m+[m[32mimport { X12Encoder } from './X12Encoder';[m
[32m+[m[32mexport { ASCIIEncoder, Base256Encoder, C40Encoder, EdifactEncoder, EncoderContext, ErrorCorrection, DefaultPlacement, HighLevelEncoder, MinimalEncoder, SymbolInfo, TextEncoder, X12Encoder, };[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7b40c03[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/datamatrix/encoder/index.js[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.X12Encoder = exports.TextEncoder = exports.SymbolInfo = exports.MinimalEncoder = exports.HighLevelEncoder = exports.DefaultPlacement = exports.ErrorCorrection = exports.EncoderContext = exports.EdifactEncoder = exports.C40Encoder = exports.Base256Encoder = exports.ASCIIEncoder = void 0;[m
[32m+[m[32mvar ASCIIEncoder_1 = require("./ASCIIEncoder");[m
[32m+[m[32mObject.defineProperty(exports, "ASCIIEncoder", { enumerable: true, get: function () { return ASCIIEncoder_1.ASCIIEncoder; } });[m
[32m+[m[32mvar Base256Encoder_1 = require("./Base256Encoder");[m
[32m+[m[32mObject.defineProperty(exports, "Base256Encoder", { enumerable: true, get: function () { return Base256Encoder_1.Base256Encoder; } });[m
[32m+[m[32mvar C40Encoder_1 = require("./C40Encoder");[m
[32m+[m[32mObject.defineProperty(exports, "C40Encoder", { enumerable: true, get: function () { return C40Encoder_1.C40Encoder; } });[m
[32m+[m[32mvar DefaultPlacement_1 = require("./DefaultPlacement");[m
[32m+[m[32mexports.DefaultPlacement = DefaultPlacement_1.default;[m
[32m+[m[32mvar EdifactEncoder_1 = require("./EdifactEncoder");[m
[32m+[m[32mObject.defineProperty(exports, "EdifactEncoder", { enumerable: true, get: function () { return EdifactEncoder_1.EdifactEncoder; } });[m
[32m+[m[32mvar EncoderContext_1 = require("./EncoderContext");[m
[32m+[m[32mObject.defineProperty(exports, "EncoderContext", { enumerable: true, get: function () { return EncoderContext_1.EncoderContext; } });[m
[32m+[m[32mvar ErrorCorrection_1 = require("./ErrorCorrection");[m
[32m+[m[32mexports.ErrorCorrection = ErrorCorrection_1.default;[m
[32m+[m[32mvar HighLevelEncoder_1 = require("./HighLevelEncoder");[m
[32m+[m[32mexports.HighLevelEncoder = HighLevelEncoder_1.default;[m
[32m+[m[32mvar MinimalEncoder_1 = require("./MinimalEncoder");[m
[32m+[m[32mObject.defineProperty(exports, "MinimalEncoder", { enumerable: true, get: function () { return MinimalEncoder_1.MinimalEncoder; } });[m
[32m+[m[32mvar SymbolInfo_1 = require("./SymbolInfo");[m
[32m+[m[32mexports.SymbolInfo = SymbolInfo_1.default;[m
[32m+[m[32mvar TextEncoder_1 = require("./TextEncoder");[m
[32m+[m[32mObject.defineProperty(exports, "TextEncoder", { enumerable: true, get: function () { return TextEncoder_1.TextEncoder; } });[m
[32m+[m[32mvar X12Encoder_1 = require("./X12Encoder");[m
[32m+[m[32mObject.defineProperty(exports, "X12Encoder", { enumerable: true, get: function () { return X12Encoder_1.X12Encoder; } });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f3c9311[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.d.ts[m
[36m@@ -0,0 +1,19 @@[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * Implementation of this interface attempt to read several barcodes from one image.[m
[32m+[m[32m *[m
[32m+[m[32m * @see com.google.zxing.Reader[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default interface MultipleBarcodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeMultiple(image: BinaryBitmap): Result[];[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeMultiple(image: BinaryBitmap, hints: Map<DecodeHintType, any>): Result[];[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.js b/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0432319[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/multi/MultipleBarcodeReader.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..fef770b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.d.ts[m
[36m@@ -0,0 +1,78 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates functionality and implementation that is common to UPC and EAN families[m
[32m+[m[32m * of one-dimensional barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mexport default abstract class AbstractUPCEANReader extends OneDReader {[m
[32m+[m[32m    private static MAX_AVG_VARIANCE;[m
[32m+[m[32m    private static MAX_INDIVIDUAL_VARIANCE;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Start/end guard pattern.[m
[32m+[m[32m     */[m
[32m+[m[32m    static START_END_PATTERN: Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.[m
[32m+[m[32m     */[m
[32m+[m[32m    static MIDDLE_PATTERN: Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * end guard pattern.[m
[32m+[m[32m     */[m
[32m+[m[32m    static END_PATTERN: Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * "Odd", or "L" patterns used to encode UPC/EAN digits.[m
[32m+[m[32m     */[m
[32m+[m[32m    static L_PATTERNS: Int32Array[];[m
[32m+[m[32m    /**[m
[32m+[m[32m     * As above but also including the "even", or "G" patterns used to encode UPC/EAN digits.[m
[32m+[m[32m     */[m
[32m+[m[32m    static L_AND_G_PATTERNS: Int32Array[];[m
[32m+[m[32m    protected decodeRowStringBuffer: string;[m
[32m+[m[32m    static findStartGuardPattern(row: BitArray): Int32Array;[m
[32m+[m[32m    abstract decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    static checkChecksum(s: string): boolean;[m
[32m+[m[32m    static checkStandardUPCEANChecksum(s: string): boolean;[m
[32m+[m[32m    static getStandardUPCEANChecksum(s: string): number;[m
[32m+[m[32m    static decodeEnd(row: BitArray, endStart: number): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    static findGuardPatternWithoutCounters(row: BitArray, rowOffset: int, whiteFirst: boolean, pattern: Int32Array): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @param rowOffset position to start search[m
[32m+[m[32m     * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...[m
[32m+[m[32m     * pixel counts, otherwise, it is interpreted as black/white/black/...[m
[32m+[m[32m     * @param pattern pattern of counts of number of black and white pixels that are being[m
[32m+[m[32m     * searched for as a pattern[m
[32m+[m[32m     * @param counters array of counters, as long as pattern, to re-use[m
[32m+[m[32m     * @return start/end horizontal offset of guard pattern, as an array of two ints[m
[32m+[m[32m     * @throws NotFoundException if pattern is not found[m
[32m+[m[32m     */[m
[32m+[m[32m    static findGuardPattern(row: BitArray, rowOffset: number, whiteFirst: boolean, pattern: Int32Array, counters: Int32Array): Int32Array;[m
[32m+[m[32m    static decodeDigit(row: BitArray, counters: Int32Array, rowOffset: int, patterns: Int32Array[]): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Get the format of this decoder.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return The 1D format.[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract getBarcodeFormat(): any;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Subclasses override this to decode the portion of a barcode between the start[m
[32m+[m[32m     * and end guard patterns.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @param startRange start/end offset of start guard pattern[m
[32m+[m[32m     * @param resultString {@link StringBuilder} to append decoded chars to[m
[32m+[m[32m     * @return horizontal offset of first pixel after the "middle" that was decoded[m
[32m+[m[32m     * @throws NotFoundException if decoding could not complete successfully[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): any;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1d5787e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js[m
[36m@@ -0,0 +1,213 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates functionality and implementation that is common to UPC and EAN families[m
[32m+[m[32m * of one-dimensional barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mvar AbstractUPCEANReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AbstractUPCEANReader, _super);[m
[32m+[m[32m    function AbstractUPCEANReader() {[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        _this.decodeRowStringBuffer = '';[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    // private final UPCEANExtensionSupport extensionReader;[m
[32m+[m[32m    // private final EANManufacturerOrgSupport eanManSupport;[m
[32m+[m[32m    /*[m
[32m+[m[32m    protected UPCEANReader() {[m
[32m+[m[32m        decodeRowStringBuffer = new StringBuilder(20);[m
[32m+[m[32m        extensionReader = new UPCEANExtensionSupport();[m
[32m+[m[32m        eanManSupport = new EANManufacturerOrgSupport();[m
[32m+[m[32m    }[m
[32m+[m[32m    */[m
[32m+[m[32m    AbstractUPCEANReader.findStartGuardPattern = function (row) {[m
[32m+[m[32m        var foundStart = false;[m
[32m+[m[32m        var startRange;[m
[32m+[m[32m        var nextStart = 0;[m
[32m+[m[32m        var counters = Int32Array.from([0, 0, 0]);[m
[32m+[m[32m        while (!foundStart) {[m
[32m+[m[32m            counters = Int32Array.from([0, 0, 0]);[m
[32m+[m[32m            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);[m
[32m+[m[32m            var start = startRange[0];[m
[32m+[m[32m            nextStart = startRange[1];[m
[32m+[m[32m            var quietStart = start - (nextStart - start);[m
[32m+[m[32m            if (quietStart >= 0) {[m
[32m+[m[32m                foundStart = row.isRange(quietStart, start, false);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return startRange;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractUPCEANReader.checkChecksum = function (s) {[m
[32m+[m[32m        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {[m
[32m+[m[32m        var length = s.length;[m
[32m+[m[32m        if (length === 0)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        var check = parseInt(s.charAt(length - 1), 10);[m
[32m+[m[32m        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {[m
[32m+[m[32m        var length = s.length;[m
[32m+[m[32m        var sum = 0;[m
[32m+[m[32m        for (var i = length - 1; i >= 0; i -= 2) {[m
[32m+[m[32m            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            if (digit < 0 || digit > 9) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            sum += digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        sum *= 3;[m
[32m+[m[32m        for (var i = length - 2; i >= 0; i -= 2) {[m
[32m+[m[32m            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            if (digit < 0 || digit > 9) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            sum += digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        return (1000 - sum) % 10;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractUPCEANReader.decodeEnd = function (row, endStart) {[m
[32m+[m[32m        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {[m
[32m+[m[32m        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @param rowOffset position to start search[m
[32m+[m[32m     * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...[m
[32m+[m[32m     * pixel counts, otherwise, it is interpreted as black/white/black/...[m
[32m+[m[32m     * @param pattern pattern of counts of number of black and white pixels that are being[m
[32m+[m[32m     * searched for as a pattern[m
[32m+[m[32m     * @param counters array of counters, as long as pattern, to re-use[m
[32m+[m[32m     * @return start/end horizontal offset of guard pattern, as an array of two ints[m
[32m+[m[32m     * @throws NotFoundException if pattern is not found[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        var patternLength = pattern.length;[m
[32m+[m[32m        var isWhite = whiteFirst;[m
[32m+[m[32m        for (var x = rowOffset; x < width; x++) {[m
[32m+[m[32m            if (row.get(x) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === patternLength - 1) {[m
[32m+[m[32m                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {[m
[32m+[m[32m                        return Int32Array.from([patternStart, x]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    var slice = counters.slice(2, counters.length);[m
[32m+[m[32m                    for (var i = 0; i < counterPosition - 1; i++) {[m
[32m+[m[32m                        counters[i] = slice[i];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    counters[counterPosition - 1] = 0;[m
[32m+[m[32m                    counters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {[m
[32m+[m[32m        this.recordPattern(row, rowOffset, counters);[m
[32m+[m[32m        var bestVariance = this.MAX_AVG_VARIANCE;[m
[32m+[m[32m        var bestMatch = -1;[m
[32m+[m[32m        var max = patterns.length;[m
[32m+[m[32m        for (var i = 0; i < max; i++) {[m
[32m+[m[32m            var pattern = patterns[i];[m
[32m+[m[32m            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);[m
[32m+[m[32m            if (variance < bestVariance) {[m
[32m+[m[32m                bestVariance = variance;[m
[32m+[m[32m                bestMatch = i;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bestMatch >= 0) {[m
[32m+[m[32m            return bestMatch;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // These two values are critical for determining how permissive the decoding will be.[m
[32m+[m[32m    // We've arrived at these values through a lot of trial and error. Setting them any higher[m
[32m+[m[32m    // lets false positives creep in quickly.[m
[32m+[m[32m    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;[m
[32m+[m[32m    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Start/end guard pattern.[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * end guard pattern.[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * "Odd", or "L" patterns used to encode UPC/EAN digits.[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractUPCEANReader.L_PATTERNS = [[m
[32m+[m[32m        Int32Array.from([3, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 4, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 3, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 4]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 3]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 2]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    return AbstractUPCEANReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = AbstractUPCEANReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ac877aa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.d.ts[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes CodaBar barcodes. </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Evan @dodobelieve[m
[32m+[m[32m * @see CodaBarReader[m
[32m+[m[32m */[m
[32m+[m[32mexport default class CodaBarReader extends OneDReader {[m
[32m+[m[32m    private readonly CODA_BAR_CHAR_SET;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * converts bit array to valid data array(lengths of black bits and white bits)[m
[32m+[m[32m     * @param row bit array to convert[m
[32m+[m[32m     */[m
[32m+[m[32m    private getValidRowData;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * decode codabar code[m
[32m+[m[32m     * @param row row to cecode[m
[32m+[m[32m     */[m
[32m+[m[32m    private codaBarDecodeRow;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * check if the string is a CodaBar string[m
[32m+[m[32m     * @param src string to determine[m
[32m+[m[32m     */[m
[32m+[m[32m    private validCodaBarString;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..4b794cb[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/CodaBarReader.js[m
[36m@@ -0,0 +1,142 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes CodaBar barcodes. </p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Evan @dodobelieve[m
[32m+[m[32m * @see CodaBarReader[m
[32m+[m[32m */[m
[32m+[m[32mvar CodaBarReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(CodaBarReader, _super);[m
[32m+[m[32m    function CodaBarReader() {[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        _this.CODA_BAR_CHAR_SET = {[m
[32m+[m[32m            nnnnnww: '0',[m
[32m+[m[32m            nnnnwwn: '1',[m
[32m+[m[32m            nnnwnnw: '2',[m
[32m+[m[32m            wwnnnnn: '3',[m
[32m+[m[32m            nnwnnwn: '4',[m
[32m+[m[32m            wnnnnwn: '5',[m
[32m+[m[32m            nwnnnnw: '6',[m
[32m+[m[32m            nwnnwnn: '7',[m
[32m+[m[32m            nwwnnnn: '8',[m
[32m+[m[32m            wnnwnnn: '9',[m
[32m+[m[32m            nnnwwnn: '-',[m
[32m+[m[32m            nnwwnnn: '$',[m
[32m+[m[32m            wnnnwnw: ':',[m
[32m+[m[32m            wnwnnnw: '/',[m
[32m+[m[32m            wnwnwnn: '.',[m
[32m+[m[32m            nnwwwww: '+',[m
[32m+[m[32m            nnwwnwn: 'A',[m
[32m+[m[32m            nwnwnnw: 'B',[m
[32m+[m[32m            nnnwnww: 'C',[m
[32m+[m[32m            nnnwwwn: 'D'[m
[32m+[m[32m        };[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    CodaBarReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var validRowData = this.getValidRowData(row);[m
[32m+[m[32m        if (!validRowData)[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        var retStr = this.codaBarDecodeRow(validRowData.row);[m
[32m+[m[32m        if (!retStr)[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        return new Result_1.default(retStr, null, 0, [new ResultPoint_1.default(validRowData.left, rowNumber), new ResultPoint_1.default(validRowData.right, rowNumber)], BarcodeFormat_1.default.CODABAR, new Date().getTime());[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * converts bit array to valid data array(lengths of black bits and white bits)[m
[32m+[m[32m     * @param row bit array to convert[m
[32m+[m[32m     */[m
[32m+[m[32m    CodaBarReader.prototype.getValidRowData = function (row) {[m
[32m+[m[32m        var booleanArr = row.toArray();[m
[32m+[m[32m        var startIndex = booleanArr.indexOf(true);[m
[32m+[m[32m        if (startIndex === -1)[m
[32m+[m[32m            return null;[m
[32m+[m[32m        var lastIndex = booleanArr.lastIndexOf(true);[m
[32m+[m[32m        if (lastIndex <= startIndex)[m
[32m+[m[32m            return null;[m
[32m+[m[32m        booleanArr = booleanArr.slice(startIndex, lastIndex + 1);[m
[32m+[m[32m        var result = [];[m
[32m+[m[32m        var lastBit = booleanArr[0];[m
[32m+[m[32m        var bitLength = 1;[m
[32m+[m[32m        for (var i = 1; i < booleanArr.length; i++) {[m
[32m+[m[32m            if (booleanArr[i] === lastBit) {[m
[32m+[m[32m                bitLength++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                lastBit = booleanArr[i];[m
[32m+[m[32m                result.push(bitLength);[m
[32m+[m[32m                bitLength = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        result.push(bitLength);[m
[32m+[m[32m        // CodaBar code data valid[m
[32m+[m[32m        if (result.length < 23 && (result.length + 1) % 8 !== 0)[m
[32m+[m[32m            return null;[m
[32m+[m[32m        return { row: result, left: startIndex, right: lastIndex };[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * decode codabar code[m
[32m+[m[32m     * @param row row to cecode[m
[32m+[m[32m     */[m
[32m+[m[32m    CodaBarReader.prototype.codaBarDecodeRow = function (row) {[m
[32m+[m[32m        var code = [];[m
[32m+[m[32m        var barThreshold = Math.ceil(row.reduce(function (pre, item) { return (pre + item) / 2; }, 0));[m
[32m+[m[32m        // Read one encoded character at a time.[m
[32m+[m[32m        while (row.length > 0) {[m
[32m+[m[32m            var seg = row.splice(0, 8).splice(0, 7);[m
[32m+[m[32m            var key = seg.map(function (len) { return (len < barThreshold ? 'n' : 'w'); }).join('');[m
[32m+[m[32m            if (this.CODA_BAR_CHAR_SET[key] === undefined)[m
[32m+[m[32m                return null;[m
[32m+[m[32m            code.push(this.CODA_BAR_CHAR_SET[key]);[m
[32m+[m[32m        }[m
[32m+[m[32m        var strCode = code.join('');[m
[32m+[m[32m        if (this.validCodaBarString(strCode))[m
[32m+[m[32m            return strCode;[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * check if the string is a CodaBar string[m
[32m+[m[32m     * @param src string to determine[m
[32m+[m[32m     */[m
[32m+[m[32m    CodaBarReader.prototype.validCodaBarString = function (src) {[m
[32m+[m[32m        var reg = /^[A-D].{1,}[A-D]$/;[m
[32m+[m[32m        return reg.test(src);[m
[32m+[m[32m    };[m
[32m+[m[32m    return CodaBarReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = CodaBarReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3cd5683[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.d.ts[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 128 barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Code128Reader extends OneDReader {[m
[32m+[m[32m    private static CODE_PATTERNS;[m
[32m+[m[32m    private static MAX_AVG_VARIANCE;[m
[32m+[m[32m    private static MAX_INDIVIDUAL_VARIANCE;[m
[32m+[m[32m    private static CODE_SHIFT;[m
[32m+[m[32m    private static CODE_CODE_C;[m
[32m+[m[32m    private static CODE_CODE_B;[m
[32m+[m[32m    private static CODE_CODE_A;[m
[32m+[m[32m    private static CODE_FNC_1;[m
[32m+[m[32m    private static CODE_FNC_2;[m
[32m+[m[32m    private static CODE_FNC_3;[m
[32m+[m[32m    private static CODE_FNC_4_A;[m
[32m+[m[32m    private static CODE_FNC_4_B;[m
[32m+[m[32m    private static CODE_START_A;[m
[32m+[m[32m    private static CODE_START_B;[m
[32m+[m[32m    private static CODE_START_C;[m
[32m+[m[32m    private static CODE_STOP;[m
[32m+[m[32m    private static findStartPattern;[m
[32m+[m[32m    private static decodeCode;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bd6e0f7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code128Reader.js[m
[36m@@ -0,0 +1,519 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar ChecksumException_1 = require("../ChecksumException");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m// import Reader from '../Reader';[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32m// import ResultMetadataType from '../ResultMetadataType';[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 128 barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Code128Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Code128Reader, _super);[m
[32m+[m[32m    function Code128Reader() {[m
[32m+[m[32m        return _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Code128Reader.findStartPattern = function (row) {[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var rowOffset = row.getNextSet(0);[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        var patternLength = 6;[m
[32m+[m[32m        for (var i = rowOffset; i < width; i++) {[m
[32m+[m[32m            if (row.get(i) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === (patternLength - 1)) {[m
[32m+[m[32m                    var bestVariance = Code128Reader.MAX_AVG_VARIANCE;[m
[32m+[m[32m                    var bestMatch = -1;[m
[32m+[m[32m                    for (var startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {[m
[32m+[m[32m                        var variance = OneDReader_1.default.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);[m
[32m+[m[32m                        if (variance < bestVariance) {[m
[32m+[m[32m                            bestVariance = variance;[m
[32m+[m[32m                            bestMatch = startCode;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // Look for whitespace before start pattern, >= 50% of width of start pattern[m
[32m+[m[32m                    if (bestMatch >= 0 &&[m
[32m+[m[32m                        row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {[m
[32m+[m[32m                        return Int32Array.from([patternStart, i, bestMatch]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    counters = counters.slice(2, counters.length);[m
[32m+[m[32m                    counters[counterPosition - 1] = 0;[m
[32m+[m[32m                    counters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    Code128Reader.decodeCode = function (row, counters, rowOffset) {[m
[32m+[m[32m        OneDReader_1.default.recordPattern(row, rowOffset, counters);[m
[32m+[m[32m        var bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept[m
[32m+[m[32m        var bestMatch = -1;[m
[32m+[m[32m        for (var d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {[m
[32m+[m[32m            var pattern = Code128Reader.CODE_PATTERNS[d];[m
[32m+[m[32m            var variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);[m
[32m+[m[32m            if (variance < bestVariance) {[m
[32m+[m[32m                bestVariance = variance;[m
[32m+[m[32m                bestMatch = d;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.[m
[32m+[m[32m        if (bestMatch >= 0) {[m
[32m+[m[32m            return bestMatch;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Code128Reader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var convertFNC1 = hints && (hints.get(DecodeHintType_1.default.ASSUME_GS1) === true);[m
[32m+[m[32m        var startPatternInfo = Code128Reader.findStartPattern(row);[m
[32m+[m[32m        var startCode = startPatternInfo[2];[m
[32m+[m[32m        var currentRawCodesIndex = 0;[m
[32m+[m[32m        var rawCodes = new Uint8Array(20);[m
[32m+[m[32m        rawCodes[currentRawCodesIndex++] = startCode;[m
[32m+[m[32m        var codeSet;[m
[32m+[m[32m        switch (startCode) {[m
[32m+[m[32m            case Code128Reader.CODE_START_A:[m
[32m+[m[32m                codeSet = Code128Reader.CODE_CODE_A;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Code128Reader.CODE_START_B:[m
[32m+[m[32m                codeSet = Code128Reader.CODE_CODE_B;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Code128Reader.CODE_START_C:[m
[32m+[m[32m                codeSet = Code128Reader.CODE_CODE_C;[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var done = false;[m
[32m+[m[32m        var isNextShifted = false;[m
[32m+[m[32m        var result = '';[m
[32m+[m[32m        var lastStart = startPatternInfo[0];[m
[32m+[m[32m        var nextStart = startPatternInfo[1];[m
[32m+[m[32m        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);[m
[32m+[m[32m        var lastCode = 0;[m
[32m+[m[32m        var code = 0;[m
[32m+[m[32m        var checksumTotal = startCode;[m
[32m+[m[32m        var multiplier = 0;[m
[32m+[m[32m        var lastCharacterWasPrintable = true;[m
[32m+[m[32m        var upperMode = false;[m
[32m+[m[32m        var shiftUpperMode = false;[m
[32m+[m[32m        while (!done) {[m
[32m+[m[32m            var unshift = isNextShifted;[m
[32m+[m[32m            isNextShifted = false;[m
[32m+[m[32m            // Save off last code[m
[32m+[m[32m            lastCode = code;[m
[32m+[m[32m            // Decode another code from image[m
[32m+[m[32m            code = Code128Reader.decodeCode(row, counters, nextStart);[m
[32m+[m[32m            rawCodes[currentRawCodesIndex++] = code;[m
[32m+[m[32m            // Remember whether the last code was printable or not (excluding CODE_STOP)[m
[32m+[m[32m            if (code !== Code128Reader.CODE_STOP) {[m
[32m+[m[32m                lastCharacterWasPrintable = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Add to checksum computation (if not CODE_STOP of course)[m
[32m+[m[32m            if (code !== Code128Reader.CODE_STOP) {[m
[32m+[m[32m                multiplier++;[m
[32m+[m[32m                checksumTotal += multiplier * code;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Advance to where the next code will to start[m
[32m+[m[32m            lastStart = nextStart;[m
[32m+[m[32m            nextStart += counters.reduce(function (previous, current) { return previous + current; }, 0);[m
[32m+[m[32m            // Take care of illegal start codes[m
[32m+[m[32m            switch (code) {[m
[32m+[m[32m                case Code128Reader.CODE_START_A:[m
[32m+[m[32m                case Code128Reader.CODE_START_B:[m
[32m+[m[32m                case Code128Reader.CODE_START_C:[m
[32m+[m[32m                    throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            switch (codeSet) {[m
[32m+[m[32m                case Code128Reader.CODE_CODE_A:[m
[32m+[m[32m                    if (code < 64) {[m
[32m+[m[32m                        if (shiftUpperMode === upperMode) {[m
[32m+[m[32m                            result += String.fromCharCode((' '.charCodeAt(0) + code));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shiftUpperMode = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (code < 96) {[m
[32m+[m[32m                        if (shiftUpperMode === upperMode) {[m
[32m+[m[32m                            result += String.fromCharCode((code - 64));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result += String.fromCharCode((code + 64));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shiftUpperMode = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        // Don't let CODE_STOP, which always appears, affect whether whether we think the last[m
[32m+[m[32m                        // code was printable or not.[m
[32m+[m[32m                        if (code !== Code128Reader.CODE_STOP) {[m
[32m+[m[32m                            lastCharacterWasPrintable = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        switch (code) {[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_1:[m
[32m+[m[32m                                if (convertFNC1) {[m
[32m+[m[32m                                    if (result.length === 0) {[m
[32m+[m[32m                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code[m
[32m+[m[32m                                        // is FNC1 then this is GS1-128. We add the symbology identifier.[m
[32m+[m[32m                                        result += ']C1';[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    else {[m
[32m+[m[32m                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)[m
[32m+[m[32m                                        result += String.fromCharCode(29);[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_2:[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_3:[m
[32m+[m[32m                                // do nothing?[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_4_A:[m
[32m+[m[32m                                if (!upperMode && shiftUpperMode) {[m
[32m+[m[32m                                    upperMode = true;[m
[32m+[m[32m                                    shiftUpperMode = false;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else if (upperMode && shiftUpperMode) {[m
[32m+[m[32m                                    upperMode = false;[m
[32m+[m[32m                                    shiftUpperMode = false;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else {[m
[32m+[m[32m                                    shiftUpperMode = true;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_SHIFT:[m
[32m+[m[32m                                isNextShifted = true;[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_B;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_B:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_B;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_C:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_C;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_STOP:[m
[32m+[m[32m                                done = true;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Code128Reader.CODE_CODE_B:[m
[32m+[m[32m                    if (code < 96) {[m
[32m+[m[32m                        if (shiftUpperMode === upperMode) {[m
[32m+[m[32m                            result += String.fromCharCode((' '.charCodeAt(0) + code));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        shiftUpperMode = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        if (code !== Code128Reader.CODE_STOP) {[m
[32m+[m[32m                            lastCharacterWasPrintable = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        switch (code) {[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_1:[m
[32m+[m[32m                                if (convertFNC1) {[m
[32m+[m[32m                                    if (result.length === 0) {[m
[32m+[m[32m                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code[m
[32m+[m[32m                                        // is FNC1 then this is GS1-128. We add the symbology identifier.[m
[32m+[m[32m                                        result += ']C1';[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    else {[m
[32m+[m[32m                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)[m
[32m+[m[32m                                        result += String.fromCharCode(29);[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_2:[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_3:[m
[32m+[m[32m                                // do nothing?[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_4_B:[m
[32m+[m[32m                                if (!upperMode && shiftUpperMode) {[m
[32m+[m[32m                                    upperMode = true;[m
[32m+[m[32m                                    shiftUpperMode = false;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else if (upperMode && shiftUpperMode) {[m
[32m+[m[32m                                    upperMode = false;[m
[32m+[m[32m                                    shiftUpperMode = false;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else {[m
[32m+[m[32m                                    shiftUpperMode = true;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_SHIFT:[m
[32m+[m[32m                                isNextShifted = true;[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_A;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_A:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_A;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_C:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_C;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_STOP:[m
[32m+[m[32m                                done = true;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Code128Reader.CODE_CODE_C:[m
[32m+[m[32m                    if (code < 100) {[m
[32m+[m[32m                        if (code < 10) {[m
[32m+[m[32m                            result += '0';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        result += code;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        if (code !== Code128Reader.CODE_STOP) {[m
[32m+[m[32m                            lastCharacterWasPrintable = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        switch (code) {[m
[32m+[m[32m                            case Code128Reader.CODE_FNC_1:[m
[32m+[m[32m                                if (convertFNC1) {[m
[32m+[m[32m                                    if (result.length === 0) {[m
[32m+[m[32m                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code[m
[32m+[m[32m                                        // is FNC1 then this is GS1-128. We add the symbology identifier.[m
[32m+[m[32m                                        result += ']C1';[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    else {[m
[32m+[m[32m                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)[m
[32m+[m[32m                                        result += String.fromCharCode(29);[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_A:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_A;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_CODE_B:[m
[32m+[m[32m                                codeSet = Code128Reader.CODE_CODE_B;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Code128Reader.CODE_STOP:[m
[32m+[m[32m                                done = true;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Unshift back to another code set if we were shifted[m
[32m+[m[32m            if (unshift) {[m
[32m+[m[32m                codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var lastPatternSize = nextStart - lastStart;[m
[32m+[m[32m        // Check for ample whitespace following pattern, but, to do this we first need to remember that[m
[32m+[m[32m        // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left[m
[32m+[m[32m        // to read off. Would be slightly better to properly read. Here we just skip it:[m
[32m+[m[32m        nextStart = row.getNextUnset(nextStart);[m
[32m+[m[32m        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Pull out from sum the value of the penultimate check code[m
[32m+[m[32m        checksumTotal -= multiplier * lastCode;[m
[32m+[m[32m        // lastCode is the checksum then:[m
[32m+[m[32m        if (checksumTotal % 103 !== lastCode) {[m
[32m+[m[32m            throw new ChecksumException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Need to pull out the check digits from string[m
[32m+[m[32m        var resultLength = result.length;[m
[32m+[m[32m        if (resultLength === 0) {[m
[32m+[m[32m            // false positive[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Only bother if the result had at least one character, and if the checksum digit happened to[m
[32m+[m[32m        // be a printable character. If it was just interpreted as a control code, nothing to remove.[m
[32m+[m[32m        if (resultLength > 0 && lastCharacterWasPrintable) {[m
[32m+[m[32m            if (codeSet === Code128Reader.CODE_CODE_C) {[m
[32m+[m[32m                result = result.substring(0, resultLength - 2);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                result = result.substring(0, resultLength - 1);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;[m
[32m+[m[32m        var right = lastStart + lastPatternSize / 2.0;[m
[32m+[m[32m        var rawCodesSize = rawCodes.length;[m
[32m+[m[32m        var rawBytes = new Uint8Array(rawCodesSize);[m
[32m+[m[32m        for (var i = 0; i < rawCodesSize; i++) {[m
[32m+[m[32m            rawBytes[i] = rawCodes[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var points = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];[m
[32m+[m[32m        return new Result_1.default(result, rawBytes, 0, points, BarcodeFormat_1.default.CODE_128, new Date().getTime());[m
[32m+[m[32m    };[m
[32m+[m[32m    Code128Reader.CODE_PATTERNS = [[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 2, 2, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 2, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 2, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 2, 2, 3]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 3, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 2, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 2, 1, 3]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 3, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 3, 2, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 2, 1, 3]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 3, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 3, 1, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 2, 3, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 1, 3, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 2, 3, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 2, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 3, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 3, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 3, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 1, 3, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 2, 3, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 3, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 3, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([3, 1, 2, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 2, 2, 2]),[m
[32m+[m[32m        Int32Array.from([3, 2, 1, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([3, 2, 1, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 2, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([3, 2, 2, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([3, 2, 2, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 1, 2, 3]),[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 3, 2, 1]),[m
[32m+[m[32m        Int32Array.from([2, 3, 2, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 3, 2, 3]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 1, 2, 3]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 3, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 3, 1, 3]),[m
[32m+[m[32m        Int32Array.from([1, 3, 2, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([1, 3, 2, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 3, 1, 3]),[m
[32m+[m[32m        Int32Array.from([2, 3, 1, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([2, 3, 1, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 1, 3, 3]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 3, 3, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 2, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 1, 2, 3]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 3, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 3, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 3, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 3, 3, 1]),[m
[32m+[m[32m        Int32Array.from([2, 3, 1, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 3, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([2, 1, 3, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 3, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 1, 2, 3]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 3, 2, 1]),[m
[32m+[m[32m        Int32Array.from([3, 3, 1, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 2, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([3, 1, 2, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([3, 3, 2, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 4, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 4, 1, 1]),[m
[32m+[m[32m        Int32Array.from([4, 3, 1, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 2, 2, 4]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 4, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 1, 2, 4]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 4, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 4, 1, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([1, 4, 1, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 2, 1, 4]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 4, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 1, 1, 4]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 4, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 4, 2, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 4, 2, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 4, 1, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 1, 1, 4]),[m
[32m+[m[32m        Int32Array.from([4, 1, 3, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 4, 1, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 3, 4, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 2, 4, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 1, 4, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 2, 4, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 4, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 4, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 4, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([4, 1, 1, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([4, 2, 1, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([4, 2, 1, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 1, 4, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 4, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([4, 1, 2, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 1, 4, 3]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 3, 4, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 1, 4, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 4, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([1, 1, 4, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([4, 1, 1, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([4, 1, 1, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 1, 4, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 4, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 1, 4, 1]),[m
[32m+[m[32m        Int32Array.from([4, 1, 1, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 4, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 2, 1, 4]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 2, 3, 2]),[m
[32m+[m[32m        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    Code128Reader.MAX_AVG_VARIANCE = 0.25;[m
[32m+[m[32m    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;[m
[32m+[m[32m    Code128Reader.CODE_SHIFT = 98;[m
[32m+[m[32m    Code128Reader.CODE_CODE_C = 99;[m
[32m+[m[32m    Code128Reader.CODE_CODE_B = 100;[m
[32m+[m[32m    Code128Reader.CODE_CODE_A = 101;[m
[32m+[m[32m    Code128Reader.CODE_FNC_1 = 102;[m
[32m+[m[32m    Code128Reader.CODE_FNC_2 = 97;[m
[32m+[m[32m    Code128Reader.CODE_FNC_3 = 96;[m
[32m+[m[32m    Code128Reader.CODE_FNC_4_A = 101;[m
[32m+[m[32m    Code128Reader.CODE_FNC_4_B = 100;[m
[32m+[m[32m    Code128Reader.CODE_START_A = 103;[m
[32m+[m[32m    Code128Reader.CODE_START_B = 104;[m
[32m+[m[32m    Code128Reader.CODE_START_C = 105;[m
[32m+[m[32m    Code128Reader.CODE_STOP = 106;[m
[32m+[m[32m    return Code128Reader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = Code128Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..7e5fe76[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.d.ts[m
[36m@@ -0,0 +1,51 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 39 barcodes. Supports "Full ASCII Code 39" if USE_CODE_39_EXTENDED_MODE is set.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see Code93Reader[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Code39Reader extends OneDReader {[m
[32m+[m[32m    private static readonly ALPHABET_STRING;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * These represent the encodings of characters, as patterns of wide and narrow bars.[m
[32m+[m[32m     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,[m
[32m+[m[32m     * with 1s representing "wide" and 0s representing narrow.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readonly CHARACTER_ENCODINGS;[m
[32m+[m[32m    private static readonly ASTERISK_ENCODING;[m
[32m+[m[32m    private usingCheckDigit;[m
[32m+[m[32m    private extendedMode;[m
[32m+[m[32m    private decodeRowResult;[m
[32m+[m[32m    private counters;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that assumes all encoded data is data, and does not treat the final[m
[32m+[m[32m     * character as a check digit. It will not decoded "extended Code 39" sequences.[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that can be configured to check the last character as a check digit.[m
[32m+[m[32m     * It will not decoded "extended Code 39" sequences.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param usingCheckDigit if true, treat the last data character as a check digit, not[m
[32m+[m[32m     * data, and verify that the checksum passes.[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that can be configured to check the last character as a check digit,[m
[32m+[m[32m     * or optionally attempt to decode "extended Code 39" sequences that are used to encode[m
[32m+[m[32m     * the full ASCII character set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param usingCheckDigit if true, treat the last data character as a check digit, not[m
[32m+[m[32m     * data, and verify that the checksum passes.[m
[32m+[m[32m     * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the[m
[32m+[m[32m     * text.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(usingCheckDigit?: boolean, extendedMode?: boolean);[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    private static findAsteriskPattern;[m
[32m+[m[32m    private static toNarrowWidePattern;[m
[32m+[m[32m    private static patternToChar;[m
[32m+[m[32m    private static decodeExtended;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..47ad30c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code39Reader.js[m
[36m@@ -0,0 +1,374 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar ChecksumException_1 = require("../ChecksumException");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 39 barcodes. Supports "Full ASCII Code 39" if USE_CODE_39_EXTENDED_MODE is set.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see Code93Reader[m
[32m+[m[32m */[m
[32m+[m[32mvar Code39Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Code39Reader, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that assumes all encoded data is data, and does not treat the final[m
[32m+[m[32m     * character as a check digit. It will not decoded "extended Code 39" sequences.[m
[32m+[m[32m     */[m
[32m+[m[32m    // public Code39Reader() {[m
[32m+[m[32m    //   this(false);[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that can be configured to check the last character as a check digit.[m
[32m+[m[32m     * It will not decoded "extended Code 39" sequences.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param usingCheckDigit if true, treat the last data character as a check digit, not[m
[32m+[m[32m     * data, and verify that the checksum passes.[m
[32m+[m[32m     */[m
[32m+[m[32m    // public Code39Reader(boolean usingCheckDigit) {[m
[32m+[m[32m    //   this(usingCheckDigit, false);[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a reader that can be configured to check the last character as a check digit,[m
[32m+[m[32m     * or optionally attempt to decode "extended Code 39" sequences that are used to encode[m
[32m+[m[32m     * the full ASCII character set.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param usingCheckDigit if true, treat the last data character as a check digit, not[m
[32m+[m[32m     * data, and verify that the checksum passes.[m
[32m+[m[32m     * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the[m
[32m+[m[32m     * text.[m
[32m+[m[32m     */[m
[32m+[m[32m    function Code39Reader(usingCheckDigit, extendedMode) {[m
[32m+[m[32m        if (usingCheckDigit === void 0) { usingCheckDigit = false; }[m
[32m+[m[32m        if (extendedMode === void 0) { extendedMode = false; }[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.usingCheckDigit = usingCheckDigit;[m
[32m+[m[32m        _this.extendedMode = extendedMode;[m
[32m+[m[32m        _this.decodeRowResult = '';[m
[32m+[m[32m        _this.counters = new Int32Array(9);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var theCounters = this.counters;[m
[32m+[m[32m        theCounters.fill(0);[m
[32m+[m[32m        this.decodeRowResult = '';[m
[32m+[m[32m        var start = Code39Reader.findAsteriskPattern(row, theCounters);[m
[32m+[m[32m        // Read off white space[m
[32m+[m[32m        var nextStart = row.getNextSet(start[1]);[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var decodedChar;[m
[32m+[m[32m        var lastStart;[m
[32m+[m[32m        do {[m
[32m+[m[32m            Code39Reader.recordPattern(row, nextStart, theCounters);[m
[32m+[m[32m            var pattern = Code39Reader.toNarrowWidePattern(theCounters);[m
[32m+[m[32m            if (pattern < 0) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            decodedChar = Code39Reader.patternToChar(pattern);[m
[32m+[m[32m            this.decodeRowResult += decodedChar;[m
[32m+[m[32m            lastStart = nextStart;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var theCounters_1 = (e_1 = void 0, __values(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {[m
[32m+[m[32m                    var counter = theCounters_1_1.value;[m
[32m+[m[32m                    nextStart += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            // Read off white space[m
[32m+[m[32m            nextStart = row.getNextSet(nextStart);[m
[32m+[m[32m        } while (decodedChar !== '*');[m
[32m+[m[32m        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk[m
[32m+[m[32m        // Look for whitespace after pattern:[m
[32m+[m[32m        var lastPatternSize = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {[m
[32m+[m[32m                var counter = theCounters_2_1.value;[m
[32m+[m[32m                lastPatternSize += counter;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;[m
[32m+[m[32m        // If 50% of last pattern size, following last pattern, is not whitespace, fail[m
[32m+[m[32m        // (but if it's whitespace to the very end of the image, that's OK)[m
[32m+[m[32m        if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.usingCheckDigit) {[m
[32m+[m[32m            var max = this.decodeRowResult.length - 1;[m
[32m+[m[32m            var total = 0;[m
[32m+[m[32m            for (var i = 0; i < max; i++) {[m
[32m+[m[32m                total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));[m
[32m+[m[32m            }[m
[32m+[m[32m            if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {[m
[32m+[m[32m                throw new ChecksumException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            this.decodeRowResult = this.decodeRowResult.substring(0, max);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.decodeRowResult.length === 0) {[m
[32m+[m[32m            // false positive[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var resultString;[m
[32m+[m[32m        if (this.extendedMode) {[m
[32m+[m[32m            resultString = Code39Reader.decodeExtended(this.decodeRowResult);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            resultString = this.decodeRowResult;[m
[32m+[m[32m        }[m
[32m+[m[32m        var left = (start[1] + start[0]) / 2.0;[m
[32m+[m[32m        var right = lastStart + lastPatternSize / 2.0;[m
[32m+[m[32m        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());[m
[32m+[m[32m    };[m
[32m+[m[32m    Code39Reader.findAsteriskPattern = function (row, counters) {[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var rowOffset = row.getNextSet(0);[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        var patternLength = counters.length;[m
[32m+[m[32m        for (var i = rowOffset; i < width; i++) {[m
[32m+[m[32m            if (row.get(i) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === patternLength - 1) {[m
[32m+[m[32m                    // Look for whitespace before start pattern, >= 50% of width of start pattern[m
[32m+[m[32m                    if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&[m
[32m+[m[32m                        row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {[m
[32m+[m[32m                        return [patternStart, i];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    counters.copyWithin(0, 2, 2 + counterPosition - 1);[m
[32m+[m[32m                    counters[counterPosition - 1] = 0;[m
[32m+[m[32m                    counters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions[m
[32m+[m[32m    // per image when using some of our blackbox images.[m
[32m+[m[32m    Code39Reader.toNarrowWidePattern = function (counters) {[m
[32m+[m[32m        var e_3, _a;[m
[32m+[m[32m        var numCounters = counters.length;[m
[32m+[m[32m        var maxNarrowCounter = 0;[m
[32m+[m[32m        var wideCounters;[m
[32m+[m[32m        do {[m
[32m+[m[32m            var minCounter = 0x7fffffff;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_3 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    if (counter < minCounter && counter > maxNarrowCounter) {[m
[32m+[m[32m                        minCounter = counter;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            maxNarrowCounter = minCounter;[m
[32m+[m[32m            wideCounters = 0;[m
[32m+[m[32m            var totalWideCountersWidth = 0;[m
[32m+[m[32m            var pattern = 0;[m
[32m+[m[32m            for (var i = 0; i < numCounters; i++) {[m
[32m+[m[32m                var counter = counters[i];[m
[32m+[m[32m                if (counter > maxNarrowCounter) {[m
[32m+[m[32m                    pattern |= 1 << (numCounters - 1 - i);[m
[32m+[m[32m                    wideCounters++;[m
[32m+[m[32m                    totalWideCountersWidth += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (wideCounters === 3) {[m
[32m+[m[32m                // Found 3 wide counters, but are they close enough in width?[m
[32m+[m[32m                // We can perform a cheap, conservative check to see if any individual[m
[32m+[m[32m                // counter is more than 1.5 times the average:[m
[32m+[m[32m                for (var i = 0; i < numCounters && wideCounters > 0; i++) {[m
[32m+[m[32m                    var counter = counters[i];[m
[32m+[m[32m                    if (counter > maxNarrowCounter) {[m
[32m+[m[32m                        wideCounters--;[m
[32m+[m[32m                        // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average[m
[32m+[m[32m                        if ((counter * 2) >= totalWideCountersWidth) {[m
[32m+[m[32m                            return -1;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return pattern;[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (wideCounters > 3);[m
[32m+[m[32m        return -1;[m
[32m+[m[32m    };[m
[32m+[m[32m    Code39Reader.patternToChar = function (pattern) {[m
[32m+[m[32m        for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {[m
[32m+[m[32m            if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {[m
[32m+[m[32m                return Code39Reader.ALPHABET_STRING.charAt(i);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (pattern === Code39Reader.ASTERISK_ENCODING) {[m
[32m+[m[32m            return '*';[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    Code39Reader.decodeExtended = function (encoded) {[m
[32m+[m[32m        var length = encoded.length;[m
[32m+[m[32m        var decoded = '';[m
[32m+[m[32m        for (var i = 0; i < length; i++) {[m
[32m+[m[32m            var c = encoded.charAt(i);[m
[32m+[m[32m            if (c === '+' || c === '$' || c === '%' || c === '/') {[m
[32m+[m[32m                var next = encoded.charAt(i + 1);[m
[32m+[m[32m                var decodedChar = '\0';[m
[32m+[m[32m                switch (c) {[m
[32m+[m[32m                    case '+':[m
[32m+[m[32m                        // +A to +Z map to a to z[m
[32m+[m[32m                        if (next >= 'A' && next <= 'Z') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case '$':[m
[32m+[m[32m                        // $A to $Z map to control codes SH to SB[m
[32m+[m[32m                        if (next >= 'A' && next <= 'Z') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case '%':[m
[32m+[m[32m                        // %A to %E map to control codes ESC to US[m
[32m+[m[32m                        if (next >= 'A' && next <= 'E') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'F' && next <= 'J') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'K' && next <= 'O') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'P' && next <= 'T') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'U') {[m
[32m+[m[32m                            decodedChar = '\0';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'V') {[m
[32m+[m[32m                            decodedChar = '@';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'W') {[m
[32m+[m[32m                            decodedChar = '`';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'X' || next === 'Y' || next === 'Z') {[m
[32m+[m[32m                            decodedChar = '\x7f';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case '/':[m
[32m+[m[32m                        // /A to /O map to ! to , and /Z maps to :[m
[32m+[m[32m                        if (next >= 'A' && next <= 'O') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'Z') {[m
[32m+[m[32m                            decodedChar = ':';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m                decoded += decodedChar;[m
[32m+[m[32m                // bump up i again since we read two characters[m
[32m+[m[32m                i++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                decoded += c;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return decoded;[m
[32m+[m[32m    };[m
[32m+[m[32m    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';[m
[32m+[m[32m    /**[m
[32m+[m[32m     * These represent the encodings of characters, as patterns of wide and narrow bars.[m
[32m+[m[32m     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,[m
[32m+[m[32m     * with 1s representing "wide" and 0s representing narrow.[m
[32m+[m[32m     */[m
[32m+[m[32m    Code39Reader.CHARACTER_ENCODINGS = [[m
[32m+[m[32m        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,[m
[32m+[m[32m        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,[m
[32m+[m[32m        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,[m
[32m+[m[32m        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,[m
[32m+[m[32m        0x0A2, 0x08A, 0x02A // /-%[m
[32m+[m[32m    ];[m
[32m+[m[32m    Code39Reader.ASTERISK_ENCODING = 0x094;[m
[32m+[m[32m    return Code39Reader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = Code39Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0bd3b74[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.d.ts[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 93 barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see Code39Reader[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Code93Reader extends OneDReader {[m
[32m+[m[32m    private static readonly ALPHABET_STRING;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * These represent the encodings of characters, as patterns of wide and narrow bars.[m
[32m+[m[32m     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static readonly CHARACTER_ENCODINGS;[m
[32m+[m[32m    private static readonly ASTERISK_ENCODING;[m
[32m+[m[32m    private decodeRowResult;[m
[32m+[m[32m    private counters;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    private findAsteriskPattern;[m
[32m+[m[32m    private toPattern;[m
[32m+[m[32m    private patternToChar;[m
[32m+[m[32m    private decodeExtended;[m
[32m+[m[32m    private checkChecksums;[m
[32m+[m[32m    private checkOneChecksum;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5a6c4aa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/Code93Reader.js[m
[36m@@ -0,0 +1,336 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar ChecksumException_1 = require("../ChecksumException");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32m//import com.google.zxing.ResultMetadataType;[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes Code 93 barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see Code39Reader[m
[32m+[m[32m */[m
[32m+[m[32mvar Code93Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Code93Reader, _super);[m
[32m+[m[32m    //public Code93Reader() {[m
[32m+[m[32m    //  decodeRowResult = new StringBuilder(20);[m
[32m+[m[32m    //  counters = new int[6];[m
[32m+[m[32m    //}[m
[32m+[m[32m    function Code93Reader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeRowResult = '';[m
[32m+[m[32m        _this.counters = new Int32Array(6);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Code93Reader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var start = this.findAsteriskPattern(row);[m
[32m+[m[32m        // Read off white space[m
[32m+[m[32m        var nextStart = row.getNextSet(start[1]);[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var theCounters = this.counters;[m
[32m+[m[32m        theCounters.fill(0);[m
[32m+[m[32m        this.decodeRowResult = '';[m
[32m+[m[32m        var decodedChar;[m
[32m+[m[32m        var lastStart;[m
[32m+[m[32m        do {[m
[32m+[m[32m            Code93Reader.recordPattern(row, nextStart, theCounters);[m
[32m+[m[32m            var pattern = this.toPattern(theCounters);[m
[32m+[m[32m            if (pattern < 0) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            decodedChar = this.patternToChar(pattern);[m
[32m+[m[32m            this.decodeRowResult += decodedChar;[m
[32m+[m[32m            lastStart = nextStart;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var theCounters_1 = (e_1 = void 0, __values(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {[m
[32m+[m[32m                    var counter = theCounters_1_1.value;[m
[32m+[m[32m                    nextStart += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            // Read off white space[m
[32m+[m[32m            nextStart = row.getNextSet(nextStart);[m
[32m+[m[32m        } while (decodedChar !== '*');[m
[32m+[m[32m        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk[m
[32m+[m[32m        var lastPatternSize = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {[m
[32m+[m[32m                var counter = theCounters_2_1.value;[m
[32m+[m[32m                lastPatternSize += counter;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Should be at least one more black module[m
[32m+[m[32m        if (nextStart === end || !row.get(nextStart)) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.decodeRowResult.length < 2) {[m
[32m+[m[32m            // false positive -- need at least 2 checksum digits[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.checkChecksums(this.decodeRowResult);[m
[32m+[m[32m        // Remove checksum digits[m
[32m+[m[32m        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 2);[m
[32m+[m[32m        var resultString = this.decodeExtended(this.decodeRowResult);[m
[32m+[m[32m        var left = (start[1] + start[0]) / 2.0;[m
[32m+[m[32m        var right = lastStart + lastPatternSize / 2.0;[m
[32m+[m[32m        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_93, new Date().getTime());[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.findAsteriskPattern = function (row) {[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var rowOffset = row.getNextSet(0);[m
[32m+[m[32m        this.counters.fill(0);[m
[32m+[m[32m        var theCounters = this.counters;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        var patternLength = theCounters.length;[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        for (var i = rowOffset; i < width; i++) {[m
[32m+[m[32m            if (row.get(i) !== isWhite) {[m
[32m+[m[32m                theCounters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === patternLength - 1) {[m
[32m+[m[32m                    if (this.toPattern(theCounters) === Code93Reader.ASTERISK_ENCODING) {[m
[32m+[m[32m                        return new Int32Array([patternStart, i]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += theCounters[0] + theCounters[1];[m
[32m+[m[32m                    theCounters.copyWithin(0, 2, 2 + counterPosition - 1);[m
[32m+[m[32m                    theCounters[counterPosition - 1] = 0;[m
[32m+[m[32m                    theCounters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                theCounters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default;[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.toPattern = function (counters) {[m
[32m+[m[32m        var e_3, _a;[m
[32m+[m[32m        var sum = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                var counter = counters_1_1.value;[m
[32m+[m[32m                sum += counter;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var pattern = 0;[m
[32m+[m[32m        var max = counters.length;[m
[32m+[m[32m        for (var i = 0; i < max; i++) {[m
[32m+[m[32m            var scaled = Math.round(counters[i] * 9.0 / sum);[m
[32m+[m[32m            if (scaled < 1 || scaled > 4) {[m
[32m+[m[32m                return -1;[m
[32m+[m[32m            }[m
[32m+[m[32m            if ((i & 0x01) === 0) {[m
[32m+[m[32m                for (var j = 0; j < scaled; j++) {[m
[32m+[m[32m                    pattern = (pattern << 1) | 0x01;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                pattern <<= scaled;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return pattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.patternToChar = function (pattern) {[m
[32m+[m[32m        for (var i = 0; i < Code93Reader.CHARACTER_ENCODINGS.length; i++) {[m
[32m+[m[32m            if (Code93Reader.CHARACTER_ENCODINGS[i] === pattern) {[m
[32m+[m[32m                return Code93Reader.ALPHABET_STRING.charAt(i);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.decodeExtended = function (encoded) {[m
[32m+[m[32m        var length = encoded.length;[m
[32m+[m[32m        var decoded = '';[m
[32m+[m[32m        for (var i = 0; i < length; i++) {[m
[32m+[m[32m            var c = encoded.charAt(i);[m
[32m+[m[32m            if (c >= 'a' && c <= 'd') {[m
[32m+[m[32m                if (i >= length - 1) {[m
[32m+[m[32m                    throw new FormatException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                var next = encoded.charAt(i + 1);[m
[32m+[m[32m                var decodedChar = '\0';[m
[32m+[m[32m                switch (c) {[m
[32m+[m[32m                    case 'd':[m
[32m+[m[32m                        // +A to +Z map to a to z[m
[32m+[m[32m                        if (next >= 'A' && next <= 'Z') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 'a':[m
[32m+[m[32m                        // $A to $Z map to control codes SH to SB[m
[32m+[m[32m                        if (next >= 'A' && next <= 'Z') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 'b':[m
[32m+[m[32m                        if (next >= 'A' && next <= 'E') {[m
[32m+[m[32m                            // %A to %E map to control codes ESC to USep[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'F' && next <= 'J') {[m
[32m+[m[32m                            // %F to %J map to ; < = > ?[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'K' && next <= 'O') {[m
[32m+[m[32m                            // %K to %O map to [ \ ] ^ _[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'P' && next <= 'T') {[m
[32m+[m[32m                            // %P to %T map to { | } ~ DEL[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'U') {[m
[32m+[m[32m                            // %U map to NUL[m
[32m+[m[32m                            decodedChar = '\0';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'V') {[m
[32m+[m[32m                            // %V map to @[m
[32m+[m[32m                            decodedChar = '@';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'W') {[m
[32m+[m[32m                            // %W map to `[m
[32m+[m[32m                            decodedChar = '`';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next >= 'X' && next <= 'Z') {[m
[32m+[m[32m                            // %X to %Z all map to DEL (127)[m
[32m+[m[32m                            decodedChar = String.fromCharCode(127);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 'c':[m
[32m+[m[32m                        // /A to /O map to ! to , and /Z maps to :[m
[32m+[m[32m                        if (next >= 'A' && next <= 'O') {[m
[32m+[m[32m                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else if (next === 'Z') {[m
[32m+[m[32m                            decodedChar = ':';[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m                decoded += decodedChar;[m
[32m+[m[32m                // bump up i again since we read two characters[m
[32m+[m[32m                i++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                decoded += c;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return decoded;[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.checkChecksums = function (result) {[m
[32m+[m[32m        var length = result.length;[m
[32m+[m[32m        this.checkOneChecksum(result, length - 2, 20);[m
[32m+[m[32m        this.checkOneChecksum(result, length - 1, 15);[m
[32m+[m[32m    };[m
[32m+[m[32m    Code93Reader.prototype.checkOneChecksum = function (result, checkPosition, weightMax) {[m
[32m+[m[32m        var weight = 1;[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        for (var i = checkPosition - 1; i >= 0; i--) {[m
[32m+[m[32m            total += weight * Code93Reader.ALPHABET_STRING.indexOf(result.charAt(i));[m
[32m+[m[32m            if (++weight > weightMax) {[m
[32m+[m[32m                weight = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (result.charAt(checkPosition) !== Code93Reader.ALPHABET_STRING[total % 47]) {[m
[32m+[m[32m            throw new ChecksumException_1.default;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Note that 'abcd' are dummy characters in place of control characters.[m
[32m+[m[32m    Code93Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";[m
[32m+[m[32m    /**[m
[32m+[m[32m     * These represent the encodings of characters, as patterns of wide and narrow bars.[m
[32m+[m[32m     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow.[m
[32m+[m[32m     */[m
[32m+[m[32m    Code93Reader.CHARACTER_ENCODINGS = [[m
[32m+[m[32m        0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A,[m
[32m+[m[32m        0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134,[m
[32m+[m[32m        0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6,[m
[32m+[m[32m        0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A,[m
[32m+[m[32m        0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE,[m
[32m+[m[32m        0x126, 0x1DA, 0x1D6, 0x132, 0x15E,[m
[32m+[m[32m    ];[m
[32m+[m[32m    Code93Reader.ASTERISK_ENCODING = Code93Reader.CHARACTER_ENCODINGS[47];[m
[32m+[m[32m    return Code93Reader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = Code93Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..af33429[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.d.ts[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport UPCEANReader from './UPCEANReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the EAN-13 format.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class EAN13Reader extends UPCEANReader {[m
[32m+[m[32m    private static FIRST_DIGIT_ENCODINGS;[m
[32m+[m[32m    private decodeMiddleCounters;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): {[m
[32m+[m[32m        rowOffset: number;[m
[32m+[m[32m        resultString: string;[m
[32m+[m[32m    };[m
[32m+[m[32m    getBarcodeFormat(): BarcodeFormat;[m
[32m+[m[32m    static determineFirstDigit(resultString: string, lgPatternFound: number): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8b8ce43[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN13Reader.js[m
[36m@@ -0,0 +1,126 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar UPCEANReader_1 = require("./UPCEANReader");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the EAN-13 format.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mvar EAN13Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(EAN13Reader, _super);[m
[32m+[m[32m    function EAN13Reader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    EAN13Reader.prototype.decodeMiddle = function (row, startRange, resultString) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var counters = this.decodeMiddleCounters;[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var rowOffset = startRange[1];[m
[32m+[m[32m        var lgPatternFound = 0;[m
[32m+[m[32m        for (var x = 0; x < 6 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_AND_G_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (bestMatch >= 10) {[m
[32m+[m[32m                lgPatternFound |= 1 << (5 - x);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);[m
[32m+[m[32m        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));[m
[32m+[m[32m        rowOffset = middleRange[1];[m
[32m+[m[32m        for (var x = 0; x < 6 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_2 = (e_2 = void 0, __values(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {[m
[32m+[m[32m                    var counter = counters_2_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return { rowOffset: rowOffset, resultString: resultString };[m
[32m+[m[32m    };[m
[32m+[m[32m    EAN13Reader.prototype.getBarcodeFormat = function () {[m
[32m+[m[32m        return BarcodeFormat_1.default.EAN_13;[m
[32m+[m[32m    };[m
[32m+[m[32m    EAN13Reader.determineFirstDigit = function (resultString, lgPatternFound) {[m
[32m+[m[32m        for (var d = 0; d < 10; d++) {[m
[32m+[m[32m            if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {[m
[32m+[m[32m                resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;[m
[32m+[m[32m                return resultString;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];[m
[32m+[m[32m    return EAN13Reader;[m
[32m+[m[32m}(UPCEANReader_1.default));[m
[32m+[m[32mexports.default = EAN13Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f297112[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport UPCEANReader from './UPCEANReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the EAN-8 format.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class EAN8Reader extends UPCEANReader {[m
[32m+[m[32m    private decodeMiddleCounters;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): {[m
[32m+[m[32m        rowOffset: number;[m
[32m+[m[32m        resultString: string;[m
[32m+[m[32m    };[m
[32m+[m[32m    getBarcodeFormat(): BarcodeFormat;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..606d6a0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/EAN8Reader.js[m
[36m@@ -0,0 +1,108 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar UPCEANReader_1 = require("./UPCEANReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the EAN-8 format.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar EAN8Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(EAN8Reader, _super);[m
[32m+[m[32m    function EAN8Reader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    EAN8Reader.prototype.decodeMiddle = function (row, startRange, resultString) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var counters = this.decodeMiddleCounters;[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var rowOffset = startRange[1];[m
[32m+[m[32m        for (var x = 0; x < 4 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));[m
[32m+[m[32m        rowOffset = middleRange[1];[m
[32m+[m[32m        for (var x = 0; x < 4 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_2 = (e_2 = void 0, __values(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {[m
[32m+[m[32m                    var counter = counters_2_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return { rowOffset: rowOffset, resultString: resultString };[m
[32m+[m[32m    };[m
[32m+[m[32m    EAN8Reader.prototype.getBarcodeFormat = function () {[m
[32m+[m[32m        return BarcodeFormat_1.default.EAN_8;[m
[32m+[m[32m    };[m
[32m+[m[32m    return EAN8Reader;[m
[32m+[m[32m}(UPCEANReader_1.default));[m
[32m+[m[32mexports.default = EAN8Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..622dba7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes ITF barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Tjieco[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ITFReader extends OneDReader {[m
[32m+[m[32m    private static PATTERNS;[m
[32m+[m[32m    private static MAX_AVG_VARIANCE;[m
[32m+[m[32m    private static MAX_INDIVIDUAL_VARIANCE;[m
[32m+[m[32m    private static DEFAULT_ALLOWED_LENGTHS;[m
[32m+[m[32m    private narrowLineWidth;[m
[32m+[m[32m    private static START_PATTERN;[m
[32m+[m[32m    private static END_PATTERN_REVERSED;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    private static decodeMiddle;[m
[32m+[m[32m    private decodeStart;[m
[32m+[m[32m    private validateQuietZone;[m
[32m+[m[32m    private static skipWhiteSpace;[m
[32m+[m[32m    private decodeEnd;[m
[32m+[m[32m    private static findGuardPattern;[m
[32m+[m[32m    private static decodeDigit;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0710029[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/ITFReader.js[m
[36m@@ -0,0 +1,376 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar StringBuilder_1 = require("../util/StringBuilder");[m
[32m+[m[32mvar System_1 = require("../util/System");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Decodes ITF barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Tjieco[m
[32m+[m[32m */[m
[32m+[m[32mvar ITFReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ITFReader, _super);[m
[32m+[m[32m    function ITFReader() {[m
[32m+[m[32m        // private static W = 3; // Pixel width of a 3x wide line[m
[32m+[m[32m        // private static w = 2; // Pixel width of a 2x wide line[m
[32m+[m[32m        // private static N = 1; // Pixed width of a narrow line[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        // Stores the actual narrow line width of the image being decoded.[m
[32m+[m[32m        _this.narrowLineWidth = -1;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    // See ITFWriter.PATTERNS[m
[32m+[m[32m    /*[m
[32m+[m[41m  [m
[32m+[m[32m    /!**[m
[32m+[m[32m     * Patterns of Wide / Narrow lines to indicate each digit[m
[32m+[m[32m     *!/[m
[32m+[m[32m    */[m
[32m+[m[32m    ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        // Find out where the Middle section (payload) starts & ends[m
[32m+[m[32m        var startRange = this.decodeStart(row);[m
[32m+[m[32m        var endRange = this.decodeEnd(row);[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);[m
[32m+[m[32m        var resultString = result.toString();[m
[32m+[m[32m        var allowedLengths = null;[m
[32m+[m[32m        if (hints != null) {[m
[32m+[m[32m            allowedLengths = hints.get(DecodeHintType_1.default.ALLOWED_LENGTHS);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (allowedLengths == null) {[m
[32m+[m[32m            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;[m
[32m+[m[32m        }[m
[32m+[m[32m        // To avoid false positives with 2D barcodes (and other patterns), make[m
[32m+[m[32m        // an assumption that the decoded string must be a 'standard' length if it's short[m
[32m+[m[32m        var length = resultString.length;[m
[32m+[m[32m        var lengthOK = false;[m
[32m+[m[32m        var maxAllowedLength = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {[m
[32m+[m[32m                var value = allowedLengths_1_1.value;[m
[32m+[m[32m                if (length === value) {[m
[32m+[m[32m                    lengthOK = true;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (value > maxAllowedLength) {[m
[32m+[m[32m                    maxAllowedLength = value;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!lengthOK && length > maxAllowedLength) {[m
[32m+[m[32m            lengthOK = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!lengthOK) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var points = [new ResultPoint_1.default(startRange[1], rowNumber), new ResultPoint_1.default(endRange[0], rowNumber)];[m
[32m+[m[32m        var resultReturn = new Result_1.default(resultString, null, // no natural byte representation for these barcodes[m
[32m+[m[32m        0, points, BarcodeFormat_1.default.ITF, new Date().getTime());[m
[32m+[m[32m        return resultReturn;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    /!**[m
[32m+[m[32m     * @param row          row of black/white values to search[m
[32m+[m[32m     * @param payloadStart offset of start pattern[m
[32m+[m[32m     * @param resultString {@link StringBuilder} to append decoded chars to[m
[32m+[m[32m     * @throws NotFoundException if decoding could not complete successfully[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {[m
[32m+[m[32m        // Digits are interleaved in pairs - 5 black lines for one digit, and the[m
[32m+[m[32m        // 5[m
[32m+[m[32m        // interleaved white lines for the second digit.[m
[32m+[m[32m        // Therefore, need to scan 10 lines and then[m
[32m+[m[32m        // split these into two arrays[m
[32m+[m[32m        var counterDigitPair = new Int32Array(10); // 10[m
[32m+[m[32m        var counterBlack = new Int32Array(5); // 5[m
[32m+[m[32m        var counterWhite = new Int32Array(5); // 5[m
[32m+[m[32m        counterDigitPair.fill(0);[m
[32m+[m[32m        counterBlack.fill(0);[m
[32m+[m[32m        counterWhite.fill(0);[m
[32m+[m[32m        while (payloadStart < payloadEnd) {[m
[32m+[m[32m            // Get 10 runs of black/white.[m
[32m+[m[32m            OneDReader_1.default.recordPattern(row, payloadStart, counterDigitPair);[m
[32m+[m[32m            // Split them into each array[m
[32m+[m[32m            for (var k = 0; k < 5; k++) {[m
[32m+[m[32m                var twoK = 2 * k;[m
[32m+[m[32m                counterBlack[k] = counterDigitPair[twoK];[m
[32m+[m[32m                counterWhite[k] = counterDigitPair[twoK + 1];[m
[32m+[m[32m            }[m
[32m+[m[32m            var bestMatch = ITFReader.decodeDigit(counterBlack);[m
[32m+[m[32m            resultString.append(bestMatch.toString());[m
[32m+[m[32m            bestMatch = this.decodeDigit(counterWhite);[m
[32m+[m[32m            resultString.append(bestMatch.toString());[m
[32m+[m[32m            counterDigitPair.forEach(function (counterDigit) {[m
[32m+[m[32m                payloadStart += counterDigit;[m
[32m+[m[32m            });[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /*/!**[m
[32m+[m[32m     * Identify where the start of the middle / payload section starts.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @return Array, containing index of start of 'start block' and end of[m
[32m+[m[32m     *         'start block'[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.prototype.decodeStart = function (row) {[m
[32m+[m[32m        var endStart = ITFReader.skipWhiteSpace(row);[m
[32m+[m[32m        var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);[m
[32m+[m[32m        // Determine the width of a narrow line in pixels. We can do this by[m
[32m+[m[32m        // getting the width of the start pattern and dividing by 4 because its[m
[32m+[m[32m        // made up of 4 narrow lines.[m
[32m+[m[32m        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;[m
[32m+[m[32m        this.validateQuietZone(row, startPattern[0]);[m
[32m+[m[32m        return startPattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*/!**[m
[32m+[m[32m     * The start & end patterns must be pre/post fixed by a quiet zone. This[m
[32m+[m[32m     * zone must be at least 10 times the width of a narrow line.  Scan back until[m
[32m+[m[32m     * we either get to the start of the barcode or match the necessary number of[m
[32m+[m[32m     * quiet zone pixels.[m
[32m+[m[32m     *[m
[32m+[m[32m     * Note: Its assumed the row is reversed when using this method to find[m
[32m+[m[32m     * quiet zone after the end pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * ref: http://www.barcode-1.net/i25code.html[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row bit array representing the scanned barcode.[m
[32m+[m[32m     * @param startPattern index into row of the start or end pattern.[m
[32m+[m[32m     * @throws NotFoundException if the quiet zone cannot be found[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.prototype.validateQuietZone = function (row, startPattern) {[m
[32m+[m[32m        var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone[m
[32m+[m[32m        // if there are not so many pixel at all let's try as many as possible[m
[32m+[m[32m        quietCount = quietCount < startPattern ? quietCount : startPattern;[m
[32m+[m[32m        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {[m
[32m+[m[32m            if (row.get(i)) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            quietCount--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (quietCount !== 0) {[m
[32m+[m[32m            // Unable to find the necessary number of quiet zone pixels.[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    /!**[m
[32m+[m[32m     * Skip all whitespace until we get to the first black line.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @return index of the first black line.[m
[32m+[m[32m     * @throws NotFoundException Throws exception if no black lines are found in the row[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.skipWhiteSpace = function (row) {[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var endStart = row.getNextSet(0);[m
[32m+[m[32m        if (endStart === width) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return endStart;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*/!**[m
[32m+[m[32m     * Identify where the end of the middle / payload section ends.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row of black/white values to search[m
[32m+[m[32m     * @return Array, containing index of start of 'end block' and end of 'end[m
[32m+[m[32m     *         block'[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.prototype.decodeEnd = function (row) {[m
[32m+[m[32m        // For convenience, reverse the row and then[m
[32m+[m[32m        // search from 'the start' for the end block[m
[32m+[m[32m        row.reverse();[m
[32m+[m[32m        try {[m
[32m+[m[32m            var endStart = ITFReader.skipWhiteSpace(row);[m
[32m+[m[32m            var endPattern = void 0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (error) {[m
[32m+[m[32m                if (error instanceof NotFoundException_1.default) {[m
[32m+[m[32m                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            // The start & end patterns must be pre/post fixed by a quiet zone. This[m
[32m+[m[32m            // zone must be at least 10 times the width of a narrow line.[m
[32m+[m[32m            // ref: http://www.barcode-1.net/i25code.html[m
[32m+[m[32m            this.validateQuietZone(row, endPattern[0]);[m
[32m+[m[32m            // Now recalculate the indices of where the 'endblock' starts & stops to[m
[32m+[m[32m            // accommodate[m
[32m+[m[32m            // the reversed nature of the search[m
[32m+[m[32m            var temp = endPattern[0];[m
[32m+[m[32m            endPattern[0] = row.getSize() - endPattern[1];[m
[32m+[m[32m            endPattern[1] = row.getSize() - temp;[m
[32m+[m[32m            return endPattern;[m
[32m+[m[32m        }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            // Put the row back the right way.[m
[32m+[m[32m            row.reverse();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    /!**[m
[32m+[m[32m     * @param row       row of black/white values to search[m
[32m+[m[32m     * @param rowOffset position to start search[m
[32m+[m[32m     * @param pattern   pattern of counts of number of black and white pixels that are[m
[32m+[m[32m     *                  being searched for as a pattern[m
[32m+[m[32m     * @return start/end horizontal offset of guard pattern, as an array of two[m
[32m+[m[32m     *         ints[m
[32m+[m[32m     * @throws NotFoundException if pattern is not found[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.findGuardPattern = function (row, rowOffset, pattern) {[m
[32m+[m[32m        var patternLength = pattern.length;[m
[32m+[m[32m        var counters = new Int32Array(patternLength);[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        counters.fill(0);[m
[32m+[m[32m        for (var x = rowOffset; x < width; x++) {[m
[32m+[m[32m            if (row.get(x) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === patternLength - 1) {[m
[32m+[m[32m                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {[m
[32m+[m[32m                        return [patternStart, x];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);[m
[32m+[m[32m                    counters[counterPosition - 1] = 0;[m
[32m+[m[32m                    counters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /*/!**[m
[32m+[m[32m     * Attempts to decode a sequence of ITF black/white lines into single[m
[32m+[m[32m     * digit.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param counters the counts of runs of observed black/white/black/... values[m
[32m+[m[32m     * @return The decoded digit[m
[32m+[m[32m     * @throws NotFoundException if digit cannot be decoded[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.decodeDigit = function (counters) {[m
[32m+[m[32m        var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept[m
[32m+[m[32m        var bestMatch = -1;[m
[32m+[m[32m        var max = ITFReader.PATTERNS.length;[m
[32m+[m[32m        for (var i = 0; i < max; i++) {[m
[32m+[m[32m            var pattern = ITFReader.PATTERNS[i];[m
[32m+[m[32m            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);[m
[32m+[m[32m            if (variance < bestVariance) {[m
[32m+[m[32m                bestVariance = variance;[m
[32m+[m[32m                bestMatch = i;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (variance === bestVariance) {[m
[32m+[m[32m                // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match[m
[32m+[m[32m                bestMatch = -1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bestMatch >= 0) {[m
[32m+[m[32m            return bestMatch % 10;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    ITFReader.PATTERNS = [[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 2, 1]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 2, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 2, 1, 2]),[m
[32m+[m[32m        Int32Array.from([2, 1, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 2, 2, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 2, 2]),[m
[32m+[m[32m        Int32Array.from([2, 1, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 2, 1, 2, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 3, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 1, 3]),[m
[32m+[m[32m        Int32Array.from([3, 3, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3, 1, 3]),[m
[32m+[m[32m        Int32Array.from([3, 1, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 3, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 3, 3]),[m
[32m+[m[32m        Int32Array.from([3, 1, 1, 3, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 1, 3, 1]) // 9[m
[32m+[m[32m    ];[m
[32m+[m[32m    ITFReader.MAX_AVG_VARIANCE = 0.38;[m
[32m+[m[32m    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;[m
[32m+[m[32m    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/[m
[32m+[m[32m    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];[m
[32m+[m[32m    /*/!**[m
[32m+[m[32m     * Start/end guard pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * Note: The end pattern is reversed because the row is reversed before[m
[32m+[m[32m     * searching for the END_PATTERN[m
[32m+[m[32m     *!/*/[m
[32m+[m[32m    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);[m
[32m+[m[32m    ITFReader.END_PATTERN_REVERSED = [[m
[32m+[m[32m        Int32Array.from([1, 1, 2]),[m
[32m+[m[32m        Int32Array.from([1, 1, 3]) // 3x[m
[32m+[m[32m    ];[m
[32m+[m[32m    return ITFReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = ITFReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5284885[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.d.ts[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Daniel Switkin <dswitkin@google.com>[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MultiFormatOneDReader extends OneDReader {[m
[32m+[m[32m    private readers;[m
[32m+[m[32m    constructor(hints?: Map<DecodeHintType, any>);[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fad58d4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatOneDReader.js[m
[36m@@ -0,0 +1,117 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar Code128Reader_1 = require("./Code128Reader");[m
[32m+[m[32mvar Code39Reader_1 = require("./Code39Reader");[m
[32m+[m[32mvar Code93Reader_1 = require("./Code93Reader");[m
[32m+[m[32mvar ITFReader_1 = require("./ITFReader");[m
[32m+[m[32mvar MultiFormatUPCEANReader_1 = require("./MultiFormatUPCEANReader");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar CodaBarReader_1 = require("./CodaBarReader");[m
[32m+[m[32mvar RSSExpandedReader_1 = require("./rss/expanded/RSSExpandedReader");[m
[32m+[m[32mvar RSS14Reader_1 = require("./rss/RSS14Reader");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Daniel Switkin <dswitkin@google.com>[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar MultiFormatOneDReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(MultiFormatOneDReader, _super);[m
[32m+[m[32m    function MultiFormatOneDReader(hints) {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.readers = [];[m
[32m+[m[32m        var possibleFormats = !hints ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);[m
[32m+[m[32m        var useCode39CheckDigit = hints && hints.get(DecodeHintType_1.default.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;[m
[32m+[m[32m        var useCode39ExtendedMode = hints && hints.get(DecodeHintType_1.default.ENABLE_CODE_39_EXTENDED_MODE) !== undefined;[m
[32m+[m[32m        if (possibleFormats) {[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.EAN_13) ||[m
[32m+[m[32m                possibleFormats.includes(BarcodeFormat_1.default.UPC_A) ||[m
[32m+[m[32m                possibleFormats.includes(BarcodeFormat_1.default.EAN_8) ||[m
[32m+[m[32m                possibleFormats.includes(BarcodeFormat_1.default.UPC_E)) {[m
[32m+[m[32m                _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_39)) {[m
[32m+[m[32m                _this.readers.push(new Code39Reader_1.default(useCode39CheckDigit, useCode39ExtendedMode));[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_93)) {[m
[32m+[m[32m                _this.readers.push(new Code93Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_128)) {[m
[32m+[m[32m                _this.readers.push(new Code128Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.ITF)) {[m
[32m+[m[32m                _this.readers.push(new ITFReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.CODABAR)) {[m
[32m+[m[32m                _this.readers.push(new CodaBarReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.RSS_14)) {[m
[32m+[m[32m                _this.readers.push(new RSS14Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.includes(BarcodeFormat_1.default.RSS_EXPANDED)) {[m
[32m+[m[32m                console.warn('RSS Expanded reader IS NOT ready for production yet! use at your own risk.');[m
[32m+[m[32m                _this.readers.push(new RSSExpandedReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (_this.readers.length === 0) {[m
[32m+[m[32m            _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));[m
[32m+[m[32m            _this.readers.push(new Code39Reader_1.default());[m
[32m+[m[32m            // this.readers.push(new CodaBarReader());[m
[32m+[m[32m            _this.readers.push(new Code93Reader_1.default());[m
[32m+[m[32m            _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));[m
[32m+[m[32m            _this.readers.push(new Code128Reader_1.default());[m
[32m+[m[32m            _this.readers.push(new ITFReader_1.default());[m
[32m+[m[32m            _this.readers.push(new RSS14Reader_1.default());[m
[32m+[m[32m            // this.readers.push(new RSSExpandedReader());[m
[32m+[m[32m        }[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    MultiFormatOneDReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        for (var i = 0; i < this.readers.length; i++) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                return this.readers[i].decodeRow(rowNumber, row, hints);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (re) {[m
[32m+[m[32m                // continue[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    MultiFormatOneDReader.prototype.reset = function () {[m
[32m+[m[32m        this.readers.forEach(function (reader) { return reader.reset(); });[m
[32m+[m[32m    };[m
[32m+[m[32m    return MultiFormatOneDReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = MultiFormatOneDReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..47f5401[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport OneDReader from './OneDReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to[m
[32m+[m[32m * read all such formats, it is most efficient to use this implementation rather than invoke[m
[32m+[m[32m * individual readers.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MultiFormatUPCEANReader extends OneDReader {[m
[32m+[m[32m    private readers;[m
[32m+[m[32m    constructor(hints?: Map<DecodeHintType, any>);[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2e07c95[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/MultiFormatUPCEANReader.js[m
[36m@@ -0,0 +1,153 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar OneDReader_1 = require("./OneDReader");[m
[32m+[m[32mvar EAN13Reader_1 = require("./EAN13Reader");[m
[32m+[m[32mvar EAN8Reader_1 = require("./EAN8Reader");[m
[32m+[m[32mvar UPCAReader_1 = require("./UPCAReader");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar UPCEReader_1 = require("./UPCEReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to[m
[32m+[m[32m * read all such formats, it is most efficient to use this implementation rather than invoke[m
[32m+[m[32m * individual readers.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar MultiFormatUPCEANReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(MultiFormatUPCEANReader, _super);[m
[32m+[m[32m    function MultiFormatUPCEANReader(hints) {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);[m
[32m+[m[32m        var readers = [];[m
[32m+[m[32m        if (possibleFormats != null) {[m
[32m+[m[32m            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_13) > -1) {[m
[32m+[m[32m                readers.push(new EAN13Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.indexOf(BarcodeFormat_1.default.UPC_A) > -1) {[m
[32m+[m[32m                readers.push(new UPCAReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_8) > -1) {[m
[32m+[m[32m                readers.push(new EAN8Reader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (possibleFormats.indexOf(BarcodeFormat_1.default.UPC_E) > -1) {[m
[32m+[m[32m                readers.push(new UPCEReader_1.default());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (readers.length === 0) {[m
[32m+[m[32m            readers.push(new EAN13Reader_1.default());[m
[32m+[m[32m            readers.push(new UPCAReader_1.default());[m
[32m+[m[32m            readers.push(new EAN8Reader_1.default());[m
[32m+[m[32m            readers.push(new UPCEReader_1.default());[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.readers = readers;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var reader = _c.value;[m
[32m+[m[32m                try {[m
[32m+[m[32m                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);[m
[32m+[m[32m                    var result = reader.decodeRow(rowNumber, row, hints);[m
[32m+[m[32m                    // Special case: a 12-digit code encoded in UPC-A is identical to a "0"[m
[32m+[m[32m                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,[m
[32m+[m[32m                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with "0".[m
[32m+[m[32m                    // Individually these are correct and their readers will both read such a code[m
[32m+[m[32m                    // and correctly call it EAN-13, or UPC-A, respectively.[m
[32m+[m[32m                    //[m
[32m+[m[32m                    // In this case, if we've been looking for both types, we'd like to call it[m
[32m+[m[32m                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read[m
[32m+[m[32m                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A[m
[32m+[m[32m                    // result if appropriate.[m
[32m+[m[32m                    //[m
[32m+[m[32m                    // But, don't return UPC-A if UPC-A was not a requested format![m
[32m+[m[32m                    var ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat_1.default.EAN_13 &&[m
[32m+[m[32m                        result.getText().charAt(0) === '0';[m
[32m+[m[32m                    // @SuppressWarnings("unchecked")[m
[32m+[m[32m                    var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);[m
[32m+[m[32m                    var canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat_1.default.UPC_A);[m
[32m+[m[32m                    if (ean13MayBeUPCA && canReturnUPCA) {[m
[32m+[m[32m                        var rawBytes = result.getRawBytes();[m
[32m+[m[32m                        // Transfer the metadata across[m
[32m+[m[32m                        var resultUPCA = new Result_1.default(result.getText().substring(1), rawBytes, (rawBytes ? rawBytes.length : null), result.getResultPoints(), BarcodeFormat_1.default.UPC_A);[m
[32m+[m[32m                        resultUPCA.putAllMetadata(result.getResultMetadata());[m
[32m+[m[32m                        return resultUPCA;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return result;[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (err) {[m
[32m+[m[32m                    // continue;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    MultiFormatUPCEANReader.prototype.reset = function () {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var reader = _c.value;[m
[32m+[m[32m                reader.reset();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return MultiFormatUPCEANReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = MultiFormatUPCEANReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e957de2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.d.ts[m
[36m@@ -0,0 +1,70 @@[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Reader from '../Reader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates functionality and implementation that is common to all families[m
[32m+[m[32m * of one-dimensional barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default abstract class OneDReader implements Reader {[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * We're going to examine rows from the middle outward, searching alternately above and below the[m
[32m+[m[32m     * middle, and farther out each time. rowStep is the number of rows between each successive[m
[32m+[m[32m     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then[m
[32m+[m[32m     * middle + rowStep, then middle - (2 * rowStep), etc.[m
[32m+[m[32m     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily[m
[32m+[m[32m     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the[m
[32m+[m[32m     * image if "trying harder".[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The image to decode[m
[32m+[m[32m     * @param hints Any hints that were requested[m
[32m+[m[32m     * @return The contents of the decoded barcode[m
[32m+[m[32m     * @throws NotFoundException Any spontaneous errors which occur[m
[32m+[m[32m     */[m
[32m+[m[32m    private doDecode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Records the size of successive runs of white and black pixels in a row, starting at a given point.[m
[32m+[m[32m     * The values are recorded in the given array, and the number of runs recorded is equal to the size[m
[32m+[m[32m     * of the array. If the row starts on a white pixel at the given start point, then the first count[m
[32m+[m[32m     * recorded is the run of white pixels starting from that point; likewise it is the count of a run[m
[32m+[m[32m     * of black pixels if the row begin on a black pixels at that point.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row to count from[m
[32m+[m[32m     * @param start offset into row to start at[m
[32m+[m[32m     * @param counters array into which to record counts[m
[32m+[m[32m     * @throws NotFoundException if counters cannot be filled entirely from row before running out[m
[32m+[m[32m     *  of pixels[m
[32m+[m[32m     */[m
[32m+[m[32m    protected static recordPattern(row: BitArray, start: number, counters: Int32Array): void;[m
[32m+[m[32m    protected static recordPatternInReverse(row: BitArray, start: number, counters: Int32Array): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines how closely a set of observed counts of runs of black/white values matches a given[m
[32m+[m[32m     * target pattern. This is reported as the ratio of the total variance from the expected pattern[m
[32m+[m[32m     * proportions across all pattern elements, to the length of the pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param counters observed counters[m
[32m+[m[32m     * @param pattern expected pattern[m
[32m+[m[32m     * @param maxIndividualVariance The most any counter can differ before we give up[m
[32m+[m[32m     * @return ratio of total variance between counters and pattern compared to total pattern size[m
[32m+[m[32m     */[m
[32m+[m[32m    protected static patternMatchVariance(counters: Int32Array, pattern: Int32Array, maxIndividualVariance: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Attempts to decode a one-dimensional barcode format given a single row of[m
[32m+[m[32m     * an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rowNumber row number from top of the row[m
[32m+[m[32m     * @param row the black/white pixel data of the row[m
[32m+[m[32m     * @param hints decode hints[m
[32m+[m[32m     * @return {@link Result} containing encoded string and start/end of barcode[m
[32m+[m[32m     * @throws NotFoundException if no potential barcode is found[m
[32m+[m[32m     * @throws ChecksumException if a potential barcode is found but does not pass its checksum[m
[32m+[m[32m     * @throws FormatException if a potential barcode is found but format is invalid[m
[32m+[m[32m     */[m
[32m+[m[32m    abstract decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..26ed5c6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/OneDReader.js[m
[36m@@ -0,0 +1,265 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BitArray_1 = require("../common/BitArray");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates functionality and implementation that is common to all families[m
[32m+[m[32m * of one-dimensional barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar OneDReader = /** @class */ (function () {[m
[32m+[m[32m    function OneDReader() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /*[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {[m
[32m+[m[32m      return decode(image, null);[m
[32m+[m[32m    }[m
[32m+[m[32m    */[m
[32m+[m[32m    // Note that we don't try rotation without the try harder flag, even if rotation was supported.[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    OneDReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            return this.doDecode(image, hints);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (nfe) {[m
[32m+[m[32m            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);[m
[32m+[m[32m            if (tryHarder && image.isRotateSupported()) {[m
[32m+[m[32m                var rotatedImage = image.rotateCounterClockwise();[m
[32m+[m[32m                var result = this.doDecode(rotatedImage, hints);[m
[32m+[m[32m                // Record that we found it rotated 90 degrees CCW / 270 degrees CW[m
[32m+[m[32m                var metadata = result.getResultMetadata();[m
[32m+[m[32m                var orientation_1 = 270;[m
[32m+[m[32m                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {[m
[32m+[m[32m                    // But if we found it reversed in doDecode(), add in that result here:[m
[32m+[m[32m                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);[m
[32m+[m[32m                }[m
[32m+[m[32m                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);[m
[32m+[m[32m                // Update result points[m
[32m+[m[32m                var points = result.getResultPoints();[m
[32m+[m[32m                if (points !== null) {[m
[32m+[m[32m                    var height = rotatedImage.getHeight();[m
[32m+[m[32m                    for (var i = 0; i < points.length; i++) {[m
[32m+[m[32m                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return result;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    OneDReader.prototype.reset = function () {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * We're going to examine rows from the middle outward, searching alternately above and below the[m
[32m+[m[32m     * middle, and farther out each time. rowStep is the number of rows between each successive[m
[32m+[m[32m     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then[m
[32m+[m[32m     * middle + rowStep, then middle - (2 * rowStep), etc.[m
[32m+[m[32m     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily[m
[32m+[m[32m     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the[m
[32m+[m[32m     * image if "trying harder".[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image The image to decode[m
[32m+[m[32m     * @param hints Any hints that were requested[m
[32m+[m[32m     * @return The contents of the decoded barcode[m
[32m+[m[32m     * @throws NotFoundException Any spontaneous errors which occur[m
[32m+[m[32m     */[m
[32m+[m[32m    OneDReader.prototype.doDecode = function (image, hints) {[m
[32m+[m[32m        var width = image.getWidth();[m
[32m+[m[32m        var height = image.getHeight();[m
[32m+[m[32m        var row = new BitArray_1.default(width);[m
[32m+[m[32m        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);[m
[32m+[m[32m        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));[m
[32m+[m[32m        var maxLines;[m
[32m+[m[32m        if (tryHarder) {[m
[32m+[m[32m            maxLines = height; // Look at the whole image, not just the center[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image[m
[32m+[m[32m        }[m
[32m+[m[32m        var middle = Math.trunc(height / 2);[m
[32m+[m[32m        for (var x = 0; x < maxLines; x++) {[m
[32m+[m[32m            // Scanning from the middle out. Determine which row we're looking at next:[m
[32m+[m[32m            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);[m
[32m+[m[32m            var isAbove = (x & 0x01) === 0; // i.e. is x even?[m
[32m+[m[32m            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);[m
[32m+[m[32m            if (rowNumber < 0 || rowNumber >= height) {[m
[32m+[m[32m                // Oops, if we run off the top or bottom, stop[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Estimate black point for this row and load it:[m
[32m+[m[32m            try {[m
[32m+[m[32m                row = image.getBlackRow(rowNumber, row);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (ignored) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var _loop_1 = function (attempt) {[m
[32m+[m[32m                if (attempt === 1) { // trying again?[m
[32m+[m[32m                    row.reverse(); // reverse the row and continue[m
[32m+[m[32m                    // This means we will only ever draw result points *once* in the life of this method[m
[32m+[m[32m                    // since we want to avoid drawing the wrong points after flipping the row, and,[m
[32m+[m[32m                    // don't want to clutter with noise from every single row scan -- just the scans[m
[32m+[m[32m                    // that start on the center line.[m
[32m+[m[32m                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {[m
[32m+[m[32m                        var newHints_1 = new Map();[m
[32m+[m[32m                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });[m
[32m+[m[32m                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);[m
[32m+[m[32m                        hints = newHints_1;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                try {[m
[32m+[m[32m                    // Look for a barcode[m
[32m+[m[32m                    var result = this_1.decodeRow(rowNumber, row, hints);[m
[32m+[m[32m                    // We found our barcode[m
[32m+[m[32m                    if (attempt === 1) {[m
[32m+[m[32m                        // But it was upside down, so note that[m
[32m+[m[32m                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);[m
[32m+[m[32m                        // And remember to flip the result points horizontally.[m
[32m+[m[32m                        var points = result.getResultPoints();[m
[32m+[m[32m                        if (points !== null) {[m
[32m+[m[32m                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());[m
[32m+[m[32m                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return { value: result };[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (re) {[m
[32m+[m[32m                    // continue -- just couldn't decode this row[m
[32m+[m[32m                }[m
[32m+[m[32m            };[m
[32m+[m[32m            var this_1 = this;[m
[32m+[m[32m            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to[m
[32m+[m[32m            // handle decoding upside down barcodes.[m
[32m+[m[32m            for (var attempt = 0; attempt < 2; attempt++) {[m
[32m+[m[32m                var state_1 = _loop_1(attempt);[m
[32m+[m[32m                if (typeof state_1 === "object")[m
[32m+[m[32m                    return state_1.value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Records the size of successive runs of white and black pixels in a row, starting at a given point.[m
[32m+[m[32m     * The values are recorded in the given array, and the number of runs recorded is equal to the size[m
[32m+[m[32m     * of the array. If the row starts on a white pixel at the given start point, then the first count[m
[32m+[m[32m     * recorded is the run of white pixels starting from that point; likewise it is the count of a run[m
[32m+[m[32m     * of black pixels if the row begin on a black pixels at that point.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param row row to count from[m
[32m+[m[32m     * @param start offset into row to start at[m
[32m+[m[32m     * @param counters array into which to record counts[m
[32m+[m[32m     * @throws NotFoundException if counters cannot be filled entirely from row before running out[m
[32m+[m[32m     *  of pixels[m
[32m+[m[32m     */[m
[32m+[m[32m    OneDReader.recordPattern = function (row, start, counters) {[m
[32m+[m[32m        var numCounters = counters.length;[m
[32m+[m[32m        for (var index = 0; index < numCounters; index++)[m
[32m+[m[32m            counters[index] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        if (start >= end) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var isWhite = !row.get(start);[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var i = start;[m
[32m+[m[32m        while (i < end) {[m
[32m+[m[32m            if (row.get(i) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (++counterPosition === numCounters) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counters[counterPosition] = 1;[m
[32m+[m[32m                    isWhite = !isWhite;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we read fully the last section of pixels and filled up our counters -- or filled[m
[32m+[m[32m        // the last counter but ran off the side of the image, OK. Otherwise, a problem.[m
[32m+[m[32m        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    OneDReader.recordPatternInReverse = function (row, start, counters) {[m
[32m+[m[32m        // This could be more efficient I guess[m
[32m+[m[32m        var numTransitionsLeft = counters.length;[m
[32m+[m[32m        var last = row.get(start);[m
[32m+[m[32m        while (start > 0 && numTransitionsLeft >= 0) {[m
[32m+[m[32m            if (row.get(--start) !== last) {[m
[32m+[m[32m                numTransitionsLeft--;[m
[32m+[m[32m                last = !last;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (numTransitionsLeft >= 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        OneDReader.recordPattern(row, start + 1, counters);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines how closely a set of observed counts of runs of black/white values matches a given[m
[32m+[m[32m     * target pattern. This is reported as the ratio of the total variance from the expected pattern[m
[32m+[m[32m     * proportions across all pattern elements, to the length of the pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param counters observed counters[m
[32m+[m[32m     * @param pattern expected pattern[m
[32m+[m[32m     * @param maxIndividualVariance The most any counter can differ before we give up[m
[32m+[m[32m     * @return ratio of total variance between counters and pattern compared to total pattern size[m
[32m+[m[32m     */[m
[32m+[m[32m    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {[m
[32m+[m[32m        var numCounters = counters.length;[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        var patternLength = 0;[m
[32m+[m[32m        for (var i = 0; i < numCounters; i++) {[m
[32m+[m[32m            total += counters[i];[m
[32m+[m[32m            patternLength += pattern[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (total < patternLength) {[m
[32m+[m[32m            // If we don't even have one pixel per unit of bar width, assume this is too small[m
[32m+[m[32m            // to reliably match, so fail:[m
[32m+[m[32m            return Number.POSITIVE_INFINITY;[m
[32m+[m[32m        }[m
[32m+[m[32m        var unitBarWidth = total / patternLength;[m
[32m+[m[32m        maxIndividualVariance *= unitBarWidth;[m
[32m+[m[32m        var totalVariance = 0.0;[m
[32m+[m[32m        for (var x = 0; x < numCounters; x++) {[m
[32m+[m[32m            var counter = counters[x];[m
[32m+[m[32m            var scaledPattern = pattern[x] * unitBarWidth;[m
[32m+[m[32m            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;[m
[32m+[m[32m            if (variance > maxIndividualVariance) {[m
[32m+[m[32m                return Number.POSITIVE_INFINITY;[m
[32m+[m[32m            }[m
[32m+[m[32m            totalVariance += variance;[m
[32m+[m[32m        }[m
[32m+[m[32m        return totalVariance / total;[m
[32m+[m[32m    };[m
[32m+[m[32m    return OneDReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = OneDReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..72dae10[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.d.ts[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport UPCEANReader from './UPCEANReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates functionality and implementation that is common to all families[m
[32m+[m[32m * of one-dimensional barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author sam2332 (Sam Rudloff)[m
[32m+[m[32m *[m
[32m+[m[32m * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java[m
[32m+[m[32m *[m
[32m+[m[32m * @experimental[m
[32m+[m[32m */[m
[32m+[m[32mexport default class UPCAReader extends UPCEANReader {[m
[32m+[m[32m    private readonly ean13Reader;[m
[32m+[m[32m    getBarcodeFormat(): BarcodeFormat;[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): {[m
[32m+[m[32m        rowOffset: number;[m
[32m+[m[32m        resultString: string;[m
[32m+[m[32m    };[m
[32m+[m[32m    maybeReturnResult(result: Result): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..833cdaf[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCAReader.js[m
[36m@@ -0,0 +1,91 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.oned {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar EAN13Reader_1 = require("./EAN13Reader");[m
[32m+[m[32mvar UPCEANReader_1 = require("./UPCEANReader");[m
[32m+[m[32m/**[m
[32m+[m[32m * Encapsulates functionality and implementation that is common to all families[m
[32m+[m[32m * of one-dimensional barcodes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author sam2332 (Sam Rudloff)[m
[32m+[m[32m *[m
[32m+[m[32m * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java[m
[32m+[m[32m *[m
[32m+[m[32m * @experimental[m
[32m+[m[32m */[m
[32m+[m[32mvar UPCAReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(UPCAReader, _super);[m
[32m+[m[32m    function UPCAReader() {[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        _this.ean13Reader = new EAN13Reader_1.default();[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCAReader.prototype.getBarcodeFormat = function () {[m
[32m+[m[32m        return BarcodeFormat_1.default.UPC_A;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Note that we don't try rotation without the try harder flag, even if rotation was supported.[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCAReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        return this.maybeReturnResult(this.ean13Reader.decode(image));[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCAReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCAReader.prototype.decodeMiddle = function (row, startRange, resultString) {[m
[32m+[m[32m        return this.ean13Reader.decodeMiddle(row, startRange, resultString);[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCAReader.prototype.maybeReturnResult = function (result) {[m
[32m+[m[32m        var text = result.getText();[m
[32m+[m[32m        if (text.charAt(0) === '0') {[m
[32m+[m[32m            var upcaResult = new Result_1.default(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat_1.default.UPC_A);[m
[32m+[m[32m            if (result.getResultMetadata() != null) {[m
[32m+[m[32m                upcaResult.putAllMetadata(result.getResultMetadata());[m
[32m+[m[32m            }[m
[32m+[m[32m            return upcaResult;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCAReader.prototype.reset = function () {[m
[32m+[m[32m        this.ean13Reader.reset();[m
[32m+[m[32m    };[m
[32m+[m[32m    return UPCAReader;[m
[32m+[m[32m}(UPCEANReader_1.default));[m
[32m+[m[32mexports.default = UPCAReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4abae40[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport ResultMetadataType from '../ResultMetadataType';[m
[32m+[m[32m/**[m
[32m+[m[32m * @see UPCEANExtension5Support[m
[32m+[m[32m */[m
[32m+[m[32mexport default class UPCEANExtension2Support {[m
[32m+[m[32m    private decodeMiddleCounters;[m
[32m+[m[32m    private decodeRowStringBuffer;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, extensionStartRange: Int32Array): Result;[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): number;[m
[32m+[m[32m    static parseExtensionString(raw: string): Map<ResultMetadataType, number>;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1862a0a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension2Support.js[m
[36m@@ -0,0 +1,109 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright (C) 2012 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar AbstractUPCEANReader_1 = require("./AbstractUPCEANReader");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @see UPCEANExtension5Support[m
[32m+[m[32m */[m
[32m+[m[32mvar UPCEANExtension2Support = /** @class */ (function () {[m
[32m+[m[32m    function UPCEANExtension2Support() {[m
[32m+[m[32m        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);[m
[32m+[m[32m        this.decodeRowStringBuffer = '';[m
[32m+[m[32m    }[m
[32m+[m[32m    UPCEANExtension2Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {[m
[32m+[m[32m        var result = this.decodeRowStringBuffer;[m
[32m+[m[32m        var end = this.decodeMiddle(row, extensionStartRange, result);[m
[32m+[m[32m        var resultString = result.toString();[m
[32m+[m[32m        var extensionData = UPCEANExtension2Support.parseExtensionString(resultString);[m
[32m+[m[32m        var resultPoints = [[m
[32m+[m[32m            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),[m
[32m+[m[32m            new ResultPoint_1.default(end, rowNumber)[m
[32m+[m[32m        ];[m
[32m+[m[32m        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());[m
[32m+[m[32m        if (extensionData != null) {[m
[32m+[m[32m            extensionResult.putAllMetadata(extensionData);[m
[32m+[m[32m        }[m
[32m+[m[32m        return extensionResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension2Support.prototype.decodeMiddle = function (row, startRange, resultString) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var counters = this.decodeMiddleCounters;[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var rowOffset = startRange[1];[m
[32m+[m[32m        var checkParity = 0;[m
[32m+[m[32m        for (var x = 0; x < 2 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (bestMatch >= 10) {[m
[32m+[m[32m                checkParity |= 1 << (1 - x);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (x !== 1) {[m
[32m+[m[32m                // Read off separator if not last[m
[32m+[m[32m                rowOffset = row.getNextSet(rowOffset);[m
[32m+[m[32m                rowOffset = row.getNextUnset(rowOffset);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (resultString.length !== 2) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (parseInt(resultString.toString()) % 4 !== checkParity) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return rowOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension2Support.parseExtensionString = function (raw) {[m
[32m+[m[32m        if (raw.length !== 2) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new Map([[ResultMetadataType_1.default.ISSUE_NUMBER, parseInt(raw)]]);[m
[32m+[m[32m    };[m
[32m+[m[32m    return UPCEANExtension2Support;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = UPCEANExtension2Support;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..478413d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport ResultMetadataType from '../ResultMetadataType';[m
[32m+[m[32m/**[m
[32m+[m[32m * @see UPCEANExtension2Support[m
[32m+[m[32m */[m
[32m+[m[32mexport default class UPCEANExtension5Support {[m
[32m+[m[32m    private CHECK_DIGIT_ENCODINGS;[m
[32m+[m[32m    private decodeMiddleCounters;[m
[32m+[m[32m    private decodeRowStringBuffer;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, extensionStartRange: Int32Array): Result;[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, resultString: string): number;[m
[32m+[m[32m    static extensionChecksum(s: string): number;[m
[32m+[m[32m    determineCheckDigit(lgPatternFound: number): number;[m
[32m+[m[32m    static parseExtensionString(raw: string): Map<ResultMetadataType, string>;[m
[32m+[m[32m    static parseExtension5String(raw: string): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6c8be81[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtension5Support.js[m
[36m@@ -0,0 +1,171 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright (C) 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32m// import UPCEANReader from './UPCEANReader';[m
[32m+[m[32mvar AbstractUPCEANReader_1 = require("./AbstractUPCEANReader");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @see UPCEANExtension2Support[m
[32m+[m[32m */[m
[32m+[m[32mvar UPCEANExtension5Support = /** @class */ (function () {[m
[32m+[m[32m    function UPCEANExtension5Support() {[m
[32m+[m[32m        this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];[m
[32m+[m[32m        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);[m
[32m+[m[32m        this.decodeRowStringBuffer = '';[m
[32m+[m[32m    }[m
[32m+[m[32m    UPCEANExtension5Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {[m
[32m+[m[32m        var result = this.decodeRowStringBuffer;[m
[32m+[m[32m        var end = this.decodeMiddle(row, extensionStartRange, result);[m
[32m+[m[32m        var resultString = result.toString();[m
[32m+[m[32m        var extensionData = UPCEANExtension5Support.parseExtensionString(resultString);[m
[32m+[m[32m        var resultPoints = [[m
[32m+[m[32m            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),[m
[32m+[m[32m            new ResultPoint_1.default(end, rowNumber)[m
[32m+[m[32m        ];[m
[32m+[m[32m        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());[m
[32m+[m[32m        if (extensionData != null) {[m
[32m+[m[32m            extensionResult.putAllMetadata(extensionData);[m
[32m+[m[32m        }[m
[32m+[m[32m        return extensionResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension5Support.prototype.decodeMiddle = function (row, startRange, resultString) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var counters = this.decodeMiddleCounters;[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var rowOffset = startRange[1];[m
[32m+[m[32m        var lgPatternFound = 0;[m
[32m+[m[32m        for (var x = 0; x < 5 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);[m
[32m+[m[32m            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (bestMatch >= 10) {[m
[32m+[m[32m                lgPatternFound |= 1 << (4 - x);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (x !== 4) {[m
[32m+[m[32m                // Read off separator if not last[m
[32m+[m[32m                rowOffset = row.getNextSet(rowOffset);[m
[32m+[m[32m                rowOffset = row.getNextUnset(rowOffset);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (resultString.length !== 5) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var checkDigit = this.determineCheckDigit(lgPatternFound);[m
[32m+[m[32m        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return rowOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension5Support.extensionChecksum = function (s) {[m
[32m+[m[32m        var length = s.length;[m
[32m+[m[32m        var sum = 0;[m
[32m+[m[32m        for (var i = length - 2; i >= 0; i -= 2) {[m
[32m+[m[32m            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        sum *= 3;[m
[32m+[m[32m        for (var i = length - 1; i >= 0; i -= 2) {[m
[32m+[m[32m            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        sum *= 3;[m
[32m+[m[32m        return sum % 10;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension5Support.prototype.determineCheckDigit = function (lgPatternFound) {[m
[32m+[m[32m        for (var d = 0; d < 10; d++) {[m
[32m+[m[32m            if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {[m
[32m+[m[32m                return d;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension5Support.parseExtensionString = function (raw) {[m
[32m+[m[32m        if (raw.length !== 5) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var value = UPCEANExtension5Support.parseExtension5String(raw);[m
[32m+[m[32m        if (value == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new Map([[ResultMetadataType_1.default.SUGGESTED_PRICE, value]]);[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtension5Support.parseExtension5String = function (raw) {[m
[32m+[m[32m        var currency;[m
[32m+[m[32m        switch (raw.charAt(0)) {[m
[32m+[m[32m            case '0':[m
[32m+[m[32m                currency = '¬£';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case '5':[m
[32m+[m[32m                currency = '$';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case '9':[m
[32m+[m[32m                // Reference: http://www.jollytech.com[m
[32m+[m[32m                switch (raw) {[m
[32m+[m[32m                    case '90000':[m
[32m+[m[32m                        // No suggested retail price[m
[32m+[m[32m                        return null;[m
[32m+[m[32m                    case '99991':[m
[32m+[m[32m                        // Complementary[m
[32m+[m[32m                        return '0.00';[m
[32m+[m[32m                    case '99990':[m
[32m+[m[32m                        return 'Used';[m
[32m+[m[32m                }[m
[32m+[m[32m                // Otherwise... unknown currency?[m
[32m+[m[32m                currency = '';[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                currency = '';[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        var rawAmount = parseInt(raw.substring(1));[m
[32m+[m[32m        var unitsString = (rawAmount / 100).toString();[m
[32m+[m[32m        var hundredths = rawAmount % 100;[m
[32m+[m[32m        var hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme[m
[32m+[m[32m        return currency + unitsString + '.' + hundredthsString;[m
[32m+[m[32m    };[m
[32m+[m[32m    return UPCEANExtension5Support;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = UPCEANExtension5Support;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..cd42c63[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.d.ts[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mexport default class UPCEANExtensionSupport {[m
[32m+[m[32m    private static EXTENSION_START_PATTERN;[m
[32m+[m[32m    static decodeRow(rowNumber: number, row: BitArray, rowOffset: number): Result;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fdf3f2f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANExtensionSupport.js[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright (C) 2010 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AbstractUPCEANReader_1 = require("./AbstractUPCEANReader");[m
[32m+[m[32mvar UPCEANExtension5Support_1 = require("./UPCEANExtension5Support");[m
[32m+[m[32mvar UPCEANExtension2Support_1 = require("./UPCEANExtension2Support");[m
[32m+[m[32mvar UPCEANExtensionSupport = /** @class */ (function () {[m
[32m+[m[32m    function UPCEANExtensionSupport() {[m
[32m+[m[32m    }[m
[32m+[m[32m    UPCEANExtensionSupport.decodeRow = function (rowNumber, row, rowOffset) {[m
[32m+[m[32m        var extensionStartRange = AbstractUPCEANReader_1.default.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));[m
[32m+[m[32m        try {[m
[32m+[m[32m            // return null;[m
[32m+[m[32m            var fiveSupport = new UPCEANExtension5Support_1.default();[m
[32m+[m[32m            return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (err) {[m
[32m+[m[32m            // return null;[m
[32m+[m[32m            var twoSupport = new UPCEANExtension2Support_1.default();[m
[32m+[m[32m            return twoSupport.decodeRow(rowNumber, row, extensionStartRange);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);[m
[32m+[m[32m    return UPCEANExtensionSupport;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = UPCEANExtensionSupport;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c490807[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.d.ts[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport AbstractUPCEANReader from './AbstractUPCEANReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates functionality and implementation that is common to UPC and EAN families[m
[32m+[m[32m * of one-dimensional barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mexport default abstract class UPCEANReader extends AbstractUPCEANReader {[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    static checkChecksum(s: string): boolean;[m
[32m+[m[32m    static checkStandardUPCEANChecksum(s: string): boolean;[m
[32m+[m[32m    static getStandardUPCEANChecksum(s: string): number;[m
[32m+[m[32m    static decodeEnd(row: BitArray, endStart: number): Int32Array;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..90af67f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEANReader.js[m
[36m@@ -0,0 +1,170 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar ResultPoint_1 = require("../ResultPoint");[m
[32m+[m[32mvar UPCEANExtensionSupport_1 = require("./UPCEANExtensionSupport");[m
[32m+[m[32mvar AbstractUPCEANReader_1 = require("./AbstractUPCEANReader");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32mvar ChecksumException_1 = require("../ChecksumException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates functionality and implementation that is common to UPC and EAN families[m
[32m+[m[32m * of one-dimensional barcodes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @author alasdair@google.com (Alasdair Mackintosh)[m
[32m+[m[32m */[m
[32m+[m[32mvar UPCEANReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(UPCEANReader, _super);[m
[32m+[m[32m    function UPCEANReader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeRowStringBuffer = '';[m
[32m+[m[32m        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) { return Int32Array.from(arr); });[m
[32m+[m[32m        for (var i = 10; i < 20; i++) {[m
[32m+[m[32m            var widths = UPCEANReader.L_PATTERNS[i - 10];[m
[32m+[m[32m            var reversedWidths = new Int32Array(widths.length);[m
[32m+[m[32m            for (var j = 0; j < widths.length; j++) {[m
[32m+[m[32m                reversedWidths[j] = widths[widths.length - j - 1];[m
[32m+[m[32m            }[m
[32m+[m[32m            UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;[m
[32m+[m[32m        }[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var startGuardRange = UPCEANReader.findStartGuardPattern(row);[m
[32m+[m[32m        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);[m
[32m+[m[32m        if (resultPointCallback != null) {[m
[32m+[m[32m            var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);[m
[32m+[m[32m            resultPointCallback.foundPossibleResultPoint(resultPoint_1);[m
[32m+[m[32m        }[m
[32m+[m[32m        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);[m
[32m+[m[32m        var endStart = budello.rowOffset;[m
[32m+[m[32m        var result = budello.resultString;[m
[32m+[m[32m        if (resultPointCallback != null) {[m
[32m+[m[32m            var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);[m
[32m+[m[32m            resultPointCallback.foundPossibleResultPoint(resultPoint_2);[m
[32m+[m[32m        }[m
[32m+[m[32m        var endRange = UPCEANReader.decodeEnd(row, endStart);[m
[32m+[m[32m        if (resultPointCallback != null) {[m
[32m+[m[32m            var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);[m
[32m+[m[32m            resultPointCallback.foundPossibleResultPoint(resultPoint_3);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The[m
[32m+[m[32m        // spec might want more whitespace, but in practice this is the maximum we can count on.[m
[32m+[m[32m        var end = endRange[1];[m
[32m+[m[32m        var quietEnd = end + (end - endRange[0]);[m
[32m+[m[32m        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var resultString = result.toString();[m
[32m+[m[32m        // UPC/EAN should never be less than 8 chars anyway[m
[32m+[m[32m        if (resultString.length < 8) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!UPCEANReader.checkChecksum(resultString)) {[m
[32m+[m[32m            throw new ChecksumException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;[m
[32m+[m[32m        var right = (endRange[1] + endRange[0]) / 2.0;[m
[32m+[m[32m        var format = this.getBarcodeFormat();[m
[32m+[m[32m        var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];[m
[32m+[m[32m        var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());[m
[32m+[m[32m        var extensionLength = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);[m
[32m+[m[32m            decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());[m
[32m+[m[32m            decodeResult.putAllMetadata(extensionResult.getResultMetadata());[m
[32m+[m[32m            decodeResult.addResultPoints(extensionResult.getResultPoints());[m
[32m+[m[32m            extensionLength = extensionResult.getText().length;[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (err) {[m
[32m+[m[32m        }[m
[32m+[m[32m        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);[m
[32m+[m[32m        if (allowedExtensions != null) {[m
[32m+[m[32m            var valid = false;[m
[32m+[m[32m            for (var length_1 in allowedExtensions) {[m
[32m+[m[32m                if (extensionLength.toString() === length_1) { // check me[m
[32m+[m[32m                    valid = true;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!valid) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {[m
[32m+[m[32m            // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo[m
[32m+[m[32m            // if (countryID != null) {[m
[32m+[m[32m            //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);[m
[32m+[m[32m            // }[m
[32m+[m[32m        }[m
[32m+[m[32m        return decodeResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANReader.checkChecksum = function (s) {[m
[32m+[m[32m        return UPCEANReader.checkStandardUPCEANChecksum(s);[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANReader.checkStandardUPCEANChecksum = function (s) {[m
[32m+[m[32m        var length = s.length;[m
[32m+[m[32m        if (length === 0)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        var check = parseInt(s.charAt(length - 1), 10);[m
[32m+[m[32m        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANReader.getStandardUPCEANChecksum = function (s) {[m
[32m+[m[32m        var length = s.length;[m
[32m+[m[32m        var sum = 0;[m
[32m+[m[32m        for (var i = length - 1; i >= 0; i -= 2) {[m
[32m+[m[32m            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            if (digit < 0 || digit > 9) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            sum += digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        sum *= 3;[m
[32m+[m[32m        for (var i = length - 2; i >= 0; i -= 2) {[m
[32m+[m[32m            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            if (digit < 0 || digit > 9) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            sum += digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        return (1000 - sum) % 10;[m
[32m+[m[32m    };[m
[32m+[m[32m    UPCEANReader.decodeEnd = function (row, endStart) {[m
[32m+[m[32m        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));[m
[32m+[m[32m    };[m
[32m+[m[32m    return UPCEANReader;[m
[32m+[m[32m}(AbstractUPCEANReader_1.default));[m
[32m+[m[32mexports.default = UPCEANReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..6a85cde[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.d.ts[m
[36m@@ -0,0 +1,54 @@[m
[32m+[m[32mimport UPCEANReader from './UPCEANReader';[m
[32m+[m[32mimport BitArray from '../common/BitArray';[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport { int } from 'src/customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the UPC-E format.</p>[m
[32m+[m[32m * <p><a href="http://www.barcodeisland.com/upce.phtml">This</a> is a great reference for[m
[32m+[m[32m * UPC-E information.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m *[m
[32m+[m[32m * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java[m
[32m+[m[32m *[m
[32m+[m[32m * @experimental[m
[32m+[m[32m */[m
[32m+[m[32mexport default class UPCEReader extends UPCEANReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The pattern that marks the middle, and end, of a UPC-E pattern.[m
[32m+[m[32m     * There is no "second half" to a UPC-E barcode.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static MIDDLE_END_PATTERN;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of[m
[32m+[m[32m     * even-odd parity encodings of digits that imply both the number system (0 or 1)[m
[32m+[m[32m     * used, and the check digit.[m
[32m+[m[32m     */[m
[32m+[m[32m    static NUMSYS_AND_CHECK_DIGIT_PATTERNS: Int32Array[];[m
[32m+[m[32m    private decodeMiddleCounters;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeMiddle(row: BitArray, startRange: Int32Array, result: string): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    protected decodeEnd(row: BitArray, endStart: int): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    protected checkChecksum(s: string): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static determineNumSysAndCheckDigit;[m
[32m+[m[32m    getBarcodeFormat(): BarcodeFormat;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Expands a UPC-E value back into its full, equivalent UPC-A code value.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param upce UPC-E code as string of digits[m
[32m+[m[32m     * @return equivalent UPC-A code as string of digits[m
[32m+[m[32m     */[m
[32m+[m[32m    static convertUPCEtoUPCA(upce: string): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a968c36[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/UPCEReader.js[m
[36m@@ -0,0 +1,221 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar UPCEANReader_1 = require("./UPCEANReader");[m
[32m+[m[32mvar StringBuilder_1 = require("../util/StringBuilder");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32m// package com.google.zxing.oned;[m
[32m+[m[32m// import com.google.zxing.BarcodeFormat;[m
[32m+[m[32m// import com.google.zxing.FormatException;[m
[32m+[m[32m// import com.google.zxing.NotFoundException;[m
[32m+[m[32m// import com.google.zxing.common.BitArray;[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Implements decoding of the UPC-E format.</p>[m
[32m+[m[32m * <p><a href="http://www.barcodeisland.com/upce.phtml">This</a> is a great reference for[m
[32m+[m[32m * UPC-E information.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m *[m
[32m+[m[32m * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java[m
[32m+[m[32m *[m
[32m+[m[32m * @experimental[m
[32m+[m[32m */[m
[32m+[m[32mvar UPCEReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(UPCEReader, _super);[m
[32m+[m[32m    function UPCEReader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeMiddleCounters = new Int32Array(4);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCEReader.prototype.decodeMiddle = function (row, startRange, result) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var counters = this.decodeMiddleCounters.map(function (x) { return x; });[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var end = row.getSize();[m
[32m+[m[32m        var rowOffset = startRange[1];[m
[32m+[m[32m        var lgPatternFound = 0;[m
[32m+[m[32m        for (var x = 0; x < 6 && rowOffset < end; x++) {[m
[32m+[m[32m            var bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);[m
[32m+[m[32m            result += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    rowOffset += counter;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (bestMatch >= 10) {[m
[32m+[m[32m                lgPatternFound |= 1 << (5 - x);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        UPCEReader.determineNumSysAndCheckDigit(new StringBuilder_1.default(result), lgPatternFound);[m
[32m+[m[32m        return rowOffset;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCEReader.prototype.decodeEnd = function (row, endStart) {[m
[32m+[m[32m        return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCEReader.prototype.checkChecksum = function (s) {[m
[32m+[m[32m        return UPCEANReader_1.default.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    UPCEReader.determineNumSysAndCheckDigit = function (resultString, lgPatternFound) {[m
[32m+[m[32m        for (var numSys = 0; numSys <= 1; numSys++) {[m
[32m+[m[32m            for (var d = 0; d < 10; d++) {[m
[32m+[m[32m                if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {[m
[32m+[m[32m                    resultString.insert(0, /*(char)*/ ('0' + numSys));[m
[32m+[m[32m                    resultString.append(/*(char)*/ ('0' + d));[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw NotFoundException_1.default.getNotFoundInstance();[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    UPCEReader.prototype.getBarcodeFormat = function () {[m
[32m+[m[32m        return BarcodeFormat_1.default.UPC_E;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Expands a UPC-E value back into its full, equivalent UPC-A code value.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param upce UPC-E code as string of digits[m
[32m+[m[32m     * @return equivalent UPC-A code as string of digits[m
[32m+[m[32m     */[m
[32m+[m[32m    UPCEReader.convertUPCEtoUPCA = function (upce) {[m
[32m+[m[32m        // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);[m
[32m+[m[32m        var upceChars = upce.slice(1, 7).split('').map(function (x) { return x.charCodeAt(0); });[m
[32m+[m[32m        var result = new StringBuilder_1.default( /*12*/);[m
[32m+[m[32m        result.append(upce.charAt(0));[m
[32m+[m[32m        var lastChar = upceChars[5];[m
[32m+[m[32m        switch (lastChar) {[m
[32m+[m[32m            case 0:[m
[32m+[m[32m            case 1:[m
[32m+[m[32m            case 2:[m
[32m+[m[32m                result.appendChars(upceChars, 0, 2);[m
[32m+[m[32m                result.append(lastChar);[m
[32m+[m[32m                result.append('0000');[m
[32m+[m[32m                result.appendChars(upceChars, 2, 3);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 3:[m
[32m+[m[32m                result.appendChars(upceChars, 0, 3);[m
[32m+[m[32m                result.append('00000');[m
[32m+[m[32m                result.appendChars(upceChars, 3, 2);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 4:[m
[32m+[m[32m                result.appendChars(upceChars, 0, 4);[m
[32m+[m[32m                result.append('00000');[m
[32m+[m[32m                result.append(upceChars[4]);[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                result.appendChars(upceChars, 0, 5);[m
[32m+[m[32m                result.append('0000');[m
[32m+[m[32m                result.append(lastChar);[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Only append check digit in conversion if supplied[m
[32m+[m[32m        if (upce.length >= 8) {[m
[32m+[m[32m            result.append(upce.charAt(7));[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The pattern that marks the middle, and end, of a UPC-E pattern.[m
[32m+[m[32m     * There is no "second half" to a UPC-E barcode.[m
[32m+[m[32m     */[m
[32m+[m[32m    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);[m
[32m+[m[32m    // For an UPC-E barcode, the final digit is represented by the parities used[m
[32m+[m[32m    // to encode the middle six digits, according to the table below.[m
[32m+[m[32m    //[m
[32m+[m[32m    //                Parity of next 6 digits[m
[32m+[m[32m    //    Digit   0     1     2     3     4     5[m
[32m+[m[32m    //       0    Even   Even  Even Odd  Odd   Odd[m
[32m+[m[32m    //       1    Even   Even  Odd  Even Odd   Odd[m
[32m+[m[32m    //       2    Even   Even  Odd  Odd  Even  Odd[m
[32m+[m[32m    //       3    Even   Even  Odd  Odd  Odd   Even[m
[32m+[m[32m    //       4    Even   Odd   Even Even Odd   Odd[m
[32m+[m[32m    //       5    Even   Odd   Odd  Even Even  Odd[m
[32m+[m[32m    //       6    Even   Odd   Odd  Odd  Even  Even[m
[32m+[m[32m    //       7    Even   Odd   Even Odd  Even  Odd[m
[32m+[m[32m    //       8    Even   Odd   Even Odd  Odd   Even[m
[32m+[m[32m    //       9    Even   Odd   Odd  Even Odd   Even[m
[32m+[m[32m    //[m
[32m+[m[32m    // The encoding is represented by the following array, which is a bit pattern[m
[32m+[m[32m    // using Odd = 0 and Even = 1. For example, 5 is represented by:[m
[32m+[m[32m    //[m
[32m+[m[32m    //              Odd Even Even Odd Odd Even[m
[32m+[m[32m    // in binary:[m
[32m+[m[32m    //                0    1    1   0   0    1   == 0x19[m
[32m+[m[32m    //[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of[m
[32m+[m[32m     * even-odd parity encodings of digits that imply both the number system (0 or 1)[m
[32m+[m[32m     * used, and the check digit.[m
[32m+[m[32m     */[m
[32m+[m[32m    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [[m
[32m+[m[32m        Int32Array.from([0x38, 0x34, 0x32, 0x31, 0x2C, 0x26, 0x23, 0x2A, 0x29, 0x25]),[m
[32m+[m[32m        Int32Array.from([0x07, 0x0B, 0x0D, 0x0E, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    return UPCEReader;[m
[32m+[m[32m}(UPCEANReader_1.default));[m
[32m+[m[32mexports.default = UPCEReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e937d2b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.d.ts[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32mimport OneDReader from '../OneDReader';[m
[32m+[m[32mexport default abstract class AbstractRSSReader extends OneDReader {[m
[32m+[m[32m    private static readonly MAX_AVG_VARIANCE;[m
[32m+[m[32m    private static readonly MAX_INDIVIDUAL_VARIANCE;[m
[32m+[m[32m    private static readonly MIN_FINDER_PATTERN_RATIO;[m
[32m+[m[32m    private static readonly MAX_FINDER_PATTERN_RATIO;[m
[32m+[m[32m    private readonly decodeFinderCounters;[m
[32m+[m[32m    private readonly dataCharacterCounters;[m
[32m+[m[32m    private readonly oddRoundingErrors;[m
[32m+[m[32m    private readonly evenRoundingErrors;[m
[32m+[m[32m    private readonly oddCounts;[m
[32m+[m[32m    private readonly evenCounts;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    protected getDecodeFinderCounters(): Int32Array;[m
[32m+[m[32m    protected getDataCharacterCounters(): Int32Array;[m
[32m+[m[32m    protected getOddRoundingErrors(): number[];[m
[32m+[m[32m    protected getEvenRoundingErrors(): number[];[m
[32m+[m[32m    protected getOddCounts(): number[];[m
[32m+[m[32m    protected getEvenCounts(): number[];[m
[32m+[m[32m    protected parseFinderValue(counters: Int32Array, finderPatterns: Int32Array[]): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param array values to sum[m
[32m+[m[32m     * @return sum of values[m
[32m+[m[32m     * @deprecated call {@link MathUtils#sum(int[])}[m
[32m+[m[32m     */[m
[32m+[m[32m    protected static count(array: number[]): number;[m
[32m+[m[32m    protected static increment(array: number[], errors: number[]): void;[m
[32m+[m[32m    protected static decrement(array: number[], errors: number[]): void;[m
[32m+[m[32m    protected static isFinderPattern(counters: Int32Array): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..503638c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/AbstractRSSReader.js[m
[36m@@ -0,0 +1,137 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32mvar OneDReader_1 = require("../OneDReader");[m
[32m+[m[32m// import Integer from '../../util/Integer';[m
[32m+[m[32m// import Float from '../../util/Float';[m
[32m+[m[32mvar AbstractRSSReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AbstractRSSReader, _super);[m
[32m+[m[32m    function AbstractRSSReader() {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.decodeFinderCounters = new Int32Array(4);[m
[32m+[m[32m        _this.dataCharacterCounters = new Int32Array(8);[m
[32m+[m[32m        _this.oddRoundingErrors = new Array(4);[m
[32m+[m[32m        _this.evenRoundingErrors = new Array(4);[m
[32m+[m[32m        _this.oddCounts = new Array(_this.dataCharacterCounters.length / 2);[m
[32m+[m[32m        _this.evenCounts = new Array(_this.dataCharacterCounters.length / 2);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AbstractRSSReader.prototype.getDecodeFinderCounters = function () {[m
[32m+[m[32m        return this.decodeFinderCounters;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.getDataCharacterCounters = function () {[m
[32m+[m[32m        return this.dataCharacterCounters;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.getOddRoundingErrors = function () {[m
[32m+[m[32m        return this.oddRoundingErrors;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.getEvenRoundingErrors = function () {[m
[32m+[m[32m        return this.evenRoundingErrors;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.getOddCounts = function () {[m
[32m+[m[32m        return this.oddCounts;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.getEvenCounts = function () {[m
[32m+[m[32m        return this.evenCounts;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.prototype.parseFinderValue = function (counters, finderPatterns) {[m
[32m+[m[32m        for (var value = 0; value < finderPatterns.length; value++) {[m
[32m+[m[32m            if (OneDReader_1.default.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {[m
[32m+[m[32m                return value;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param array values to sum[m
[32m+[m[32m     * @return sum of values[m
[32m+[m[32m     * @deprecated call {@link MathUtils#sum(int[])}[m
[32m+[m[32m     */[m
[32m+[m[32m    AbstractRSSReader.count = function (array) {[m
[32m+[m[32m        return MathUtils_1.default.sum(new Int32Array(array));[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.increment = function (array, errors) {[m
[32m+[m[32m        var index = 0;[m
[32m+[m[32m        var biggestError = errors[0];[m
[32m+[m[32m        for (var i = 1; i < array.length; i++) {[m
[32m+[m[32m            if (errors[i] > biggestError) {[m
[32m+[m[32m                biggestError = errors[i];[m
[32m+[m[32m                index = i;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        array[index]++;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.decrement = function (array, errors) {[m
[32m+[m[32m        var index = 0;[m
[32m+[m[32m        var biggestError = errors[0];[m
[32m+[m[32m        for (var i = 1; i < array.length; i++) {[m
[32m+[m[32m            if (errors[i] < biggestError) {[m
[32m+[m[32m                biggestError = errors[i];[m
[32m+[m[32m                index = i;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        array[index]--;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.isFinderPattern = function (counters) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var firstTwoSum = counters[0] + counters[1];[m
[32m+[m[32m        var sum = firstTwoSum + counters[2] + counters[3];[m
[32m+[m[32m        var ratio = firstTwoSum / sum;[m
[32m+[m[32m        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {[m
[32m+[m[32m            // passes ratio test in spec, but see if the counts are unreasonable[m
[32m+[m[32m            var minCounter = Number.MAX_SAFE_INTEGER;[m
[32m+[m[32m            var maxCounter = Number.MIN_SAFE_INTEGER;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {[m
[32m+[m[32m                    var counter = counters_1_1.value;[m
[32m+[m[32m                    if (counter > maxCounter) {[m
[32m+[m[32m                        maxCounter = counter;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (counter < minCounter) {[m
[32m+[m[32m                        minCounter = counter;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            return maxCounter < 10 * minCounter;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;[m
[32m+[m[32m    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;[m
[32m+[m[32m    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;[m
[32m+[m[32m    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;[m
[32m+[m[32m    return AbstractRSSReader;[m
[32m+[m[32m}(OneDReader_1.default));[m
[32m+[m[32mexports.default = AbstractRSSReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..74a7719[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mexport default class DataCharacter {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private checksumPortion;[m
[32m+[m[32m    constructor(value: number, checksumPortion: number);[m
[32m+[m[32m    getValue(): number;[m
[32m+[m[32m    getChecksumPortion(): number;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    equals(o: object): boolean;[m
[32m+[m[32m    hashCode(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..40e5783[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/DataCharacter.js[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DataCharacter = /** @class */ (function () {[m
[32m+[m[32m    function DataCharacter(value, checksumPortion) {[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.checksumPortion = checksumPortion;[m
[32m+[m[32m    }[m
[32m+[m[32m    DataCharacter.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataCharacter.prototype.getChecksumPortion = function () {[m
[32m+[m[32m        return this.checksumPortion;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataCharacter.prototype.toString = function () {[m
[32m+[m[32m        return this.value + '(' + this.checksumPortion + ')';[m
[32m+[m[32m    };[m
[32m+[m[32m    DataCharacter.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof DataCharacter)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var that = o;[m
[32m+[m[32m        return this.value === that.value && this.checksumPortion === that.checksumPortion;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataCharacter.prototype.hashCode = function () {[m
[32m+[m[32m        return this.value ^ this.checksumPortion;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DataCharacter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataCharacter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e2dce6d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.d.ts[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mexport default class FinderPattern {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private startEnd;[m
[32m+[m[32m    private resultPoints;[m
[32m+[m[32m    constructor(value: number, startEnd: number[], start: number, end: number, rowNumber: number);[m
[32m+[m[32m    getValue(): number;[m
[32m+[m[32m    getStartEnd(): number[];[m
[32m+[m[32m    getResultPoints(): Array<ResultPoint>;[m
[32m+[m[32m    equals(o: object): boolean;[m
[32m+[m[32m    hashCode(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js[m
[1mnew file mode 100644[m
[1mindex 0000000..40a4662[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/FinderPattern.js[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar FinderPattern = /** @class */ (function () {[m
[32m+[m[32m    function FinderPattern(value, startEnd, start, end, rowNumber) {[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.startEnd = startEnd;[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.startEnd = startEnd;[m
[32m+[m[32m        this.resultPoints = new Array();[m
[32m+[m[32m        this.resultPoints.push(new ResultPoint_1.default(start, rowNumber));[m
[32m+[m[32m        this.resultPoints.push(new ResultPoint_1.default(end, rowNumber));[m
[32m+[m[32m    }[m
[32m+[m[32m    FinderPattern.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPattern.prototype.getStartEnd = function () {[m
[32m+[m[32m        return this.startEnd;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPattern.prototype.getResultPoints = function () {[m
[32m+[m[32m        return this.resultPoints;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPattern.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof FinderPattern)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var that = o;[m
[32m+[m[32m        return this.value === that.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPattern.prototype.hashCode = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    return FinderPattern;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = FinderPattern;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..421546c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport DataCharacter from './DataCharacter';[m
[32m+[m[32mimport FinderPattern from './FinderPattern';[m
[32m+[m[32mexport default class Pair extends DataCharacter {[m
[32m+[m[32m    private finderPattern;[m
[32m+[m[32m    private count;[m
[32m+[m[32m    constructor(value: number, checksumPortion: number, finderPattern: FinderPattern);[m
[32m+[m[32m    getFinderPattern(): FinderPattern;[m
[32m+[m[32m    getCount(): number;[m
[32m+[m[32m    incrementCount(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c1a2c40[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/Pair.js[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DataCharacter_1 = require("./DataCharacter");[m
[32m+[m[32mvar Pair = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(Pair, _super);[m
[32m+[m[32m    function Pair(value, checksumPortion, finderPattern) {[m
[32m+[m[32m        var _this = _super.call(this, value, checksumPortion) || this;[m
[32m+[m[32m        _this.count = 0;[m
[32m+[m[32m        _this.finderPattern = finderPattern;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    Pair.prototype.getFinderPattern = function () {[m
[32m+[m[32m        return this.finderPattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    Pair.prototype.getCount = function () {[m
[32m+[m[32m        return this.count;[m
[32m+[m[32m    };[m
[32m+[m[32m    Pair.prototype.incrementCount = function () {[m
[32m+[m[32m        this.count++;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Pair;[m
[32m+[m[32m}(DataCharacter_1.default));[m
[32m+[m[32mexports.default = Pair;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ce67eeb[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.d.ts[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mimport AbstractRSSReader from './AbstractRSSReader';[m
[32m+[m[32mimport Result from '../../Result';[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32mexport default class RSS14Reader extends AbstractRSSReader {[m
[32m+[m[32m    private static readonly OUTSIDE_EVEN_TOTAL_SUBSET;[m
[32m+[m[32m    private static readonly INSIDE_ODD_TOTAL_SUBSET;[m
[32m+[m[32m    private static readonly OUTSIDE_GSUM;[m
[32m+[m[32m    private static readonly INSIDE_GSUM;[m
[32m+[m[32m    private static readonly OUTSIDE_ODD_WIDEST;[m
[32m+[m[32m    private static readonly INSIDE_ODD_WIDEST;[m
[32m+[m[32m    private static readonly FINDER_PATTERNS;[m
[32m+[m[32m    private readonly possibleLeftPairs;[m
[32m+[m[32m    private readonly possibleRightPairs;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    private static addOrTally;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    private static constructResult;[m
[32m+[m[32m    private static checkChecksum;[m
[32m+[m[32m    private decodePair;[m
[32m+[m[32m    private decodeDataCharacter;[m
[32m+[m[32m    private findFinderPattern;[m
[32m+[m[32m    private parseFoundFinderPattern;[m
[32m+[m[32m    private adjustOddEvenCounts;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..326bba8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSS14Reader.js[m
[36m@@ -0,0 +1,456 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AbstractRSSReader_1 = require("./AbstractRSSReader");[m
[32m+[m[32mvar Pair_1 = require("./Pair");[m
[32m+[m[32mvar Result_1 = require("../../Result");[m
[32m+[m[32mvar DecodeHintType_1 = require("../../DecodeHintType");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar BarcodeFormat_1 = require("../../BarcodeFormat");[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar FinderPattern_1 = require("./FinderPattern");[m
[32m+[m[32mvar DataCharacter_1 = require("./DataCharacter");[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32mvar RSSUtils_1 = require("./RSSUtils");[m
[32m+[m[32mvar System_1 = require("../../util/System");[m
[32m+[m[32mvar OneDReader_1 = require("../OneDReader");[m
[32m+[m[32mvar RSS14Reader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(RSS14Reader, _super);[m
[32m+[m[32m    function RSS14Reader() {[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        _this.possibleLeftPairs = [];[m
[32m+[m[32m        _this.possibleRightPairs = [];[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    RSS14Reader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var leftPair = this.decodePair(row, false, rowNumber, hints);[m
[32m+[m[32m        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);[m
[32m+[m[32m        row.reverse();[m
[32m+[m[32m        var rightPair = this.decodePair(row, true, rowNumber, hints);[m
[32m+[m[32m        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);[m
[32m+[m[32m        row.reverse();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _c = __values(this.possibleLeftPairs), _d = _c.next(); !_d.done; _d = _c.next()) {[m
[32m+[m[32m                var left = _d.value;[m
[32m+[m[32m                if (left.getCount() > 1) {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        for (var _e = (e_2 = void 0, __values(this.possibleRightPairs)), _f = _e.next(); !_f.done; _f = _e.next()) {[m
[32m+[m[32m                            var right = _f.value;[m
[32m+[m[32m                            if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {[m
[32m+[m[32m                                return RSS14Reader.constructResult(left, right);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m                    finally {[m
[32m+[m[32m                        try {[m
[32m+[m[32m                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.addOrTally = function (possiblePairs, pair) {[m
[32m+[m[32m        var e_3, _a;[m
[32m+[m[32m        if (pair == null) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var found = false;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var possiblePairs_1 = __values(possiblePairs), possiblePairs_1_1 = possiblePairs_1.next(); !possiblePairs_1_1.done; possiblePairs_1_1 = possiblePairs_1.next()) {[m
[32m+[m[32m                var other = possiblePairs_1_1.value;[m
[32m+[m[32m                if (other.getValue() === pair.getValue()) {[m
[32m+[m[32m                    other.incrementCount();[m
[32m+[m[32m                    found = true;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (possiblePairs_1_1 && !possiblePairs_1_1.done && (_a = possiblePairs_1.return)) _a.call(possiblePairs_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!found) {[m
[32m+[m[32m            possiblePairs.push(pair);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.reset = function () {[m
[32m+[m[32m        this.possibleLeftPairs.length = 0;[m
[32m+[m[32m        this.possibleRightPairs.length = 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.constructResult = function (leftPair, rightPair) {[m
[32m+[m[32m        var symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();[m
[32m+[m[32m        var text = new String(symbolValue).toString();[m
[32m+[m[32m        var buffer = new StringBuilder_1.default();[m
[32m+[m[32m        for (var i = 13 - text.length; i > 0; i--) {[m
[32m+[m[32m            buffer.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        buffer.append(text);[m
[32m+[m[32m        var checkDigit = 0;[m
[32m+[m[32m        for (var i = 0; i < 13; i++) {[m
[32m+[m[32m            var digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        checkDigit = 10 - (checkDigit % 10);[m
[32m+[m[32m        if (checkDigit === 10) {[m
[32m+[m[32m            checkDigit = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        buffer.append(checkDigit.toString());[m
[32m+[m[32m        var leftPoints = leftPair.getFinderPattern().getResultPoints();[m
[32m+[m[32m        var rightPoints = rightPair.getFinderPattern().getResultPoints();[m
[32m+[m[32m        return new Result_1.default(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat_1.default.RSS_14, new Date().getTime());[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.checkChecksum = function (leftPair, rightPair) {[m
[32m+[m[32m        var checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;[m
[32m+[m[32m        var targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();[m
[32m+[m[32m        if (targetCheckValue > 72) {[m
[32m+[m[32m            targetCheckValue--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (targetCheckValue > 8) {[m
[32m+[m[32m            targetCheckValue--;[m
[32m+[m[32m        }[m
[32m+[m[32m        return checkValue === targetCheckValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.decodePair = function (row, right, rowNumber, hints) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            var startEnd = this.findFinderPattern(row, right);[m
[32m+[m[32m            var pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);[m
[32m+[m[32m            var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);[m
[32m+[m[32m            if (resultPointCallback != null) {[m
[32m+[m[32m                var center = (startEnd[0] + startEnd[1]) / 2.0;[m
[32m+[m[32m                if (right) {[m
[32m+[m[32m                    // row is actually reversed[m
[32m+[m[32m                    center = row.getSize() - 1 - center;[m
[32m+[m[32m                }[m
[32m+[m[32m                resultPointCallback.foundPossibleResultPoint(new ResultPoint_1.default(center, rowNumber));[m
[32m+[m[32m            }[m
[32m+[m[32m            var outside = this.decodeDataCharacter(row, pattern, true);[m
[32m+[m[32m            var inside = this.decodeDataCharacter(row, pattern, false);[m
[32m+[m[32m            return new Pair_1.default(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (err) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.decodeDataCharacter = function (row, pattern, outsideChar) {[m
[32m+[m[32m        var counters = this.getDataCharacterCounters();[m
[32m+[m[32m        for (var x = 0; x < counters.length; x++) {[m
[32m+[m[32m            counters[x] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (outsideChar) {[m
[32m+[m[32m            OneDReader_1.default.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            OneDReader_1.default.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);[m
[32m+[m[32m            // reverse it[m
[32m+[m[32m            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {[m
[32m+[m[32m                var temp = counters[i];[m
[32m+[m[32m                counters[i] = counters[j];[m
[32m+[m[32m                counters[j] = temp;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var numModules = outsideChar ? 16 : 15;[m
[32m+[m[32m        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;[m
[32m+[m[32m        var oddCounts = this.getOddCounts();[m
[32m+[m[32m        var evenCounts = this.getEvenCounts();[m
[32m+[m[32m        var oddRoundingErrors = this.getOddRoundingErrors();[m
[32m+[m[32m        var evenRoundingErrors = this.getEvenRoundingErrors();[m
[32m+[m[32m        for (var i = 0; i < counters.length; i++) {[m
[32m+[m[32m            var value = counters[i] / elementWidth;[m
[32m+[m[32m            var count = Math.floor(value + 0.5);[m
[32m+[m[32m            if (count < 1) {[m
[32m+[m[32m                count = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (count > 8) {[m
[32m+[m[32m                count = 8;[m
[32m+[m[32m            }[m
[32m+[m[32m            var offset = Math.floor(i / 2);[m
[32m+[m[32m            if ((i & 0x01) === 0) {[m
[32m+[m[32m                oddCounts[offset] = count;[m
[32m+[m[32m                oddRoundingErrors[offset] = value - count;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                evenCounts[offset] = count;[m
[32m+[m[32m                evenRoundingErrors[offset] = value - count;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.adjustOddEvenCounts(outsideChar, numModules);[m
[32m+[m[32m        var oddSum = 0;[m
[32m+[m[32m        var oddChecksumPortion = 0;[m
[32m+[m[32m        for (var i = oddCounts.length - 1; i >= 0; i--) {[m
[32m+[m[32m            oddChecksumPortion *= 9;[m
[32m+[m[32m            oddChecksumPortion += oddCounts[i];[m
[32m+[m[32m            oddSum += oddCounts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var evenChecksumPortion = 0;[m
[32m+[m[32m        var evenSum = 0;[m
[32m+[m[32m        for (var i = evenCounts.length - 1; i >= 0; i--) {[m
[32m+[m[32m            evenChecksumPortion *= 9;[m
[32m+[m[32m            evenChecksumPortion += evenCounts[i];[m
[32m+[m[32m            evenSum += evenCounts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;[m
[32m+[m[32m        if (outsideChar) {[m
[32m+[m[32m            if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var group = (12 - oddSum) / 2;[m
[32m+[m[32m            var oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];[m
[32m+[m[32m            var evenWidest = 9 - oddWidest;[m
[32m+[m[32m            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, false);[m
[32m+[m[32m            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, true);[m
[32m+[m[32m            var tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];[m
[32m+[m[32m            var gSum = RSS14Reader.OUTSIDE_GSUM[group];[m
[32m+[m[32m            return new DataCharacter_1.default(vOdd * tEven + vEven + gSum, checksumPortion);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var group = (10 - evenSum) / 2;[m
[32m+[m[32m            var oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];[m
[32m+[m[32m            var evenWidest = 9 - oddWidest;[m
[32m+[m[32m            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);[m
[32m+[m[32m            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);[m
[32m+[m[32m            var tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];[m
[32m+[m[32m            var gSum = RSS14Reader.INSIDE_GSUM[group];[m
[32m+[m[32m            return new DataCharacter_1.default(vEven * tOdd + vOdd + gSum, checksumPortion);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.findFinderPattern = function (row, rightFinderPattern) {[m
[32m+[m[32m        var counters = this.getDecodeFinderCounters();[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        var rowOffset = 0;[m
[32m+[m[32m        while (rowOffset < width) {[m
[32m+[m[32m            isWhite = !row.get(rowOffset);[m
[32m+[m[32m            if (rightFinderPattern === isWhite) {[m
[32m+[m[32m                // Will encounter white first when searching for right finder pattern[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            rowOffset++;[m
[32m+[m[32m        }[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        for (var x = rowOffset; x < width; x++) {[m
[32m+[m[32m            if (row.get(x) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === 3) {[m
[32m+[m[32m                    if (AbstractRSSReader_1.default.isFinderPattern(counters)) {[m
[32m+[m[32m                        return [patternStart, x];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    counters[0] = counters[2];[m
[32m+[m[32m                    counters[1] = counters[3];[m
[32m+[m[32m                    counters[2] = 0;[m
[32m+[m[32m                    counters[3] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.parseFoundFinderPattern = function (row, rowNumber, right, startEnd) {[m
[32m+[m[32m        // Actually we found elements 2-5[m
[32m+[m[32m        var firstIsBlack = row.get(startEnd[0]);[m
[32m+[m[32m        var firstElementStart = startEnd[0] - 1;[m
[32m+[m[32m        // Locate element 1[m
[32m+[m[32m        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {[m
[32m+[m[32m            firstElementStart--;[m
[32m+[m[32m        }[m
[32m+[m[32m        firstElementStart++;[m
[32m+[m[32m        var firstCounter = startEnd[0] - firstElementStart;[m
[32m+[m[32m        // Make 'counters' hold 1-4[m
[32m+[m[32m        var counters = this.getDecodeFinderCounters();[m
[32m+[m[32m        var copy = new Int32Array(counters.length);[m
[32m+[m[32m        System_1.default.arraycopy(counters, 0, copy, 1, counters.length - 1);[m
[32m+[m[32m        copy[0] = firstCounter;[m
[32m+[m[32m        var value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);[m
[32m+[m[32m        var start = firstElementStart;[m
[32m+[m[32m        var end = startEnd[1];[m
[32m+[m[32m        if (right) {[m
[32m+[m[32m            // row is actually reversed[m
[32m+[m[32m            start = row.getSize() - 1 - start;[m
[32m+[m[32m            end = row.getSize() - 1 - end;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new FinderPattern_1.default(value, [firstElementStart, startEnd[1]], start, end, rowNumber);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.prototype.adjustOddEvenCounts = function (outsideChar, numModules) {[m
[32m+[m[32m        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));[m
[32m+[m[32m        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));[m
[32m+[m[32m        var incrementOdd = false;[m
[32m+[m[32m        var decrementOdd = false;[m
[32m+[m[32m        var incrementEven = false;[m
[32m+[m[32m        var decrementEven = false;[m
[32m+[m[32m        if (outsideChar) {[m
[32m+[m[32m            if (oddSum > 12) {[m
[32m+[m[32m                decrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (oddSum < 4) {[m
[32m+[m[32m                incrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (evenSum > 12) {[m
[32m+[m[32m                decrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (evenSum < 4) {[m
[32m+[m[32m                incrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            if (oddSum > 11) {[m
[32m+[m[32m                decrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (oddSum < 5) {[m
[32m+[m[32m                incrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (evenSum > 10) {[m
[32m+[m[32m                decrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (evenSum < 4) {[m
[32m+[m[32m                incrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var mismatch = oddSum + evenSum - numModules;[m
[32m+[m[32m        var oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);[m
[32m+[m[32m        var evenParityBad = (evenSum & 0x01) === 1;[m
[32m+[m[32m        if (mismatch === 1) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                decrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                decrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (mismatch === -1) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                incrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                incrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (mismatch === 0) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                // Both bad[m
[32m+[m[32m                if (oddSum < evenSum) {[m
[32m+[m[32m                    incrementOdd = true;[m
[32m+[m[32m                    decrementEven = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    decrementOdd = true;[m
[32m+[m[32m                    incrementEven = true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                // Nothing to do![m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (incrementOdd) {[m
[32m+[m[32m            if (decrementOdd) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            AbstractRSSReader_1.default.increment(this.getOddCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decrementOdd) {[m
[32m+[m[32m            AbstractRSSReader_1.default.decrement(this.getOddCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (incrementEven) {[m
[32m+[m[32m            if (decrementEven) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            AbstractRSSReader_1.default.increment(this.getEvenCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decrementEven) {[m
[32m+[m[32m            AbstractRSSReader_1.default.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];[m
[32m+[m[32m    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];[m
[32m+[m[32m    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];[m
[32m+[m[32m    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];[m
[32m+[m[32m    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];[m
[32m+[m[32m    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];[m
[32m+[m[32m    RSS14Reader.FINDER_PATTERNS = [[m
[32m+[m[32m        Int32Array.from([3, 8, 2, 1]),[m
[32m+[m[32m        Int32Array.from([3, 5, 5, 1]),[m
[32m+[m[32m        Int32Array.from([3, 3, 7, 1]),[m
[32m+[m[32m        Int32Array.from([3, 1, 9, 1]),[m
[32m+[m[32m        Int32Array.from([2, 7, 4, 1]),[m
[32m+[m[32m        Int32Array.from([2, 5, 6, 1]),[m
[32m+[m[32m        Int32Array.from([2, 3, 8, 1]),[m
[32m+[m[32m        Int32Array.from([1, 5, 7, 1]),[m
[32m+[m[32m        Int32Array.from([1, 3, 9, 1]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    return RSS14Reader;[m
[32m+[m[32m}(AbstractRSSReader_1.default));[m
[32m+[m[32mexports.default = RSS14Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9386b32[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * RSS util functions.[m
[32m+[m[32m */[m
[32m+[m[32mexport default class RSSUtils {[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    static getRSSvalue(widths: number[], maxWidth: number, noNarrow: boolean): number;[m
[32m+[m[32m    private static combins;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js[m
[1mnew file mode 100644[m
[1mindex 0000000..aaedada[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/RSSUtils.js[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * RSS util functions.[m
[32m+[m[32m */[m
[32m+[m[32mvar RSSUtils = /** @class */ (function () {[m
[32m+[m[32m    function RSSUtils() {[m
[32m+[m[32m    }[m
[32m+[m[32m    RSSUtils.getRSSvalue = function (widths, maxWidth, noNarrow) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var n = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var widths_1 = __values(widths), widths_1_1 = widths_1.next(); !widths_1_1.done; widths_1_1 = widths_1.next()) {[m
[32m+[m[32m                var width = widths_1_1.value;[m
[32m+[m[32m                n += width;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (widths_1_1 && !widths_1_1.done && (_a = widths_1.return)) _a.call(widths_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var val = 0;[m
[32m+[m[32m        var narrowMask = 0;[m
[32m+[m[32m        var elements = widths.length;[m
[32m+[m[32m        for (var bar = 0; bar < elements - 1; bar++) {[m
[32m+[m[32m            var elmWidth = void 0;[m
[32m+[m[32m            for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {[m
[32m+[m[32m                var subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);[m
[32m+[m[32m                if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {[m
[32m+[m[32m                    subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (elements - bar - 1 > 1) {[m
[32m+[m[32m                    var lessVal = 0;[m
[32m+[m[32m                    for (var mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {[m
[32m+[m[32m                        lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    subVal -= lessVal * (elements - 1 - bar);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (n - elmWidth > maxWidth) {[m
[32m+[m[32m                    subVal--;[m
[32m+[m[32m                }[m
[32m+[m[32m                val += subVal;[m
[32m+[m[32m            }[m
[32m+[m[32m            n -= elmWidth;[m
[32m+[m[32m        }[m
[32m+[m[32m        return val;[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSUtils.combins = function (n, r) {[m
[32m+[m[32m        var maxDenom;[m
[32m+[m[32m        var minDenom;[m
[32m+[m[32m        if (n - r > r) {[m
[32m+[m[32m            minDenom = r;[m
[32m+[m[32m            maxDenom = n - r;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            minDenom = n - r;[m
[32m+[m[32m            maxDenom = r;[m
[32m+[m[32m        }[m
[32m+[m[32m        var val = 1;[m
[32m+[m[32m        var j = 1;[m
[32m+[m[32m        for (var i = n; i > maxDenom; i--) {[m
[32m+[m[32m            val *= i;[m
[32m+[m[32m            if (j <= minDenom) {[m
[32m+[m[32m                val /= j;[m
[32m+[m[32m                j++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        while ((j <= minDenom)) {[m
[32m+[m[32m            val /= j;[m
[32m+[m[32m            j++;[m
[32m+[m[32m        }[m
[32m+[m[32m        return val;[m
[32m+[m[32m    };[m
[32m+[m[32m    return RSSUtils;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = RSSUtils;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2e8f592[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.d.ts[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mimport BitArray from '../../../common/BitArray';[m
[32m+[m[32mimport ExpandedPair from './ExpandedPair';[m
[32m+[m[32mexport default class BitArrayBuilder {[m
[32m+[m[32m    static buildBitArray(pairs: Array<ExpandedPair>): BitArray;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..96b954d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/BitArrayBuilder.js[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BitArray_1 = require("../../../common/BitArray");[m
[32m+[m[32mvar BitArrayBuilder = /** @class */ (function () {[m
[32m+[m[32m    function BitArrayBuilder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    BitArrayBuilder.buildBitArray = function (pairs) {[m
[32m+[m[32m        var charNumber = pairs.length * 2 - 1;[m
[32m+[m[32m        if (pairs[pairs.length - 1].getRightChar() == null) {[m
[32m+[m[32m            charNumber -= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        var size = 12 * charNumber;[m
[32m+[m[32m        var binary = new BitArray_1.default(size);[m
[32m+[m[32m        var accPos = 0;[m
[32m+[m[32m        var firstPair = pairs[0];[m
[32m+[m[32m        var firstValue = firstPair.getRightChar().getValue();[m
[32m+[m[32m        for (var i = 11; i >= 0; --i) {[m
[32m+[m[32m            if ((firstValue & (1 << i)) !== 0) {[m
[32m+[m[32m                binary.set(accPos);[m
[32m+[m[32m            }[m
[32m+[m[32m            accPos++;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 1; i < pairs.length; ++i) {[m
[32m+[m[32m            var currentPair = pairs[i];[m
[32m+[m[32m            var leftValue = currentPair.getLeftChar().getValue();[m
[32m+[m[32m            for (var j = 11; j >= 0; --j) {[m
[32m+[m[32m                if ((leftValue & (1 << j)) !== 0) {[m
[32m+[m[32m                    binary.set(accPos);[m
[32m+[m[32m                }[m
[32m+[m[32m                accPos++;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (currentPair.getRightChar() !== null) {[m
[32m+[m[32m                var rightValue = currentPair.getRightChar().getValue();[m
[32m+[m[32m                for (var j = 11; j >= 0; --j) {[m
[32m+[m[32m                    if ((rightValue & (1 << j)) !== 0) {[m
[32m+[m[32m                        binary.set(accPos);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    accPos++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return binary;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitArrayBuilder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitArrayBuilder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..cea6ac0[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport DataCharacter from '../../rss/DataCharacter';[m
[32m+[m[32mimport FinderPattern from '../../rss/FinderPattern';[m
[32m+[m[32mexport default class ExpandedPair {[m
[32m+[m[32m    private readonly maybeLast;[m
[32m+[m[32m    private readonly leftchar;[m
[32m+[m[32m    private readonly rightchar;[m
[32m+[m[32m    private readonly finderpattern;[m
[32m+[m[32m    constructor(leftChar: DataCharacter, rightChar: DataCharacter, finderPatter: FinderPattern, mayBeLast: boolean);[m
[32m+[m[32m    mayBeLast(): boolean;[m
[32m+[m[32m    getLeftChar(): DataCharacter;[m
[32m+[m[32m    getRightChar(): DataCharacter;[m
[32m+[m[32m    getFinderPattern(): FinderPattern;[m
[32m+[m[32m    mustBeLast(): boolean;[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m    static equals(o1: any, o2: any): boolean;[m
[32m+[m[32m    private static equalsOrNull;[m
[32m+[m[32m    hashCode(): any;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5d74830[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedPair.js[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ExpandedPair = /** @class */ (function () {[m
[32m+[m[32m    function ExpandedPair(leftChar, rightChar, finderPatter, mayBeLast) {[m
[32m+[m[32m        this.leftchar = leftChar;[m
[32m+[m[32m        this.rightchar = rightChar;[m
[32m+[m[32m        this.finderpattern = finderPatter;[m
[32m+[m[32m        this.maybeLast = mayBeLast;[m
[32m+[m[32m    }[m
[32m+[m[32m    ExpandedPair.prototype.mayBeLast = function () {[m
[32m+[m[32m        return this.maybeLast;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.getLeftChar = function () {[m
[32m+[m[32m        return this.leftchar;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.getRightChar = function () {[m
[32m+[m[32m        return this.rightchar;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.getFinderPattern = function () {[m
[32m+[m[32m        return this.finderpattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.mustBeLast = function () {[m
[32m+[m[32m        return this.rightchar == null;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.toString = function () {[m
[32m+[m[32m        return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) + ' ]';[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.equals = function (o1, o2) {[m
[32m+[m[32m        if (!(o1 instanceof ExpandedPair)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&[m
[32m+[m[32m            ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&[m
[32m+[m[32m            ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.equalsOrNull = function (o1, o2) {[m
[32m+[m[32m        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedPair.prototype.hashCode = function () {[m
[32m+[m[32m        // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);[m
[32m+[m[32m        var value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();[m
[32m+[m[32m        return value;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ExpandedPair;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ExpandedPair;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ef331f8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport ExpandedPair from './ExpandedPair';[m
[32m+[m[32mexport default class ExpandedRow {[m
[32m+[m[32m    private readonly pairs;[m
[32m+[m[32m    private readonly rowNumber;[m
[32m+[m[32m    private readonly wasReversed;[m
[32m+[m[32m    constructor(pairs: Array<ExpandedPair>, rowNumber: number, wasReversed: boolean);[m
[32m+[m[32m    getPairs(): Array<ExpandedPair>;[m
[32m+[m[32m    getRowNumber(): number;[m
[32m+[m[32m    isReversed(): boolean;[m
[32m+[m[32m    isEquivalent(otherPairs: Array<ExpandedPair>): boolean;[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Two rows are equal if they contain the same pairs in the same order.[m
[32m+[m[32m     */[m
[32m+[m[32m    equals(o1: ExpandedRow, o2: ExpandedRow): boolean;[m
[32m+[m[32m    checkEqualitity(pair1: any, pair2: any): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e343692[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/ExpandedRow.js[m
[36m@@ -0,0 +1,52 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar ExpandedRow = /** @class */ (function () {[m
[32m+[m[32m    function ExpandedRow(pairs, rowNumber, wasReversed) {[m
[32m+[m[32m        this.pairs = pairs;[m
[32m+[m[32m        this.rowNumber = rowNumber;[m
[32m+[m[32m        this.wasReversed = wasReversed;[m
[32m+[m[32m    }[m
[32m+[m[32m    ExpandedRow.prototype.getPairs = function () {[m
[32m+[m[32m        return this.pairs;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedRow.prototype.getRowNumber = function () {[m
[32m+[m[32m        return this.rowNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedRow.prototype.isReversed = function () {[m
[32m+[m[32m        return this.wasReversed;[m
[32m+[m[32m    };[m
[32m+[m[32m    // check implementation[m
[32m+[m[32m    ExpandedRow.prototype.isEquivalent = function (otherPairs) {[m
[32m+[m[32m        return this.checkEqualitity(this, otherPairs);[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    ExpandedRow.prototype.toString = function () {[m
[32m+[m[32m        return '{ ' + this.pairs + ' }';[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Two rows are equal if they contain the same pairs in the same order.[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    // check implementation[m
[32m+[m[32m    ExpandedRow.prototype.equals = function (o1, o2) {[m
[32m+[m[32m        if (!(o1 instanceof ExpandedRow)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;[m
[32m+[m[32m    };[m
[32m+[m[32m    ExpandedRow.prototype.checkEqualitity = function (pair1, pair2) {[m
[32m+[m[32m        if (!pair1 || !pair2)[m
[32m+[m[32m            return;[m
[32m+[m[32m        var result;[m
[32m+[m[32m        pair1.forEach(function (e1, i) {[m
[32m+[m[32m            pair2.forEach(function (e2) {[m
[32m+[m[32m                if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {[m
[32m+[m[32m                    result = true;[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m        });[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ExpandedRow;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ExpandedRow;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..05916e1[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.d.ts[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32mimport BitArray from '../../../common/BitArray';[m
[32m+[m[32mimport DecodeHintType from '../../../DecodeHintType';[m
[32m+[m[32mimport Result from '../../../Result';[m
[32m+[m[32mimport AbstractRSSReader from '../../rss/AbstractRSSReader';[m
[32m+[m[32mimport DataCharacter from '../../rss/DataCharacter';[m
[32m+[m[32mimport FinderPattern from '../../rss/FinderPattern';[m
[32m+[m[32mimport ExpandedPair from './ExpandedPair';[m
[32m+[m[32m/** @experimental */[m
[32m+[m[32mexport default class RSSExpandedReader extends AbstractRSSReader {[m
[32m+[m[32m    private static readonly SYMBOL_WIDEST;[m
[32m+[m[32m    private static readonly EVEN_TOTAL_SUBSET;[m
[32m+[m[32m    private static readonly GSUM;[m
[32m+[m[32m    private static readonly FINDER_PATTERNS;[m
[32m+[m[32m    private static readonly WEIGHTS;[m
[32m+[m[32m    private static readonly FINDER_PAT_A;[m
[32m+[m[32m    private static readonly FINDER_PAT_B;[m
[32m+[m[32m    private static readonly FINDER_PAT_C;[m
[32m+[m[32m    private static readonly FINDER_PAT_D;[m
[32m+[m[32m    private static readonly FINDER_PAT_E;[m
[32m+[m[32m    private static readonly FINDER_PAT_F;[m
[32m+[m[32m    private static readonly FINDER_PATTERN_SEQUENCES;[m
[32m+[m[32m    private static readonly MAX_PAIRS;[m
[32m+[m[32m    private pairs;[m
[32m+[m[32m    private rows;[m
[32m+[m[32m    private readonly startEnd;[m
[32m+[m[32m    private startFromEven;[m
[32m+[m[32m    decodeRow(rowNumber: number, row: BitArray, hints: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    decodeRow2pairs(rowNumber: number, row: BitArray): Array<ExpandedPair>;[m
[32m+[m[32m    private checkRowsBoolean;[m
[32m+[m[32m    private checkRows;[m
[32m+[m[32m    private static isValidSequence;[m
[32m+[m[32m    private storeRow;[m
[32m+[m[32m    private removePartialRows;[m
[32m+[m[32m    private static isPartialRow;[m
[32m+[m[32m    getRows(): any;[m
[32m+[m[32m    static constructResult(pairs: Array<ExpandedPair>): Result;[m
[32m+[m[32m    private checkChecksum;[m
[32m+[m[32m    private static getNextSecondBar;[m
[32m+[m[32m    retrieveNextPair(row: BitArray, previousPairs: Array<ExpandedPair>, rowNumber: number): ExpandedPair;[m
[32m+[m[32m    isEmptyPair(pairs: any): boolean;[m
[32m+[m[32m    private findNextPair;[m
[32m+[m[32m    private static reverseCounters;[m
[32m+[m[32m    private parseFoundFinderPattern;[m
[32m+[m[32m    decodeDataCharacter(row: BitArray, pattern: FinderPattern, isOddPattern: boolean, leftChar: boolean): DataCharacter;[m
[32m+[m[32m    private static isNotA1left;[m
[32m+[m[32m    private adjustOddEvenCounts;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0221460[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/RSSExpandedReader.js[m
[36m@@ -0,0 +1,896 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BarcodeFormat_1 = require("../../../BarcodeFormat");[m
[32m+[m[32mvar MathUtils_1 = require("../../../common/detector/MathUtils");[m
[32m+[m[32m// import FormatException from '../../../FormatException';[m
[32m+[m[32mvar NotFoundException_1 = require("../../../NotFoundException");[m
[32m+[m[32mvar Result_1 = require("../../../Result");[m
[32m+[m[32mvar System_1 = require("../../../util/System");[m
[32m+[m[32mvar AbstractRSSReader_1 = require("../../rss/AbstractRSSReader");[m
[32m+[m[32mvar DataCharacter_1 = require("../../rss/DataCharacter");[m
[32m+[m[32mvar FinderPattern_1 = require("../../rss/FinderPattern");[m
[32m+[m[32mvar RSSUtils_1 = require("../../rss/RSSUtils");[m
[32m+[m[32mvar BitArrayBuilder_1 = require("./BitArrayBuilder");[m
[32m+[m[32mvar AbstractExpandedDecoderComplement_1 = require("./decoders/AbstractExpandedDecoderComplement");[m
[32m+[m[32mvar ExpandedPair_1 = require("./ExpandedPair");[m
[32m+[m[32mvar ExpandedRow_1 = require("./ExpandedRow");[m
[32m+[m[32m// import java.util.ArrayList;[m
[32m+[m[32m// import java.util.Iterator;[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32m// import java.util.Collections;[m
[32m+[m[32m/** @experimental */[m
[32m+[m[32mvar RSSExpandedReader = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(RSSExpandedReader, _super);[m
[32m+[m[32m    function RSSExpandedReader() {[m
[32m+[m[32m        var _this = _super !== null && _super.apply(this, arguments) || this;[m
[32m+[m[32m        _this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);[m
[32m+[m[32m        _this.rows = new Array();[m
[32m+[m[32m        _this.startEnd = [2];[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    RSSExpandedReader.prototype.decodeRow = function (rowNumber, row, hints) {[m
[32m+[m[32m        // Rows can start with even pattern in case in prev rows there where odd number of patters.[m
[32m+[m[32m        // So lets try twice[m
[32m+[m[32m        // this.pairs.clear();[m
[32m+[m[32m        this.pairs.length = 0;[m
[32m+[m[32m        this.startFromEven = false;[m
[32m+[m[32m        try {[m
[32m+[m[32m            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            // OK[m
[32m+[m[32m            // console.log(e);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.pairs.length = 0;[m
[32m+[m[32m        this.startFromEven = true;[m
[32m+[m[32m        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.reset = function () {[m
[32m+[m[32m        this.pairs.length = 0;[m
[32m+[m[32m        this.rows.length = 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Not private for testing[m
[32m+[m[32m    RSSExpandedReader.prototype.decodeRow2pairs = function (rowNumber, row) {[m
[32m+[m[32m        var done = false;[m
[32m+[m[32m        while (!done) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (error) {[m
[32m+[m[32m                if (error instanceof NotFoundException_1.default) {[m
[32m+[m[32m                    if (!this.pairs.length) {[m
[32m+[m[32m                        throw new NotFoundException_1.default();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // exit this loop when retrieveNextPair() fails and throws[m
[32m+[m[32m                    done = true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // TODO: verify sequence of finder patterns as in checkPairSequence()[m
[32m+[m[32m        if (this.checkChecksum()) {[m
[32m+[m[32m            return this.pairs;[m
[32m+[m[32m        }[m
[32m+[m[32m        var tryStackedDecode;[m
[32m+[m[32m        if (this.rows.length) {[m
[32m+[m[32m            tryStackedDecode = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            tryStackedDecode = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // let tryStackedDecode = !this.rows.isEmpty();[m
[32m+[m[32m        this.storeRow(rowNumber, false); // TODO: deal with reversed rows[m
[32m+[m[32m        if (tryStackedDecode) {[m
[32m+[m[32m            // When the image is 180-rotated, then rows are sorted in wrong direction.[m
[32m+[m[32m            // Try twice with both the directions.[m
[32m+[m[32m            var ps = this.checkRowsBoolean(false);[m
[32m+[m[32m            if (ps != null) {[m
[32m+[m[32m                return ps;[m
[32m+[m[32m            }[m
[32m+[m[32m            ps = this.checkRowsBoolean(true);[m
[32m+[m[32m            if (ps != null) {[m
[32m+[m[32m                return ps;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    // Need to Verify[m
[32m+[m[32m    RSSExpandedReader.prototype.checkRowsBoolean = function (reverse) {[m
[32m+[m[32m        // Limit number of rows we are checking[m
[32m+[m[32m        // We use recursive algorithm with pure complexity and don't want it to take forever[m
[32m+[m[32m        // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough[m
[32m+[m[32m        if (this.rows.length > 25) {[m
[32m+[m[32m            this.rows.length = 0; // We will never have a chance to get result, so clear it[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.pairs.length = 0;[m
[32m+[m[32m        if (reverse) {[m
[32m+[m[32m            this.rows = this.rows.reverse();[m
[32m+[m[32m            // Collections.reverse(this.rows);[m
[32m+[m[32m        }[m
[32m+[m[32m        var ps = null;[m
[32m+[m[32m        try {[m
[32m+[m[32m            ps = this.checkRows(new Array(), 0);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            // OK[m
[32m+[m[32m            console.log(e);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (reverse) {[m
[32m+[m[32m            this.rows = this.rows.reverse();[m
[32m+[m[32m            // Collections.reverse(this.rows);[m
[32m+[m[32m        }[m
[32m+[m[32m        return ps;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Try to construct a valid rows sequence[m
[32m+[m[32m    // Recursion is used to implement backtracking[m
[32m+[m[32m    RSSExpandedReader.prototype.checkRows = function (collectedRows, currentRow) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        for (var i = currentRow; i < this.rows.length; i++) {[m
[32m+[m[32m            var row = this.rows[i];[m
[32m+[m[32m            this.pairs.length = 0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var collectedRows_1 = (e_1 = void 0, __values(collectedRows)), collectedRows_1_1 = collectedRows_1.next(); !collectedRows_1_1.done; collectedRows_1_1 = collectedRows_1.next()) {[m
[32m+[m[32m                    var collectedRow = collectedRows_1_1.value;[m
[32m+[m[32m                    this.pairs.push(collectedRow.getPairs());[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (collectedRows_1_1 && !collectedRows_1_1.done && (_a = collectedRows_1.return)) _a.call(collectedRows_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            this.pairs.push(row.getPairs());[m
[32m+[m[32m            if (!RSSExpandedReader.isValidSequence(this.pairs)) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (this.checkChecksum()) {[m
[32m+[m[32m                return this.pairs;[m
[32m+[m[32m            }[m
[32m+[m[32m            var rs = new Array(collectedRows);[m
[32m+[m[32m            rs.push(row);[m
[32m+[m[32m            try {[m
[32m+[m[32m                // Recursion: try to add more rows[m
[32m+[m[32m                return this.checkRows(rs, i + 1);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e) {[m
[32m+[m[32m                // We failed, try the next candidate[m
[32m+[m[32m                console.log(e);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    // Whether the pairs form a valid find pattern sequence,[m
[32m+[m[32m    // either complete or a prefix[m
[32m+[m[32m    RSSExpandedReader.isValidSequence = function (pairs) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(RSSExpandedReader.FINDER_PATTERN_SEQUENCES), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var sequence = _c.value;[m
[32m+[m[32m                if (pairs.length > sequence.length) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                var stop_1 = true;[m
[32m+[m[32m                for (var j = 0; j < pairs.length; j++) {[m
[32m+[m[32m                    if (pairs[j].getFinderPattern().getValue() !== sequence[j]) {[m
[32m+[m[32m                        stop_1 = false;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (stop_1) {[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.storeRow = function (rowNumber, wasReversed) {[m
[32m+[m[32m        // Discard if duplicate above or below; otherwise insert in order by row number.[m
[32m+[m[32m        var insertPos = 0;[m
[32m+[m[32m        var prevIsSame = false;[m
[32m+[m[32m        var nextIsSame = false;[m
[32m+[m[32m        while (insertPos < this.rows.length) {[m
[32m+[m[32m            var erow = this.rows[insertPos];[m
[32m+[m[32m            if (erow.getRowNumber() > rowNumber) {[m
[32m+[m[32m                nextIsSame = erow.isEquivalent(this.pairs);[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            prevIsSame = erow.isEquivalent(this.pairs);[m
[32m+[m[32m            insertPos++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (nextIsSame || prevIsSame) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        // When the row was partially decoded (e.g. 2 pairs found instead of 3),[m
[32m+[m[32m        // it will prevent us from detecting the barcode.[m
[32m+[m[32m        // Try to merge partial rows[m
[32m+[m[32m        // Check whether the row is part of an allready detected row[m
[32m+[m[32m        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.rows.push(insertPos, new ExpandedRow_1.default(this.pairs, rowNumber, wasReversed));[m
[32m+[m[32m        this.removePartialRows(this.pairs, this.rows);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Remove all the rows that contains only specified pairs[m
[32m+[m[32m    RSSExpandedReader.prototype.removePartialRows = function (pairs, rows) {[m
[32m+[m[32m        var e_3, _a, e_4, _b, e_5, _c;[m
[32m+[m[32m        try {[m
[32m+[m[32m            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {[m
[32m+[m[32m            //   ExpandedRow r = iterator.next();[m
[32m+[m[32m            //   if (r.getPairs().size() == pairs.size()) {[m
[32m+[m[32m            //     continue;[m
[32m+[m[32m            //   }[m
[32m+[m[32m            //   boolean allFound = true;[m
[32m+[m[32m            //   for (ExpandedPair p : r.getPairs()) {[m
[32m+[m[32m            //     boolean found = false;[m
[32m+[m[32m            //     for (ExpandedPair pp : pairs) {[m
[32m+[m[32m            //       if (p.equals(pp)) {[m
[32m+[m[32m            //         found = true;[m
[32m+[m[32m            //         break;[m
[32m+[m[32m            //       }[m
[32m+[m[32m            //     }[m
[32m+[m[32m            //     if (!found) {[m
[32m+[m[32m            //       allFound = false;[m
[32m+[m[32m            //       break;[m
[32m+[m[32m            //     }[m
[32m+[m[32m            //   }[m
[32m+[m[32m            //   if (allFound) {[m
[32m+[m[32m            //     // 'pairs' contains all the pairs from the row 'r'[m
[32m+[m[32m            //     iterator.remove();[m
[32m+[m[32m            //   }[m
[32m+[m[32m            // }[m
[32m+[m[32m            for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {[m
[32m+[m[32m                var row = rows_1_1.value;[m
[32m+[m[32m                if (row.getPairs().length === pairs.length) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                var allFound = true;[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var _d = (e_4 = void 0, __values(row.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {[m
[32m+[m[32m                        var p = _e.value;[m
[32m+[m[32m                        var found = false;[m
[32m+[m[32m                        try {[m
[32m+[m[32m                            for (var pairs_1 = (e_5 = void 0, __values(pairs)), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {[m
[32m+[m[32m                                var pp = pairs_1_1.value;[m
[32m+[m[32m                                if (ExpandedPair_1.default.equals(p, pp)) {[m
[32m+[m[32m                                    found = true;[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        catch (e_5_1) { e_5 = { error: e_5_1 }; }[m
[32m+[m[32m                        finally {[m
[32m+[m[32m                            try {[m
[32m+[m[32m                                if (pairs_1_1 && !pairs_1_1.done && (_c = pairs_1.return)) _c.call(pairs_1);[m
[32m+[m[32m                            }[m
[32m+[m[32m                            finally { if (e_5) throw e_5.error; }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (!found) {[m
[32m+[m[32m                            allFound = false;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Returns true when one of the rows already contains all the pairs[m
[32m+[m[32m    RSSExpandedReader.isPartialRow = function (pairs, rows) {[m
[32m+[m[32m        var e_6, _a, e_7, _b, e_8, _c;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var rows_2 = __values(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {[m
[32m+[m[32m                var r = rows_2_1.value;[m
[32m+[m[32m                var allFound = true;[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var pairs_2 = (e_7 = void 0, __values(pairs)), pairs_2_1 = pairs_2.next(); !pairs_2_1.done; pairs_2_1 = pairs_2.next()) {[m
[32m+[m[32m                        var p = pairs_2_1.value;[m
[32m+[m[32m                        var found = false;[m
[32m+[m[32m                        try {[m
[32m+[m[32m                            for (var _d = (e_8 = void 0, __values(r.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {[m
[32m+[m[32m                                var pp = _e.value;[m
[32m+[m[32m                                if (p.equals(pp)) {[m
[32m+[m[32m                                    found = true;[m
[32m+[m[32m                                    break;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        catch (e_8_1) { e_8 = { error: e_8_1 }; }[m
[32m+[m[32m                        finally {[m
[32m+[m[32m                            try {[m
[32m+[m[32m                                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);[m
[32m+[m[32m                            }[m
[32m+[m[32m                            finally { if (e_8) throw e_8.error; }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (!found) {[m
[32m+[m[32m                            allFound = false;[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_7_1) { e_7 = { error: e_7_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (pairs_2_1 && !pairs_2_1.done && (_b = pairs_2.return)) _b.call(pairs_2);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_7) throw e_7.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (allFound) {[m
[32m+[m[32m                    // the row 'r' contain all the pairs from 'pairs'[m
[32m+[m[32m                    return true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_6_1) { e_6 = { error: e_6_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (rows_2_1 && !rows_2_1.done && (_a = rows_2.return)) _a.call(rows_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_6) throw e_6.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Only used for unit testing[m
[32m+[m[32m    RSSExpandedReader.prototype.getRows = function () {[m
[32m+[m[32m        return this.rows;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Not private for unit testing[m
[32m+[m[32m    RSSExpandedReader.constructResult = function (pairs) {[m
[32m+[m[32m        var binary = BitArrayBuilder_1.default.buildBitArray(pairs);[m
[32m+[m[32m        var decoder = AbstractExpandedDecoderComplement_1.createDecoder(binary);[m
[32m+[m[32m        var resultingString = decoder.parseInformation();[m
[32m+[m[32m        var firstPoints = pairs[0].getFinderPattern().getResultPoints();[m
[32m+[m[32m        var lastPoints = pairs[pairs.length - 1][m
[32m+[m[32m            .getFinderPattern()[m
[32m+[m[32m            .getResultPoints();[m
[32m+[m[32m        var points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];[m
[32m+[m[32m        return new Result_1.default(resultingString, null, null, points, BarcodeFormat_1.default.RSS_EXPANDED, null);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.checkChecksum = function () {[m
[32m+[m[32m        var firstPair = this.pairs.get(0);[m
[32m+[m[32m        var checkCharacter = firstPair.getLeftChar();[m
[32m+[m[32m        var firstCharacter = firstPair.getRightChar();[m
[32m+[m[32m        if (firstCharacter === null) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var checksum = firstCharacter.getChecksumPortion();[m
[32m+[m[32m        var s = 2;[m
[32m+[m[32m        for (var i = 1; i < this.pairs.size(); ++i) {[m
[32m+[m[32m            var currentPair = this.pairs.get(i);[m
[32m+[m[32m            checksum += currentPair.getLeftChar().getChecksumPortion();[m
[32m+[m[32m            s++;[m
[32m+[m[32m            var currentRightChar = currentPair.getRightChar();[m
[32m+[m[32m            if (currentRightChar != null) {[m
[32m+[m[32m                checksum += currentRightChar.getChecksumPortion();[m
[32m+[m[32m                s++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        checksum %= 211;[m
[32m+[m[32m        var checkCharacterValue = 211 * (s - 4) + checksum;[m
[32m+[m[32m        return checkCharacterValue === checkCharacter.getValue();[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.getNextSecondBar = function (row, initialPos) {[m
[32m+[m[32m        var currentPos;[m
[32m+[m[32m        if (row.get(initialPos)) {[m
[32m+[m[32m            currentPos = row.getNextUnset(initialPos);[m
[32m+[m[32m            currentPos = row.getNextSet(currentPos);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            currentPos = row.getNextSet(initialPos);[m
[32m+[m[32m            currentPos = row.getNextUnset(currentPos);[m
[32m+[m[32m        }[m
[32m+[m[32m        return currentPos;[m
[32m+[m[32m    };[m
[32m+[m[32m    // not private for testing[m
[32m+[m[32m    RSSExpandedReader.prototype.retrieveNextPair = function (row, previousPairs, rowNumber) {[m
[32m+[m[32m        var isOddPattern = previousPairs.length % 2 === 0;[m
[32m+[m[32m        if (this.startFromEven) {[m
[32m+[m[32m            isOddPattern = !isOddPattern;[m
[32m+[m[32m        }[m
[32m+[m[32m        var pattern;[m
[32m+[m[32m        var keepFinding = true;[m
[32m+[m[32m        var forcedOffset = -1;[m
[32m+[m[32m        do {[m
[32m+[m[32m            this.findNextPair(row, previousPairs, forcedOffset);[m
[32m+[m[32m            pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);[m
[32m+[m[32m            if (pattern === null) {[m
[32m+[m[32m                forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                keepFinding = false;[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (keepFinding);[m
[32m+[m[32m        // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.[m
[32m+[m[32m        // boolean mayBeLast = checkPairSequence(previousPairs, pattern);[m
[32m+[m[32m        var leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);[m
[32m+[m[32m        if (!this.isEmptyPair(previousPairs) &&[m
[32m+[m[32m            previousPairs[previousPairs.length - 1].mustBeLast()) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var rightChar;[m
[32m+[m[32m        try {[m
[32m+[m[32m            rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            rightChar = null;[m
[32m+[m[32m            console.log(e);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ExpandedPair_1.default(leftChar, rightChar, pattern, true);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.isEmptyPair = function (pairs) {[m
[32m+[m[32m        if (pairs.length === 0) {[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.findNextPair = function (row, previousPairs, forcedOffset) {[m
[32m+[m[32m        var counters = this.getDecodeFinderCounters();[m
[32m+[m[32m        counters[0] = 0;[m
[32m+[m[32m        counters[1] = 0;[m
[32m+[m[32m        counters[2] = 0;[m
[32m+[m[32m        counters[3] = 0;[m
[32m+[m[32m        var width = row.getSize();[m
[32m+[m[32m        var rowOffset;[m
[32m+[m[32m        if (forcedOffset >= 0) {[m
[32m+[m[32m            rowOffset = forcedOffset;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.isEmptyPair(previousPairs)) {[m
[32m+[m[32m            rowOffset = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var lastPair = previousPairs[previousPairs.length - 1];[m
[32m+[m[32m            rowOffset = lastPair.getFinderPattern().getStartEnd()[1];[m
[32m+[m[32m        }[m
[32m+[m[32m        var searchingEvenPair = previousPairs.length % 2 !== 0;[m
[32m+[m[32m        if (this.startFromEven) {[m
[32m+[m[32m            searchingEvenPair = !searchingEvenPair;[m
[32m+[m[32m        }[m
[32m+[m[32m        var isWhite = false;[m
[32m+[m[32m        while (rowOffset < width) {[m
[32m+[m[32m            isWhite = !row.get(rowOffset);[m
[32m+[m[32m            if (!isWhite) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            rowOffset++;[m
[32m+[m[32m        }[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternStart = rowOffset;[m
[32m+[m[32m        for (var x = rowOffset; x < width; x++) {[m
[32m+[m[32m            if (row.get(x) !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === 3) {[m
[32m+[m[32m                    if (searchingEvenPair) {[m
[32m+[m[32m                        RSSExpandedReader.reverseCounters(counters);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (RSSExpandedReader.isFinderPattern(counters)) {[m
[32m+[m[32m                        this.startEnd[0] = patternStart;[m
[32m+[m[32m                        this.startEnd[1] = x;[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (searchingEvenPair) {[m
[32m+[m[32m                        RSSExpandedReader.reverseCounters(counters);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    counters[0] = counters[2];[m
[32m+[m[32m                    counters[1] = counters[3];[m
[32m+[m[32m                    counters[2] = 0;[m
[32m+[m[32m                    counters[3] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.reverseCounters = function (counters) {[m
[32m+[m[32m        var length = counters.length;[m
[32m+[m[32m        for (var i = 0; i < length / 2; ++i) {[m
[32m+[m[32m            var tmp = counters[i];[m
[32m+[m[32m            counters[i] = counters[length - i - 1];[m
[32m+[m[32m            counters[length - i - 1] = tmp;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.parseFoundFinderPattern = function (row, rowNumber, oddPattern) {[m
[32m+[m[32m        // Actually we found elements 2-5.[m
[32m+[m[32m        var firstCounter;[m
[32m+[m[32m        var start;[m
[32m+[m[32m        var end;[m
[32m+[m[32m        if (oddPattern) {[m
[32m+[m[32m            // If pattern number is odd, we need to locate element 1 *before* the current block.[m
[32m+[m[32m            var firstElementStart = this.startEnd[0] - 1;[m
[32m+[m[32m            // Locate element 1[m
[32m+[m[32m            while (firstElementStart >= 0 && !row.get(firstElementStart)) {[m
[32m+[m[32m                firstElementStart--;[m
[32m+[m[32m            }[m
[32m+[m[32m            firstElementStart++;[m
[32m+[m[32m            firstCounter = this.startEnd[0] - firstElementStart;[m
[32m+[m[32m            start = firstElementStart;[m
[32m+[m[32m            end = this.startEnd[1];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.[m
[32m+[m[32m            start = this.startEnd[0];[m
[32m+[m[32m            end = row.getNextUnset(this.startEnd[1] + 1);[m
[32m+[m[32m            firstCounter = end - this.startEnd[1];[m
[32m+[m[32m        }[m
[32m+[m[32m        // Make 'counters' hold 1-4[m
[32m+[m[32m        var counters = this.getDecodeFinderCounters();[m
[32m+[m[32m        System_1.default.arraycopy(counters, 0, counters, 1, counters.length - 1);[m
[32m+[m[32m        counters[0] = firstCounter;[m
[32m+[m[32m        var value;[m
[32m+[m[32m        try {[m
[32m+[m[32m            value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});[m
[32m+[m[32m        return new FinderPattern_1.default(value, [start, end], start, end, rowNumber);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.decodeDataCharacter = function (row, pattern, isOddPattern, leftChar) {[m
[32m+[m[32m        var counters = this.getDataCharacterCounters();[m
[32m+[m[32m        for (var x = 0; x < counters.length; x++) {[m
[32m+[m[32m            counters[x] = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (leftChar) {[m
[32m+[m[32m            RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);[m
[32m+[m[32m            // reverse it[m
[32m+[m[32m            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {[m
[32m+[m[32m                var temp = counters[i];[m
[32m+[m[32m                counters[i] = counters[j];[m
[32m+[m[32m                counters[j] = temp;[m
[32m+[m[32m            }[m
[32m+[m[32m        } // counters[] has the pixels of the module[m
[32m+[m[32m        var numModules = 17; // left and right data characters have all the same length[m
[32m+[m[32m        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;[m
[32m+[m[32m        // Sanity check: element width for pattern and the character should match[m
[32m+[m[32m        var expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;[m
[32m+[m[32m        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth >[m
[32m+[m[32m            0.3) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var oddCounts = this.getOddCounts();[m
[32m+[m[32m        var evenCounts = this.getEvenCounts();[m
[32m+[m[32m        var oddRoundingErrors = this.getOddRoundingErrors();[m
[32m+[m[32m        var evenRoundingErrors = this.getEvenRoundingErrors();[m
[32m+[m[32m        for (var i = 0; i < counters.length; i++) {[m
[32m+[m[32m            var value_1 = (1.0 * counters[i]) / elementWidth;[m
[32m+[m[32m            var count = value_1 + 0.5; // Round[m
[32m+[m[32m            if (count < 1) {[m
[32m+[m[32m                if (value_1 < 0.3) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                count = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (count > 8) {[m
[32m+[m[32m                if (value_1 > 8.7) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                count = 8;[m
[32m+[m[32m            }[m
[32m+[m[32m            var offset = i / 2;[m
[32m+[m[32m            if ((i & 0x01) === 0) {[m
[32m+[m[32m                oddCounts[offset] = count;[m
[32m+[m[32m                oddRoundingErrors[offset] = value_1 - count;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                evenCounts[offset] = count;[m
[32m+[m[32m                evenRoundingErrors[offset] = value_1 - count;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.adjustOddEvenCounts(numModules);[m
[32m+[m[32m        var weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;[m
[32m+[m[32m        var oddSum = 0;[m
[32m+[m[32m        var oddChecksumPortion = 0;[m
[32m+[m[32m        for (var i = oddCounts.length - 1; i >= 0; i--) {[m
[32m+[m[32m            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {[m
[32m+[m[32m                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];[m
[32m+[m[32m                oddChecksumPortion += oddCounts[i] * weight;[m
[32m+[m[32m            }[m
[32m+[m[32m            oddSum += oddCounts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var evenChecksumPortion = 0;[m
[32m+[m[32m        // int evenSum = 0;[m
[32m+[m[32m        for (var i = evenCounts.length - 1; i >= 0; i--) {[m
[32m+[m[32m            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {[m
[32m+[m[32m                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];[m
[32m+[m[32m                evenChecksumPortion += evenCounts[i] * weight;[m
[32m+[m[32m            }[m
[32m+[m[32m            // evenSum += evenCounts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        var checksumPortion = oddChecksumPortion + evenChecksumPortion;[m
[32m+[m[32m        if ((oddSum & 0x01) !== 0 || oddSum > 13 || oddSum < 4) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var group = (13 - oddSum) / 2;[m
[32m+[m[32m        var oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];[m
[32m+[m[32m        var evenWidest = 9 - oddWidest;[m
[32m+[m[32m        var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);[m
[32m+[m[32m        var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);[m
[32m+[m[32m        var tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];[m
[32m+[m[32m        var gSum = RSSExpandedReader.GSUM[group];[m
[32m+[m[32m        var value = vOdd * tEven + vEven + gSum;[m
[32m+[m[32m        return new DataCharacter_1.default(value, checksumPortion);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.isNotA1left = function (pattern, isOddPattern, leftChar) {[m
[32m+[m[32m        // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char[m
[32m+[m[32m        return !(pattern.getValue() === 0 && isOddPattern && leftChar);[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.prototype.adjustOddEvenCounts = function (numModules) {[m
[32m+[m[32m        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));[m
[32m+[m[32m        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));[m
[32m+[m[32m        var incrementOdd = false;[m
[32m+[m[32m        var decrementOdd = false;[m
[32m+[m[32m        if (oddSum > 13) {[m
[32m+[m[32m            decrementOdd = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (oddSum < 4) {[m
[32m+[m[32m            incrementOdd = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        var incrementEven = false;[m
[32m+[m[32m        var decrementEven = false;[m
[32m+[m[32m        if (evenSum > 13) {[m
[32m+[m[32m            decrementEven = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (evenSum < 4) {[m
[32m+[m[32m            incrementEven = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        var mismatch = oddSum + evenSum - numModules;[m
[32m+[m[32m        var oddParityBad = (oddSum & 0x01) === 1;[m
[32m+[m[32m        var evenParityBad = (evenSum & 0x01) === 0;[m
[32m+[m[32m        if (mismatch === 1) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                decrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                decrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (mismatch === -1) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                incrementOdd = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                incrementEven = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (mismatch === 0) {[m
[32m+[m[32m            if (oddParityBad) {[m
[32m+[m[32m                if (!evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                // Both bad[m
[32m+[m[32m                if (oddSum < evenSum) {[m
[32m+[m[32m                    incrementOdd = true;[m
[32m+[m[32m                    decrementEven = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    decrementOdd = true;[m
[32m+[m[32m                    incrementEven = true;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (evenParityBad) {[m
[32m+[m[32m                    throw new NotFoundException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                // Nothing to do![m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (incrementOdd) {[m
[32m+[m[32m            if (decrementOdd) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decrementOdd) {[m
[32m+[m[32m            RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (incrementEven) {[m
[32m+[m[32m            if (decrementEven) {[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decrementEven) {[m
[32m+[m[32m            RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];[m
[32m+[m[32m    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];[m
[32m+[m[32m    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];[m
[32m+[m[32m    RSSExpandedReader.FINDER_PATTERNS = [[m
[32m+[m[32m        Int32Array.from([1, 8, 4, 1]),[m
[32m+[m[32m        Int32Array.from([3, 6, 4, 1]),[m
[32m+[m[32m        Int32Array.from([3, 4, 6, 1]),[m
[32m+[m[32m        Int32Array.from([3, 2, 8, 1]),[m
[32m+[m[32m        Int32Array.from([2, 6, 5, 1]),[m
[32m+[m[32m        Int32Array.from([2, 2, 9, 1]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    RSSExpandedReader.WEIGHTS = [[m
[32m+[m[32m        [1, 3, 9, 27, 81, 32, 96, 77],[m
[32m+[m[32m        [20, 60, 180, 118, 143, 7, 21, 63],[m
[32m+[m[32m        [189, 145, 13, 39, 117, 140, 209, 205],[m
[32m+[m[32m        [193, 157, 49, 147, 19, 57, 171, 91],[m
[32m+[m[32m        [62, 186, 136, 197, 169, 85, 44, 132],[m
[32m+[m[32m        [185, 133, 188, 142, 4, 12, 36, 108],[m
[32m+[m[32m        [113, 128, 173, 97, 80, 29, 87, 50],[m
[32m+[m[32m        [150, 28, 84, 41, 123, 158, 52, 156],[m
[32m+[m[32m        [46, 138, 203, 187, 139, 206, 196, 166],[m
[32m+[m[32m        [76, 17, 51, 153, 37, 111, 122, 155],[m
[32m+[m[32m        [43, 129, 176, 106, 107, 110, 119, 146],[m
[32m+[m[32m        [16, 48, 144, 10, 30, 90, 59, 177],[m
[32m+[m[32m        [109, 116, 137, 200, 178, 112, 125, 164],[m
[32m+[m[32m        [70, 210, 208, 202, 184, 130, 179, 115],[m
[32m+[m[32m        [134, 191, 151, 31, 93, 68, 204, 190],[m
[32m+[m[32m        [148, 22, 66, 198, 172, 94, 71, 2],[m
[32m+[m[32m        [6, 18, 54, 162, 64, 192, 154, 40],[m
[32m+[m[32m        [120, 149, 25, 75, 14, 42, 126, 167],[m
[32m+[m[32m        [79, 26, 78, 23, 69, 207, 199, 175],[m
[32m+[m[32m        [103, 98, 83, 38, 114, 131, 182, 124],[m
[32m+[m[32m        [161, 61, 183, 127, 170, 88, 53, 159],[m
[32m+[m[32m        [55, 165, 73, 8, 24, 72, 5, 15],[m
[32m+[m[32m        [45, 135, 194, 160, 58, 174, 100, 89],[m
[32m+[m[32m    ];[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_A = 0;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_B = 1;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_C = 2;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_D = 3;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_E = 4;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PAT_F = 5;[m
[32m+[m[32m    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [[m
[32m+[m[32m        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m        ],[m
[32m+[m[32m        [[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_A,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_B,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_C,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_D,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_E,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m            RSSExpandedReader.FINDER_PAT_F,[m
[32m+[m[32m        ],[m
[32m+[m[32m    ];[m
[32m+[m[32m    RSSExpandedReader.MAX_PAIRS = 11;[m
[32m+[m[32m    return RSSExpandedReader;[m
[32m+[m[32m}(AbstractRSSReader_1.default));[m
[32m+[m[32mexports.default = RSSExpandedReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d466a37[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport AI013x0xDecoder from './AI013x0xDecoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mexport default class AI013103decoder extends AI013x0xDecoder {[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    protected addWeightCode(buf: StringBuilder, weight: number): void;[m
[32m+[m[32m    protected checkWeight(weight: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d7cbe41[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013103decoder.js[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI013x0xDecoder_1 = require("./AI013x0xDecoder");[m
[32m+[m[32mvar AI013103decoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI013103decoder, _super);[m
[32m+[m[32m    function AI013103decoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI013103decoder.prototype.addWeightCode = function (buf, weight) {[m
[32m+[m[32m        buf.append('(3103)');[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013103decoder.prototype.checkWeight = function (weight) {[m
[32m+[m[32m        return weight;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AI013103decoder;[m
[32m+[m[32m}(AI013x0xDecoder_1.default));[m
[32m+[m[32mexports.default = AI013103decoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e10618d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport AI013x0xDecoder from './AI013x0xDecoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mexport default class AI01320xDecoder extends AI013x0xDecoder {[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    protected addWeightCode(buf: StringBuilder, weight: number): void;[m
[32m+[m[32m    protected checkWeight(weight: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f758723[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01320xDecoder.js[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI013x0xDecoder_1 = require("./AI013x0xDecoder");[m
[32m+[m[32mvar AI01320xDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01320xDecoder, _super);[m
[32m+[m[32m    function AI01320xDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01320xDecoder.prototype.addWeightCode = function (buf, weight) {[m
[32m+[m[32m        if (weight < 10000) {[m
[32m+[m[32m            buf.append('(3202)');[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            buf.append('(3203)');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01320xDecoder.prototype.checkWeight = function (weight) {[m
[32m+[m[32m        if (weight < 10000) {[m
[32m+[m[32m            return weight;[m
[32m+[m[32m        }[m
[32m+[m[32m        return weight - 10000;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AI01320xDecoder;[m
[32m+[m[32m}(AI013x0xDecoder_1.default));[m
[32m+[m[32mexports.default = AI01320xDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..99fb00b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport AI01decoder from './AI01decoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mexport default class AI01392xDecoder extends AI01decoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    private static readonly LAST_DIGIT_SIZE;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..867ede7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01392xDecoder.js[m
[36m@@ -0,0 +1,42 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01decoder_1 = require("./AI01decoder");[m
[32m+[m[32mvar NotFoundException_1 = require("../../../../NotFoundException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar AI01392xDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01392xDecoder, _super);[m
[32m+[m[32m    function AI01392xDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01392xDecoder.prototype.parseInformation = function () {[m
[32m+[m[32m        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var buf = new StringBuilder_1.default();[m
[32m+[m[32m        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);[m
[32m+[m[32m        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);[m
[32m+[m[32m        buf.append('(392');[m
[32m+[m[32m        buf.append(lastAIdigit);[m
[32m+[m[32m        buf.append(')');[m
[32m+[m[32m        var decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);[m
[32m+[m[32m        buf.append(decodedInformation.getNewString());[m
[32m+[m[32m        return buf.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;[m
[32m+[m[32m    AI01392xDecoder.LAST_DIGIT_SIZE = 2;[m
[32m+[m[32m    return AI01392xDecoder;[m
[32m+[m[32m}(AI01decoder_1.default));[m
[32m+[m[32mexports.default = AI01392xDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..605ddc7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.d.ts[m
[36m@@ -0,0 +1,9 @@[m
[32m+[m[32mimport AI01decoder from './AI01decoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mexport default class AI01393xDecoder extends AI01decoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    private static readonly LAST_DIGIT_SIZE;[m
[32m+[m[32m    private static readonly FIRST_THREE_DIGITS_SIZE;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..34ab36d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01393xDecoder.js[m
[36m@@ -0,0 +1,57 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01decoder_1 = require("./AI01decoder");[m
[32m+[m[32mvar NotFoundException_1 = require("../../../../NotFoundException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar AI01393xDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01393xDecoder, _super);[m
[32m+[m[32m    function AI01393xDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01393xDecoder.prototype.parseInformation = function () {[m
[32m+[m[32m        if (this.getInformation().getSize() <[m
[32m+[m[32m            AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var buf = new StringBuilder_1.default();[m
[32m+[m[32m        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);[m
[32m+[m[32m        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);[m
[32m+[m[32m        buf.append('(393');[m
[32m+[m[32m        buf.append(lastAIdigit);[m
[32m+[m[32m        buf.append(')');[m
[32m+[m[32m        var firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE +[m
[32m+[m[32m            AI01decoder_1.default.GTIN_SIZE +[m
[32m+[m[32m            AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);[m
[32m+[m[32m        if (firstThreeDigits / 100 === 0) {[m
[32m+[m[32m            buf.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (firstThreeDigits / 10 === 0) {[m
[32m+[m[32m            buf.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(firstThreeDigits);[m
[32m+[m[32m        var generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE +[m
[32m+[m[32m            AI01decoder_1.default.GTIN_SIZE +[m
[32m+[m[32m            AI01393xDecoder.LAST_DIGIT_SIZE +[m
[32m+[m[32m            AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);[m
[32m+[m[32m        buf.append(generalInformation.getNewString());[m
[32m+[m[32m        return buf.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;[m
[32m+[m[32m    AI01393xDecoder.LAST_DIGIT_SIZE = 2;[m
[32m+[m[32m    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;[m
[32m+[m[32m    return AI01393xDecoder;[m
[32m+[m[32m}(AI01decoder_1.default));[m
[32m+[m[32mexports.default = AI01393xDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5791833[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.d.ts[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32mimport AI01weightDecoder from './AI01weightDecoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mexport default class AI013x0x1xDecoder extends AI01weightDecoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    private static readonly WEIGHT_SIZE;[m
[32m+[m[32m    private static readonly DATE_SIZE;[m
[32m+[m[32m    private readonly dateCode;[m
[32m+[m[32m    private readonly firstAIdigits;[m
[32m+[m[32m    constructor(information: BitArray, firstAIdigits: string, dateCode: string);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m    private encodeCompressedDate;[m
[32m+[m[32m    protected addWeightCode(buf: StringBuilder, weight: number): void;[m
[32m+[m[32m    protected checkWeight(weight: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9c5b2d4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js[m
[36m@@ -0,0 +1,83 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01weightDecoder_1 = require("./AI01weightDecoder");[m
[32m+[m[32mvar NotFoundException_1 = require("../../../../NotFoundException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar AI013x0x1xDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI013x0x1xDecoder, _super);[m
[32m+[m[32m    function AI013x0x1xDecoder(information, firstAIdigits, dateCode) {[m
[32m+[m[32m        var _this = _super.call(this, information) || this;[m
[32m+[m[32m        _this.dateCode = dateCode;[m
[32m+[m[32m        _this.firstAIdigits = firstAIdigits;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI013x0x1xDecoder.prototype.parseInformation = function () {[m
[32m+[m[32m        if (this.getInformation().getSize() !==[m
[32m+[m[32m            AI013x0x1xDecoder.HEADER_SIZE +[m
[32m+[m[32m                AI013x0x1xDecoder.GTIN_SIZE +[m
[32m+[m[32m                AI013x0x1xDecoder.WEIGHT_SIZE +[m
[32m+[m[32m                AI013x0x1xDecoder.DATE_SIZE) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var buf = new StringBuilder_1.default();[m
[32m+[m[32m        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);[m
[32m+[m[32m        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);[m
[32m+[m[32m        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE +[m
[32m+[m[32m            AI013x0x1xDecoder.GTIN_SIZE +[m
[32m+[m[32m            AI013x0x1xDecoder.WEIGHT_SIZE);[m
[32m+[m[32m        return buf.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013x0x1xDecoder.prototype.encodeCompressedDate = function (buf, currentPos) {[m
[32m+[m[32m        var numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);[m
[32m+[m[32m        if (numericDate === 38400) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append('(');[m
[32m+[m[32m        buf.append(this.dateCode);[m
[32m+[m[32m        buf.append(')');[m
[32m+[m[32m        var day = numericDate % 32;[m
[32m+[m[32m        numericDate /= 32;[m
[32m+[m[32m        var month = (numericDate % 12) + 1;[m
[32m+[m[32m        numericDate /= 12;[m
[32m+[m[32m        var year = numericDate;[m
[32m+[m[32m        if (year / 10 === 0) {[m
[32m+[m[32m            buf.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(year);[m
[32m+[m[32m        if (month / 10 === 0) {[m
[32m+[m[32m            buf.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(month);[m
[32m+[m[32m        if (day / 10 === 0) {[m
[32m+[m[32m            buf.append('0');[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(day);[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013x0x1xDecoder.prototype.addWeightCode = function (buf, weight) {[m
[32m+[m[32m        buf.append('(');[m
[32m+[m[32m        buf.append(this.firstAIdigits);[m
[32m+[m[32m        buf.append(weight / 100000);[m
[32m+[m[32m        buf.append(')');[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013x0x1xDecoder.prototype.checkWeight = function (weight) {[m
[32m+[m[32m        return weight % 100000;[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;[m
[32m+[m[32m    AI013x0x1xDecoder.WEIGHT_SIZE = 20;[m
[32m+[m[32m    AI013x0x1xDecoder.DATE_SIZE = 16;[m
[32m+[m[32m    return AI013x0x1xDecoder;[m
[32m+[m[32m}(AI01weightDecoder_1.default));[m
[32m+[m[32mexports.default = AI013x0x1xDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f367441[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport AI01weightDecoder from './AI01weightDecoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mexport default abstract class AI013x0xDecoder extends AI01weightDecoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    private static readonly WEIGHT_SIZE;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..48355e6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI013x0xDecoder.js[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01weightDecoder_1 = require("./AI01weightDecoder");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar NotFoundException_1 = require("../../../../NotFoundException");[m
[32m+[m[32mvar AI013x0xDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI013x0xDecoder, _super);[m
[32m+[m[32m    function AI013x0xDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI013x0xDecoder.prototype.parseInformation = function () {[m
[32m+[m[32m        if (this.getInformation().getSize() !==[m
[32m+[m[32m            AI013x0xDecoder.HEADER_SIZE +[m
[32m+[m[32m                AI01weightDecoder_1.default.GTIN_SIZE +[m
[32m+[m[32m                AI013x0xDecoder.WEIGHT_SIZE) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var buf = new StringBuilder_1.default();[m
[32m+[m[32m        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);[m
[32m+[m[32m        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder_1.default.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);[m
[32m+[m[32m        return buf.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    AI013x0xDecoder.HEADER_SIZE = 4 + 1;[m
[32m+[m[32m    AI013x0xDecoder.WEIGHT_SIZE = 15;[m
[32m+[m[32m    return AI013x0xDecoder;[m
[32m+[m[32m}(AI01weightDecoder_1.default));[m
[32m+[m[32mexports.default = AI013x0xDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5bd35f2[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport AI01decoder from './AI01decoder';[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mexport default class AI01AndOtherAIs extends AI01decoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js[m
[1mnew file mode 100644[m
[1mindex 0000000..8c3e7dd[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01decoder_1 = require("./AI01decoder");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar AI01AndOtherAIs = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01AndOtherAIs, _super);[m
[32m+[m[32m    // the second one is the encodation method, and the other two are for the variable length[m
[32m+[m[32m    function AI01AndOtherAIs(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01AndOtherAIs.prototype.parseInformation = function () {[m
[32m+[m[32m        var buff = new StringBuilder_1.default();[m
[32m+[m[32m        buff.append('(01)');[m
[32m+[m[32m        var initialGtinPosition = buff.length();[m
[32m+[m[32m        var firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);[m
[32m+[m[32m        buff.append(firstGtinDigit);[m
[32m+[m[32m        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);[m
[32m+[m[32m        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,[m
[32m+[m[32m    return AI01AndOtherAIs;[m
[32m+[m[32m}(AI01decoder_1.default));[m
[32m+[m[32mexports.default = AI01AndOtherAIs;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2197b6c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mimport AbstractExpandedDecoder from './AbstractExpandedDecoder';[m
[32m+[m[32mexport default abstract class AI01decoder extends AbstractExpandedDecoder {[m
[32m+[m[32m    static readonly GTIN_SIZE: number;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    encodeCompressedGtin(buf: StringBuilder, currentPos: number): void;[m
[32m+[m[32m    encodeCompressedGtinWithoutAI(buf: StringBuilder, currentPos: number, initialBufferPosition: number): void;[m
[32m+[m[32m    private static appendCheckDigit;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7e93be9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01decoder.js[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AbstractExpandedDecoder_1 = require("./AbstractExpandedDecoder");[m
[32m+[m[32mvar AI01decoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01decoder, _super);[m
[32m+[m[32m    function AI01decoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01decoder.prototype.encodeCompressedGtin = function (buf, currentPos) {[m
[32m+[m[32m        buf.append('(01)');[m
[32m+[m[32m        var initialPosition = buf.length();[m
[32m+[m[32m        buf.append('9');[m
[32m+[m[32m        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01decoder.prototype.encodeCompressedGtinWithoutAI = function (buf, currentPos, initialBufferPosition) {[m
[32m+[m[32m        for (var i = 0; i < 4; ++i) {[m
[32m+[m[32m            var currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);[m
[32m+[m[32m            if (currentBlock / 100 === 0) {[m
[32m+[m[32m                buf.append('0');[m
[32m+[m[32m            }[m
[32m+[m[32m            if (currentBlock / 10 === 0) {[m
[32m+[m[32m                buf.append('0');[m
[32m+[m[32m            }[m
[32m+[m[32m            buf.append(currentBlock);[m
[32m+[m[32m        }[m
[32m+[m[32m        AI01decoder.appendCheckDigit(buf, initialBufferPosition);[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01decoder.appendCheckDigit = function (buf, currentPos) {[m
[32m+[m[32m        var checkDigit = 0;[m
[32m+[m[32m        for (var i = 0; i < 13; i++) {[m
[32m+[m[32m            // let digit = buf.charAt(i + currentPos) - '0';[m
[32m+[m[32m            // To be checked[m
[32m+[m[32m            var digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);[m
[32m+[m[32m            checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;[m
[32m+[m[32m        }[m
[32m+[m[32m        checkDigit = 10 - (checkDigit % 10);[m
[32m+[m[32m        if (checkDigit === 10) {[m
[32m+[m[32m            checkDigit = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(checkDigit);[m
[32m+[m[32m    };[m
[32m+[m[32m    AI01decoder.GTIN_SIZE = 40;[m
[32m+[m[32m    return AI01decoder;[m
[32m+[m[32m}(AbstractExpandedDecoder_1.default));[m
[32m+[m[32mexports.default = AI01decoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b837bba[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.d.ts[m
[36m@@ -0,0 +1,9 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mimport AI01decoder from './AI01decoder';[m
[32m+[m[32mexport default abstract class AI01weightDecoder extends AI01decoder {[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    encodeCompressedWeight(buf: StringBuilder, currentPos: number, weightSize: number): void;[m
[32m+[m[32m    protected abstract addWeightCode(buf: StringBuilder, weight: number): void;[m
[32m+[m[32m    protected abstract checkWeight(weight: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2a42bd9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AI01weightDecoder.js[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AI01decoder_1 = require("./AI01decoder");[m
[32m+[m[32mvar AI01weightDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AI01weightDecoder, _super);[m
[32m+[m[32m    function AI01weightDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AI01weightDecoder.prototype.encodeCompressedWeight = function (buf, currentPos, weightSize) {[m
[32m+[m[32m        var originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);[m
[32m+[m[32m        this.addWeightCode(buf, originalWeightNumeric);[m
[32m+[m[32m        var weightNumeric = this.checkWeight(originalWeightNumeric);[m
[32m+[m[32m        var currentDivisor = 100000;[m
[32m+[m[32m        for (var i = 0; i < 5; ++i) {[m
[32m+[m[32m            if (weightNumeric / currentDivisor === 0) {[m
[32m+[m[32m                buf.append('0');[m
[32m+[m[32m            }[m
[32m+[m[32m            currentDivisor /= 10;[m
[32m+[m[32m        }[m
[32m+[m[32m        buf.append(weightNumeric);[m
[32m+[m[32m    };[m
[32m+[m[32m    return AI01weightDecoder;[m
[32m+[m[32m}(AI01decoder_1.default));[m
[32m+[m[32mexports.default = AI01weightDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..92fe7f7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport GeneralAppIdDecoder from './GeneralAppIdDecoder';[m
[32m+[m[32mexport default abstract class AbstractExpandedDecoder {[m
[32m+[m[32m    private readonly information;[m
[32m+[m[32m    private readonly generalDecoder;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    protected getInformation(): BitArray;[m
[32m+[m[32m    protected getGeneralDecoder(): GeneralAppIdDecoder;[m
[32m+[m[32m    abstract parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c0c7835[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar GeneralAppIdDecoder_1 = require("./GeneralAppIdDecoder");[m
[32m+[m[32mvar AbstractExpandedDecoder = /** @class */ (function () {[m
[32m+[m[32m    function AbstractExpandedDecoder(information) {[m
[32m+[m[32m        this.information = information;[m
[32m+[m[32m        this.generalDecoder = new GeneralAppIdDecoder_1.default(information);[m
[32m+[m[32m    }[m
[32m+[m[32m    AbstractExpandedDecoder.prototype.getInformation = function () {[m
[32m+[m[32m        return this.information;[m
[32m+[m[32m    };[m
[32m+[m[32m    AbstractExpandedDecoder.prototype.getGeneralDecoder = function () {[m
[32m+[m[32m        return this.generalDecoder;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AbstractExpandedDecoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AbstractExpandedDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3242000[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.d.ts[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport AbstractExpandedDecoder from './AbstractExpandedDecoder';[m
[32m+[m[32mexport declare function createDecoder(information: BitArray): AbstractExpandedDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c3e8341[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.createDecoder = void 0;[m
[32m+[m[32mvar IllegalStateException_1 = require("../../../../IllegalStateException");[m
[32m+[m[32mvar GeneralAppIdDecoder_1 = require("./GeneralAppIdDecoder");[m
[32m+[m[32mvar AI01AndOtherAIs_1 = require("./AI01AndOtherAIs");[m
[32m+[m[32mvar AnyAIDecoder_1 = require("./AnyAIDecoder");[m
[32m+[m[32mvar AI013103decoder_1 = require("./AI013103decoder");[m
[32m+[m[32mvar AI01320xDecoder_1 = require("./AI01320xDecoder");[m
[32m+[m[32mvar AI01392xDecoder_1 = require("./AI01392xDecoder");[m
[32m+[m[32mvar AI01393xDecoder_1 = require("./AI01393xDecoder");[m
[32m+[m[32mvar AI013x0x1xDecoder_1 = require("./AI013x0x1xDecoder");[m
[32m+[m[32mfunction createDecoder(information) {[m
[32m+[m[32m    try {[m
[32m+[m[32m        if (information.get(1)) {[m
[32m+[m[32m            return new AI01AndOtherAIs_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!information.get(2)) {[m
[32m+[m[32m            return new AnyAIDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var fourBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 4);[m
[32m+[m[32m        switch (fourBitEncodationMethod) {[m
[32m+[m[32m            case 4: return new AI013103decoder_1.default(information);[m
[32m+[m[32m            case 5: return new AI01320xDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var fiveBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 5);[m
[32m+[m[32m        switch (fiveBitEncodationMethod) {[m
[32m+[m[32m            case 12: return new AI01392xDecoder_1.default(information);[m
[32m+[m[32m            case 13: return new AI01393xDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var sevenBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 7);[m
[32m+[m[32m        switch (sevenBitEncodationMethod) {[m
[32m+[m[32m            case 56: return new AI013x0x1xDecoder_1.default(information, '310', '11');[m
[32m+[m[32m            case 57: return new AI013x0x1xDecoder_1.default(information, '320', '11');[m
[32m+[m[32m            case 58: return new AI013x0x1xDecoder_1.default(information, '310', '13');[m
[32m+[m[32m            case 59: return new AI013x0x1xDecoder_1.default(information, '320', '13');[m
[32m+[m[32m            case 60: return new AI013x0x1xDecoder_1.default(information, '310', '15');[m
[32m+[m[32m            case 61: return new AI013x0x1xDecoder_1.default(information, '320', '15');[m
[32m+[m[32m            case 62: return new AI013x0x1xDecoder_1.default(information, '310', '17');[m
[32m+[m[32m            case 63: return new AI013x0x1xDecoder_1.default(information, '320', '17');[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    catch (e) {[m
[32m+[m[32m        console.log(e);[m
[32m+[m[32m        throw new IllegalStateException_1.default('unknown decoder: ' + information);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32mexports.createDecoder = createDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..03090a9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport AbstractExpandedDecoder from './AbstractExpandedDecoder';[m
[32m+[m[32mexport default class AnyAIDecoder extends AbstractExpandedDecoder {[m
[32m+[m[32m    private static readonly HEADER_SIZE;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    parseInformation(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..49059c8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/AnyAIDecoder.js[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar AbstractExpandedDecoder_1 = require("./AbstractExpandedDecoder");[m
[32m+[m[32mvar AnyAIDecoder = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AnyAIDecoder, _super);[m
[32m+[m[32m    function AnyAIDecoder(information) {[m
[32m+[m[32m        return _super.call(this, information) || this;[m
[32m+[m[32m    }[m
[32m+[m[32m    AnyAIDecoder.prototype.parseInformation = function () {[m
[32m+[m[32m        var buf = new StringBuilder_1.default();[m
[32m+[m[32m        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);[m
[32m+[m[32m    };[m
[32m+[m[32m    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;[m
[32m+[m[32m    return AnyAIDecoder;[m
[32m+[m[32m}(AbstractExpandedDecoder_1.default));[m
[32m+[m[32mexports.default = AnyAIDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..740e762[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport DecodedInformation from './DecodedInformation';[m
[32m+[m[32mexport default class BlockParsedResult {[m
[32m+[m[32m    private readonly decodedInformation;[m
[32m+[m[32m    private readonly finished;[m
[32m+[m[32m    constructor(finished: boolean, decodedInformation?: DecodedInformation);[m
[32m+[m[32m    getDecodedInformation(): DecodedInformation;[m
[32m+[m[32m    isFinished(): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ba4f338[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/BlockParsedResult.js[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar BlockParsedResult = /** @class */ (function () {[m
[32m+[m[32m    function BlockParsedResult(finished, decodedInformation) {[m
[32m+[m[32m        if (decodedInformation) {[m
[32m+[m[32m            this.decodedInformation = null;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.finished = finished;[m
[32m+[m[32m            this.decodedInformation = decodedInformation;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    BlockParsedResult.prototype.getDecodedInformation = function () {[m
[32m+[m[32m        return this.decodedInformation;[m
[32m+[m[32m    };[m
[32m+[m[32m    BlockParsedResult.prototype.isFinished = function () {[m
[32m+[m[32m        return this.finished;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BlockParsedResult;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BlockParsedResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5664c29[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.d.ts[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mexport default class CurrentParsingState {[m
[32m+[m[32m    private position;[m
[32m+[m[32m    private encoding;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    getPosition(): number;[m
[32m+[m[32m    setPosition(position: number): void;[m
[32m+[m[32m    incrementPosition(delta: number): void;[m
[32m+[m[32m    isAlpha(): boolean;[m
[32m+[m[32m    isNumeric(): boolean;[m
[32m+[m[32m    isIsoIec646(): boolean;[m
[32m+[m[32m    setNumeric(): void;[m
[32m+[m[32m    setAlpha(): void;[m
[32m+[m[32m    setIsoIec646(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ac3d40d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/CurrentParsingState.js[m
[36m@@ -0,0 +1,43 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar State;[m
[32m+[m[32m(function (State) {[m
[32m+[m[32m    State[State["NUMERIC"] = 0] = "NUMERIC";[m
[32m+[m[32m    State[State["ALPHA"] = 1] = "ALPHA";[m
[32m+[m[32m    State[State["ISO_IEC_646"] = 2] = "ISO_IEC_646";[m
[32m+[m[32m})(State || (State = {}));[m
[32m+[m[32mvar CurrentParsingState = /** @class */ (function () {[m
[32m+[m[32m    function CurrentParsingState() {[m
[32m+[m[32m        this.position = 0;[m
[32m+[m[32m        this.encoding = State.NUMERIC;[m
[32m+[m[32m    }[m
[32m+[m[32m    CurrentParsingState.prototype.getPosition = function () {[m
[32m+[m[32m        return this.position;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.setPosition = function (position) {[m
[32m+[m[32m        this.position = position;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.incrementPosition = function (delta) {[m
[32m+[m[32m        this.position += delta;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.isAlpha = function () {[m
[32m+[m[32m        return this.encoding === State.ALPHA;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.isNumeric = function () {[m
[32m+[m[32m        return this.encoding === State.NUMERIC;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.isIsoIec646 = function () {[m
[32m+[m[32m        return this.encoding === State.ISO_IEC_646;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.setNumeric = function () {[m
[32m+[m[32m        this.encoding = State.NUMERIC;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.setAlpha = function () {[m
[32m+[m[32m        this.encoding = State.ALPHA;[m
[32m+[m[32m    };[m
[32m+[m[32m    CurrentParsingState.prototype.setIsoIec646 = function () {[m
[32m+[m[32m        this.encoding = State.ISO_IEC_646;[m
[32m+[m[32m    };[m
[32m+[m[32m    return CurrentParsingState;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = CurrentParsingState;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..4d2d467[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.d.ts[m
[36m@@ -0,0 +1,8 @@[m
[32m+[m[32mimport DecodedObject from './DecodedObject';[m
[32m+[m[32mexport default class DecodedChar extends DecodedObject {[m
[32m+[m[32m    private readonly value;[m
[32m+[m[32m    static readonly FNC1 = "$";[m
[32m+[m[32m    constructor(newPosition: number, value: string);[m
[32m+[m[32m    getValue(): string;[m
[32m+[m[32m    isFNC1(): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f5431ca[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedChar.js[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecodedObject_1 = require("./DecodedObject");[m
[32m+[m[32mvar DecodedChar = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DecodedChar, _super);[m
[32m+[m[32m    function DecodedChar(newPosition, value) {[m
[32m+[m[32m        var _this = _super.call(this, newPosition) || this;[m
[32m+[m[32m        _this.value = value;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedChar.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedChar.prototype.isFNC1 = function () {[m
[32m+[m[32m        return this.value === DecodedChar.FNC1;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedChar.FNC1 = '$';[m
[32m+[m[32m    return DecodedChar;[m
[32m+[m[32m}(DecodedObject_1.default));[m
[32m+[m[32mexports.default = DecodedChar;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ee505d7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.d.ts[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mimport DecodedObject from './DecodedObject';[m
[32m+[m[32mexport default class DecodedInformation extends DecodedObject {[m
[32m+[m[32m    private readonly newString;[m
[32m+[m[32m    private readonly remainingValue;[m
[32m+[m[32m    private readonly remaining;[m
[32m+[m[32m    constructor(newPosition: number, newString: string, remainingValue?: number);[m
[32m+[m[32m    getNewString(): string;[m
[32m+[m[32m    isRemaining(): boolean;[m
[32m+[m[32m    getRemainingValue(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b96c527[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedInformation.js[m
[36m@@ -0,0 +1,43 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecodedObject_1 = require("./DecodedObject");[m
[32m+[m[32mvar DecodedInformation = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DecodedInformation, _super);[m
[32m+[m[32m    function DecodedInformation(newPosition, newString, remainingValue) {[m
[32m+[m[32m        var _this = _super.call(this, newPosition) || this;[m
[32m+[m[32m        if (remainingValue) {[m
[32m+[m[32m            _this.remaining = true;[m
[32m+[m[32m            _this.remainingValue = _this.remainingValue;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            _this.remaining = false;[m
[32m+[m[32m            _this.remainingValue = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.newString = newString;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedInformation.prototype.getNewString = function () {[m
[32m+[m[32m        return this.newString;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedInformation.prototype.isRemaining = function () {[m
[32m+[m[32m        return this.remaining;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedInformation.prototype.getRemainingValue = function () {[m
[32m+[m[32m        return this.remainingValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DecodedInformation;[m
[32m+[m[32m}(DecodedObject_1.default));[m
[32m+[m[32mexports.default = DecodedInformation;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..fa08d0e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mimport DecodedObject from './DecodedObject';[m
[32m+[m[32mexport default class DecodedNumeric extends DecodedObject {[m
[32m+[m[32m    private readonly firstDigit;[m
[32m+[m[32m    private readonly secondDigit;[m
[32m+[m[32m    static readonly FNC1: number;[m
[32m+[m[32m    constructor(newPosition: number, firstDigit: number, secondDigit: number);[m
[32m+[m[32m    getFirstDigit(): number;[m
[32m+[m[32m    getSecondDigit(): number;[m
[32m+[m[32m    getValue(): number;[m
[32m+[m[32m    isFirstDigitFNC1(): boolean;[m
[32m+[m[32m    isSecondDigitFNC1(): boolean;[m
[32m+[m[32m    isAnyFNC1(): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fd70af1[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedNumeric.js[m
[36m@@ -0,0 +1,50 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar FormatException_1 = require("../../../../FormatException");[m
[32m+[m[32mvar DecodedObject_1 = require("./DecodedObject");[m
[32m+[m[32mvar DecodedNumeric = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DecodedNumeric, _super);[m
[32m+[m[32m    function DecodedNumeric(newPosition, firstDigit, secondDigit) {[m
[32m+[m[32m        var _this = _super.call(this, newPosition) || this;[m
[32m+[m[32m        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.firstDigit = firstDigit;[m
[32m+[m[32m        _this.secondDigit = secondDigit;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedNumeric.prototype.getFirstDigit = function () {[m
[32m+[m[32m        return this.firstDigit;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.prototype.getSecondDigit = function () {[m
[32m+[m[32m        return this.secondDigit;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.prototype.getValue = function () {[m
[32m+[m[32m        return this.firstDigit * 10 + this.secondDigit;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.prototype.isFirstDigitFNC1 = function () {[m
[32m+[m[32m        return this.firstDigit === DecodedNumeric.FNC1;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.prototype.isSecondDigitFNC1 = function () {[m
[32m+[m[32m        return this.secondDigit === DecodedNumeric.FNC1;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.prototype.isAnyFNC1 = function () {[m
[32m+[m[32m        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedNumeric.FNC1 = 10;[m
[32m+[m[32m    return DecodedNumeric;[m
[32m+[m[32m}(DecodedObject_1.default));[m
[32m+[m[32mexports.default = DecodedNumeric;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2312775[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.d.ts[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mexport default abstract class DecodedObject {[m
[32m+[m[32m    private readonly newPosition;[m
[32m+[m[32m    constructor(newPosition: number);[m
[32m+[m[32m    getNewPosition(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e63a8e3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/DecodedObject.js[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar DecodedObject = /** @class */ (function () {[m
[32m+[m[32m    function DecodedObject(newPosition) {[m
[32m+[m[32m        this.newPosition = newPosition;[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedObject.prototype.getNewPosition = function () {[m
[32m+[m[32m        return this.newPosition;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DecodedObject;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DecodedObject;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..ea895ea[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.d.ts[m
[36m@@ -0,0 +1,11 @@[m
[32m+[m[32mexport default class FieldParser {[m
[32m+[m[32m    private static readonly VARIABLE_LENGTH;[m
[32m+[m[32m    private static readonly TWO_DIGIT_DATA_LENGTH;[m
[32m+[m[32m    private static readonly THREE_DIGIT_DATA_LENGTH;[m
[32m+[m[32m    private static readonly THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH;[m
[32m+[m[32m    private static readonly FOUR_DIGIT_DATA_LENGTH;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    static parseFieldsInGeneralPurpose(rawInformation: string): string;[m
[32m+[m[32m    private static processFixedAI;[m
[32m+[m[32m    private static processVariableAI;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b59f9fa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/FieldParser.js[m
[36m@@ -0,0 +1,276 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar NotFoundException_1 = require("../../../../NotFoundException");[m
[32m+[m[32mvar FieldParser = /** @class */ (function () {[m
[32m+[m[32m    function FieldParser() {[m
[32m+[m[32m    }[m
[32m+[m[32m    FieldParser.parseFieldsInGeneralPurpose = function (rawInformation) {[m
[32m+[m[32m        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;[m
[32m+[m[32m        if (!rawInformation) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Processing 2-digit AIs[m
[32m+[m[32m        if (rawInformation.length < 2) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var firstTwoDigits = rawInformation.substring(0, 2);[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _e = __values(FieldParser.TWO_DIGIT_DATA_LENGTH), _f = _e.next(); !_f.done; _f = _e.next()) {[m
[32m+[m[32m                var dataLength = _f.value;[m
[32m+[m[32m                if (dataLength[0] === firstTwoDigits) {[m
[32m+[m[32m                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {[m
[32m+[m[32m                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (rawInformation.length < 3) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var firstThreeDigits = rawInformation.substring(0, 3);[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _g = __values(FieldParser.THREE_DIGIT_DATA_LENGTH), _h = _g.next(); !_h.done; _h = _g.next()) {[m
[32m+[m[32m                var dataLength = _h.value;[m
[32m+[m[32m                if (dataLength[0] === firstThreeDigits) {[m
[32m+[m[32m                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {[m
[32m+[m[32m                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _j = __values(FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), _k = _j.next(); !_k.done; _k = _j.next()) {[m
[32m+[m[32m                var dataLength = _k.value;[m
[32m+[m[32m                if (dataLength[0] === firstThreeDigits) {[m
[32m+[m[32m                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {[m
[32m+[m[32m                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (rawInformation.length < 4) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var firstFourDigits = rawInformation.substring(0, 4);[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _l = __values(FieldParser.FOUR_DIGIT_DATA_LENGTH), _m = _l.next(); !_m.done; _m = _l.next()) {[m
[32m+[m[32m                var dataLength = _m.value;[m
[32m+[m[32m                if (dataLength[0] === firstFourDigits) {[m
[32m+[m[32m                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {[m
[32m+[m[32m                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_m && !_m.done && (_d = _l.return)) _d.call(_l);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    FieldParser.processFixedAI = function (aiSize, fieldSize, rawInformation) {[m
[32m+[m[32m        if (rawInformation.length < aiSize) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var ai = rawInformation.substring(0, aiSize);[m
[32m+[m[32m        if (rawInformation.length < aiSize + fieldSize) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var field = rawInformation.substring(aiSize, aiSize + fieldSize);[m
[32m+[m[32m        var remaining = rawInformation.substring(aiSize + fieldSize);[m
[32m+[m[32m        var result = '(' + ai + ')' + field;[m
[32m+[m[32m        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);[m
[32m+[m[32m        return parsedAI == null ? result : result + parsedAI;[m
[32m+[m[32m    };[m
[32m+[m[32m    FieldParser.processVariableAI = function (aiSize, variableFieldSize, rawInformation) {[m
[32m+[m[32m        var ai = rawInformation.substring(0, aiSize);[m
[32m+[m[32m        var maxSize;[m
[32m+[m[32m        if (rawInformation.length < aiSize + variableFieldSize) {[m
[32m+[m[32m            maxSize = rawInformation.length;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            maxSize = aiSize + variableFieldSize;[m
[32m+[m[32m        }[m
[32m+[m[32m        var field = rawInformation.substring(aiSize, maxSize);[m
[32m+[m[32m        var remaining = rawInformation.substring(maxSize);[m
[32m+[m[32m        var result = '(' + ai + ')' + field;[m
[32m+[m[32m        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);[m
[32m+[m[32m        return parsedAI == null ? result : result + parsedAI;[m
[32m+[m[32m    };[m
[32m+[m[32m    FieldParser.VARIABLE_LENGTH = [];[m
[32m+[m[32m    FieldParser.TWO_DIGIT_DATA_LENGTH = [[m
[32m+[m[32m        ['00', 18],[m
[32m+[m[32m        ['01', 14],[m
[32m+[m[32m        ['02', 14],[m
[32m+[m[32m        ['10', FieldParser.VARIABLE_LENGTH, 20],[m
[32m+[m[32m        ['11', 6],[m
[32m+[m[32m        ['12', 6],[m
[32m+[m[32m        ['13', 6],[m
[32m+[m[32m        ['15', 6],[m
[32m+[m[32m        ['17', 6],[m
[32m+[m[32m        ['20', 2],[m
[32m+[m[32m        ['21', FieldParser.VARIABLE_LENGTH, 20],[m
[32m+[m[32m        ['22', FieldParser.VARIABLE_LENGTH, 29],[m
[32m+[m[32m        ['30', FieldParser.VARIABLE_LENGTH, 8],[m
[32m+[m[32m        ['37', FieldParser.VARIABLE_LENGTH, 8],[m
[32m+[m[32m        // internal company codes[m
[32m+[m[32m        ['90', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['91', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['92', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['93', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['94', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['95', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['96', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['97', FieldParser.VARIABLE_LENGTH, 3],[m
[32m+[m[32m        ['98', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['99', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m    ];[m
[32m+[m[32m    FieldParser.THREE_DIGIT_DATA_LENGTH = [[m
[32m+[m[32m        // Same format as above[m
[32m+[m[32m        ['240', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['241', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['242', FieldParser.VARIABLE_LENGTH, 6],[m
[32m+[m[32m        ['250', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['251', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['253', FieldParser.VARIABLE_LENGTH, 17],[m
[32m+[m[32m        ['254', FieldParser.VARIABLE_LENGTH, 20],[m
[32m+[m[32m        ['400', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['401', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['402', 17],[m
[32m+[m[32m        ['403', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['410', 13],[m
[32m+[m[32m        ['411', 13],[m
[32m+[m[32m        ['412', 13],[m
[32m+[m[32m        ['413', 13],[m
[32m+[m[32m        ['414', 13],[m
[32m+[m[32m        ['420', FieldParser.VARIABLE_LENGTH, 20],[m
[32m+[m[32m        ['421', FieldParser.VARIABLE_LENGTH, 15],[m
[32m+[m[32m        ['422', 3],[m
[32m+[m[32m        ['423', FieldParser.VARIABLE_LENGTH, 15],[m
[32m+[m[32m        ['424', 3],[m
[32m+[m[32m        ['425', 3],[m
[32m+[m[32m        ['426', 3],[m
[32m+[m[32m    ];[m
[32m+[m[32m    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [[m
[32m+[m[32m        // Same format as above[m
[32m+[m[32m        ['310', 6],[m
[32m+[m[32m        ['311', 6],[m
[32m+[m[32m        ['312', 6],[m
[32m+[m[32m        ['313', 6],[m
[32m+[m[32m        ['314', 6],[m
[32m+[m[32m        ['315', 6],[m
[32m+[m[32m        ['316', 6],[m
[32m+[m[32m        ['320', 6],[m
[32m+[m[32m        ['321', 6],[m
[32m+[m[32m        ['322', 6],[m
[32m+[m[32m        ['323', 6],[m
[32m+[m[32m        ['324', 6],[m
[32m+[m[32m        ['325', 6],[m
[32m+[m[32m        ['326', 6],[m
[32m+[m[32m        ['327', 6],[m
[32m+[m[32m        ['328', 6],[m
[32m+[m[32m        ['329', 6],[m
[32m+[m[32m        ['330', 6],[m
[32m+[m[32m        ['331', 6],[m
[32m+[m[32m        ['332', 6],[m
[32m+[m[32m        ['333', 6],[m
[32m+[m[32m        ['334', 6],[m
[32m+[m[32m        ['335', 6],[m
[32m+[m[32m        ['336', 6],[m
[32m+[m[32m        ['340', 6],[m
[32m+[m[32m        ['341', 6],[m
[32m+[m[32m        ['342', 6],[m
[32m+[m[32m        ['343', 6],[m
[32m+[m[32m        ['344', 6],[m
[32m+[m[32m        ['345', 6],[m
[32m+[m[32m        ['346', 6],[m
[32m+[m[32m        ['347', 6],[m
[32m+[m[32m        ['348', 6],[m
[32m+[m[32m        ['349', 6],[m
[32m+[m[32m        ['350', 6],[m
[32m+[m[32m        ['351', 6],[m
[32m+[m[32m        ['352', 6],[m
[32m+[m[32m        ['353', 6],[m
[32m+[m[32m        ['354', 6],[m
[32m+[m[32m        ['355', 6],[m
[32m+[m[32m        ['356', 6],[m
[32m+[m[32m        ['357', 6],[m
[32m+[m[32m        ['360', 6],[m
[32m+[m[32m        ['361', 6],[m
[32m+[m[32m        ['362', 6],[m
[32m+[m[32m        ['363', 6],[m
[32m+[m[32m        ['364', 6],[m
[32m+[m[32m        ['365', 6],[m
[32m+[m[32m        ['366', 6],[m
[32m+[m[32m        ['367', 6],[m
[32m+[m[32m        ['368', 6],[m
[32m+[m[32m        ['369', 6],[m
[32m+[m[32m        ['390', FieldParser.VARIABLE_LENGTH, 15],[m
[32m+[m[32m        ['391', FieldParser.VARIABLE_LENGTH, 18],[m
[32m+[m[32m        ['392', FieldParser.VARIABLE_LENGTH, 15],[m
[32m+[m[32m        ['393', FieldParser.VARIABLE_LENGTH, 18],[m
[32m+[m[32m        ['703', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m    ];[m
[32m+[m[32m    FieldParser.FOUR_DIGIT_DATA_LENGTH = [[m
[32m+[m[32m        // Same format as above[m
[32m+[m[32m        ['7001', 13],[m
[32m+[m[32m        ['7002', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['7003', 10],[m
[32m+[m[32m        ['8001', 14],[m
[32m+[m[32m        ['8002', FieldParser.VARIABLE_LENGTH, 20],[m
[32m+[m[32m        ['8003', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['8004', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['8005', 6],[m
[32m+[m[32m        ['8006', 18],[m
[32m+[m[32m        ['8007', FieldParser.VARIABLE_LENGTH, 30],[m
[32m+[m[32m        ['8008', FieldParser.VARIABLE_LENGTH, 12],[m
[32m+[m[32m        ['8018', 18],[m
[32m+[m[32m        ['8020', FieldParser.VARIABLE_LENGTH, 25],[m
[32m+[m[32m        ['8100', 6],[m
[32m+[m[32m        ['8101', 10],[m
[32m+[m[32m        ['8102', 2],[m
[32m+[m[32m        ['8110', FieldParser.VARIABLE_LENGTH, 70],[m
[32m+[m[32m        ['8200', FieldParser.VARIABLE_LENGTH, 70],[m
[32m+[m[32m    ];[m
[32m+[m[32m    return FieldParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = FieldParser;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2d9234f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mimport BitArray from '../../../../common/BitArray';[m
[32m+[m[32mimport StringBuilder from '../../../../util/StringBuilder';[m
[32m+[m[32mimport DecodedInformation from './DecodedInformation';[m
[32m+[m[32mexport default class GeneralAppIdDecoder {[m
[32m+[m[32m    private readonly information;[m
[32m+[m[32m    private readonly current;[m
[32m+[m[32m    private readonly buffer;[m
[32m+[m[32m    constructor(information: BitArray);[m
[32m+[m[32m    decodeAllCodes(buff: StringBuilder, initialPosition: number): string;[m
[32m+[m[32m    private isStillNumeric;[m
[32m+[m[32m    private decodeNumeric;[m
[32m+[m[32m    extractNumericValueFromBitArray(pos: number, bits: number): number;[m
[32m+[m[32m    static extractNumericValueFromBitArray(information: BitArray, pos: number, bits: number): number;[m
[32m+[m[32m    decodeGeneralPurposeField(pos: number, remaining: string): DecodedInformation;[m
[32m+[m[32m    private parseBlocks;[m
[32m+[m[32m    private parseNumericBlock;[m
[32m+[m[32m    private parseIsoIec646Block;[m
[32m+[m[32m    private parseAlphaBlock;[m
[32m+[m[32m    private isStillIsoIec646;[m
[32m+[m[32m    private decodeIsoIec646;[m
[32m+[m[32m    private isStillAlpha;[m
[32m+[m[32m    private decodeAlphanumeric;[m
[32m+[m[32m    private isAlphaTo646ToAlphaLatch;[m
[32m+[m[32m    private isAlphaOr646ToNumericLatch;[m
[32m+[m[32m    private isNumericToAlphaNumericLatch;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1103078[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js[m
[36m@@ -0,0 +1,389 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar FormatException_1 = require("../../../../FormatException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../../../../IllegalStateException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../../util/StringBuilder");[m
[32m+[m[32mvar BlockParsedResult_1 = require("./BlockParsedResult");[m
[32m+[m[32mvar DecodedChar_1 = require("./DecodedChar");[m
[32m+[m[32mvar DecodedInformation_1 = require("./DecodedInformation");[m
[32m+[m[32mvar DecodedNumeric_1 = require("./DecodedNumeric");[m
[32m+[m[32mvar FieldParser_1 = require("./FieldParser");[m
[32m+[m[32mvar GeneralAppIdDecoder = /** @class */ (function () {[m
[32m+[m[32m    function GeneralAppIdDecoder(information) {[m
[32m+[m[32m        this.buffer = new StringBuilder_1.default();[m
[32m+[m[32m        this.information = information;[m
[32m+[m[32m    }[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.decodeAllCodes = function (buff, initialPosition) {[m
[32m+[m[32m        var currentPosition = initialPosition;[m
[32m+[m[32m        var remaining = null;[m
[32m+[m[32m        do {[m
[32m+[m[32m            var info = this.decodeGeneralPurposeField(currentPosition, remaining);[m
[32m+[m[32m            var parsedFields = FieldParser_1.default.parseFieldsInGeneralPurpose(info.getNewString());[m
[32m+[m[32m            if (parsedFields != null) {[m
[32m+[m[32m                buff.append(parsedFields);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (info.isRemaining()) {[m
[32m+[m[32m                remaining = '' + info.getRemainingValue();[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                remaining = null;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (currentPosition === info.getNewPosition()) { // No step forward![m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            currentPosition = info.getNewPosition();[m
[32m+[m[32m        } while (true);[m
[32m+[m[32m        return buff.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isStillNumeric = function (pos) {[m
[32m+[m[32m        // It's numeric if it still has 7 positions[m
[32m+[m[32m        // and one of the first 4 bits is "1".[m
[32m+[m[32m        if (pos + 7 > this.information.getSize()) {[m
[32m+[m[32m            return pos + 4 <= this.information.getSize();[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = pos; i < pos + 3; ++i) {[m
[32m+[m[32m            if (this.information.get(i)) {[m
[32m+[m[32m                return true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.information.get(pos + 3);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.decodeNumeric = function (pos) {[m
[32m+[m[32m        if (pos + 7 > this.information.getSize()) {[m
[32m+[m[32m            var numeric_1 = this.extractNumericValueFromBitArray(pos, 4);[m
[32m+[m[32m            if (numeric_1 === 0) {[m
[32m+[m[32m                return new DecodedNumeric_1.default(this.information.getSize(), DecodedNumeric_1.default.FNC1, DecodedNumeric_1.default.FNC1);[m
[32m+[m[32m            }[m
[32m+[m[32m            return new DecodedNumeric_1.default(this.information.getSize(), numeric_1 - 1, DecodedNumeric_1.default.FNC1);[m
[32m+[m[32m        }[m
[32m+[m[32m        var numeric = this.extractNumericValueFromBitArray(pos, 7);[m
[32m+[m[32m        var digit1 = (numeric - 8) / 11;[m
[32m+[m[32m        var digit2 = (numeric - 8) % 11;[m
[32m+[m[32m        return new DecodedNumeric_1.default(pos + 7, digit1, digit2);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.extractNumericValueFromBitArray = function (pos, bits) {[m
[32m+[m[32m        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.extractNumericValueFromBitArray = function (information, pos, bits) {[m
[32m+[m[32m        var value = 0;[m
[32m+[m[32m        for (var i = 0; i < bits; ++i) {[m
[32m+[m[32m            if (information.get(pos + i)) {[m
[32m+[m[32m                value |= 1 << (bits - i - 1);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return value;[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.decodeGeneralPurposeField = function (pos, remaining) {[m
[32m+[m[32m        // this.buffer.setLength(0);[m
[32m+[m[32m        this.buffer.setLengthToZero();[m
[32m+[m[32m        if (remaining != null) {[m
[32m+[m[32m            this.buffer.append(remaining);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.current.setPosition(pos);[m
[32m+[m[32m        var lastDecoded = this.parseBlocks();[m
[32m+[m[32m        if (lastDecoded != null && lastDecoded.isRemaining()) {[m
[32m+[m[32m            return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.parseBlocks = function () {[m
[32m+[m[32m        var isFinished;[m
[32m+[m[32m        var result;[m
[32m+[m[32m        do {[m
[32m+[m[32m            var initialPosition = this.current.getPosition();[m
[32m+[m[32m            if (this.current.isAlpha()) {[m
[32m+[m[32m                result = this.parseAlphaBlock();[m
[32m+[m[32m                isFinished = result.isFinished();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.current.isIsoIec646()) {[m
[32m+[m[32m                result = this.parseIsoIec646Block();[m
[32m+[m[32m                isFinished = result.isFinished();[m
[32m+[m[32m            }[m
[32m+[m[32m            else { // it must be numeric[m
[32m+[m[32m                result = this.parseNumericBlock();[m
[32m+[m[32m                isFinished = result.isFinished();[m
[32m+[m[32m            }[m
[32m+[m[32m            var positionChanged = initialPosition !== this.current.getPosition();[m
[32m+[m[32m            if (!positionChanged && !isFinished) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        } while (!isFinished);[m
[32m+[m[32m        return result.getDecodedInformation();[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.parseNumericBlock = function () {[m
[32m+[m[32m        while (this.isStillNumeric(this.current.getPosition())) {[m
[32m+[m[32m            var numeric = this.decodeNumeric(this.current.getPosition());[m
[32m+[m[32m            this.current.setPosition(numeric.getNewPosition());[m
[32m+[m[32m            if (numeric.isFirstDigitFNC1()) {[m
[32m+[m[32m                var information = void 0;[m
[32m+[m[32m                if (numeric.isSecondDigitFNC1()) {[m
[32m+[m[32m                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());[m
[32m+[m[32m                }[m
[32m+[m[32m                return new BlockParsedResult_1.default(true, information);[m
[32m+[m[32m            }[m
[32m+[m[32m            this.buffer.append(numeric.getFirstDigit());[m
[32m+[m[32m            if (numeric.isSecondDigitFNC1()) {[m
[32m+[m[32m                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());[m
[32m+[m[32m                return new BlockParsedResult_1.default(true, information);[m
[32m+[m[32m            }[m
[32m+[m[32m            this.buffer.append(numeric.getSecondDigit());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {[m
[32m+[m[32m            this.current.setAlpha();[m
[32m+[m[32m            this.current.incrementPosition(4);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new BlockParsedResult_1.default(false);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.parseIsoIec646Block = function () {[m
[32m+[m[32m        while (this.isStillIsoIec646(this.current.getPosition())) {[m
[32m+[m[32m            var iso = this.decodeIsoIec646(this.current.getPosition());[m
[32m+[m[32m            this.current.setPosition(iso.getNewPosition());[m
[32m+[m[32m            if (iso.isFNC1()) {[m
[32m+[m[32m                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());[m
[32m+[m[32m                return new BlockParsedResult_1.default(true, information);[m
[32m+[m[32m            }[m
[32m+[m[32m            this.buffer.append(iso.getValue());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {[m
[32m+[m[32m            this.current.incrementPosition(3);[m
[32m+[m[32m            this.current.setNumeric();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {[m
[32m+[m[32m            if (this.current.getPosition() + 5 < this.information.getSize()) {[m
[32m+[m[32m                this.current.incrementPosition(5);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.current.setPosition(this.information.getSize());[m
[32m+[m[32m            }[m
[32m+[m[32m            this.current.setAlpha();[m
[32m+[m[32m        }[m
[32m+[m[32m        return new BlockParsedResult_1.default(false);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.parseAlphaBlock = function () {[m
[32m+[m[32m        while (this.isStillAlpha(this.current.getPosition())) {[m
[32m+[m[32m            var alpha = this.decodeAlphanumeric(this.current.getPosition());[m
[32m+[m[32m            this.current.setPosition(alpha.getNewPosition());[m
[32m+[m[32m            if (alpha.isFNC1()) {[m
[32m+[m[32m                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());[m
[32m+[m[32m                return new BlockParsedResult_1.default(true, information); // end of the char block[m
[32m+[m[32m            }[m
[32m+[m[32m            this.buffer.append(alpha.getValue());[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {[m
[32m+[m[32m            this.current.incrementPosition(3);[m
[32m+[m[32m            this.current.setNumeric();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {[m
[32m+[m[32m            if (this.current.getPosition() + 5 < this.information.getSize()) {[m
[32m+[m[32m                this.current.incrementPosition(5);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.current.setPosition(this.information.getSize());[m
[32m+[m[32m            }[m
[32m+[m[32m            this.current.setIsoIec646();[m
[32m+[m[32m        }[m
[32m+[m[32m        return new BlockParsedResult_1.default(false);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isStillIsoIec646 = function (pos) {[m
[32m+[m[32m        if (pos + 5 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);[m
[32m+[m[32m        if (fiveBitValue >= 5 && fiveBitValue < 16) {[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (pos + 7 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);[m
[32m+[m[32m        if (sevenBitValue >= 64 && sevenBitValue < 116) {[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (pos + 8 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);[m
[32m+[m[32m        return eightBitValue >= 232 && eightBitValue < 253;[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.decodeIsoIec646 = function (pos) {[m
[32m+[m[32m        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);[m
[32m+[m[32m        if (fiveBitValue === 15) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (fiveBitValue >= 5 && fiveBitValue < 15) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));[m
[32m+[m[32m        }[m
[32m+[m[32m        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);[m
[32m+[m[32m        if (sevenBitValue >= 64 && sevenBitValue < 90) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 7, ('' + (sevenBitValue + 1)));[m
[32m+[m[32m        }[m
[32m+[m[32m        if (sevenBitValue >= 90 && sevenBitValue < 116) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 7, ('' + (sevenBitValue + 7)));[m
[32m+[m[32m        }[m
[32m+[m[32m        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);[m
[32m+[m[32m        var c;[m
[32m+[m[32m        switch (eightBitValue) {[m
[32m+[m[32m            case 232:[m
[32m+[m[32m                c = '!';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 233:[m
[32m+[m[32m                c = '"';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 234:[m
[32m+[m[32m                c = '%';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 235:[m
[32m+[m[32m                c = '&';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 236:[m
[32m+[m[32m                c = '\'';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 237:[m
[32m+[m[32m                c = '(';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 238:[m
[32m+[m[32m                c = ')';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 239:[m
[32m+[m[32m                c = '*';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 240:[m
[32m+[m[32m                c = '+';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 241:[m
[32m+[m[32m                c = ',';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 242:[m
[32m+[m[32m                c = '-';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 243:[m
[32m+[m[32m                c = '.';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 244:[m
[32m+[m[32m                c = '/';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 245:[m
[32m+[m[32m                c = ':';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 246:[m
[32m+[m[32m                c = ';';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 247:[m
[32m+[m[32m                c = '<';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 248:[m
[32m+[m[32m                c = '=';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 249:[m
[32m+[m[32m                c = '>';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 250:[m
[32m+[m[32m                c = '?';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 251:[m
[32m+[m[32m                c = '_';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 252:[m
[32m+[m[32m                c = ' ';[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DecodedChar_1.default(pos + 8, c);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isStillAlpha = function (pos) {[m
[32m+[m[32m        if (pos + 5 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // We now check if it's a valid 5-bit value (0..9 and FNC1)[m
[32m+[m[32m        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);[m
[32m+[m[32m        if (fiveBitValue >= 5 && fiveBitValue < 16) {[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (pos + 6 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);[m
[32m+[m[32m        return sixBitValue >= 16 && sixBitValue < 63; // 63 not included[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.decodeAlphanumeric = function (pos) {[m
[32m+[m[32m        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);[m
[32m+[m[32m        if (fiveBitValue === 15) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (fiveBitValue >= 5 && fiveBitValue < 15) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));[m
[32m+[m[32m        }[m
[32m+[m[32m        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);[m
[32m+[m[32m        if (sixBitValue >= 32 && sixBitValue < 58) {[m
[32m+[m[32m            return new DecodedChar_1.default(pos + 6, ('' + (sixBitValue + 33)));[m
[32m+[m[32m        }[m
[32m+[m[32m        var c;[m
[32m+[m[32m        switch (sixBitValue) {[m
[32m+[m[32m            case 58:[m
[32m+[m[32m                c = '*';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 59:[m
[32m+[m[32m                c = ',';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 60:[m
[32m+[m[32m                c = '-';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 61:[m
[32m+[m[32m                c = '.';[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 62:[m
[32m+[m[32m                c = '/';[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new IllegalStateException_1.default('Decoding invalid alphanumeric value: ' + sixBitValue);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DecodedChar_1.default(pos + 6, c);[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isAlphaTo646ToAlphaLatch = function (pos) {[m
[32m+[m[32m        if (pos + 1 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {[m
[32m+[m[32m            if (i === 2) {[m
[32m+[m[32m                if (!this.information.get(pos + 2)) {[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.information.get(pos + i)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isAlphaOr646ToNumericLatch = function (pos) {[m
[32m+[m[32m        // Next is alphanumeric if there are 3 positions and they are all zeros[m
[32m+[m[32m        if (pos + 3 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = pos; i < pos + 3; ++i) {[m
[32m+[m[32m            if (this.information.get(i)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    GeneralAppIdDecoder.prototype.isNumericToAlphaNumericLatch = function (pos) {[m
[32m+[m[32m        // Next is alphanumeric if there are 4 positions and they are all zeros, or[m
[32m+[m[32m        // if there is a subset of this just before the end of the symbol[m
[32m+[m[32m        if (pos + 1 > this.information.getSize()) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {[m
[32m+[m[32m            if (this.information.get(pos + i)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    return GeneralAppIdDecoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = GeneralAppIdDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d0e76d7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.d.ts[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mimport { BitArray } from '../../../../..';[m
[32m+[m[32mimport AbstractExpandedDecoder from './AbstractExpandedDecoder';[m
[32m+[m[32mexport default function createDecoder(information: BitArray): AbstractExpandedDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5e6ecab[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/oned/rss/expanded/decoders/createDecoder.js[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar __1 = require("../../../../..");[m
[32m+[m[32mvar AI013103decoder_1 = require("./AI013103decoder");[m
[32m+[m[32mvar AI01320xDecoder_1 = require("./AI01320xDecoder");[m
[32m+[m[32mvar AI01392xDecoder_1 = require("./AI01392xDecoder");[m
[32m+[m[32mvar AI01393xDecoder_1 = require("./AI01393xDecoder");[m
[32m+[m[32mvar AI013x0x1xDecoder_1 = require("./AI013x0x1xDecoder");[m
[32m+[m[32mvar AI01AndOtherAIs_1 = require("./AI01AndOtherAIs");[m
[32m+[m[32mvar AnyAIDecoder_1 = require("./AnyAIDecoder");[m
[32m+[m[32mvar GeneralAppIdDecoder_1 = require("./GeneralAppIdDecoder");[m
[32m+[m[32mfunction createDecoder(information) {[m
[32m+[m[32m    try {[m
[32m+[m[32m        if (information.get(1)) {[m
[32m+[m[32m            return new AI01AndOtherAIs_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!information.get(2)) {[m
[32m+[m[32m            return new AnyAIDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var fourBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 4);[m
[32m+[m[32m        switch (fourBitEncodationMethod) {[m
[32m+[m[32m            case 4: return new AI013103decoder_1.default(information);[m
[32m+[m[32m            case 5: return new AI01320xDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var fiveBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 5);[m
[32m+[m[32m        switch (fiveBitEncodationMethod) {[m
[32m+[m[32m            case 12: return new AI01392xDecoder_1.default(information);[m
[32m+[m[32m            case 13: return new AI01393xDecoder_1.default(information);[m
[32m+[m[32m        }[m
[32m+[m[32m        var sevenBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 7);[m
[32m+[m[32m        switch (sevenBitEncodationMethod) {[m
[32m+[m[32m            case 56: return new AI013x0x1xDecoder_1.default(information, '310', '11');[m
[32m+[m[32m            case 57: return new AI013x0x1xDecoder_1.default(information, '320', '11');[m
[32m+[m[32m            case 58: return new AI013x0x1xDecoder_1.default(information, '310', '13');[m
[32m+[m[32m            case 59: return new AI013x0x1xDecoder_1.default(information, '320', '13');[m
[32m+[m[32m            case 60: return new AI013x0x1xDecoder_1.default(information, '310', '15');[m
[32m+[m[32m            case 61: return new AI013x0x1xDecoder_1.default(information, '320', '15');[m
[32m+[m[32m            case 62: return new AI013x0x1xDecoder_1.default(information, '310', '17');[m
[32m+[m[32m            case 63: return new AI013x0x1xDecoder_1.default(information, '320', '17');[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    catch (e) {[m
[32m+[m[32m        console.log(e);[m
[32m+[m[32m        throw new __1.IllegalStateException('unknown decoder: ' + information);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32mexports.default = createDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..093f2e1[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.d.ts[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417Common {[m
[32m+[m[32m    static NUMBER_OF_CODEWORDS: number;[m
[32m+[m[32m    static MAX_CODEWORDS_IN_BARCODE: number;[m
[32m+[m[32m    static MIN_ROWS_IN_BARCODE: number;[m
[32m+[m[32m    static MAX_ROWS_IN_BARCODE: number;[m
[32m+[m[32m    static MODULES_IN_CODEWORD: number;[m
[32m+[m[32m    static MODULES_IN_STOP_PATTERN: number;[m
[32m+[m[32m    static BARS_IN_MODULE: number;[m
[32m+[m[32m    private static EMPTY_INT_ARRAY;[m
[32m+[m[32m    private PDF417Common;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param moduleBitCount values to sum[m
[32m+[m[32m     * @return sum of values[m
[32m+[m[32m     * @deprecated call {@link MathUtils#sum(int[])}[m
[32m+[m[32m     */[m
[32m+[m[32m    static getBitCountSum(moduleBitCount: Int32Array): int;[m
[32m+[m[32m    static toIntArray(list: int[]): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param symbol encoded symbol to translate to a codeword[m
[32m+[m[32m     * @return the codeword corresponding to the symbol.[m
[32m+[m[32m     */[m
[32m+[m[32m    static getCodeword(symbol: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The sorted table of all possible symbols. Extracted from the PDF417[m
[32m+[m[32m     * specification. The index of a symbol in this table corresponds to the[m
[32m+[m[32m     * index into the codeword table.[m
[32m+[m[32m     */[m
[32m+[m[32m    static SYMBOL_TABLE: Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This table contains to codewords for all symbols.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static CODEWORD_TABLE;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js[m
[1mnew file mode 100644[m
[1mindex 0000000..734c991[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Common.js[m
[36m@@ -0,0 +1,484 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2009 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32m// package com.google.zxing.pdf417;[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import java.util.Arrays;[m
[32m+[m[32mvar Arrays_1 = require("../util/Arrays");[m
[32m+[m[32m// import java.util.Collection;[m
[32m+[m[32m// import com.google.zxing.common.detector.MathUtils;[m
[32m+[m[32mvar MathUtils_1 = require("../common/detector/MathUtils");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417Common = /** @class */ (function () {[m
[32m+[m[32m    function PDF417Common() {[m
[32m+[m[32m    }[m
[32m+[m[32m    PDF417Common.prototype.PDF417Common = function () {[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param moduleBitCount values to sum[m
[32m+[m[32m     * @return sum of values[m
[32m+[m[32m     * @deprecated call {@link MathUtils#sum(int[])}[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Deprecated[m
[32m+[m[32m    PDF417Common.getBitCountSum = function (moduleBitCount) {[m
[32m+[m[32m        return MathUtils_1.default.sum(moduleBitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Common.toIntArray = function (list) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (list == null || !list.length) {[m
[32m+[m[32m            return PDF417Common.EMPTY_INT_ARRAY;[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Int32Array(list.length);[m
[32m+[m[32m        var i = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {[m
[32m+[m[32m                var integer = list_1_1.value;[m
[32m+[m[32m                result[i++] = integer;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param symbol encoded symbol to translate to a codeword[m
[32m+[m[32m     * @return the codeword corresponding to the symbol.[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417Common.getCodeword = function (symbol /*int*/) {[m
[32m+[m[32m        var i = Arrays_1.default.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);[m
[32m+[m[32m        if (i < 0) {[m
[32m+[m[32m            return -1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Common.NUMBER_OF_CODEWORDS = 929;[m
[32m+[m[32m    // Maximum Codewords (Data + Error).[m
[32m+[m[32m    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;[m
[32m+[m[32m    PDF417Common.MIN_ROWS_IN_BARCODE = 3;[m
[32m+[m[32m    PDF417Common.MAX_ROWS_IN_BARCODE = 90;[m
[32m+[m[32m    // One left row indication column + max 30 data columns + one right row indicator column[m
[32m+[m[32m    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;[m
[32m+[m[32m    PDF417Common.MODULES_IN_CODEWORD = 17;[m
[32m+[m[32m    PDF417Common.MODULES_IN_STOP_PATTERN = 18;[m
[32m+[m[32m    PDF417Common.BARS_IN_MODULE = 8;[m
[32m+[m[32m    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The sorted table of all possible symbols. Extracted from the PDF417[m
[32m+[m[32m     * specification. The index of a symbol in this table corresponds to the[m
[32m+[m[32m     * index into the codeword table.[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417Common.SYMBOL_TABLE = Int32Array.from([[m
[32m+[m[32m        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,[m
[32m+[m[32m        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,[m
[32m+[m[32m        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,[m
[32m+[m[32m        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,[m
[32m+[m[32m        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,[m
[32m+[m[32m        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,[m
[32m+[m[32m        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,[m
[32m+[m[32m        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,[m
[32m+[m[32m        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,[m
[32m+[m[32m        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,[m
[32m+[m[32m        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,[m
[32m+[m[32m        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,[m
[32m+[m[32m        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,[m
[32m+[m[32m        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,[m
[32m+[m[32m        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,[m
[32m+[m[32m        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,[m
[32m+[m[32m        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,[m
[32m+[m[32m        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,[m
[32m+[m[32m        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,[m
[32m+[m[32m        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,[m
[32m+[m[32m        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,[m
[32m+[m[32m        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,[m
[32m+[m[32m        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,[m
[32m+[m[32m        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,[m
[32m+[m[32m        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,[m
[32m+[m[32m        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,[m
[32m+[m[32m        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,[m
[32m+[m[32m        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,[m
[32m+[m[32m        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,[m
[32m+[m[32m        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,[m
[32m+[m[32m        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,[m
[32m+[m[32m        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,[m
[32m+[m[32m        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,[m
[32m+[m[32m        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,[m
[32m+[m[32m        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,[m
[32m+[m[32m        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,[m
[32m+[m[32m        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,[m
[32m+[m[32m        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,[m
[32m+[m[32m        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,[m
[32m+[m[32m        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,[m
[32m+[m[32m        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,[m
[32m+[m[32m        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,[m
[32m+[m[32m        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,[m
[32m+[m[32m        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,[m
[32m+[m[32m        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,[m
[32m+[m[32m        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,[m
[32m+[m[32m        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,[m
[32m+[m[32m        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,[m
[32m+[m[32m        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,[m
[32m+[m[32m        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,[m
[32m+[m[32m        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,[m
[32m+[m[32m        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,[m
[32m+[m[32m        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,[m
[32m+[m[32m        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,[m
[32m+[m[32m        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,[m
[32m+[m[32m        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,[m
[32m+[m[32m        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,[m
[32m+[m[32m        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,[m
[32m+[m[32m        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,[m
[32m+[m[32m        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,[m
[32m+[m[32m        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,[m
[32m+[m[32m        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,[m
[32m+[m[32m        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,[m
[32m+[m[32m        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,[m
[32m+[m[32m        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,[m
[32m+[m[32m        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,[m
[32m+[m[32m        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,[m
[32m+[m[32m        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,[m
[32m+[m[32m        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,[m
[32m+[m[32m        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,[m
[32m+[m[32m        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,[m
[32m+[m[32m        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,[m
[32m+[m[32m        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,[m
[32m+[m[32m        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,[m
[32m+[m[32m        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,[m
[32m+[m[32m        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,[m
[32m+[m[32m        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,[m
[32m+[m[32m        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,[m
[32m+[m[32m        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,[m
[32m+[m[32m        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,[m
[32m+[m[32m        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,[m
[32m+[m[32m        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,[m
[32m+[m[32m        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,[m
[32m+[m[32m        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,[m
[32m+[m[32m        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,[m
[32m+[m[32m        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,[m
[32m+[m[32m        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,[m
[32m+[m[32m        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,[m
[32m+[m[32m        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,[m
[32m+[m[32m        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,[m
[32m+[m[32m        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,[m
[32m+[m[32m        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,[m
[32m+[m[32m        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,[m
[32m+[m[32m        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,[m
[32m+[m[32m        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,[m
[32m+[m[32m        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,[m
[32m+[m[32m        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,[m
[32m+[m[32m        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,[m
[32m+[m[32m        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,[m
[32m+[m[32m        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,[m
[32m+[m[32m        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,[m
[32m+[m[32m        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,[m
[32m+[m[32m        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,[m
[32m+[m[32m        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,[m
[32m+[m[32m        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,[m
[32m+[m[32m        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,[m
[32m+[m[32m        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,[m
[32m+[m[32m        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,[m
[32m+[m[32m        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,[m
[32m+[m[32m        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,[m
[32m+[m[32m        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,[m
[32m+[m[32m        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,[m
[32m+[m[32m        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,[m
[32m+[m[32m        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,[m
[32m+[m[32m        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,[m
[32m+[m[32m        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,[m
[32m+[m[32m        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,[m
[32m+[m[32m        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,[m
[32m+[m[32m        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,[m
[32m+[m[32m        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,[m
[32m+[m[32m        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,[m
[32m+[m[32m        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,[m
[32m+[m[32m        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,[m
[32m+[m[32m        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,[m
[32m+[m[32m        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,[m
[32m+[m[32m        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,[m
[32m+[m[32m        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,[m
[32m+[m[32m        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,[m
[32m+[m[32m        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,[m
[32m+[m[32m        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,[m
[32m+[m[32m        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,[m
[32m+[m[32m        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,[m
[32m+[m[32m        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,[m
[32m+[m[32m        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,[m
[32m+[m[32m        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,[m
[32m+[m[32m        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,[m
[32m+[m[32m        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,[m
[32m+[m[32m        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,[m
[32m+[m[32m        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,[m
[32m+[m[32m        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,[m
[32m+[m[32m        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,[m
[32m+[m[32m        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,[m
[32m+[m[32m        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,[m
[32m+[m[32m        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,[m
[32m+[m[32m        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,[m
[32m+[m[32m        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,[m
[32m+[m[32m        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,[m
[32m+[m[32m        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,[m
[32m+[m[32m        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,[m
[32m+[m[32m        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,[m
[32m+[m[32m        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,[m
[32m+[m[32m        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,[m
[32m+[m[32m        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,[m
[32m+[m[32m        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,[m
[32m+[m[32m        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,[m
[32m+[m[32m        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,[m
[32m+[m[32m        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,[m
[32m+[m[32m        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,[m
[32m+[m[32m        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,[m
[32m+[m[32m        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,[m
[32m+[m[32m        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,[m
[32m+[m[32m        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,[m
[32m+[m[32m        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,[m
[32m+[m[32m        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,[m
[32m+[m[32m        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,[m
[32m+[m[32m        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,[m
[32m+[m[32m        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,[m
[32m+[m[32m        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,[m
[32m+[m[32m        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,[m
[32m+[m[32m        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,[m
[32m+[m[32m        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,[m
[32m+[m[32m        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,[m
[32m+[m[32m        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,[m
[32m+[m[32m        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,[m
[32m+[m[32m        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,[m
[32m+[m[32m        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,[m
[32m+[m[32m        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,[m
[32m+[m[32m        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,[m
[32m+[m[32m        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,[m
[32m+[m[32m        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,[m
[32m+[m[32m        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,[m
[32m+[m[32m        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,[m
[32m+[m[32m        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,[m
[32m+[m[32m        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,[m
[32m+[m[32m        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,[m
[32m+[m[32m        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,[m
[32m+[m[32m        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,[m
[32m+[m[32m        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,[m
[32m+[m[32m        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,[m
[32m+[m[32m        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,[m
[32m+[m[32m        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,[m
[32m+[m[32m        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,[m
[32m+[m[32m        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,[m
[32m+[m[32m        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,[m
[32m+[m[32m        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,[m
[32m+[m[32m        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,[m
[32m+[m[32m        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,[m
[32m+[m[32m        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,[m
[32m+[m[32m        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,[m
[32m+[m[32m        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,[m
[32m+[m[32m        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,[m
[32m+[m[32m        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,[m
[32m+[m[32m        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,[m
[32m+[m[32m        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,[m
[32m+[m[32m        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,[m
[32m+[m[32m        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,[m
[32m+[m[32m        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,[m
[32m+[m[32m        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,[m
[32m+[m[32m        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,[m
[32m+[m[32m        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,[m
[32m+[m[32m        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,[m
[32m+[m[32m        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,[m
[32m+[m[32m        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,[m
[32m+[m[32m        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,[m
[32m+[m[32m        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,[m
[32m+[m[32m        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,[m
[32m+[m[32m        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,[m
[32m+[m[32m        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,[m
[32m+[m[32m        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,[m
[32m+[m[32m        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,[m
[32m+[m[32m        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,[m
[32m+[m[32m        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,[m
[32m+[m[32m        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,[m
[32m+[m[32m        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,[m
[32m+[m[32m        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,[m
[32m+[m[32m        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,[m
[32m+[m[32m        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,[m
[32m+[m[32m        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,[m
[32m+[m[32m        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,[m
[32m+[m[32m        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,[m
[32m+[m[32m        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,[m
[32m+[m[32m        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,[m
[32m+[m[32m        0x1fba8, 0x1fbb6, 0x1fbda[m
[32m+[m[32m    ]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This table contains to codewords for all symbols.[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417Common.CODEWORD_TABLE = Int32Array.from([[m
[32m+[m[32m        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,[m
[32m+[m[32m        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,[m
[32m+[m[32m        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,[m
[32m+[m[32m        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,[m
[32m+[m[32m        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,[m
[32m+[m[32m        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,[m
[32m+[m[32m        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,[m
[32m+[m[32m        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,[m
[32m+[m[32m        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,[m
[32m+[m[32m        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,[m
[32m+[m[32m        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,[m
[32m+[m[32m        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,[m
[32m+[m[32m        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,[m
[32m+[m[32m        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,[m
[32m+[m[32m        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,[m
[32m+[m[32m        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,[m
[32m+[m[32m        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,[m
[32m+[m[32m        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,[m
[32m+[m[32m        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,[m
[32m+[m[32m        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,[m
[32m+[m[32m        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,[m
[32m+[m[32m        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,[m
[32m+[m[32m        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,[m
[32m+[m[32m        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,[m
[32m+[m[32m        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,[m
[32m+[m[32m        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,[m
[32m+[m[32m        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,[m
[32m+[m[32m        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,[m
[32m+[m[32m        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,[m
[32m+[m[32m        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,[m
[32m+[m[32m        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,[m
[32m+[m[32m        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,[m
[32m+[m[32m        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,[m
[32m+[m[32m        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,[m
[32m+[m[32m        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,[m
[32m+[m[32m        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,[m
[32m+[m[32m        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,[m
[32m+[m[32m        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,[m
[32m+[m[32m        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,[m
[32m+[m[32m        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,[m
[32m+[m[32m        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,[m
[32m+[m[32m        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,[m
[32m+[m[32m        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,[m
[32m+[m[32m        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,[m
[32m+[m[32m        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,[m
[32m+[m[32m        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,[m
[32m+[m[32m        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,[m
[32m+[m[32m        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,[m
[32m+[m[32m        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,[m
[32m+[m[32m        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,[m
[32m+[m[32m        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,[m
[32m+[m[32m        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,[m
[32m+[m[32m        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,[m
[32m+[m[32m        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,[m
[32m+[m[32m        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,[m
[32m+[m[32m        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,[m
[32m+[m[32m        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,[m
[32m+[m[32m        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,[m
[32m+[m[32m        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,[m
[32m+[m[32m        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,[m
[32m+[m[32m        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,[m
[32m+[m[32m        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,[m
[32m+[m[32m        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,[m
[32m+[m[32m        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,[m
[32m+[m[32m        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,[m
[32m+[m[32m        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,[m
[32m+[m[32m        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,[m
[32m+[m[32m        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,[m
[32m+[m[32m        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,[m
[32m+[m[32m        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,[m
[32m+[m[32m        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,[m
[32m+[m[32m        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,[m
[32m+[m[32m        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,[m
[32m+[m[32m        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,[m
[32m+[m[32m        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,[m
[32m+[m[32m        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,[m
[32m+[m[32m        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,[m
[32m+[m[32m        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,[m
[32m+[m[32m        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,[m
[32m+[m[32m        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,[m
[32m+[m[32m        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,[m
[32m+[m[32m        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,[m
[32m+[m[32m        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,[m
[32m+[m[32m        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,[m
[32m+[m[32m        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,[m
[32m+[m[32m        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,[m
[32m+[m[32m        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,[m
[32m+[m[32m        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,[m
[32m+[m[32m        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,[m
[32m+[m[32m        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,[m
[32m+[m[32m        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,[m
[32m+[m[32m        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,[m
[32m+[m[32m        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,[m
[32m+[m[32m        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,[m
[32m+[m[32m        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,[m
[32m+[m[32m        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,[m
[32m+[m[32m        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,[m
[32m+[m[32m        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,[m
[32m+[m[32m        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,[m
[32m+[m[32m        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,[m
[32m+[m[32m        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,[m
[32m+[m[32m        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,[m
[32m+[m[32m        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,[m
[32m+[m[32m        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,[m
[32m+[m[32m        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,[m
[32m+[m[32m        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,[m
[32m+[m[32m        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,[m
[32m+[m[32m        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,[m
[32m+[m[32m        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,[m
[32m+[m[32m        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,[m
[32m+[m[32m        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,[m
[32m+[m[32m        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,[m
[32m+[m[32m        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,[m
[32m+[m[32m        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,[m
[32m+[m[32m        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,[m
[32m+[m[32m        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,[m
[32m+[m[32m        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,[m
[32m+[m[32m        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,[m
[32m+[m[32m        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,[m
[32m+[m[32m        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,[m
[32m+[m[32m        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,[m
[32m+[m[32m        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,[m
[32m+[m[32m        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,[m
[32m+[m[32m        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,[m
[32m+[m[32m        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,[m
[32m+[m[32m        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,[m
[32m+[m[32m        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,[m
[32m+[m[32m        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,[m
[32m+[m[32m        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,[m
[32m+[m[32m        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,[m
[32m+[m[32m        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,[m
[32m+[m[32m        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,[m
[32m+[m[32m        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,[m
[32m+[m[32m        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,[m
[32m+[m[32m        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,[m
[32m+[m[32m        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,[m
[32m+[m[32m        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,[m
[32m+[m[32m        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,[m
[32m+[m[32m        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,[m
[32m+[m[32m        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700[m
[32m+[m[32m    ]);[m
[32m+[m[32m    return PDF417Common;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417Common;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3b106f4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.d.ts[m
[36m@@ -0,0 +1,44 @@[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Reader from '../Reader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport MultipleBarcodeReader from '../multi/MultipleBarcodeReader';[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode PDF417 codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417Reader implements Reader, MultipleBarcodeReader {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a PDF417 code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the PDF417 code[m
[32m+[m[32m     * @throws NotFoundException if a PDF417 code cannot be found,[m
[32m+[m[32m     * @throws FormatException if a PDF417 cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param BinaryBitmap[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeMultiple(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result[];[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param hints[m
[32m+[m[32m     * @param multiple[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     * @throws FormatException√ü[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decode;[m
[32m+[m[32m    private static getMaxWidth;[m
[32m+[m[32m    private static getMinWidth;[m
[32m+[m[32m    private static getMaxCodewordWidth;[m
[32m+[m[32m    private static getMinCodewordWidth;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..df14440[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417Reader.js[m
[36m@@ -0,0 +1,162 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417;[m
[32m+[m[32m// import com.google.zxing.BarcodeFormat;[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32m// import com.google.zxing.ChecksumException;[m
[32m+[m[32mvar ChecksumException_1 = require("../ChecksumException");[m
[32m+[m[32m// import com.google.zxing.FormatException;[m
[32m+[m[32mvar FormatException_1 = require("../FormatException");[m
[32m+[m[32m// import com.google.zxing.NotFoundException;[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32m// import com.google.zxing.Result;[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32m// import com.google.zxing.common.DecoderResult;[m
[32m+[m[32m// import com.google.zxing.multi.MultipleBarcodeReader;[m
[32m+[m[32m// import com.google.zxing.pdf417.decoder.PDF417ScanningDecoder;[m
[32m+[m[32m// import com.google.zxing.pdf417.detector.Detector;[m
[32m+[m[32m// import com.google.zxing.pdf417.detector.PDF417DetectorResult;[m
[32m+[m[32mvar PDF417Common_1 = require("./PDF417Common");[m
[32m+[m[32mvar Integer_1 = require("../util/Integer");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32mvar Detector_1 = require("./detector/Detector");[m
[32m+[m[32mvar PDF417ScanningDecoder_1 = require("./decoder/PDF417ScanningDecoder");[m
[32m+[m[32m// import java.util.ArrayList;[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode PDF417 codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417Reader = /** @class */ (function () {[m
[32m+[m[32m    function PDF417Reader() {[m
[32m+[m[32m    }[m
[32m+[m[32m    // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a PDF417 code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a String representing the content encoded by the PDF417 code[m
[32m+[m[32m     * @throws NotFoundException if a PDF417 code cannot be found,[m
[32m+[m[32m     * @throws FormatException if a PDF417 cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    PDF417Reader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        var result = PDF417Reader.decode(image, hints, false);[m
[32m+[m[32m        if (result == null || result.length === 0 || result[0] == null) {[m
[32m+[m[32m            throw NotFoundException_1.default.getNotFoundInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        return result[0];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param BinaryBitmap[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    //   @Override[m
[32m+[m[32m    PDF417Reader.prototype.decodeMultiple = function (image, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        try {[m
[32m+[m[32m            return PDF417Reader.decode(image, hints, true);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored) {[m
[32m+[m[32m            if (ignored instanceof FormatException_1.default || ignored instanceof ChecksumException_1.default) {[m
[32m+[m[32m                throw NotFoundException_1.default.getNotFoundInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            throw ignored;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param hints[m
[32m+[m[32m     * @param multiple[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     * @throws FormatException√ü[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417Reader.decode = function (image, hints, multiple) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var results = new Array();[m
[32m+[m[32m        var detectorResult = Detector_1.default.detectMultiple(image, hints, multiple);[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var points = _c.value;[m
[32m+[m[32m                var decoderResult = PDF417ScanningDecoder_1.default.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));[m
[32m+[m[32m                var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.PDF_417);[m
[32m+[m[32m                result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());[m
[32m+[m[32m                var pdf417ResultMetadata = decoderResult.getOther();[m
[32m+[m[32m                if (pdf417ResultMetadata != null) {[m
[32m+[m[32m                    result.putMetadata(ResultMetadataType_1.default.PDF417_EXTRA_METADATA, pdf417ResultMetadata);[m
[32m+[m[32m                }[m
[32m+[m[32m                results.push(result);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return results.map(function (x) { return x; });[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Reader.getMaxWidth = function (p1, p2) {[m
[32m+[m[32m        if (p1 == null || p2 == null) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        return Math.trunc(Math.abs(p1.getX() - p2.getX()));[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Reader.getMinWidth = function (p1, p2) {[m
[32m+[m[32m        if (p1 == null || p2 == null) {[m
[32m+[m[32m            return Integer_1.default.MAX_VALUE;[m
[32m+[m[32m        }[m
[32m+[m[32m        return Math.trunc(Math.abs(p1.getX() - p2.getX()));[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Reader.getMaxCodewordWidth = function (p) {[m
[32m+[m[32m        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /[m
[32m+[m[32m            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /[m
[32m+[m[32m            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417Reader.getMinCodewordWidth = function (p) {[m
[32m+[m[32m        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /[m
[32m+[m[32m            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /[m
[32m+[m[32m            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    PDF417Reader.prototype.reset = function () {[m
[32m+[m[32m        // nothing needs to be reset[m
[32m+[m[32m    };[m
[32m+[m[32m    return PDF417Reader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417Reader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f1fe723[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.d.ts[m
[36m@@ -0,0 +1,82 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417ResultMetadata {[m
[32m+[m[32m    private segmentIndex;[m
[32m+[m[32m    private fileId;[m
[32m+[m[32m    private lastSegment;[m
[32m+[m[32m    private segmentCount;[m
[32m+[m[32m    private sender;[m
[32m+[m[32m    private addressee;[m
[32m+[m[32m    private fileName;[m
[32m+[m[32m    private fileSize;[m
[32m+[m[32m    private timestamp;[m
[32m+[m[32m    private checksum;[m
[32m+[m[32m    private optionalData;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The Segment ID represents the segment of the whole file distributed over different symbols.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return File segment index[m
[32m+[m[32m     */[m
[32m+[m[32m    getSegmentIndex(): number;[m
[32m+[m[32m    setSegmentIndex(segmentIndex: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Is the same for each related PDF417 symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return File ID[m
[32m+[m[32m     */[m
[32m+[m[32m    getFileId(): string;[m
[32m+[m[32m    setFileId(fileId: string): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return always null[m
[32m+[m[32m     * @deprecated use dedicated already parsed fields[m
[32m+[m[32m     */[m
[32m+[m[32m    getOptionalData(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param optionalData old optional data format as int array[m
[32m+[m[32m     * @deprecated parse and use new fields[m
[32m+[m[32m     */[m
[32m+[m[32m    setOptionalData(optionalData: Int32Array): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if it is the last segment[m
[32m+[m[32m     */[m
[32m+[m[32m    isLastSegment(): boolean;[m
[32m+[m[32m    setLastSegment(lastSegment: boolean): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return count of segments, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    getSegmentCount(): number;[m
[32m+[m[32m    setSegmentCount(segmentCount: number): void;[m
[32m+[m[32m    getSender(): string;[m
[32m+[m[32m    setSender(sender: string): void;[m
[32m+[m[32m    getAddressee(): string;[m
[32m+[m[32m    setAddressee(addressee: string): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Filename of the encoded file[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return filename[m
[32m+[m[32m     */[m
[32m+[m[32m    getFileName(): string;[m
[32m+[m[32m    setFileName(fileName: string): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * filesize in bytes of the encoded file[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return filesize in bytes, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    getFileSize(): number;[m
[32m+[m[32m    setFileSize(fileSize: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * 16-bit CRC checksum using CCITT-16[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return crc checksum, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    getChecksum(): number;[m
[32m+[m[32m    setChecksum(checksum: number): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * unix epock timestamp, elapsed seconds since 1970-01-01[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return elapsed seconds, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    getTimestamp(): number;[m
[32m+[m[32m    setTimestamp(timestamp: number): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js[m
[1mnew file mode 100644[m
[1mindex 0000000..98b6945[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/PDF417ResultMetadata.js[m
[36m@@ -0,0 +1,143 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417ResultMetadata = /** @class */ (function () {[m
[32m+[m[32m    function PDF417ResultMetadata() {[m
[32m+[m[32m        this.segmentCount = -1;[m
[32m+[m[32m        this.fileSize = -1;[m
[32m+[m[32m        this.timestamp = -1;[m
[32m+[m[32m        this.checksum = -1;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The Segment ID represents the segment of the whole file distributed over different symbols.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return File segment index[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getSegmentIndex = function () {[m
[32m+[m[32m        return this.segmentIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setSegmentIndex = function (segmentIndex) {[m
[32m+[m[32m        this.segmentIndex = segmentIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Is the same for each related PDF417 symbol[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return File ID[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getFileId = function () {[m
[32m+[m[32m        return this.fileId;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setFileId = function (fileId) {[m
[32m+[m[32m        this.fileId = fileId;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return always null[m
[32m+[m[32m     * @deprecated use dedicated already parsed fields[m
[32m+[m[32m     */[m
[32m+[m[32m    //   @Deprecated[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getOptionalData = function () {[m
[32m+[m[32m        return this.optionalData;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param optionalData old optional data format as int array[m
[32m+[m[32m     * @deprecated parse and use new fields[m
[32m+[m[32m     */[m
[32m+[m[32m    //   @Deprecated[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setOptionalData = function (optionalData) {[m
[32m+[m[32m        this.optionalData = optionalData;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if it is the last segment[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.isLastSegment = function () {[m
[32m+[m[32m        return this.lastSegment;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setLastSegment = function (lastSegment) {[m
[32m+[m[32m        this.lastSegment = lastSegment;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return count of segments, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getSegmentCount = function () {[m
[32m+[m[32m        return this.segmentCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setSegmentCount = function (segmentCount /*int*/) {[m
[32m+[m[32m        this.segmentCount = segmentCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getSender = function () {[m
[32m+[m[32m        return this.sender || null;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setSender = function (sender) {[m
[32m+[m[32m        this.sender = sender;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getAddressee = function () {[m
[32m+[m[32m        return this.addressee || null;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setAddressee = function (addressee) {[m
[32m+[m[32m        this.addressee = addressee;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Filename of the encoded file[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return filename[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getFileName = function () {[m
[32m+[m[32m        return this.fileName;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setFileName = function (fileName) {[m
[32m+[m[32m        this.fileName = fileName;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * filesize in bytes of the encoded file[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return filesize in bytes, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getFileSize = function () {[m
[32m+[m[32m        return this.fileSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setFileSize = function (fileSize /*long*/) {[m
[32m+[m[32m        this.fileSize = fileSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * 16-bit CRC checksum using CCITT-16[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return crc checksum, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getChecksum = function () {[m
[32m+[m[32m        return this.checksum;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setChecksum = function (checksum /*int*/) {[m
[32m+[m[32m        this.checksum = checksum;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * unix epock timestamp, elapsed seconds since 1970-01-01[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return elapsed seconds, -1 if not set[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ResultMetadata.prototype.getTimestamp = function () {[m
[32m+[m[32m        return this.timestamp;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ResultMetadata.prototype.setTimestamp = function (timestamp /*long*/) {[m
[32m+[m[32m        this.timestamp = timestamp;[m
[32m+[m[32m    };[m
[32m+[m[32m    return PDF417ResultMetadata;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417ResultMetadata;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..8e18a1b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BarcodeMetadata {[m
[32m+[m[32m    private columnCount;[m
[32m+[m[32m    private errorCorrectionLevel;[m
[32m+[m[32m    private rowCountUpperPart;[m
[32m+[m[32m    private rowCountLowerPart;[m
[32m+[m[32m    private rowCount;[m
[32m+[m[32m    constructor(columnCount: int, rowCountUpperPart: int, rowCountLowerPart: int, errorCorrectionLevel: int);[m
[32m+[m[32m    getColumnCount(): int;[m
[32m+[m[32m    getErrorCorrectionLevel(): int;[m
[32m+[m[32m    getRowCount(): int;[m
[32m+[m[32m    getRowCountUpperPart(): int;[m
[32m+[m[32m    getRowCountLowerPart(): int;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7b03b8b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeMetadata.js[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar BarcodeMetadata = /** @class */ (function () {[m
[32m+[m[32m    function BarcodeMetadata(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {[m
[32m+[m[32m        this.columnCount = columnCount;[m
[32m+[m[32m        this.errorCorrectionLevel = errorCorrectionLevel;[m
[32m+[m[32m        this.rowCountUpperPart = rowCountUpperPart;[m
[32m+[m[32m        this.rowCountLowerPart = rowCountLowerPart;[m
[32m+[m[32m        this.rowCount = rowCountUpperPart + rowCountLowerPart;[m
[32m+[m[32m    }[m
[32m+[m[32m    BarcodeMetadata.prototype.getColumnCount = function () {[m
[32m+[m[32m        return this.columnCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    BarcodeMetadata.prototype.getErrorCorrectionLevel = function () {[m
[32m+[m[32m        return this.errorCorrectionLevel;[m
[32m+[m[32m    };[m
[32m+[m[32m    BarcodeMetadata.prototype.getRowCount = function () {[m
[32m+[m[32m        return this.rowCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    BarcodeMetadata.prototype.getRowCountUpperPart = function () {[m
[32m+[m[32m        return this.rowCountUpperPart;[m
[32m+[m[32m    };[m
[32m+[m[32m    BarcodeMetadata.prototype.getRowCountLowerPart = function () {[m
[32m+[m[32m        return this.rowCountLowerPart;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BarcodeMetadata;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BarcodeMetadata;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0b6e46f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BarcodeValue {[m
[32m+[m[32m    private values;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Add an occurrence of a value[m
[32m+[m[32m     */[m
[32m+[m[32m    setValue(value: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.[m
[32m+[m[32m     * @return an array of int, containing the values with the highest occurrence, or null, if no value was set[m
[32m+[m[32m     */[m
[32m+[m[32m    getValue(): Int32Array;[m
[32m+[m[32m    getConfidence(value: int): int;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a91380b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BarcodeValue.js[m
[36m@@ -0,0 +1,114 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mvar __read = (this && this.__read) || function (o, n) {[m
[32m+[m[32m    var m = typeof Symbol === "function" && o[Symbol.iterator];[m
[32m+[m[32m    if (!m) return o;[m
[32m+[m[32m    var i = m.call(o), r, ar = [], e;[m
[32m+[m[32m    try {[m
[32m+[m[32m        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);[m
[32m+[m[32m    }[m
[32m+[m[32m    catch (error) { e = { error: error }; }[m
[32m+[m[32m    finally {[m
[32m+[m[32m        try {[m
[32m+[m[32m            if (r && !r.done && (m = i["return"])) m.call(i);[m
[32m+[m[32m        }[m
[32m+[m[32m        finally { if (e) throw e.error; }[m
[32m+[m[32m    }[m
[32m+[m[32m    return ar;[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../PDF417Common");[m
[32m+[m[32m// import java.util.ArrayList;[m
[32m+[m[32m// import java.util.Collection;[m
[32m+[m[32m// import java.util.HashMap;[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32m// import java.util.Map.Entry;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar BarcodeValue = /** @class */ (function () {[m
[32m+[m[32m    function BarcodeValue() {[m
[32m+[m[32m        this.values = new Map();[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Add an occurrence of a value[m
[32m+[m[32m     */[m
[32m+[m[32m    BarcodeValue.prototype.setValue = function (value) {[m
[32m+[m[32m        value = Math.trunc(value);[m
[32m+[m[32m        var confidence = this.values.get(value);[m
[32m+[m[32m        if (confidence == null) {[m
[32m+[m[32m            confidence = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        confidence++;[m
[32m+[m[32m        this.values.set(value, confidence);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.[m
[32m+[m[32m     * @return an array of int, containing the values with the highest occurrence, or null, if no value was set[m
[32m+[m[32m     */[m
[32m+[m[32m    BarcodeValue.prototype.getValue = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var maxConfidence = -1;[m
[32m+[m[32m        var result = new Array();[m
[32m+[m[32m        var _loop_1 = function (key, value) {[m
[32m+[m[32m            var entry = {[m
[32m+[m[32m                getKey: function () { return key; },[m
[32m+[m[32m                getValue: function () { return value; },[m
[32m+[m[32m            };[m
[32m+[m[32m            if (entry.getValue() > maxConfidence) {[m
[32m+[m[32m                maxConfidence = entry.getValue();[m
[32m+[m[32m                result = [];[m
[32m+[m[32m                result.push(entry.getKey());[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (entry.getValue() === maxConfidence) {[m
[32m+[m[32m                result.push(entry.getKey());[m
[32m+[m[32m            }[m
[32m+[m[32m        };[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];[m
[32m+[m[32m                _loop_1(key, value);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return PDF417Common_1.default.toIntArray(result);[m
[32m+[m[32m    };[m
[32m+[m[32m    BarcodeValue.prototype.getConfidence = function (value) {[m
[32m+[m[32m        return this.values.get(value);[m
[32m+[m[32m    };[m
[32m+[m[32m    return BarcodeValue;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BarcodeValue;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..cdee501[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.d.ts[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BoundingBox {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private topLeft;[m
[32m+[m[32m    private bottomLeft;[m
[32m+[m[32m    private topRight;[m
[32m+[m[32m    private bottomRight;[m
[32m+[m[32m    private minX;[m
[32m+[m[32m    private maxX;[m
[32m+[m[32m    private minY;[m
[32m+[m[32m    private maxY;[m
[32m+[m[32m    constructor(image: BitMatrix | BoundingBox, topLeft?: ResultPoint, bottomLeft?: ResultPoint, topRight?: ResultPoint, bottomRight?: ResultPoint);[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param topLeft[m
[32m+[m[32m     * @param bottomLeft[m
[32m+[m[32m     * @param topRight[m
[32m+[m[32m     * @param bottomRight[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private constructor_1;[m
[32m+[m[32m    private constructor_2;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    static merge(leftBox: BoundingBox, rightBox: BoundingBox): BoundingBox;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    addMissingRows(missingStartRows: int, missingEndRows: int, isLeft: boolean): BoundingBox;[m
[32m+[m[32m    getMinX(): int;[m
[32m+[m[32m    getMaxX(): int;[m
[32m+[m[32m    getMinY(): int;[m
[32m+[m[32m    getMaxY(): int;[m
[32m+[m[32m    getTopLeft(): ResultPoint;[m
[32m+[m[32m    getTopRight(): ResultPoint;[m
[32m+[m[32m    getBottomLeft(): ResultPoint;[m
[32m+[m[32m    getBottomRight(): ResultPoint;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js[m
[1mnew file mode 100644[m
[1mindex 0000000..47400c6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/BoundingBox.js[m
[36m@@ -0,0 +1,156 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.NotFoundException;[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m// import com.google.zxing.ResultPoint;[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar BoundingBox = /** @class */ (function () {[m
[32m+[m[32m    function BoundingBox(image, topLeft, bottomLeft, topRight, bottomRight) {[m
[32m+[m[32m        if (image instanceof BoundingBox) {[m
[32m+[m[32m            this.constructor_2(image);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param topLeft[m
[32m+[m[32m     * @param bottomLeft[m
[32m+[m[32m     * @param topRight[m
[32m+[m[32m     * @param bottomRight[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    BoundingBox.prototype.constructor_1 = function (image, topLeft, bottomLeft, topRight, bottomRight) {[m
[32m+[m[32m        var leftUnspecified = topLeft == null || bottomLeft == null;[m
[32m+[m[32m        var rightUnspecified = topRight == null || bottomRight == null;[m
[32m+[m[32m        if (leftUnspecified && rightUnspecified) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (leftUnspecified) {[m
[32m+[m[32m            topLeft = new ResultPoint_1.default(0, topRight.getY());[m
[32m+[m[32m            bottomLeft = new ResultPoint_1.default(0, bottomRight.getY());[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (rightUnspecified) {[m
[32m+[m[32m            topRight = new ResultPoint_1.default(image.getWidth() - 1, topLeft.getY());[m
[32m+[m[32m            bottomRight = new ResultPoint_1.default(image.getWidth() - 1, bottomLeft.getY());[m
[32m+[m[32m        }[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.topLeft = topLeft;[m
[32m+[m[32m        this.bottomLeft = bottomLeft;[m
[32m+[m[32m        this.topRight = topRight;[m
[32m+[m[32m        this.bottomRight = bottomRight;[m
[32m+[m[32m        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));[m
[32m+[m[32m        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));[m
[32m+[m[32m        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));[m
[32m+[m[32m        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.constructor_2 = function (boundingBox) {[m
[32m+[m[32m        this.image = boundingBox.image;[m
[32m+[m[32m        this.topLeft = boundingBox.getTopLeft();[m
[32m+[m[32m        this.bottomLeft = boundingBox.getBottomLeft();[m
[32m+[m[32m        this.topRight = boundingBox.getTopRight();[m
[32m+[m[32m        this.bottomRight = boundingBox.getBottomRight();[m
[32m+[m[32m        this.minX = boundingBox.getMinX();[m
[32m+[m[32m        this.maxX = boundingBox.getMaxX();[m
[32m+[m[32m        this.minY = boundingBox.getMinY();[m
[32m+[m[32m        this.maxY = boundingBox.getMaxY();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    BoundingBox.merge = function (leftBox, rightBox) {[m
[32m+[m[32m        if (leftBox == null) {[m
[32m+[m[32m            return rightBox;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (rightBox == null) {[m
[32m+[m[32m            return leftBox;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    BoundingBox.prototype.addMissingRows = function (missingStartRows, missingEndRows, isLeft) {[m
[32m+[m[32m        var newTopLeft = this.topLeft;[m
[32m+[m[32m        var newBottomLeft = this.bottomLeft;[m
[32m+[m[32m        var newTopRight = this.topRight;[m
[32m+[m[32m        var newBottomRight = this.bottomRight;[m
[32m+[m[32m        if (missingStartRows > 0) {[m
[32m+[m[32m            var top_1 = isLeft ? this.topLeft : this.topRight;[m
[32m+[m[32m            var newMinY = Math.trunc(top_1.getY() - missingStartRows);[m
[32m+[m[32m            if (newMinY < 0) {[m
[32m+[m[32m                newMinY = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            var newTop = new ResultPoint_1.default(top_1.getX(), newMinY);[m
[32m+[m[32m            if (isLeft) {[m
[32m+[m[32m                newTopLeft = newTop;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                newTopRight = newTop;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (missingEndRows > 0) {[m
[32m+[m[32m            var bottom = isLeft ? this.bottomLeft : this.bottomRight;[m
[32m+[m[32m            var newMaxY = Math.trunc(bottom.getY() + missingEndRows);[m
[32m+[m[32m            if (newMaxY >= this.image.getHeight()) {[m
[32m+[m[32m                newMaxY = this.image.getHeight() - 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            var newBottom = new ResultPoint_1.default(bottom.getX(), newMaxY);[m
[32m+[m[32m            if (isLeft) {[m
[32m+[m[32m                newBottomLeft = newBottom;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                newBottomRight = newBottom;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getMinX = function () {[m
[32m+[m[32m        return this.minX;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getMaxX = function () {[m
[32m+[m[32m        return this.maxX;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getMinY = function () {[m
[32m+[m[32m        return this.minY;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getMaxY = function () {[m
[32m+[m[32m        return this.maxY;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getTopLeft = function () {[m
[32m+[m[32m        return this.topLeft;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getTopRight = function () {[m
[32m+[m[32m        return this.topRight;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getBottomLeft = function () {[m
[32m+[m[32m        return this.bottomLeft;[m
[32m+[m[32m    };[m
[32m+[m[32m    BoundingBox.prototype.getBottomRight = function () {[m
[32m+[m[32m        return this.bottomRight;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BoundingBox;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BoundingBox;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d6c7f08[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.d.ts[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Codeword {[m
[32m+[m[32m    private static BARCODE_ROW_UNKNOWN;[m
[32m+[m[32m    private startX;[m
[32m+[m[32m    private endX;[m
[32m+[m[32m    private bucket;[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private rowNumber;[m
[32m+[m[32m    constructor(startX: int, endX: int, bucket: int, value: int);[m
[32m+[m[32m    hasValidRowNumber(): boolean;[m
[32m+[m[32m    isValidRowNumber(rowNumber: int): boolean;[m
[32m+[m[32m    setRowNumberAsRowIndicatorColumn(): void;[m
[32m+[m[32m    getWidth(): int;[m
[32m+[m[32m    getStartX(): int;[m
[32m+[m[32m    getEndX(): int;[m
[32m+[m[32m    getBucket(): int;[m
[32m+[m[32m    getValue(): int;[m
[32m+[m[32m    getRowNumber(): int;[m
[32m+[m[32m    setRowNumber(rowNumber: int): void;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js[m
[1mnew file mode 100644[m
[1mindex 0000000..bcb679a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/Codeword.js[m
[36m@@ -0,0 +1,67 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar Codeword = /** @class */ (function () {[m
[32m+[m[32m    function Codeword(startX, endX, bucket, value) {[m
[32m+[m[32m        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;[m
[32m+[m[32m        this.startX = Math.trunc(startX);[m
[32m+[m[32m        this.endX = Math.trunc(endX);[m
[32m+[m[32m        this.bucket = Math.trunc(bucket);[m
[32m+[m[32m        this.value = Math.trunc(value);[m
[32m+[m[32m    }[m
[32m+[m[32m    Codeword.prototype.hasValidRowNumber = function () {[m
[32m+[m[32m        return this.isValidRowNumber(this.rowNumber);[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.isValidRowNumber = function (rowNumber) {[m
[32m+[m[32m        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.setRowNumberAsRowIndicatorColumn = function () {[m
[32m+[m[32m        this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getWidth = function () {[m
[32m+[m[32m        return this.endX - this.startX;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getStartX = function () {[m
[32m+[m[32m        return this.startX;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getEndX = function () {[m
[32m+[m[32m        return this.endX;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getBucket = function () {[m
[32m+[m[32m        return this.bucket;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.getRowNumber = function () {[m
[32m+[m[32m        return this.rowNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.prototype.setRowNumber = function (rowNumber) {[m
[32m+[m[32m        this.rowNumber = rowNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    //   @Override[m
[32m+[m[32m    Codeword.prototype.toString = function () {[m
[32m+[m[32m        return this.rowNumber + '|' + this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    Codeword.BARCODE_ROW_UNKNOWN = -1;[m
[32m+[m[32m    return Codeword;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Codeword;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d79c5bc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.d.ts[m
[36m@@ -0,0 +1,163 @@[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32mimport PDF417ResultMetadata from '../PDF417ResultMetadata';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains the methods for decoding the PDF417 codewords.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DecodedBitStreamParser {[m
[32m+[m[32m    private static TEXT_COMPACTION_MODE_LATCH;[m
[32m+[m[32m    private static BYTE_COMPACTION_MODE_LATCH;[m
[32m+[m[32m    private static NUMERIC_COMPACTION_MODE_LATCH;[m
[32m+[m[32m    private static BYTE_COMPACTION_MODE_LATCH_6;[m
[32m+[m[32m    private static ECI_USER_DEFINED;[m
[32m+[m[32m    private static ECI_GENERAL_PURPOSE;[m
[32m+[m[32m    private static ECI_CHARSET;[m
[32m+[m[32m    private static BEGIN_MACRO_PDF417_CONTROL_BLOCK;[m
[32m+[m[32m    private static BEGIN_MACRO_PDF417_OPTIONAL_FIELD;[m
[32m+[m[32m    private static MACRO_PDF417_TERMINATOR;[m
[32m+[m[32m    private static MODE_SHIFT_TO_BYTE_COMPACTION_MODE;[m
[32m+[m[32m    private static MAX_NUMERIC_CODEWORDS;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_SENDER;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE;[m
[32m+[m[32m    private static MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM;[m
[32m+[m[32m    private static PL;[m
[32m+[m[32m    private static LL;[m
[32m+[m[32m    private static AS;[m
[32m+[m[32m    private static ML;[m
[32m+[m[32m    private static AL;[m
[32m+[m[32m    private static PS;[m
[32m+[m[32m    private static PAL;[m
[32m+[m[32m    private static PUNCT_CHARS;[m
[32m+[m[32m    private static MIXED_CHARS;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Table containing values for the exponent of 900.[m
[32m+[m[32m     * This is used in the numeric compaction decode algorithm.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static EXP900;[m
[32m+[m[32m    private static NUMBER_OF_SEQUENCE_CODEWORDS;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords[m
[32m+[m[32m     * @param ecLevel[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    static decode(codewords: Int32Array, ecLevel: string): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param param1[m
[32m+[m[32m     * @param codewords[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param codeIndex[m
[32m+[m[32m     * @param PDF417ResultMetadata[m
[32m+[m[32m     * @param resultMetadata[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    static decodeMacroBlock(codewords: Int32Array, codeIndex: int, resultMetadata: PDF417ResultMetadata): int;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be[m
[32m+[m[32m     * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as[m
[32m+[m[32m     * well as selected control characters.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static textCompaction;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The Text Compaction mode includes all the printable ASCII characters[m
[32m+[m[32m     * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab[m
[32m+[m[32m     * (9: e), LF or line feed (10: e), and CR or carriage[m
[32m+[m[32m     * return (13: e). The Text Compaction mode also includes various latch[m
[32m+[m[32m     * and shift characters which are used exclusively within the mode. The Text[m
[32m+[m[32m     * Compaction mode encodes up to 2 characters per codeword. The compaction rules[m
[32m+[m[32m     * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode[m
[32m+[m[32m     * switches are defined in 5.4.2.3.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param textCompactionData The text compaction data.[m
[32m+[m[32m     * @param byteCompactionData The byte compaction data if there[m
[32m+[m[32m     *                           was a mode shift.[m
[32m+[m[32m     * @param length             The size of the text compaction and byte compaction data.[m
[32m+[m[32m     * @param result             The decoded data is appended to the result.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeTextCompaction;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.[m
[32m+[m[32m     * This includes all ASCII characters value 0 to 127 inclusive and provides for international[m
[32m+[m[32m     * character set support.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mode      The byte compaction mode i.e. 901 or 924[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param encoding  Currently active character encoding[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static byteCompaction;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static numericCompaction;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords[m
[32m+[m[32m     * @param count     The number of codewords[m
[32m+[m[32m     * @return The decoded string representing the Numeric data.[m
[32m+[m[32m     *[m
[32m+[m[32m     * EXAMPLE[m
[32m+[m[32m     * Encode the fifteen digit numeric string 000213298174000[m
[32m+[m[32m     * Prefix the numeric string with a 1 and set the initial value of[m
[32m+[m[32m     * t = 1 000 213 298 174 000[m
[32m+[m[32m     * Calculate codeword 0[m
[32m+[m[32m     * d0 = 1 000 213 298 174 000 mod 900 = 200[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082[m
[32m+[m[32m     * Calculate codeword 1[m
[32m+[m[32m     * d1 = 1 111 348 109 082 mod 900 = 282[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 111 348 109 082 div 900 = 1 234 831 232[m
[32m+[m[32m     * Calculate codeword 2[m
[32m+[m[32m     * d2 = 1 234 831 232 mod 900 = 632[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 234 831 232 div 900 = 1 372 034[m
[32m+[m[32m     * Calculate codeword 3[m
[32m+[m[32m     * d3 = 1 372 034 mod 900 = 434[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 372 034 div 900 = 1 524[m
[32m+[m[32m     * Calculate codeword 4[m
[32m+[m[32m     * d4 = 1 524 mod 900 = 624[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 524 div 900 = 1[m
[32m+[m[32m     * Calculate codeword 5[m
[32m+[m[32m     * d5 = 1 mod 900 = 1[m
[32m+[m[32m     * t = 1 div 900 = 0[m
[32m+[m[32m     * Codeword sequence is: 1, 624, 434, 632, 282, 200[m
[32m+[m[32m     *[m
[32m+[m[32m     * Decode the above codewords involves[m
[32m+[m[32m     *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +[m
[32m+[m[32m     * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000[m
[32m+[m[32m     *[m
[32m+[m[32m     * Remove leading 1 =>  Result is 000213298174000[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeBase900toBase10;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6bd6f4e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DecodedBitStreamParser.js[m
[36m@@ -0,0 +1,778 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2009 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.FormatException;[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32m// import com.google.zxing.common.CharacterSetECI;[m
[32m+[m[32mvar CharacterSetECI_1 = require("../../common/CharacterSetECI");[m
[32m+[m[32m// import com.google.zxing.common.DecoderResult;[m
[32m+[m[32mvar DecoderResult_1 = require("../../common/DecoderResult");[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417ResultMetadata;[m
[32m+[m[32mvar PDF417ResultMetadata_1 = require("../PDF417ResultMetadata");[m
[32m+[m[32m// import java.io.ByteArrayOutputStream;[m
[32m+[m[32m// import java.math.BigInteger;[m
[32m+[m[32m// import java.nio.charset.Charset;[m
[32m+[m[32m// import java.nio.charset.StandardCharsets;[m
[32m+[m[32m// import java.util.Arrays;[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar Long_1 = require("../../util/Long");[m
[32m+[m[32mvar ByteArrayOutputStream_1 = require("../../util/ByteArrayOutputStream");[m
[32m+[m[32mvar StringEncoding_1 = require("../../util/StringEncoding");[m
[32m+[m[32m/*private*/ var Mode;[m
[32m+[m[32m(function (Mode) {[m
[32m+[m[32m    Mode[Mode["ALPHA"] = 0] = "ALPHA";[m
[32m+[m[32m    Mode[Mode["LOWER"] = 1] = "LOWER";[m
[32m+[m[32m    Mode[Mode["MIXED"] = 2] = "MIXED";[m
[32m+[m[32m    Mode[Mode["PUNCT"] = 3] = "PUNCT";[m
[32m+[m[32m    Mode[Mode["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";[m
[32m+[m[32m    Mode[Mode["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";[m
[32m+[m[32m})(Mode || (Mode = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * Indirectly access the global BigInt constructor, it[m
[32m+[m[32m * allows browsers that doesn't support BigInt to run[m
[32m+[m[32m * the library without breaking due to "undefined BigInt"[m
[32m+[m[32m * errors.[m
[32m+[m[32m */[m
[32m+[m[32mfunction getBigIntConstructor() {[m
[32m+[m[32m    if (typeof window !== 'undefined') {[m
[32m+[m[32m        return window['BigInt'] || null;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (typeof global !== 'undefined') {[m
[32m+[m[32m        return global['BigInt'] || null;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (typeof self !== 'undefined') {[m
[32m+[m[32m        return self['BigInt'] || null;[m
[32m+[m[32m    }[m
[32m+[m[32m    throw new Error('Can\'t search globals for BigInt!');[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * Used to store the BigInt constructor.[m
[32m+[m[32m */[m
[32m+[m[32mvar BigInteger;[m
[32m+[m[32m/**[m
[32m+[m[32m * This function creates a bigint value. It allows browsers[m
[32m+[m[32m * that doesn't support BigInt to run the rest of the library[m
[32m+[m[32m * by not directly accessing the BigInt constructor.[m
[32m+[m[32m */[m
[32m+[m[32mfunction createBigInt(num) {[m
[32m+[m[32m    if (typeof BigInteger === 'undefined') {[m
[32m+[m[32m        BigInteger = getBigIntConstructor();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (BigInteger === null) {[m
[32m+[m[32m        throw new Error('BigInt is not supported!');[m
[32m+[m[32m    }[m
[32m+[m[32m    return BigInteger(num);[m
[32m+[m[32m}[m
[32m+[m[32mfunction getEXP900() {[m
[32m+[m[32m    // in Java - array with length = 16[m
[32m+[m[32m    var EXP900 = [];[m
[32m+[m[32m    EXP900[0] = createBigInt(1);[m
[32m+[m[32m    var nineHundred = createBigInt(900);[m
[32m+[m[32m    EXP900[1] = nineHundred;[m
[32m+[m[32m    // in Java - array with length = 16[m
[32m+[m[32m    for (var i /*int*/ = 2; i < 16; i++) {[m
[32m+[m[32m        EXP900[i] = EXP900[i - 1] * nineHundred;[m
[32m+[m[32m    }[m
[32m+[m[32m    return EXP900;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class contains the methods for decoding the PDF417 codewords.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar DecodedBitStreamParser = /** @class */ (function () {[m
[32m+[m[32m    function DecodedBitStreamParser() {[m
[32m+[m[32m    }[m
[32m+[m[32m    //   private DecodedBitStreamParser() {[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords[m
[32m+[m[32m     * @param ecLevel[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decode = function (codewords, ecLevel) {[m
[32m+[m[32m        // pass encoding to result (will be used for decode symbols in byte mode)[m
[32m+[m[32m        var result = new StringBuilder_1.default('');[m
[32m+[m[32m        // let encoding: Charset = StandardCharsets.ISO_8859_1;[m
[32m+[m[32m        var encoding = CharacterSetECI_1.default.ISO8859_1;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * @note the next command is specific from this TypeScript library[m
[32m+[m[32m         * because TS can't properly cast some values to char and[m
[32m+[m[32m         * convert it to string later correctly due to encoding[m
[32m+[m[32m         * differences from Java version. As reported here:[m
[32m+[m[32m         * https://github.com/zxing-js/library/pull/264/files#r382831593[m
[32m+[m[32m         */[m
[32m+[m[32m        result.enableDecoding(encoding);[m
[32m+[m[32m        // Get compaction mode[m
[32m+[m[32m        var codeIndex = 1;[m
[32m+[m[32m        var code = codewords[codeIndex++];[m
[32m+[m[32m        var resultMetadata = new PDF417ResultMetadata_1.default();[m
[32m+[m[32m        while (codeIndex < codewords[0]) {[m
[32m+[m[32m            switch (code) {[m
[32m+[m[32m                case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                    codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                    result.append(/*(char)*/ codewords[codeIndex++]);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.ECI_CHARSET:[m
[32m+[m[32m                    var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]);[m
[32m+[m[32m                    // encoding = Charset.forName(charsetECI.getName());[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:[m
[32m+[m[32m                    // Can't do anything with generic ECI; skip its 2 characters[m
[32m+[m[32m                    codeIndex += 2;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.ECI_USER_DEFINED:[m
[32m+[m[32m                    // Can't do anything with user ECI; skip its 1 character[m
[32m+[m[32m                    codeIndex++;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:[m
[32m+[m[32m                    codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                    // Should not see these outside a macro block[m
[32m+[m[32m                    throw new FormatException_1.default();[m
[32m+[m[32m                default:[m
[32m+[m[32m                    // Default to text compaction. During testing numerous barcodes[m
[32m+[m[32m                    // appeared to be missing the starting mode. In these cases defaulting[m
[32m+[m[32m                    // to text compaction seems to work.[m
[32m+[m[32m                    codeIndex--;[m
[32m+[m[32m                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);[m
[32m+[m[32m                    break;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (codeIndex < codewords.length) {[m
[32m+[m[32m                code = codewords[codeIndex++];[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (result.length() === 0) {[m
[32m+[m[32m            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);[m
[32m+[m[32m        decoderResult.setOther(resultMetadata);[m
[32m+[m[32m        return decoderResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param param1[m
[32m+[m[32m     * @param codewords[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param codeIndex[m
[32m+[m[32m     * @param PDF417ResultMetadata[m
[32m+[m[32m     * @param resultMetadata[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    // @SuppressWarnings("deprecation")[m
[32m+[m[32m    DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {[m
[32m+[m[32m        if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {[m
[32m+[m[32m            // we must have at least two bytes left for the segment index[m
[32m+[m[32m            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {[m
[32m+[m[32m            segmentIndexArray[i] = codewords[codeIndex];[m
[32m+[m[32m        }[m
[32m+[m[32m        resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));[m
[32m+[m[32m        var fileId = new StringBuilder_1.default();[m
[32m+[m[32m        codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);[m
[32m+[m[32m        resultMetadata.setFileId(fileId.toString());[m
[32m+[m[32m        var optionalFieldsStart = -1;[m
[32m+[m[32m        if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {[m
[32m+[m[32m            optionalFieldsStart = codeIndex + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (codeIndex < codewords[0]) {[m
[32m+[m[32m            switch (codewords[codeIndex]) {[m
[32m+[m[32m                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                    codeIndex++;[m
[32m+[m[32m                    switch (codewords[codeIndex]) {[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:[m
[32m+[m[32m                            var fileName = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);[m
[32m+[m[32m                            resultMetadata.setFileName(fileName.toString());[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:[m
[32m+[m[32m                            var sender = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);[m
[32m+[m[32m                            resultMetadata.setSender(sender.toString());[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:[m
[32m+[m[32m                            var addressee = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);[m
[32m+[m[32m                            resultMetadata.setAddressee(addressee.toString());[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:[m
[32m+[m[32m                            var segmentCount = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);[m
[32m+[m[32m                            resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:[m
[32m+[m[32m                            var timestamp = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);[m
[32m+[m[32m                            resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:[m
[32m+[m[32m                            var checksum = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);[m
[32m+[m[32m                            resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:[m
[32m+[m[32m                            var fileSize = new StringBuilder_1.default();[m
[32m+[m[32m                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);[m
[32m+[m[32m                            resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        default:[m
[32m+[m[32m                            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                    codeIndex++;[m
[32m+[m[32m                    resultMetadata.setLastSegment(true);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                default:[m
[32m+[m[32m                    throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // copy optional fields to additional options[m
[32m+[m[32m        if (optionalFieldsStart !== -1) {[m
[32m+[m[32m            var optionalFieldsLength = codeIndex - optionalFieldsStart;[m
[32m+[m[32m            if (resultMetadata.isLastSegment()) {[m
[32m+[m[32m                // do not include terminator[m
[32m+[m[32m                optionalFieldsLength--;[m
[32m+[m[32m            }[m
[32m+[m[32m            resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));[m
[32m+[m[32m        }[m
[32m+[m[32m        return codeIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be[m
[32m+[m[32m     * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as[m
[32m+[m[32m     * well as selected control characters.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {[m
[32m+[m[32m        // 2 character per codeword[m
[32m+[m[32m        var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);[m
[32m+[m[32m        // Used to hold the byte compaction value if there is a mode shift[m
[32m+[m[32m        var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);[m
[32m+[m[32m        var index = 0;[m
[32m+[m[32m        var end = false;[m
[32m+[m[32m        while ((codeIndex < codewords[0]) && !end) {[m
[32m+[m[32m            var code = codewords[codeIndex++];[m
[32m+[m[32m            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {[m
[32m+[m[32m                textCompactionData[index] = code / 30;[m
[32m+[m[32m                textCompactionData[index + 1] = code % 30;[m
[32m+[m[32m                index += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                switch (code) {[m
[32m+[m[32m                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                        // reinitialize text compaction mode to alpha sub mode[m
[32m+[m[32m                        textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                    case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:[m
[32m+[m[32m                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                        codeIndex--;[m
[32m+[m[32m                        end = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                        // The Mode Shift codeword 913 shall cause a temporary[m
[32m+[m[32m                        // switch from Text Compaction mode to Byte Compaction mode.[m
[32m+[m[32m                        // This switch shall be in effect for only the next codeword,[m
[32m+[m[32m                        // after which the mode shall revert to the prevailing sub-mode[m
[32m+[m[32m                        // of the Text Compaction mode. Codeword 913 is only available[m
[32m+[m[32m                        // in Text Compaction mode; its use is described in 5.4.2.4.[m
[32m+[m[32m                        textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;[m
[32m+[m[32m                        code = codewords[codeIndex++];[m
[32m+[m[32m                        byteCompactionData[index] = code;[m
[32m+[m[32m                        index++;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);[m
[32m+[m[32m        return codeIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The Text Compaction mode includes all the printable ASCII characters[m
[32m+[m[32m     * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab[m
[32m+[m[32m     * (9: e), LF or line feed (10: e), and CR or carriage[m
[32m+[m[32m     * return (13: e). The Text Compaction mode also includes various latch[m
[32m+[m[32m     * and shift characters which are used exclusively within the mode. The Text[m
[32m+[m[32m     * Compaction mode encodes up to 2 characters per codeword. The compaction rules[m
[32m+[m[32m     * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode[m
[32m+[m[32m     * switches are defined in 5.4.2.3.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param textCompactionData The text compaction data.[m
[32m+[m[32m     * @param byteCompactionData The byte compaction data if there[m
[32m+[m[32m     *                           was a mode shift.[m
[32m+[m[32m     * @param length             The size of the text compaction and byte compaction data.[m
[32m+[m[32m     * @param result             The decoded data is appended to the result.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {[m
[32m+[m[32m        // Beginning from an initial state of the Alpha sub-mode[m
[32m+[m[32m        // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text[m
[32m+[m[32m        // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text[m
[32m+[m[32m        // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.[m
[32m+[m[32m        var subMode = Mode.ALPHA;[m
[32m+[m[32m        var priorToShiftMode = Mode.ALPHA;[m
[32m+[m[32m        var i = 0;[m
[32m+[m[32m        while (i < length) {[m
[32m+[m[32m            var subModeCh = textCompactionData[i];[m
[32m+[m[32m            var ch = /*char*/ '';[m
[32m+[m[32m            switch (subMode) {[m
[32m+[m[32m                case Mode.ALPHA:[m
[32m+[m[32m                    // Alpha (alphabetic: uppercase)[m
[32m+[m[32m                    if (subModeCh < 26) {[m
[32m+[m[32m                        // Upper case Alpha Character[m
[32m+[m[32m                        // Note: 65 = 'A' ASCII -> there is byte code of symbol[m
[32m+[m[32m                        ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case 26:[m
[32m+[m[32m                                ch = ' ';[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.LL:[m
[32m+[m[32m                                subMode = Mode.LOWER;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.ML:[m
[32m+[m[32m                                subMode = Mode.MIXED;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.PS:[m
[32m+[m[32m                                // Shift to punctuation[m
[32m+[m[32m                                priorToShiftMode = subMode;[m
[32m+[m[32m                                subMode = Mode.PUNCT_SHIFT;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                                result.append(/*(char)*/ byteCompactionData[i]);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Mode.LOWER:[m
[32m+[m[32m                    // Lower (alphabetic: lowercase)[m
[32m+[m[32m                    if (subModeCh < 26) {[m
[32m+[m[32m                        ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case 26:[m
[32m+[m[32m                                ch = ' ';[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.AS:[m
[32m+[m[32m                                // Shift to alpha[m
[32m+[m[32m                                priorToShiftMode = subMode;[m
[32m+[m[32m                                subMode = Mode.ALPHA_SHIFT;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.ML:[m
[32m+[m[32m                                subMode = Mode.MIXED;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.PS:[m
[32m+[m[32m                                // Shift to punctuation[m
[32m+[m[32m                                priorToShiftMode = subMode;[m
[32m+[m[32m                                subMode = Mode.PUNCT_SHIFT;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                                // TODO Does this need to use the current character encoding? See other occurrences below[m
[32m+[m[32m                                result.append(/*(char)*/ byteCompactionData[i]);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Mode.MIXED:[m
[32m+[m[32m                    // Mixed (punctuation: e)[m
[32m+[m[32m                    if (subModeCh < DecodedBitStreamParser.PL) {[m
[32m+[m[32m                        ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case DecodedBitStreamParser.PL:[m
[32m+[m[32m                                subMode = Mode.PUNCT;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case 26:[m
[32m+[m[32m                                ch = ' ';[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.LL:[m
[32m+[m[32m                                subMode = Mode.LOWER;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.AL:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.PS:[m
[32m+[m[32m                                // Shift to punctuation[m
[32m+[m[32m                                priorToShiftMode = subMode;[m
[32m+[m[32m                                subMode = Mode.PUNCT_SHIFT;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                                result.append(/*(char)*/ byteCompactionData[i]);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Mode.PUNCT:[m
[32m+[m[32m                    // Punctuation[m
[32m+[m[32m                    if (subModeCh < DecodedBitStreamParser.PAL) {[m
[32m+[m[32m                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case DecodedBitStreamParser.PAL:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                                result.append(/*(char)*/ byteCompactionData[i]);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Mode.ALPHA_SHIFT:[m
[32m+[m[32m                    // Restore sub-mode[m
[32m+[m[32m                    subMode = priorToShiftMode;[m
[32m+[m[32m                    if (subModeCh < 26) {[m
[32m+[m[32m                        ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case 26:[m
[32m+[m[32m                                ch = ' ';[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case Mode.PUNCT_SHIFT:[m
[32m+[m[32m                    // Restore sub-mode[m
[32m+[m[32m                    subMode = priorToShiftMode;[m
[32m+[m[32m                    if (subModeCh < DecodedBitStreamParser.PAL) {[m
[32m+[m[32m                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (subModeCh) {[m
[32m+[m[32m                            case DecodedBitStreamParser.PAL:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:[m
[32m+[m[32m                                // PS before Shift-to-Byte is used as a padding character,[m
[32m+[m[32m                                // see 5.4.2.4 of the specification[m
[32m+[m[32m                                result.append(/*(char)*/ byteCompactionData[i]);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                                subMode = Mode.ALPHA;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // if (ch !== 0) {[m
[32m+[m[32m            if (ch !== '') {[m
[32m+[m[32m                // Append decoded character to result[m
[32m+[m[32m                result.append(ch);[m
[32m+[m[32m            }[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.[m
[32m+[m[32m     * This includes all ASCII characters value 0 to 127 inclusive and provides for international[m
[32m+[m[32m     * character set support.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mode      The byte compaction mode i.e. 901 or 924[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param encoding  Currently active character encoding[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {[m
[32m+[m[32m        var decodedBytes = new ByteArrayOutputStream_1.default();[m
[32m+[m[32m        var count = 0;[m
[32m+[m[32m        var value = /*long*/ 0;[m
[32m+[m[32m        var end = false;[m
[32m+[m[32m        switch (mode) {[m
[32m+[m[32m            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                // Total number of Byte Compaction characters to be encoded[m
[32m+[m[32m                // is not a multiple of 6[m
[32m+[m[32m                var byteCompactedCodewords = new Int32Array(6);[m
[32m+[m[32m                var nextCode = codewords[codeIndex++];[m
[32m+[m[32m                while ((codeIndex < codewords[0]) && !end) {[m
[32m+[m[32m                    byteCompactedCodewords[count++] = nextCode;[m
[32m+[m[32m                    // Base 900[m
[32m+[m[32m                    value = 900 * value + nextCode;[m
[32m+[m[32m                    nextCode = codewords[codeIndex++];[m
[32m+[m[32m                    // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH[m
[32m+[m[32m                    switch (nextCode) {[m
[32m+[m[32m                        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:[m
[32m+[m[32m                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                            codeIndex--;[m
[32m+[m[32m                            end = true;[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        default:[m
[32m+[m[32m                            if ((count % 5 === 0) && (count > 0)) {[m
[32m+[m[32m                                // Decode every 5 codewords[m
[32m+[m[32m                                // Convert to Base 256[m
[32m+[m[32m                                for (var j /*int*/ = 0; j < 6; ++j) {[m
[32m+[m[32m                                    /* @note[m
[32m+[m[32m                                     * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.[m
[32m+[m[32m                                     * So the next bitwise operation could not be done with simple numbers[m
[32m+[m[32m                                     */[m
[32m+[m[32m                                    decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));[m
[32m+[m[32m                                }[m
[32m+[m[32m                                value = 0;[m
[32m+[m[32m                                count = 0;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                // if the end of all codewords is reached the last codeword needs to be added[m
[32m+[m[32m                if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {[m
[32m+[m[32m                    byteCompactedCodewords[count++] = nextCode;[m
[32m+[m[32m                }[m
[32m+[m[32m                // If Byte Compaction mode is invoked with codeword 901,[m
[32m+[m[32m                // the last group of codewords is interpreted directly[m
[32m+[m[32m                // as one byte per codeword, without compaction.[m
[32m+[m[32m                for (var i /*int*/ = 0; i < count; i++) {[m
[32m+[m[32m                    decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                // Total number of Byte Compaction characters to be encoded[m
[32m+[m[32m                // is an integer multiple of 6[m
[32m+[m[32m                while (codeIndex < codewords[0] && !end) {[m
[32m+[m[32m                    var code = codewords[codeIndex++];[m
[32m+[m[32m                    if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {[m
[32m+[m[32m                        count++;[m
[32m+[m[32m                        // Base 900[m
[32m+[m[32m                        value = 900 * value + code;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        switch (code) {[m
[32m+[m[32m                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:[m
[32m+[m[32m                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                                codeIndex--;[m
[32m+[m[32m                                end = true;[m
[32m+[m[32m                                break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if ((count % 5 === 0) && (count > 0)) {[m
[32m+[m[32m                        // Decode every 5 codewords[m
[32m+[m[32m                        // Convert to Base 256[m
[32m+[m[32m                        /* @note[m
[32m+[m[32m                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.[m
[32m+[m[32m                         * So the next bitwise operation could not be done with simple numbers[m
[32m+[m[32m                        */[m
[32m+[m[32m                        for (var j /*int*/ = 0; j < 6; ++j) {[m
[32m+[m[32m                            decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        value = 0;[m
[32m+[m[32m                        count = 0;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m        result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));[m
[32m+[m[32m        return codeIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords (data + error)[m
[32m+[m[32m     * @param codeIndex The current index into the codeword array.[m
[32m+[m[32m     * @param result    The decoded data is appended to the result.[m
[32m+[m[32m     * @return The next index into the codeword array.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex /*int*/, result) {[m
[32m+[m[32m        var count = 0;[m
[32m+[m[32m        var end = false;[m
[32m+[m[32m        var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);[m
[32m+[m[32m        while (codeIndex < codewords[0] && !end) {[m
[32m+[m[32m            var code = codewords[codeIndex++];[m
[32m+[m[32m            if (codeIndex === codewords[0]) {[m
[32m+[m[32m                end = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {[m
[32m+[m[32m                numericCodewords[count] = code;[m
[32m+[m[32m                count++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                switch (code) {[m
[32m+[m[32m                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:[m
[32m+[m[32m                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:[m
[32m+[m[32m                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:[m
[32m+[m[32m                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:[m
[32m+[m[32m                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:[m
[32m+[m[32m                        codeIndex--;[m
[32m+[m[32m                        end = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {[m
[32m+[m[32m                // Re-invoking Numeric Compaction mode (by using codeword 902[m
[32m+[m[32m                // while in Numeric Compaction mode) serves  to terminate the[m
[32m+[m[32m                // current Numeric Compaction mode grouping as described in 5.4.4.2,[m
[32m+[m[32m                // and then to start a new one grouping.[m
[32m+[m[32m                result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));[m
[32m+[m[32m                count = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return codeIndex;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords The array of codewords[m
[32m+[m[32m     * @param count     The number of codewords[m
[32m+[m[32m     * @return The decoded string representing the Numeric data.[m
[32m+[m[32m     *[m
[32m+[m[32m     * EXAMPLE[m
[32m+[m[32m     * Encode the fifteen digit numeric string 000213298174000[m
[32m+[m[32m     * Prefix the numeric string with a 1 and set the initial value of[m
[32m+[m[32m     * t = 1 000 213 298 174 000[m
[32m+[m[32m     * Calculate codeword 0[m
[32m+[m[32m     * d0 = 1 000 213 298 174 000 mod 900 = 200[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082[m
[32m+[m[32m     * Calculate codeword 1[m
[32m+[m[32m     * d1 = 1 111 348 109 082 mod 900 = 282[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 111 348 109 082 div 900 = 1 234 831 232[m
[32m+[m[32m     * Calculate codeword 2[m
[32m+[m[32m     * d2 = 1 234 831 232 mod 900 = 632[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 234 831 232 div 900 = 1 372 034[m
[32m+[m[32m     * Calculate codeword 3[m
[32m+[m[32m     * d3 = 1 372 034 mod 900 = 434[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 372 034 div 900 = 1 524[m
[32m+[m[32m     * Calculate codeword 4[m
[32m+[m[32m     * d4 = 1 524 mod 900 = 624[m
[32m+[m[32m     *[m
[32m+[m[32m     * t = 1 524 div 900 = 1[m
[32m+[m[32m     * Calculate codeword 5[m
[32m+[m[32m     * d5 = 1 mod 900 = 1[m
[32m+[m[32m     * t = 1 div 900 = 0[m
[32m+[m[32m     * Codeword sequence is: 1, 624, 434, 632, 282, 200[m
[32m+[m[32m     *[m
[32m+[m[32m     * Decode the above codewords involves[m
[32m+[m[32m     *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +[m
[32m+[m[32m     * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000[m
[32m+[m[32m     *[m
[32m+[m[32m     * Remove leading 1 =>  Result is 000213298174000[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {[m
[32m+[m[32m        var result = createBigInt(0);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < count; i++) {[m
[32m+[m[32m            result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        var resultString = result.toString();[m
[32m+[m[32m        if (resultString.charAt(0) !== '1') {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return resultString.substring(1);[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;[m
[32m+[m[32m    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;[m
[32m+[m[32m    DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;[m
[32m+[m[32m    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;[m
[32m+[m[32m    DecodedBitStreamParser.ECI_USER_DEFINED = 925;[m
[32m+[m[32m    DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;[m
[32m+[m[32m    DecodedBitStreamParser.ECI_CHARSET = 927;[m
[32m+[m[32m    DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;[m
[32m+[m[32m    DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;[m
[32m+[m[32m    DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;[m
[32m+[m[32m    DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;[m
[32m+[m[32m    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;[m
[32m+[m[32m    DecodedBitStreamParser.PL = 25;[m
[32m+[m[32m    DecodedBitStreamParser.LL = 27;[m
[32m+[m[32m    DecodedBitStreamParser.AS = 27;[m
[32m+[m[32m    DecodedBitStreamParser.ML = 28;[m
[32m+[m[32m    DecodedBitStreamParser.AL = 28;[m
[32m+[m[32m    DecodedBitStreamParser.PS = 29;[m
[32m+[m[32m    DecodedBitStreamParser.PAL = 29;[m
[32m+[m[32m    DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\]_`~!\r\t,:\n-.$/"|*()?{}\'';[m
[32m+[m[32m    DecodedBitStreamParser.MIXED_CHARS = '0123456789&\r\t,:#-.$/+%*=^';[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Table containing values for the exponent of 900.[m
[32m+[m[32m     * This is used in the numeric compaction decode algorithm.[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];[m
[32m+[m[32m    DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;[m
[32m+[m[32m    return DecodedBitStreamParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DecodedBitStreamParser;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..863f0c6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.d.ts[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32mimport BoundingBox from './BoundingBox';[m
[32m+[m[32mimport BarcodeMetadata from './BarcodeMetadata';[m
[32m+[m[32mimport DetectionResultColumn from './DetectionResultColumn';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DetectionResult {[m
[32m+[m[32m    ADJUST_ROW_NUMBER_SKIP: int;[m
[32m+[m[32m    private barcodeMetadata;[m
[32m+[m[32m    private detectionResultColumns;[m
[32m+[m[32m    private boundingBox;[m
[32m+[m[32m    private barcodeColumnCount;[m
[32m+[m[32m    constructor(barcodeMetadata: BarcodeMetadata, boundingBox: BoundingBox);[m
[32m+[m[32m    getDetectionResultColumns(): DetectionResultColumn[];[m
[32m+[m[32m    private adjustIndicatorColumnRowNumbers;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords[m
[32m+[m[32m     * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers[m
[32m+[m[32m     */[m
[32m+[m[32m    private adjustRowNumbersAndGetCount;[m
[32m+[m[32m    private adjustRowNumbersByRow;[m
[32m+[m[32m    private adjustRowNumbersFromBothRI;[m
[32m+[m[32m    private adjustRowNumbersFromRRI;[m
[32m+[m[32m    private adjustRowNumbersFromLRI;[m
[32m+[m[32m    private static adjustRowNumberIfValid;[m
[32m+[m[32m    private adjustRowNumbers;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true, if row number was adjusted, false otherwise[m
[32m+[m[32m     */[m
[32m+[m[32m    private static adjustRowNumber;[m
[32m+[m[32m    getBarcodeColumnCount(): int;[m
[32m+[m[32m    getBarcodeRowCount(): int;[m
[32m+[m[32m    getBarcodeECLevel(): int;[m
[32m+[m[32m    setBoundingBox(boundingBox: BoundingBox): void;[m
[32m+[m[32m    getBoundingBox(): BoundingBox;[m
[32m+[m[32m    setDetectionResultColumn(barcodeColumn: int, detectionResultColumn: DetectionResultColumn): void;[m
[32m+[m[32m    getDetectionResultColumn(barcodeColumn: int): DetectionResultColumn;[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c3d718c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResult.js[m
[36m@@ -0,0 +1,297 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../PDF417Common");[m
[32m+[m[32mvar Formatter_1 = require("../../util/Formatter");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar DetectionResult = /** @class */ (function () {[m
[32m+[m[32m    function DetectionResult(barcodeMetadata, boundingBox) {[m
[32m+[m[32m        /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;[m
[32m+[m[32m        this.barcodeMetadata = barcodeMetadata;[m
[32m+[m[32m        this.barcodeColumnCount = barcodeMetadata.getColumnCount();[m
[32m+[m[32m        this.boundingBox = boundingBox;[m
[32m+[m[32m        // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];[m
[32m+[m[32m        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);[m
[32m+[m[32m    }[m
[32m+[m[32m    DetectionResult.prototype.getDetectionResultColumns = function () {[m
[32m+[m[32m        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);[m
[32m+[m[32m        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);[m
[32m+[m[32m        var unadjustedCodewordCount = PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE;[m
[32m+[m[32m        var previousUnadjustedCount;[m
[32m+[m[32m        do {[m
[32m+[m[32m            previousUnadjustedCount = unadjustedCodewordCount;[m
[32m+[m[32m            unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();[m
[32m+[m[32m        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);[m
[32m+[m[32m        return this.detectionResultColumns;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustIndicatorColumnRowNumbers = function (detectionResultColumn) {[m
[32m+[m[32m        if (detectionResultColumn != null) {[m
[32m+[m[32m            detectionResultColumn[m
[32m+[m[32m                .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // TODO ensure that no detected codewords with unknown row number are left[m
[32m+[m[32m    // we should be able to estimate the row height and use it as a hint for the row number[m
[32m+[m[32m    // we should also fill the rows top to bottom and bottom to top[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords[m
[32m+[m[32m     * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers[m
[32m+[m[32m     */[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbersAndGetCount = function () {[m
[32m+[m[32m        var unadjustedCount = this.adjustRowNumbersByRow();[m
[32m+[m[32m        if (unadjustedCount === 0) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {[m
[32m+[m[32m            var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();[m
[32m+[m[32m            for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {[m
[32m+[m[32m                if (codewords[codewordsRow] == null) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (!codewords[codewordsRow].hasValidRowNumber()) {[m
[32m+[m[32m                    this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return unadjustedCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbersByRow = function () {[m
[32m+[m[32m        this.adjustRowNumbersFromBothRI();[m
[32m+[m[32m        // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.[m
[32m+[m[32m        // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode[m
[32m+[m[32m        // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row[m
[32m+[m[32m        // number starts and ends.[m
[32m+[m[32m        var unadjustedCount = this.adjustRowNumbersFromLRI();[m
[32m+[m[32m        return unadjustedCount + this.adjustRowNumbersFromRRI();[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbersFromBothRI = function () {[m
[32m+[m[32m        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var LRIcodewords = this.detectionResultColumns[0].getCodewords();[m
[32m+[m[32m        var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();[m
[32m+[m[32m        for (var codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {[m
[32m+[m[32m            if (LRIcodewords[codewordsRow] != null &&[m
[32m+[m[32m                RRIcodewords[codewordsRow] != null &&[m
[32m+[m[32m                LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {[m
[32m+[m[32m                for (var barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {[m
[32m+[m[32m                    var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];[m
[32m+[m[32m                    if (codeword == null) {[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());[m
[32m+[m[32m                    if (!codeword.hasValidRowNumber()) {[m
[32m+[m[32m                        this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbersFromRRI = function () {[m
[32m+[m[32m        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var unadjustedCount = 0;[m
[32m+[m[32m        var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();[m
[32m+[m[32m        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {[m
[32m+[m[32m            if (codewords[codewordsRow] == null) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();[m
[32m+[m[32m            var invalidRowCounts = 0;[m
[32m+[m[32m            for (var barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {[m
[32m+[m[32m                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);[m
[32m+[m[32m                    if (!codeword.hasValidRowNumber()) {[m
[32m+[m[32m                        unadjustedCount++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return unadjustedCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbersFromLRI = function () {[m
[32m+[m[32m        if (this.detectionResultColumns[0] == null) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var unadjustedCount = 0;[m
[32m+[m[32m        var codewords = this.detectionResultColumns[0].getCodewords();[m
[32m+[m[32m        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {[m
[32m+[m[32m            if (codewords[codewordsRow] == null) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();[m
[32m+[m[32m            var invalidRowCounts = 0;[m
[32m+[m[32m            for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {[m
[32m+[m[32m                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);[m
[32m+[m[32m                    if (!codeword.hasValidRowNumber()) {[m
[32m+[m[32m                        unadjustedCount++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return unadjustedCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.adjustRowNumberIfValid = function (rowIndicatorRowNumber, invalidRowCounts, codeword) {[m
[32m+[m[32m        if (codeword == null) {[m
[32m+[m[32m            return invalidRowCounts;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!codeword.hasValidRowNumber()) {[m
[32m+[m[32m            if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {[m
[32m+[m[32m                codeword.setRowNumber(rowIndicatorRowNumber);[m
[32m+[m[32m                invalidRowCounts = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                ++invalidRowCounts;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return invalidRowCounts;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.adjustRowNumbers = function (barcodeColumn, codewordsRow, codewords) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (this.detectionResultColumns[barcodeColumn - 1] == null) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var codeword = codewords[codewordsRow];[m
[32m+[m[32m        var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();[m
[32m+[m[32m        var nextColumnCodewords = previousColumnCodewords;[m
[32m+[m[32m        if (this.detectionResultColumns[barcodeColumn + 1] != null) {[m
[32m+[m[32m            nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();[m
[32m+[m[32m        }[m
[32m+[m[32m        // let otherCodewords: Codeword[] = new Codeword[14];[m
[32m+[m[32m        var otherCodewords = new Array(14);[m
[32m+[m[32m        otherCodewords[2] = previousColumnCodewords[codewordsRow];[m
[32m+[m[32m        otherCodewords[3] = nextColumnCodewords[codewordsRow];[m
[32m+[m[32m        if (codewordsRow > 0) {[m
[32m+[m[32m            otherCodewords[0] = codewords[codewordsRow - 1];[m
[32m+[m[32m            otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];[m
[32m+[m[32m            otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (codewordsRow > 1) {[m
[32m+[m[32m            otherCodewords[8] = codewords[codewordsRow - 2];[m
[32m+[m[32m            otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];[m
[32m+[m[32m            otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (codewordsRow < codewords.length - 1) {[m
[32m+[m[32m            otherCodewords[1] = codewords[codewordsRow + 1];[m
[32m+[m[32m            otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];[m
[32m+[m[32m            otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (codewordsRow < codewords.length - 2) {[m
[32m+[m[32m            otherCodewords[9] = codewords[codewordsRow + 2];[m
[32m+[m[32m            otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];[m
[32m+[m[32m            otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var otherCodewords_1 = __values(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {[m
[32m+[m[32m                var otherCodeword = otherCodewords_1_1.value;[m
[32m+[m[32m                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return)) _a.call(otherCodewords_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true, if row number was adjusted, false otherwise[m
[32m+[m[32m     */[m
[32m+[m[32m    DetectionResult.adjustRowNumber = function (codeword, otherCodeword) {[m
[32m+[m[32m        if (otherCodeword == null) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {[m
[32m+[m[32m            codeword.setRowNumber(otherCodeword.getRowNumber());[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.getBarcodeColumnCount = function () {[m
[32m+[m[32m        return this.barcodeColumnCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.getBarcodeRowCount = function () {[m
[32m+[m[32m        return this.barcodeMetadata.getRowCount();[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.getBarcodeECLevel = function () {[m
[32m+[m[32m        return this.barcodeMetadata.getErrorCorrectionLevel();[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.setBoundingBox = function (boundingBox) {[m
[32m+[m[32m        this.boundingBox = boundingBox;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.getBoundingBox = function () {[m
[32m+[m[32m        return this.boundingBox;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.setDetectionResultColumn = function (barcodeColumn, detectionResultColumn) {[m
[32m+[m[32m        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResult.prototype.getDetectionResultColumn = function (barcodeColumn) {[m
[32m+[m[32m        return this.detectionResultColumns[barcodeColumn];[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    DetectionResult.prototype.toString = function () {[m
[32m+[m[32m        var rowIndicatorColumn = this.detectionResultColumns[0];[m
[32m+[m[32m        if (rowIndicatorColumn == null) {[m
[32m+[m[32m            rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];[m
[32m+[m[32m        }[m
[32m+[m[32m        // try ([m
[32m+[m[32m        var formatter = new Formatter_1.default();[m
[32m+[m[32m        // ) {[m
[32m+[m[32m        for (var codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {[m
[32m+[m[32m            formatter.format('CW %3d:', codewordsRow);[m
[32m+[m[32m            for (var barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {[m
[32m+[m[32m                if (this.detectionResultColumns[barcodeColumn] == null) {[m
[32m+[m[32m                    formatter.format('    |   ');[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];[m
[32m+[m[32m                if (codeword == null) {[m
[32m+[m[32m                    formatter.format('    |   ');[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());[m
[32m+[m[32m            }[m
[32m+[m[32m            formatter.format('%n');[m
[32m+[m[32m        }[m
[32m+[m[32m        return formatter.toString();[m
[32m+[m[32m        // }[m
[32m+[m[32m    };[m
[32m+[m[32m    return DetectionResult;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DetectionResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..943623f[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.d.ts[m
[36m@@ -0,0 +1,19 @@[m
[32m+[m[32mimport Codeword from './Codeword';[m
[32m+[m[32mimport BoundingBox from './BoundingBox';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DetectionResultColumn {[m
[32m+[m[32m    private static MAX_NEARBY_DISTANCE;[m
[32m+[m[32m    private boundingBox;[m
[32m+[m[32m    private codewords;[m
[32m+[m[32m    constructor(boundingBox: BoundingBox);[m
[32m+[m[32m    getCodewordNearby(imageRow: int): Codeword;[m
[32m+[m[32m    imageRowToCodewordIndex(imageRow: int): int;[m
[32m+[m[32m    setCodeword(imageRow: int, codeword: Codeword): void;[m
[32m+[m[32m    getCodeword(imageRow: int): Codeword;[m
[32m+[m[32m    getBoundingBox(): BoundingBox;[m
[32m+[m[32m    getCodewords(): Codeword[];[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ceddd42[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultColumn.js[m
[36m@@ -0,0 +1,107 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import java.util.Formatter;[m
[32m+[m[32mvar Formatter_1 = require("../../util/Formatter");[m
[32m+[m[32mvar BoundingBox_1 = require("./BoundingBox");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar DetectionResultColumn = /** @class */ (function () {[m
[32m+[m[32m    function DetectionResultColumn(boundingBox) {[m
[32m+[m[32m        this.boundingBox = new BoundingBox_1.default(boundingBox);[m
[32m+[m[32m        // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];[m
[32m+[m[32m        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);[m
[32m+[m[32m    }[m
[32m+[m[32m    /*final*/ DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {[m
[32m+[m[32m        var codeword = this.getCodeword(imageRow);[m
[32m+[m[32m        if (codeword != null) {[m
[32m+[m[32m            return codeword;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {[m
[32m+[m[32m            var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;[m
[32m+[m[32m            if (nearImageRow >= 0) {[m
[32m+[m[32m                codeword = this.codewords[nearImageRow];[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    return codeword;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;[m
[32m+[m[32m            if (nearImageRow < this.codewords.length) {[m
[32m+[m[32m                codeword = this.codewords[nearImageRow];[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    return codeword;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final int*/ DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {[m
[32m+[m[32m        return imageRow - this.boundingBox.getMinY();[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final void*/ DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {[m
[32m+[m[32m        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final*/ DetectionResultColumn.prototype.getCodeword = function (imageRow) {[m
[32m+[m[32m        return this.codewords[this.imageRowToCodewordIndex(imageRow)];[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final*/ DetectionResultColumn.prototype.getBoundingBox = function () {[m
[32m+[m[32m        return this.boundingBox;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final*/ DetectionResultColumn.prototype.getCodewords = function () {[m
[32m+[m[32m        return this.codewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    DetectionResultColumn.prototype.toString = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var formatter = new Formatter_1.default();[m
[32m+[m[32m        var row = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var codeword = _c.value;[m
[32m+[m[32m                if (codeword == null) {[m
[32m+[m[32m                    formatter.format('%3d:    |   %n', row++);[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return formatter.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;[m
[32m+[m[32m    return DetectionResultColumn;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DetectionResultColumn;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a825755[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.d.ts[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mimport BarcodeMetadata from './BarcodeMetadata';[m
[32m+[m[32mimport BoundingBox from './BoundingBox';[m
[32m+[m[32mimport DetectionResultColumn from './DetectionResultColumn';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DetectionResultRowIndicatorColumn extends DetectionResultColumn {[m
[32m+[m[32m    private _isLeft;[m
[32m+[m[32m    constructor(boundingBox: BoundingBox, isLeft: boolean);[m
[32m+[m[32m    private setRowNumbers;[m
[32m+[m[32m    adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata: BarcodeMetadata): void;[m
[32m+[m[32m    getRowHeights(): Int32Array;[m
[32m+[m[32m    private adjustIncompleteIndicatorColumnRowNumbers;[m
[32m+[m[32m    getBarcodeMetadata(): BarcodeMetadata;[m
[32m+[m[32m    private removeIncorrectCodewords;[m
[32m+[m[32m    isLeft(): boolean;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js[m
[1mnew file mode 100644[m
[1mindex 0000000..4b0dfb8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js[m
[36m@@ -0,0 +1,316 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../PDF417Common");[m
[32m+[m[32mvar BarcodeMetadata_1 = require("./BarcodeMetadata");[m
[32m+[m[32mvar DetectionResultColumn_1 = require("./DetectionResultColumn");[m
[32m+[m[32mvar BarcodeValue_1 = require("./BarcodeValue");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar DetectionResultRowIndicatorColumn = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(DetectionResultRowIndicatorColumn, _super);[m
[32m+[m[32m    function DetectionResultRowIndicatorColumn(boundingBox, isLeft) {[m
[32m+[m[32m        var _this = _super.call(this, boundingBox) || this;[m
[32m+[m[32m        _this._isLeft = isLeft;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.setRowNumbers = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var codeword = _c.value /*Codeword*/;[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    codeword.setRowNumberAsRowIndicatorColumn();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // TODO implement properly[m
[32m+[m[32m    // TODO maybe we should add missing codewords to store the correct row number to make[m
[32m+[m[32m    // finding row numbers for other columns easier[m
[32m+[m[32m    // use row height count to make detection of invalid row numbers more reliable[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.adjustCompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {[m
[32m+[m[32m        var codewords = this.getCodewords();[m
[32m+[m[32m        this.setRowNumbers();[m
[32m+[m[32m        this.removeIncorrectCodewords(codewords, barcodeMetadata);[m
[32m+[m[32m        var boundingBox = this.getBoundingBox();[m
[32m+[m[32m        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();[m
[32m+[m[32m        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();[m
[32m+[m[32m        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));[m
[32m+[m[32m        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));[m
[32m+[m[32m        // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and[m
[32m+[m[32m        // taller rows[m
[32m+[m[32m        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();[m
[32m+[m[32m        var barcodeRow = -1;[m
[32m+[m[32m        var maxRowHeight = 1;[m
[32m+[m[32m        var currentRowHeight = 0;[m
[32m+[m[32m        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {[m
[32m+[m[32m            if (codewords[codewordsRow] == null) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var codeword = codewords[codewordsRow];[m
[32m+[m[32m            //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;[m
[32m+[m[32m            //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {[m
[32m+[m[32m            //        SimpleLog.log(LEVEL.WARNING,[m
[32m+[m[32m            //            "Removing codeword, rowNumberSkew too high, codeword[" + codewordsRow + "]: Expected Row: " +[m
[32m+[m[32m            //                expectedRowNumber + ", RealRow: " + codeword.getRowNumber() + ", value: " + codeword.getValue());[m
[32m+[m[32m            //        codewords[codewordsRow] = null;[m
[32m+[m[32m            //      }[m
[32m+[m[32m            var rowDifference = codeword.getRowNumber() - barcodeRow;[m
[32m+[m[32m            // TODO improve handling with case where first row indicator doesn't start with 0[m
[32m+[m[32m            if (rowDifference === 0) {[m
[32m+[m[32m                currentRowHeight++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (rowDifference === 1) {[m
[32m+[m[32m                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);[m
[32m+[m[32m                currentRowHeight = 1;[m
[32m+[m[32m                barcodeRow = codeword.getRowNumber();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (rowDifference < 0 ||[m
[32m+[m[32m                codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||[m
[32m+[m[32m                rowDifference > codewordsRow) {[m
[32m+[m[32m                codewords[codewordsRow] = null;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                var checkedRows = void 0;[m
[32m+[m[32m                if (maxRowHeight > 2) {[m
[32m+[m[32m                    checkedRows = (maxRowHeight - 2) * rowDifference;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    checkedRows = rowDifference;[m
[32m+[m[32m                }[m
[32m+[m[32m                var closePreviousCodewordFound = checkedRows >= codewordsRow;[m
[32m+[m[32m                for (var i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {[m
[32m+[m[32m                    // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.[m
[32m+[m[32m                    // This should hopefully get rid of most problems already.[m
[32m+[m[32m                    closePreviousCodewordFound = codewords[codewordsRow - i] != null;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (closePreviousCodewordFound) {[m
[32m+[m[32m                    codewords[codewordsRow] = null;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    barcodeRow = codeword.getRowNumber();[m
[32m+[m[32m                    currentRowHeight = 1;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // return (int) (averageRowHeight + 0.5);[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.getRowHeights = function () {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        var barcodeMetadata = this.getBarcodeMetadata();[m
[32m+[m[32m        if (barcodeMetadata == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);[m
[32m+[m[32m        var result = new Int32Array(barcodeMetadata.getRowCount());[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var codeword = _c.value /*Codeword*/;[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    var rowNumber = codeword.getRowNumber();[m
[32m+[m[32m                    if (rowNumber >= result.length) {[m
[32m+[m[32m                        // We have more rows than the barcode metadata allows for, ignore them.[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    result[rowNumber]++;[m
[32m+[m[32m                } // else throw exception?[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    // TODO maybe we should add missing codewords to store the correct row number to make[m
[32m+[m[32m    // finding row numbers for other columns easier[m
[32m+[m[32m    // use row height count to make detection of invalid row numbers more reliable[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.adjustIncompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {[m
[32m+[m[32m        var boundingBox = this.getBoundingBox();[m
[32m+[m[32m        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();[m
[32m+[m[32m        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();[m
[32m+[m[32m        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));[m
[32m+[m[32m        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));[m
[32m+[m[32m        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();[m
[32m+[m[32m        var codewords = this.getCodewords();[m
[32m+[m[32m        var barcodeRow = -1;[m
[32m+[m[32m        var maxRowHeight = 1;[m
[32m+[m[32m        var currentRowHeight = 0;[m
[32m+[m[32m        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {[m
[32m+[m[32m            if (codewords[codewordsRow] == null) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var codeword = codewords[codewordsRow];[m
[32m+[m[32m            codeword.setRowNumberAsRowIndicatorColumn();[m
[32m+[m[32m            var rowDifference = codeword.getRowNumber() - barcodeRow;[m
[32m+[m[32m            // TODO improve handling with case where first row indicator doesn't start with 0[m
[32m+[m[32m            if (rowDifference === 0) {[m
[32m+[m[32m                currentRowHeight++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (rowDifference === 1) {[m
[32m+[m[32m                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);[m
[32m+[m[32m                currentRowHeight = 1;[m
[32m+[m[32m                barcodeRow = codeword.getRowNumber();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {[m
[32m+[m[32m                codewords[codewordsRow] = null;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                barcodeRow = codeword.getRowNumber();[m
[32m+[m[32m                currentRowHeight = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // return (int) (averageRowHeight + 0.5);[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.getBarcodeMetadata = function () {[m
[32m+[m[32m        var e_3, _a;[m
[32m+[m[32m        var codewords = this.getCodewords();[m
[32m+[m[32m        var barcodeColumnCount = new BarcodeValue_1.default();[m
[32m+[m[32m        var barcodeRowCountUpperPart = new BarcodeValue_1.default();[m
[32m+[m[32m        var barcodeRowCountLowerPart = new BarcodeValue_1.default();[m
[32m+[m[32m        var barcodeECLevel = new BarcodeValue_1.default();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var codewords_1 = __values(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {[m
[32m+[m[32m                var codeword = codewords_1_1.value /*Codeword*/;[m
[32m+[m[32m                if (codeword == null) {[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                codeword.setRowNumberAsRowIndicatorColumn();[m
[32m+[m[32m                var rowIndicatorValue = codeword.getValue() % 30;[m
[32m+[m[32m                var codewordRowNumber = codeword.getRowNumber();[m
[32m+[m[32m                if (!this._isLeft) {[m
[32m+[m[32m                    codewordRowNumber += 2;[m
[32m+[m[32m                }[m
[32m+[m[32m                switch (codewordRowNumber % 3) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        barcodeECLevel.setValue(rowIndicatorValue / 3);[m
[32m+[m[32m                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 2:[m
[32m+[m[32m                        barcodeColumnCount.setValue(rowIndicatorValue + 1);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (codewords_1_1 && !codewords_1_1.done && (_a = codewords_1.return)) _a.call(codewords_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Maybe we should check if we have ambiguous values?[m
[32m+[m[32m        if ((barcodeColumnCount.getValue().length === 0) ||[m
[32m+[m[32m            (barcodeRowCountUpperPart.getValue().length === 0) ||[m
[32m+[m[32m            (barcodeRowCountLowerPart.getValue().length === 0) ||[m
[32m+[m[32m            (barcodeECLevel.getValue().length === 0) ||[m
[32m+[m[32m            barcodeColumnCount.getValue()[0] < 1 ||[m
[32m+[m[32m            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_1.default.MIN_ROWS_IN_BARCODE ||[m
[32m+[m[32m            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_1.default.MAX_ROWS_IN_BARCODE) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var barcodeMetadata = new BarcodeMetadata_1.default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);[m
[32m+[m[32m        this.removeIncorrectCodewords(codewords, barcodeMetadata);[m
[32m+[m[32m        return barcodeMetadata;[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.removeIncorrectCodewords = function (codewords, barcodeMetadata) {[m
[32m+[m[32m        // Remove codewords which do not match the metadata[m
[32m+[m[32m        // TODO Maybe we should keep the incorrect codewords for the start and end positions?[m
[32m+[m[32m        for (var codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {[m
[32m+[m[32m            var codeword = codewords[codewordRow];[m
[32m+[m[32m            if (codewords[codewordRow] == null) {[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var rowIndicatorValue = codeword.getValue() % 30;[m
[32m+[m[32m            var codewordRowNumber = codeword.getRowNumber();[m
[32m+[m[32m            if (codewordRowNumber > barcodeMetadata.getRowCount()) {[m
[32m+[m[32m                codewords[codewordRow] = null;[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!this._isLeft) {[m
[32m+[m[32m                codewordRowNumber += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            switch (codewordRowNumber % 3) {[m
[32m+[m[32m                case 0:[m
[32m+[m[32m                    if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {[m
[32m+[m[32m                        codewords[codewordRow] = null;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 1:[m
[32m+[m[32m                    if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||[m
[32m+[m[32m                        rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {[m
[32m+[m[32m                        codewords[codewordRow] = null;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m                case 2:[m
[32m+[m[32m                    if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {[m
[32m+[m[32m                        codewords[codewordRow] = null;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.isLeft = function () {[m
[32m+[m[32m        return this._isLeft;[m
[32m+[m[32m    };[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    DetectionResultRowIndicatorColumn.prototype.toString = function () {[m
[32m+[m[32m        return 'IsLeft: ' + this._isLeft + '\n' + _super.prototype.toString.call(this);[m
[32m+[m[32m    };[m
[32m+[m[32m    return DetectionResultRowIndicatorColumn;[m
[32m+[m[32m}(DetectionResultColumn_1.default));[m
[32m+[m[32mexports.default = DetectionResultRowIndicatorColumn;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..91b3250[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.d.ts[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m * @author creatale GmbH (christoph.schulz@creatale.de)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417CodewordDecoder {[m
[32m+[m[32m    private static bSymbolTableReady;[m
[32m+[m[32m    private static RATIOS_TABLE;[m
[32m+[m[32m    static initialize(): void;[m
[32m+[m[32m    static getDecodedValue(moduleBitCount: Int32Array): int;[m
[32m+[m[32m    private static sampleBitCounts;[m
[32m+[m[32m    private static getDecodedCodewordValue;[m
[32m+[m[32m    private static getBitValue;[m
[32m+[m[32m    private static getClosestDecodedValue;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e994603[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417CodewordDecoder.js[m
[36m@@ -0,0 +1,128 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.common.detector.MathUtils;[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../PDF417Common");[m
[32m+[m[32mvar Float_1 = require("../../util/Float");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m * @author creatale GmbH (christoph.schulz@creatale.de)[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417CodewordDecoder = /** @class */ (function () {[m
[32m+[m[32m    function PDF417CodewordDecoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /* @note[m
[32m+[m[32m     * this action have to be performed before first use of class[m
[32m+[m[32m     * - static constructor[m
[32m+[m[32m     * working with 32bit float (based from Java logic)[m
[32m+[m[32m    */[m
[32m+[m[32m    PDF417CodewordDecoder.initialize = function () {[m
[32m+[m[32m        // Pre-computes the symbol ratio table.[m
[32m+[m[32m        for ( /*int*/var i = 0; i < PDF417Common_1.default.SYMBOL_TABLE.length; i++) {[m
[32m+[m[32m            var currentSymbol = PDF417Common_1.default.SYMBOL_TABLE[i];[m
[32m+[m[32m            var currentBit = currentSymbol & 0x1;[m
[32m+[m[32m            for ( /*int*/var j = 0; j < PDF417Common_1.default.BARS_IN_MODULE; j++) {[m
[32m+[m[32m                var size = 0.0;[m
[32m+[m[32m                while ((currentSymbol & 0x1) === currentBit) {[m
[32m+[m[32m                    size += 1.0;[m
[32m+[m[32m                    currentSymbol >>= 1;[m
[32m+[m[32m                }[m
[32m+[m[32m                currentBit = currentSymbol & 0x1;[m
[32m+[m[32m                if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {[m
[32m+[m[32m                    PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common_1.default.BARS_IN_MODULE);[m
[32m+[m[32m                }[m
[32m+[m[32m                PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common_1.default.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common_1.default.MODULES_IN_CODEWORD);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bSymbolTableReady = true;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417CodewordDecoder.getDecodedValue = function (moduleBitCount) {[m
[32m+[m[32m        var decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));[m
[32m+[m[32m        if (decodedValue !== -1) {[m
[32m+[m[32m            return decodedValue;[m
[32m+[m[32m        }[m
[32m+[m[32m        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417CodewordDecoder.sampleBitCounts = function (moduleBitCount) {[m
[32m+[m[32m        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);[m
[32m+[m[32m        var result = new Int32Array(PDF417Common_1.default.BARS_IN_MODULE);[m
[32m+[m[32m        var bitCountIndex = 0;[m
[32m+[m[32m        var sumPreviousBits = 0;[m
[32m+[m[32m        for ( /*int*/var i = 0; i < PDF417Common_1.default.MODULES_IN_CODEWORD; i++) {[m
[32m+[m[32m            var sampleIndex = bitCountSum / (2 * PDF417Common_1.default.MODULES_IN_CODEWORD) +[m
[32m+[m[32m                (i * bitCountSum) / PDF417Common_1.default.MODULES_IN_CODEWORD;[m
[32m+[m[32m            if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {[m
[32m+[m[32m                sumPreviousBits += moduleBitCount[bitCountIndex];[m
[32m+[m[32m                bitCountIndex++;[m
[32m+[m[32m            }[m
[32m+[m[32m            result[bitCountIndex]++;[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417CodewordDecoder.getDecodedCodewordValue = function (moduleBitCount) {[m
[32m+[m[32m        var decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);[m
[32m+[m[32m        return PDF417Common_1.default.getCodeword(decodedValue) === -1 ? -1 : decodedValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417CodewordDecoder.getBitValue = function (moduleBitCount) {[m
[32m+[m[32m        var result = /*long*/ 0;[m
[32m+[m[32m        for (var /*int*/ i = 0; i < moduleBitCount.length; i++) {[m
[32m+[m[32m            for ( /*int*/var bit = 0; bit < moduleBitCount[i]; bit++) {[m
[32m+[m[32m                result = (result << 1) | (i % 2 === 0 ? 1 : 0);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return Math.trunc(result);[m
[32m+[m[32m    };[m
[32m+[m[32m    // working with 32bit float (as in Java)[m
[32m+[m[32m    PDF417CodewordDecoder.getClosestDecodedValue = function (moduleBitCount) {[m
[32m+[m[32m        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);[m
[32m+[m[32m        var bitCountRatios = new Array(PDF417Common_1.default.BARS_IN_MODULE);[m
[32m+[m[32m        if (bitCountSum > 1) {[m
[32m+[m[32m            for (var /*int*/ i = 0; i < bitCountRatios.length; i++) {[m
[32m+[m[32m                bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var bestMatchError = Float_1.default.MAX_VALUE;[m
[32m+[m[32m        var bestMatch = -1;[m
[32m+[m[32m        if (!this.bSymbolTableReady) {[m
[32m+[m[32m            PDF417CodewordDecoder.initialize();[m
[32m+[m[32m        }[m
[32m+[m[32m        for ( /*int*/var j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {[m
[32m+[m[32m            var error = 0.0;[m
[32m+[m[32m            var ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];[m
[32m+[m[32m            for ( /*int*/var k = 0; k < PDF417Common_1.default.BARS_IN_MODULE; k++) {[m
[32m+[m[32m                var diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);[m
[32m+[m[32m                error += Math.fround(diff * diff);[m
[32m+[m[32m                if (error >= bestMatchError) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (error < bestMatchError) {[m
[32m+[m[32m                bestMatchError = error;[m
[32m+[m[32m                bestMatch = PDF417Common_1.default.SYMBOL_TABLE[j];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bestMatch;[m
[32m+[m[32m    };[m
[32m+[m[32m    // flag that the table is ready for use[m
[32m+[m[32m    PDF417CodewordDecoder.bSymbolTableReady = false;[m
[32m+[m[32m    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common_1.default.SYMBOL_TABLE.length).map(function (x) { return x = new Array(PDF417Common_1.default.BARS_IN_MODULE); });[m
[32m+[m[32m    return PDF417CodewordDecoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417CodewordDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..8ee833d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.d.ts[m
[36m@@ -0,0 +1,131 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32mimport ErrorCorrection from './ec/ErrorCorrection';[m
[32m+[m[32mimport BarcodeValue from './BarcodeValue';[m
[32m+[m[32mimport { int } from '../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417ScanningDecoder {[m
[32m+[m[32m    static CODEWORD_SKEW_SIZE: int;[m
[32m+[m[32m    static MAX_ERRORS: int;[m
[32m+[m[32m    static MAX_EC_CODEWORDS: int;[m
[32m+[m[32m    static errorCorrection: ErrorCorrection;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern[m
[32m+[m[32m     *[m
[32m+[m[32m     * columns. That way width can be deducted from the pattern column.[m
[32m+[m[32m     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider[m
[32m+[m[32m     * than it should be. This can happen if the scanner used a bad blackpoint.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param BitMatrix[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageTopLeft[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageBottomLeft[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageTopRight[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageBottomRight[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param minCodewordWidth[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param maxCodewordWidth[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    static decode(image: BitMatrix, imageTopLeft: ResultPoint, imageBottomLeft: ResultPoint, imageTopRight: ResultPoint, imageBottomRight: ResultPoint, minCodewordWidth: int, maxCodewordWidth: int): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param leftRowIndicatorColumn[m
[32m+[m[32m     * @param rightRowIndicatorColumn[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static merge;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rowIndicatorColumn[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static adjustBoundingBox;[m
[32m+[m[32m    private static getMax;[m
[32m+[m[32m    private static getBarcodeMetadata;[m
[32m+[m[32m    private static getRowIndicatorColumn;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param detectionResult[m
[32m+[m[32m     * @param BarcodeValue[m
[32m+[m[32m     * @param param2[m
[32m+[m[32m     * @param param3[m
[32m+[m[32m     * @param barcodeMatrix[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static adjustCodewordCount;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param detectionResult[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static createDecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The[m
[32m+[m[32m     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value[m
[32m+[m[32m     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of[m
[32m+[m[32m     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the[m
[32m+[m[32m     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,[m
[32m+[m[32m     * so decoding the normal barcodes is not affected by this.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param erasureArray contains the indexes of erasures[m
[32m+[m[32m     * @param ambiguousIndexes array with the indexes that have more than one most likely value[m
[32m+[m[32m     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must[m
[32m+[m[32m     * be the same length as the ambiguousIndexes array[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static createDecoderResultFromAmbiguousValues;[m
[32m+[m[32m    private static createBarcodeMatrix;[m
[32m+[m[32m    private static isValidBarcodeColumn;[m
[32m+[m[32m    private static getStartColumn;[m
[32m+[m[32m    private static detectCodeword;[m
[32m+[m[32m    private static getModuleBitCount;[m
[32m+[m[32m    private static getNumberOfECCodeWords;[m
[32m+[m[32m    private static adjustCodewordStartColumn;[m
[32m+[m[32m    private static checkCodewordSkew;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws FormatException,[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeCodewords;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords   data and error correction codewords[m
[32m+[m[32m     * @param erasures positions of any known erasures[m
[32m+[m[32m     * @param numECCodewords number of error correction codewords that are available in codewords[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    private static correctErrors;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Verify that all is OK with the codeword array.[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    private static verifyCodewordCount;[m
[32m+[m[32m    private static getBitCountForCodeword;[m
[32m+[m[32m    private static getCodewordBucketNumber;[m
[32m+[m[32m    private static getCodewordBucketNumber_number;[m
[32m+[m[32m    private static getCodewordBucketNumber_Int32Array;[m
[32m+[m[32m    static toString(barcodeMatrix: BarcodeValue[][]): String;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..905319c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js[m
[36m@@ -0,0 +1,705 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2013 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder;[m
[32m+[m[32m// import com.google.zxing.ChecksumException;[m
[32m+[m[32mvar ChecksumException_1 = require("../../ChecksumException");[m
[32m+[m[32m// import com.google.zxing.FormatException;[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32m// import com.google.zxing.NotFoundException;[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m// import com.google.zxing.common.detector.MathUtils;[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../PDF417Common");[m
[32m+[m[32m// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;[m
[32m+[m[32mvar ErrorCorrection_1 = require("./ec/ErrorCorrection");[m
[32m+[m[32m// local[m
[32m+[m[32mvar BoundingBox_1 = require("./BoundingBox");[m
[32m+[m[32mvar DetectionResultRowIndicatorColumn_1 = require("./DetectionResultRowIndicatorColumn");[m
[32m+[m[32mvar DetectionResult_1 = require("./DetectionResult");[m
[32m+[m[32mvar DetectionResultColumn_1 = require("./DetectionResultColumn");[m
[32m+[m[32mvar Codeword_1 = require("./Codeword");[m
[32m+[m[32mvar BarcodeValue_1 = require("./BarcodeValue");[m
[32m+[m[32mvar PDF417CodewordDecoder_1 = require("./PDF417CodewordDecoder");[m
[32m+[m[32mvar DecodedBitStreamParser_1 = require("./DecodedBitStreamParser");[m
[32m+[m[32m// utils[m
[32m+[m[32mvar Formatter_1 = require("../../util/Formatter");[m
[32m+[m[32m// import java.util.ArrayList;[m
[32m+[m[32m// import java.util.Collection;[m
[32m+[m[32m// import java.util.Formatter;[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417ScanningDecoder = /** @class */ (function () {[m
[32m+[m[32m    function PDF417ScanningDecoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern[m
[32m+[m[32m     *[m
[32m+[m[32m     * columns. That way width can be deducted from the pattern column.[m
[32m+[m[32m     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider[m
[32m+[m[32m     * than it should be. This can happen if the scanner used a bad blackpoint.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param BitMatrix[m
[32m+[m[32m     * @param image[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageTopLeft[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageBottomLeft[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageTopRight[m
[32m+[m[32m     * @param ResultPoint[m
[32m+[m[32m     * @param imageBottomRight[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param minCodewordWidth[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param maxCodewordWidth[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {[m
[32m+[m[32m        var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);[m
[32m+[m[32m        var leftRowIndicatorColumn = null;[m
[32m+[m[32m        var rightRowIndicatorColumn = null;[m
[32m+[m[32m        var detectionResult;[m
[32m+[m[32m        for (var firstPass /*boolean*/ = true;; firstPass = false) {[m
[32m+[m[32m            if (imageTopLeft != null) {[m
[32m+[m[32m                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (imageTopRight != null) {[m
[32m+[m[32m                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);[m
[32m+[m[32m            }[m
[32m+[m[32m            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);[m
[32m+[m[32m            if (detectionResult == null) {[m
[32m+[m[32m                throw NotFoundException_1.default.getNotFoundInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            var resultBox = detectionResult.getBoundingBox();[m
[32m+[m[32m            if (firstPass && resultBox != null &&[m
[32m+[m[32m                (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {[m
[32m+[m[32m                boundingBox = resultBox;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        detectionResult.setBoundingBox(boundingBox);[m
[32m+[m[32m        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;[m
[32m+[m[32m        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);[m
[32m+[m[32m        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);[m
[32m+[m[32m        var leftToRight = leftRowIndicatorColumn != null;[m
[32m+[m[32m        for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {[m
[32m+[m[32m            var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;[m
[32m+[m[32m            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {[m
[32m+[m[32m                // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            var detectionResultColumn = void 0;[m
[32m+[m[32m            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {[m
[32m+[m[32m                detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);[m
[32m+[m[32m            }[m
[32m+[m[32m            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);[m
[32m+[m[32m            var startColumn = -1;[m
[32m+[m[32m            var previousStartColumn = startColumn;[m
[32m+[m[32m            // TODO start at a row for which we know the start position, then detect upwards and downwards from there.[m
[32m+[m[32m            for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {[m
[32m+[m[32m                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);[m
[32m+[m[32m                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {[m
[32m+[m[32m                    if (previousStartColumn === -1) {[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    startColumn = previousStartColumn;[m
[32m+[m[32m                }[m
[32m+[m[32m                var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    detectionResultColumn.setCodeword(imageRow, codeword);[m
[32m+[m[32m                    previousStartColumn = startColumn;[m
[32m+[m[32m                    minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());[m
[32m+[m[32m                    maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return PDF417ScanningDecoder.createDecoderResult(detectionResult);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param leftRowIndicatorColumn[m
[32m+[m[32m     * @param rightRowIndicatorColumn[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {[m
[32m+[m[32m        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);[m
[32m+[m[32m        if (barcodeMetadata == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));[m
[32m+[m[32m        return new DetectionResult_1.default(barcodeMetadata, boundingBox);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rowIndicatorColumn[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (rowIndicatorColumn == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var rowHeights = rowIndicatorColumn.getRowHeights();[m
[32m+[m[32m        if (rowHeights == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);[m
[32m+[m[32m        var missingStartRows = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {[m
[32m+[m[32m                var rowHeight = rowHeights_1_1.value /*int*/;[m
[32m+[m[32m                missingStartRows += maxRowHeight - rowHeight;[m
[32m+[m[32m                if (rowHeight > 0) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var codewords = rowIndicatorColumn.getCodewords();[m
[32m+[m[32m        for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {[m
[32m+[m[32m            missingStartRows--;[m
[32m+[m[32m        }[m
[32m+[m[32m        var missingEndRows = 0;[m
[32m+[m[32m        for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {[m
[32m+[m[32m            missingEndRows += maxRowHeight - rowHeights[row];[m
[32m+[m[32m            if (rowHeights[row] > 0) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {[m
[32m+[m[32m            missingEndRows--;[m
[32m+[m[32m        }[m
[32m+[m[32m        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getMax = function (values) {[m
[32m+[m[32m        var e_2, _a;[m
[32m+[m[32m        var maxValue = -1;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {[m
[32m+[m[32m                var value = values_1_1.value /*int*/;[m
[32m+[m[32m                maxValue = Math.max(maxValue, value);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return maxValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {[m
[32m+[m[32m        var leftBarcodeMetadata;[m
[32m+[m[32m        if (leftRowIndicatorColumn == null ||[m
[32m+[m[32m            (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {[m
[32m+[m[32m            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();[m
[32m+[m[32m        }[m
[32m+[m[32m        var rightBarcodeMetadata;[m
[32m+[m[32m        if (rightRowIndicatorColumn == null ||[m
[32m+[m[32m            (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {[m
[32m+[m[32m            return leftBarcodeMetadata;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&[m
[32m+[m[32m            leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&[m
[32m+[m[32m            leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        return leftBarcodeMetadata;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {[m
[32m+[m[32m        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < 2; i++) {[m
[32m+[m[32m            var increment = i === 0 ? 1 : -1;[m
[32m+[m[32m            var startColumn = Math.trunc(Math.trunc(startPoint.getX()));[m
[32m+[m[32m            for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&[m
[32m+[m[32m                imageRow >= boundingBox.getMinY(); imageRow += increment) {[m
[32m+[m[32m                var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);[m
[32m+[m[32m                if (codeword != null) {[m
[32m+[m[32m                    rowIndicatorColumn.setCodeword(imageRow, codeword);[m
[32m+[m[32m                    if (leftToRight) {[m
[32m+[m[32m                        startColumn = codeword.getStartX();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        startColumn = codeword.getEndX();[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return rowIndicatorColumn;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param detectionResult[m
[32m+[m[32m     * @param BarcodeValue[m
[32m+[m[32m     * @param param2[m
[32m+[m[32m     * @param param3[m
[32m+[m[32m     * @param barcodeMatrix[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {[m
[32m+[m[32m        var barcodeMatrix01 = barcodeMatrix[0][1];[m
[32m+[m[32m        var numberOfCodewords = barcodeMatrix01.getValue();[m
[32m+[m[32m        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *[m
[32m+[m[32m            detectionResult.getBarcodeRowCount() -[m
[32m+[m[32m            PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());[m
[32m+[m[32m        if (numberOfCodewords.length === 0) {[m
[32m+[m[32m            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {[m
[32m+[m[32m                throw NotFoundException_1.default.getNotFoundInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            barcodeMatrix01.setValue(calculatedNumberOfCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {[m
[32m+[m[32m            // The calculated one is more reliable as it is derived from the row indicator columns[m
[32m+[m[32m            barcodeMatrix01.setValue(calculatedNumberOfCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param detectionResult[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     * @throws NotFoundException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {[m
[32m+[m[32m        var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);[m
[32m+[m[32m        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);[m
[32m+[m[32m        var erasures /*Collection<Integer>*/ = new Array();[m
[32m+[m[32m        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());[m
[32m+[m[32m        var ambiguousIndexValuesList = /*List<int[]>*/ [];[m
[32m+[m[32m        var ambiguousIndexesList = /*Collection<Integer>*/ new Array();[m
[32m+[m[32m        for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {[m
[32m+[m[32m            for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {[m
[32m+[m[32m                var values = barcodeMatrix[row][column + 1].getValue();[m
[32m+[m[32m                var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;[m
[32m+[m[32m                if (values.length === 0) {[m
[32m+[m[32m                    erasures.push(codewordIndex);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (values.length === 1) {[m
[32m+[m[32m                    codewords[codewordIndex] = values[0];[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    ambiguousIndexesList.push(codewordIndex);[m
[32m+[m[32m                    ambiguousIndexValuesList.push(values);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {[m
[32m+[m[32m            ambiguousIndexValues[i] = ambiguousIndexValuesList[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The[m
[32m+[m[32m     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value[m
[32m+[m[32m     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of[m
[32m+[m[32m     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the[m
[32m+[m[32m     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,[m
[32m+[m[32m     * so decoding the normal barcodes is not affected by this.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param erasureArray contains the indexes of erasures[m
[32m+[m[32m     * @param ambiguousIndexes array with the indexes that have more than one most likely value[m
[32m+[m[32m     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must[m
[32m+[m[32m     * be the same length as the ambiguousIndexes array[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {[m
[32m+[m[32m        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);[m
[32m+[m[32m        var tries = 100;[m
[32m+[m[32m        while (tries-- > 0) {[m
[32m+[m[32m            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {[m
[32m+[m[32m                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];[m
[32m+[m[32m            }[m
[32m+[m[32m            try {[m
[32m+[m[32m                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (err) {[m
[32m+[m[32m                var ignored = err instanceof ChecksumException_1.default;[m
[32m+[m[32m                if (!ignored) {[m
[32m+[m[32m                    throw err;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (ambiguousIndexCount.length === 0) {[m
[32m+[m[32m                throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {[m
[32m+[m[32m                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {[m
[32m+[m[32m                    ambiguousIndexCount[i]++;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    ambiguousIndexCount[i] = 0;[m
[32m+[m[32m                    if (i === ambiguousIndexCount.length - 1) {[m
[32m+[m[32m                        throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {[m
[32m+[m[32m        var e_3, _a, e_4, _b;[m
[32m+[m[32m        // let barcodeMatrix: BarcodeValue[][] =[m
[32m+[m[32m        // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];[m
[32m+[m[32m        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });[m
[32m+[m[32m        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {[m
[32m+[m[32m            for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {[m
[32m+[m[32m                barcodeMatrix[row][column_1] = new BarcodeValue_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var column = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {[m
[32m+[m[32m                var detectionResultColumn = _d.value /*DetectionResultColumn*/;[m
[32m+[m[32m                if (detectionResultColumn != null) {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        for (var _e = (e_4 = void 0, __values(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {[m
[32m+[m[32m                            var codeword = _f.value /*Codeword*/;[m
[32m+[m[32m                            if (codeword != null) {[m
[32m+[m[32m                                var rowNumber = codeword.getRowNumber();[m
[32m+[m[32m                                if (rowNumber >= 0) {[m
[32m+[m[32m                                    if (rowNumber >= barcodeMatrix.length) {[m
[32m+[m[32m                                        // We have more rows than the barcode metadata allows for, ignore them.[m
[32m+[m[32m                                        continue;[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m                    finally {[m
[32m+[m[32m                        try {[m
[32m+[m[32m                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                column++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return barcodeMatrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {[m
[32m+[m[32m        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {[m
[32m+[m[32m        var e_5, _a;[m
[32m+[m[32m        var offset = leftToRight ? 1 : -1;[m
[32m+[m[32m        var codeword = null;[m
[32m+[m[32m        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {[m
[32m+[m[32m            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (codeword != null) {[m
[32m+[m[32m            return leftToRight ? codeword.getEndX() : codeword.getStartX();[m
[32m+[m[32m        }[m
[32m+[m[32m        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);[m
[32m+[m[32m        if (codeword != null) {[m
[32m+[m[32m            return leftToRight ? codeword.getStartX() : codeword.getEndX();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {[m
[32m+[m[32m            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (codeword != null) {[m
[32m+[m[32m            return leftToRight ? codeword.getEndX() : codeword.getStartX();[m
[32m+[m[32m        }[m
[32m+[m[32m        var skippedColumns = 0;[m
[32m+[m[32m        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {[m
[32m+[m[32m            barcodeColumn -= offset;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var _b = (e_5 = void 0, __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                    var previousRowCodeword = _c.value /*Codeword*/;[m
[32m+[m[32m                    if (previousRowCodeword != null) {[m
[32m+[m[32m                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +[m
[32m+[m[32m                            offset *[m
[32m+[m[32m                                skippedColumns *[m
[32m+[m[32m                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_5_1) { e_5 = { error: e_5_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_5) throw e_5.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            skippedColumns++;[m
[32m+[m[32m        }[m
[32m+[m[32m        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {[m
[32m+[m[32m        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);[m
[32m+[m[32m        // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length[m
[32m+[m[32m        // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.[m
[32m+[m[32m        // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate[m
[32m+[m[32m        // for the current position[m
[32m+[m[32m        var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);[m
[32m+[m[32m        if (moduleBitCount == null) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var endColumn;[m
[32m+[m[32m        var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);[m
[32m+[m[32m        if (leftToRight) {[m
[32m+[m[32m            endColumn = startColumn + codewordBitCount;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {[m
[32m+[m[32m                var tmpCount = moduleBitCount[i];[m
[32m+[m[32m                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];[m
[32m+[m[32m                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;[m
[32m+[m[32m            }[m
[32m+[m[32m            endColumn = startColumn;[m
[32m+[m[32m            startColumn = endColumn - codewordBitCount;[m
[32m+[m[32m        }[m
[32m+[m[32m        // TODO implement check for width and correction of black and white bars[m
[32m+[m[32m        // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.[m
[32m+[m[32m        // should probably done only for codewords with a lot more than 17 bits.[m
[32m+[m[32m        // The following fixes 10-1.png, which has wide black bars and small white bars[m
[32m+[m[32m        //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {[m
[32m+[m[32m        //      if (i % 2 === 0) {[m
[32m+[m[32m        //        moduleBitCount[i]--;[m
[32m+[m[32m        //      } else {[m
[32m+[m[32m        //        moduleBitCount[i]++;[m
[32m+[m[32m        //      }[m
[32m+[m[32m        //    }[m
[32m+[m[32m        // We could also use the width of surrounding codewords for more accurate results, but this seems[m
[32m+[m[32m        // sufficient for now[m
[32m+[m[32m        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {[m
[32m+[m[32m            // We could try to use the startX and endX position of the codeword in the same column in the previous row,[m
[32m+[m[32m            // create the bit count from it and normalize it to 8. This would help with single pixel errors.[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);[m
[32m+[m[32m        var codeword = PDF417Common_1.default.getCodeword(decodedValue);[m
[32m+[m[32m        if (codeword === -1) {[m
[32m+[m[32m            return null;[m
[32m+[m[32m        }[m
[32m+[m[32m        return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {[m
[32m+[m[32m        var imageColumn = startColumn;[m
[32m+[m[32m        var moduleBitCount = new Int32Array(8);[m
[32m+[m[32m        var moduleNumber = 0;[m
[32m+[m[32m        var increment = leftToRight ? 1 : -1;[m
[32m+[m[32m        var previousPixelValue = leftToRight;[m
[32m+[m[32m        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&[m
[32m+[m[32m            moduleNumber < moduleBitCount.length) {[m
[32m+[m[32m            if (image.get(imageColumn, imageRow) === previousPixelValue) {[m
[32m+[m[32m                moduleBitCount[moduleNumber]++;[m
[32m+[m[32m                imageColumn += increment;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                moduleNumber++;[m
[32m+[m[32m                previousPixelValue = !previousPixelValue;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (moduleNumber === moduleBitCount.length ||[m
[32m+[m[32m            ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&[m
[32m+[m[32m                moduleNumber === moduleBitCount.length - 1)) {[m
[32m+[m[32m            return moduleBitCount;[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {[m
[32m+[m[32m        return 2 << barcodeECLevel;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {[m
[32m+[m[32m        var correctedStartColumn = codewordStartColumn;[m
[32m+[m[32m        var increment = leftToRight ? -1 : 1;[m
[32m+[m[32m        // there should be no black pixels before the start column. If there are, then we need to start earlier.[m
[32m+[m[32m        for (var i /*int*/ = 0; i < 2; i++) {[m
[32m+[m[32m            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&[m
[32m+[m[32m                leftToRight === image.get(correctedStartColumn, imageRow)) {[m
[32m+[m[32m                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {[m
[32m+[m[32m                    return codewordStartColumn;[m
[32m+[m[32m                }[m
[32m+[m[32m                correctedStartColumn += increment;[m
[32m+[m[32m            }[m
[32m+[m[32m            increment = -increment;[m
[32m+[m[32m            leftToRight = !leftToRight;[m
[32m+[m[32m        }[m
[32m+[m[32m        return correctedStartColumn;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {[m
[32m+[m[32m        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&[m
[32m+[m[32m            codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws FormatException,[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {[m
[32m+[m[32m        if (codewords.length === 0) {[m
[32m+[m[32m            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        var numECCodewords = 1 << (ecLevel + 1);[m
[32m+[m[32m        var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);[m
[32m+[m[32m        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);[m
[32m+[m[32m        // Decode the codewords[m
[32m+[m[32m        var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);[m
[32m+[m[32m        decoderResult.setErrorsCorrected(correctedErrorsCount);[m
[32m+[m[32m        decoderResult.setErasures(erasures.length);[m
[32m+[m[32m        return decoderResult;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewords   data and error correction codewords[m
[32m+[m[32m     * @param erasures positions of any known erasures[m
[32m+[m[32m     * @param numECCodewords number of error correction codewords that are available in codewords[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {[m
[32m+[m[32m        if (erasures != null &&[m
[32m+[m[32m            erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||[m
[32m+[m[32m            numECCodewords < 0 ||[m
[32m+[m[32m            numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {[m
[32m+[m[32m            // Too many errors or EC Codewords is corrupted[m
[32m+[m[32m            throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Verify that all is OK with the codeword array.[m
[32m+[m[32m     * @throws FormatException[m
[32m+[m[32m     */[m
[32m+[m[32m    PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {[m
[32m+[m[32m        if (codewords.length < 4) {[m
[32m+[m[32m            // Codeword array size should be at least 4 allowing for[m
[32m+[m[32m            // Count CW, At least one Data CW, Error Correction CW, Error Correction CW[m
[32m+[m[32m            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data[m
[32m+[m[32m        // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad[m
[32m+[m[32m        // codewords, but excluding the number of error correction codewords.[m
[32m+[m[32m        var numberOfCodewords = codewords[0];[m
[32m+[m[32m        if (numberOfCodewords > codewords.length) {[m
[32m+[m[32m            throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (numberOfCodewords === 0) {[m
[32m+[m[32m            // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)[m
[32m+[m[32m            if (numECCodewords < codewords.length) {[m
[32m+[m[32m                codewords[0] = codewords.length - numECCodewords;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                throw FormatException_1.default.getFormatInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {[m
[32m+[m[32m        var result = new Int32Array(8);[m
[32m+[m[32m        var previousValue = 0;[m
[32m+[m[32m        var i = result.length - 1;[m
[32m+[m[32m        while (true) {[m
[32m+[m[32m            if ((codeword & 0x1) !== previousValue) {[m
[32m+[m[32m                previousValue = codeword & 0x1;[m
[32m+[m[32m                i--;[m
[32m+[m[32m                if (i < 0) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            result[i]++;[m
[32m+[m[32m            codeword >>= 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {[m
[32m+[m[32m        if (codeword instanceof Int32Array) {[m
[32m+[m[32m            return this.getCodewordBucketNumber_Int32Array(codeword);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.getCodewordBucketNumber_number(codeword);[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {[m
[32m+[m[32m        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {[m
[32m+[m[32m        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417ScanningDecoder.toString = function (barcodeMatrix) {[m
[32m+[m[32m        var formatter = new Formatter_1.default();[m
[32m+[m[32m        // try (let formatter = new Formatter()) {[m
[32m+[m[32m        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {[m
[32m+[m[32m            formatter.format('Row %2d: ', row);[m
[32m+[m[32m            for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {[m
[32m+[m[32m                var barcodeValue = barcodeMatrix[row][column];[m
[32m+[m[32m                if (barcodeValue.getValue().length === 0) {[m
[32m+[m[32m                    formatter.format('        ', null);[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            formatter.format('%n');[m
[32m+[m[32m        }[m
[32m+[m[32m        return formatter.toString();[m
[32m+[m[32m        // }[m
[32m+[m[32m    };[m
[32m+[m[32m    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;[m
[32m+[m[32m    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;[m
[32m+[m[32m    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;[m
[32m+[m[32m    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();[m
[32m+[m[32m    return PDF417ScanningDecoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417ScanningDecoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e884981[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.d.ts[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32mimport { int } from '../../../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>PDF417 error correction implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This <a href="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>[m
[32m+[m[32m * is quite useful in understanding the algorithm.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ErrorCorrection {[m
[32m+[m[32m    private field;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param received received codewords[m
[32m+[m[32m     * @param numECCodewords number of those codewords used for EC[m
[32m+[m[32m     * @param erasures location of erasures[m
[32m+[m[32m     * @return number of errors[m
[32m+[m[32m     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(received: Int32Array, numECCodewords: int, erasures: Int32Array): int;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param ModulusPoly[m
[32m+[m[32m     * @param a[m
[32m+[m[32m     * @param ModulusPoly[m
[32m+[m[32m     * @param b[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param R[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    private runEuclideanAlgorithm;[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param errorLocator[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    private findErrorLocations;[m
[32m+[m[32m    private findErrorMagnitudes;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js[m
[1mnew file mode 100644[m
[1mindex 0000000..384c5da[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ErrorCorrection.js[m
[36m@@ -0,0 +1,200 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2012 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder.ec;[m
[32m+[m[32m// import com.google.zxing.ChecksumException;[m
[32m+[m[32mvar ChecksumException_1 = require("../../../ChecksumException");[m
[32m+[m[32mvar ModulusPoly_1 = require("./ModulusPoly");[m
[32m+[m[32mvar ModulusGF_1 = require("./ModulusGF");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>PDF417 error correction implementation.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This <a href="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>[m
[32m+[m[32m * is quite useful in understanding the algorithm.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder[m
[32m+[m[32m */[m
[32m+[m[32mvar ErrorCorrection = /** @class */ (function () {[m
[32m+[m[32m    function ErrorCorrection() {[m
[32m+[m[32m        this.field = ModulusGF_1.default.PDF417_GF;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param received received codewords[m
[32m+[m[32m     * @param numECCodewords number of those codewords used for EC[m
[32m+[m[32m     * @param erasures location of erasures[m
[32m+[m[32m     * @return number of errors[m
[32m+[m[32m     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors[m
[32m+[m[32m     */[m
[32m+[m[32m    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var poly = new ModulusPoly_1.default(this.field, received);[m
[32m+[m[32m        var S = new Int32Array(numECCodewords);[m
[32m+[m[32m        var error = false;[m
[32m+[m[32m        for (var i /*int*/ = numECCodewords; i > 0; i--) {[m
[32m+[m[32m            var evaluation = poly.evaluateAt(this.field.exp(i));[m
[32m+[m[32m            S[numECCodewords - i] = evaluation;[m
[32m+[m[32m            if (evaluation !== 0) {[m
[32m+[m[32m                error = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!error) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var knownErrors = this.field.getOne();[m
[32m+[m[32m        if (erasures != null) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {[m
[32m+[m[32m                    var erasure = erasures_1_1.value;[m
[32m+[m[32m                    var b = this.field.exp(received.length - 1 - erasure);[m
[32m+[m[32m                    // Add (1 - bx) term:[m
[32m+[m[32m                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));[m
[32m+[m[32m                    knownErrors = knownErrors.multiply(term);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var syndrome = new ModulusPoly_1.default(this.field, S);[m
[32m+[m[32m        // syndrome = syndrome.multiply(knownErrors);[m
[32m+[m[32m        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);[m
[32m+[m[32m        var sigma = sigmaOmega[0];[m
[32m+[m[32m        var omega = sigmaOmega[1];[m
[32m+[m[32m        // sigma = sigma.multiply(knownErrors);[m
[32m+[m[32m        var errorLocations = this.findErrorLocations(sigma);[m
[32m+[m[32m        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < errorLocations.length; i++) {[m
[32m+[m[32m            var position = received.length - 1 - this.field.log(errorLocations[i]);[m
[32m+[m[32m            if (position < 0) {[m
[32m+[m[32m                throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return errorLocations.length;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param ModulusPoly[m
[32m+[m[32m     * @param a[m
[32m+[m[32m     * @param ModulusPoly[m
[32m+[m[32m     * @param b[m
[32m+[m[32m     * @param int[m
[32m+[m[32m     * @param R[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {[m
[32m+[m[32m        // Assume a's degree is >= b's[m
[32m+[m[32m        if (a.getDegree() < b.getDegree()) {[m
[32m+[m[32m            var temp = a;[m
[32m+[m[32m            a = b;[m
[32m+[m[32m            b = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var rLast = a;[m
[32m+[m[32m        var r = b;[m
[32m+[m[32m        var tLast = this.field.getZero();[m
[32m+[m[32m        var t = this.field.getOne();[m
[32m+[m[32m        // Run Euclidean algorithm until r's degree is less than R/2[m
[32m+[m[32m        while (r.getDegree() >= Math.round(R / 2)) {[m
[32m+[m[32m            var rLastLast = rLast;[m
[32m+[m[32m            var tLastLast = tLast;[m
[32m+[m[32m            rLast = r;[m
[32m+[m[32m            tLast = t;[m
[32m+[m[32m            // Divide rLastLast by rLast, with quotient in q and remainder in r[m
[32m+[m[32m            if (rLast.isZero()) {[m
[32m+[m[32m                // Oops, Euclidean algorithm already terminated?[m
[32m+[m[32m                throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m            }[m
[32m+[m[32m            r = rLastLast;[m
[32m+[m[32m            var q = this.field.getZero();[m
[32m+[m[32m            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());[m
[32m+[m[32m            var dltInverse = this.field.inverse(denominatorLeadingTerm);[m
[32m+[m[32m            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {[m
[32m+[m[32m                var degreeDiff = r.getDegree() - rLast.getDegree();[m
[32m+[m[32m                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);[m
[32m+[m[32m                q = q.add(this.field.buildMonomial(degreeDiff, scale));[m
[32m+[m[32m                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));[m
[32m+[m[32m            }[m
[32m+[m[32m            t = q.multiply(tLast).subtract(tLastLast).negative();[m
[32m+[m[32m        }[m
[32m+[m[32m        var sigmaTildeAtZero = t.getCoefficient(0);[m
[32m+[m[32m        if (sigmaTildeAtZero === 0) {[m
[32m+[m[32m            throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        var inverse = this.field.inverse(sigmaTildeAtZero);[m
[32m+[m[32m        var sigma = t.multiply(inverse);[m
[32m+[m[32m        var omega = r.multiply(inverse);[m
[32m+[m[32m        return [sigma, omega];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param errorLocator[m
[32m+[m[32m     * @throws ChecksumException[m
[32m+[m[32m     */[m
[32m+[m[32m    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {[m
[32m+[m[32m        // This is a direct application of Chien's search[m
[32m+[m[32m        var numErrors = errorLocator.getDegree();[m
[32m+[m[32m        var result = new Int32Array(numErrors);[m
[32m+[m[32m        var e = 0;[m
[32m+[m[32m        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {[m
[32m+[m[32m            if (errorLocator.evaluateAt(i) === 0) {[m
[32m+[m[32m                result[e] = this.field.inverse(i);[m
[32m+[m[32m                e++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (e !== numErrors) {[m
[32m+[m[32m            throw ChecksumException_1.default.getChecksumInstance();[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {[m
[32m+[m[32m        var errorLocatorDegree = errorLocator.getDegree();[m
[32m+[m[32m        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);[m
[32m+[m[32m        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {[m
[32m+[m[32m            formalDerivativeCoefficients[errorLocatorDegree - i] =[m
[32m+[m[32m                this.field.multiply(i, errorLocator.getCoefficient(i));[m
[32m+[m[32m        }[m
[32m+[m[32m        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);[m
[32m+[m[32m        // This is directly applying Forney's Formula[m
[32m+[m[32m        var s = errorLocations.length;[m
[32m+[m[32m        var result = new Int32Array(s);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < s; i++) {[m
[32m+[m[32m            var xiInverse = this.field.inverse(errorLocations[i]);[m
[32m+[m[32m            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));[m
[32m+[m[32m            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));[m
[32m+[m[32m            result[i] = this.field.multiply(numerator, denominator);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ErrorCorrection;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ErrorCorrection;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d391d4c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.d.ts[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mexport default class ModulusBase {[m
[32m+[m[32m    protected logTable: Int32Array;[m
[32m+[m[32m    protected expTable: Int32Array;[m
[32m+[m[32m    protected modulus: number;[m
[32m+[m[32m    add(a: number, b: number): number;[m
[32m+[m[32m    subtract(a: number, b: number): number;[m
[32m+[m[32m    exp(a: number): number;[m
[32m+[m[32m    log(a: number): number;[m
[32m+[m[32m    inverse(a: number): number;[m
[32m+[m[32m    multiply(a: number, b: number): number;[m
[32m+[m[32m    getSize(): number;[m
[32m+[m[32m    equals(o: Object): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js[m
[1mnew file mode 100644[m
[1mindex 0000000..fb2c2fd[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusBase.js[m
[36m@@ -0,0 +1,43 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../../IllegalArgumentException");[m
[32m+[m[32mvar ArithmeticException_1 = require("../../../ArithmeticException");[m
[32m+[m[32mvar ModulusBase = /** @class */ (function () {[m
[32m+[m[32m    function ModulusBase() {[m
[32m+[m[32m    }[m
[32m+[m[32m    ModulusBase.prototype.add = function (a, b) {[m
[32m+[m[32m        return (a + b) % this.modulus;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.subtract = function (a, b) {[m
[32m+[m[32m        return (this.modulus + a - b) % this.modulus;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.exp = function (a) {[m
[32m+[m[32m        return this.expTable[a];[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.log = function (a) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.logTable[a];[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.inverse = function (a) {[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            throw new ArithmeticException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.expTable[this.modulus - this.logTable[a] - 1];[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.multiply = function (a, b) {[m
[32m+[m[32m        if (a === 0 || b === 0) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.getSize = function () {[m
[32m+[m[32m        return this.modulus;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusBase.prototype.equals = function (o) {[m
[32m+[m[32m        return o === this;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ModulusBase;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ModulusBase;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..14ef177[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.d.ts[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mimport ModulusPoly from './ModulusPoly';[m
[32m+[m[32mimport ModulusBase from './ModulusBase';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A field based on powers of a generator integer, modulo some modulus.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.GenericGF[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ModulusGF extends ModulusBase {[m
[32m+[m[32m    static PDF417_GF: ModulusGF;[m
[32m+[m[32m    private zero;[m
[32m+[m[32m    private one;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    getZero(): ModulusPoly;[m
[32m+[m[32m    getOne(): ModulusPoly;[m
[32m+[m[32m    buildMonomial(degree: number, coefficient: number): ModulusPoly;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2c65761[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusGF.js[m
[36m@@ -0,0 +1,84 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2012 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder.ec;[m
[32m+[m[32m// import com.google.zxing.pdf417.PDF417Common;[m
[32m+[m[32mvar PDF417Common_1 = require("../../PDF417Common");[m
[32m+[m[32mvar ModulusPoly_1 = require("./ModulusPoly");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../../IllegalArgumentException");[m
[32m+[m[32mvar ModulusBase_1 = require("./ModulusBase");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>A field based on powers of a generator integer, modulo some modulus.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.GenericGF[m
[32m+[m[32m */[m
[32m+[m[32mvar ModulusGF = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ModulusGF, _super);[m
[32m+[m[32m    // private /*final*/ modulus: /*int*/ number;[m
[32m+[m[32m    function ModulusGF(modulus, generator) {[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        _this.modulus = modulus;[m
[32m+[m[32m        _this.expTable = new Int32Array(modulus);[m
[32m+[m[32m        _this.logTable = new Int32Array(modulus);[m
[32m+[m[32m        var x = /*int*/ 1;[m
[32m+[m[32m        for (var i /*int*/ = 0; i < modulus; i++) {[m
[32m+[m[32m            _this.expTable[i] = x;[m
[32m+[m[32m            x = (x * generator) % modulus;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i /*int*/ = 0; i < modulus - 1; i++) {[m
[32m+[m[32m            _this.logTable[_this.expTable[i]] = i;[m
[32m+[m[32m        }[m
[32m+[m[32m        // logTable[0] == 0 but this should never be used[m
[32m+[m[32m        _this.zero = new ModulusPoly_1.default(_this, new Int32Array([0]));[m
[32m+[m[32m        _this.one = new ModulusPoly_1.default(_this, new Int32Array([1]));[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    ModulusGF.prototype.getZero = function () {[m
[32m+[m[32m        return this.zero;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusGF.prototype.getOne = function () {[m
[32m+[m[32m        return this.one;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusGF.prototype.buildMonomial = function (degree, coefficient) {[m
[32m+[m[32m        if (degree < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (coefficient === 0) {[m
[32m+[m[32m            return this.zero;[m
[32m+[m[32m        }[m
[32m+[m[32m        var coefficients = new Int32Array(degree + 1);[m
[32m+[m[32m        coefficients[0] = coefficient;[m
[32m+[m[32m        return new ModulusPoly_1.default(this, coefficients);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common_1.default.NUMBER_OF_CODEWORDS, 3);[m
[32m+[m[32m    return ModulusGF;[m
[32m+[m[32m}(ModulusBase_1.default));[m
[32m+[m[32mexports.default = ModulusGF;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a95ab34[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.d.ts[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32mimport ModulusBase from './ModulusBase';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.GenericGFPoly[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ModulusPoly {[m
[32m+[m[32m    private field;[m
[32m+[m[32m    private coefficients;[m
[32m+[m[32m    constructor(field: ModulusBase, coefficients: Int32Array);[m
[32m+[m[32m    getCoefficients(): Int32Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getDegree(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    isZero(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    getCoefficient(degree: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    evaluateAt(a: number): number;[m
[32m+[m[32m    add(other: ModulusPoly): ModulusPoly;[m
[32m+[m[32m    subtract(other: ModulusPoly): ModulusPoly;[m
[32m+[m[32m    multiply(other: ModulusPoly | number): ModulusPoly;[m
[32m+[m[32m    multiplyOther(other: ModulusPoly): ModulusPoly;[m
[32m+[m[32m    negative(): ModulusPoly;[m
[32m+[m[32m    multiplyScalar(scalar: number): ModulusPoly;[m
[32m+[m[32m    multiplyByMonomial(degree: number, coefficient: number): ModulusPoly;[m
[32m+[m[32m    toString(): String;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js[m
[1mnew file mode 100644[m
[1mindex 0000000..49f65a8[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/decoder/ec/ModulusPoly.js[m
[36m@@ -0,0 +1,275 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2012 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package com.google.zxing.pdf417.decoder.ec;[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../../IllegalArgumentException");[m
[32m+[m[32mvar System_1 = require("../../../util/System");[m
[32m+[m[32mvar StringBuilder_1 = require("../../../util/StringBuilder");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see com.google.zxing.common.reedsolomon.GenericGFPoly[m
[32m+[m[32m */[m
[32m+[m[32mvar ModulusPoly = /** @class */ (function () {[m
[32m+[m[32m    function ModulusPoly(field, coefficients) {[m
[32m+[m[32m        if (coefficients.length === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.field = field;[m
[32m+[m[32m        var coefficientsLength = /*int*/ coefficients.length;[m
[32m+[m[32m        if (coefficientsLength > 1 && coefficients[0] === 0) {[m
[32m+[m[32m            // Leading term must be non-zero for anything except the constant polynomial "0"[m
[32m+[m[32m            var firstNonZero = /*int*/ 1;[m
[32m+[m[32m            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {[m
[32m+[m[32m                firstNonZero++;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (firstNonZero === coefficientsLength) {[m
[32m+[m[32m                this.coefficients = new Int32Array([0]);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);[m
[32m+[m[32m                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            this.coefficients = coefficients;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    ModulusPoly.prototype.getCoefficients = function () {[m
[32m+[m[32m        return this.coefficients;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return degree of this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    ModulusPoly.prototype.getDegree = function () {[m
[32m+[m[32m        return this.coefficients.length - 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff this polynomial is the monomial "0"[m
[32m+[m[32m     */[m
[32m+[m[32m    ModulusPoly.prototype.isZero = function () {[m
[32m+[m[32m        return this.coefficients[0] === 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return coefficient of x^degree term in this polynomial[m
[32m+[m[32m     */[m
[32m+[m[32m    ModulusPoly.prototype.getCoefficient = function (degree) {[m
[32m+[m[32m        return this.coefficients[this.coefficients.length - 1 - degree];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return evaluation of this polynomial at a given point[m
[32m+[m[32m     */[m
[32m+[m[32m    ModulusPoly.prototype.evaluateAt = function (a) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (a === 0) {[m
[32m+[m[32m            // Just return the x^0 coefficient[m
[32m+[m[32m            return this.getCoefficient(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (a === 1) {[m
[32m+[m[32m            // Just the sum of the coefficients[m
[32m+[m[32m            var sum = /*int*/ 0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var _b = __values(this.coefficients), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                    var coefficient = _c.value /*int*/;[m
[32m+[m[32m                    sum = this.field.add(sum, coefficient);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            return sum;[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = /*int*/ this.coefficients[0];[m
[32m+[m[32m        var size = /*int*/ this.coefficients.length;[m
[32m+[m[32m        for (var i /*int*/ = 1; i < size; i++) {[m
[32m+[m[32m            result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.add = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isZero()) {[m
[32m+[m[32m            return other;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (other.isZero()) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        var smallerCoefficients = this.coefficients;[m
[32m+[m[32m        var largerCoefficients = other.coefficients;[m
[32m+[m[32m        if (smallerCoefficients.length > largerCoefficients.length) {[m
[32m+[m[32m            var temp = smallerCoefficients;[m
[32m+[m[32m            smallerCoefficients = largerCoefficients;[m
[32m+[m[32m            largerCoefficients = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var sumDiff = new Int32Array(largerCoefficients.length);[m
[32m+[m[32m        var lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;[m
[32m+[m[32m        // Copy high-order terms only found in higher-degree polynomial's coefficients[m
[32m+[m[32m        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);[m
[32m+[m[32m        for (var i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {[m
[32m+[m[32m            sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ModulusPoly(this.field, sumDiff);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.subtract = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (other.isZero()) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.add(other.negative());[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.multiply = function (other) {[m
[32m+[m[32m        if (other instanceof ModulusPoly) {[m
[32m+[m[32m            return this.multiplyOther(other);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.multiplyScalar(other);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.multiplyOther = function (other) {[m
[32m+[m[32m        if (!this.field.equals(other.field)) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.isZero() || other.isZero()) {[m
[32m+[m[32m            // return this.field.getZero();[m
[32m+[m[32m            return new ModulusPoly(this.field, new Int32Array([0]));[m
[32m+[m[32m        }[m
[32m+[m[32m        var aCoefficients = this.coefficients;[m
[32m+[m[32m        var aLength = /*int*/ aCoefficients.length;[m
[32m+[m[32m        var bCoefficients = other.coefficients;[m
[32m+[m[32m        var bLength = /*int*/ bCoefficients.length;[m
[32m+[m[32m        var product = new Int32Array(aLength + bLength - 1);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < aLength; i++) {[m
[32m+[m[32m            var aCoeff = /*int*/ aCoefficients[i];[m
[32m+[m[32m            for (var j /*int*/ = 0; j < bLength; j++) {[m
[32m+[m[32m                product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ModulusPoly(this.field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.negative = function () {[m
[32m+[m[32m        var size = /*int*/ this.coefficients.length;[m
[32m+[m[32m        var negativeCoefficients = new Int32Array(size);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < size; i++) {[m
[32m+[m[32m            negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ModulusPoly(this.field, negativeCoefficients);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.multiplyScalar = function (scalar) {[m
[32m+[m[32m        if (scalar === 0) {[m
[32m+[m[32m            return new ModulusPoly(this.field, new Int32Array([0]));[m
[32m+[m[32m        }[m
[32m+[m[32m        if (scalar === 1) {[m
[32m+[m[32m            return this;[m
[32m+[m[32m        }[m
[32m+[m[32m        var size = /*int*/ this.coefficients.length;[m
[32m+[m[32m        var product = new Int32Array(size);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < size; i++) {[m
[32m+[m[32m            product[i] = this.field.multiply(this.coefficients[i], scalar);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ModulusPoly(this.field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    ModulusPoly.prototype.multiplyByMonomial = function (degree, coefficient) {[m
[32m+[m[32m        if (degree < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (coefficient === 0) {[m
[32m+[m[32m            return new ModulusPoly(this.field, new Int32Array([0]));[m
[32m+[m[32m        }[m
[32m+[m[32m        var size = /*int*/ this.coefficients.length;[m
[32m+[m[32m        var product = new Int32Array(size + degree);[m
[32m+[m[32m        for (var i /*int*/ = 0; i < size; i++) {[m
[32m+[m[32m            product[i] = this.field.multiply(this.coefficients[i], coefficient);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new ModulusPoly(this.field, product);[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    ModulusPoly[] divide(other: ModulusPoly) {[m
[32m+[m[32m      if (!field.equals(other.field)) {[m
[32m+[m[32m        throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");[m
[32m+[m[32m      }[m
[32m+[m[32m      if (other.isZero()) {[m
[32m+[m[32m        throw new IllegalArgumentException("Divide by 0");[m
[32m+[m[32m      }[m
[32m+[m[41m  [m
[32m+[m[32m      let quotient: ModulusPoly = field.getZero();[m
[32m+[m[32m      let remainder: ModulusPoly = this;[m
[32m+[m[41m  [m
[32m+[m[32m      let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());[m
[32m+[m[32m      let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);[m
[32m+[m[41m  [m
[32m+[m[32m      while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {[m
[32m+[m[32m        let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();[m
[32m+[m[32m        let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);[m
[32m+[m[32m        let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);[m
[32m+[m[32m        let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);[m
[32m+[m[32m        quotient = quotient.add(iterationQuotient);[m
[32m+[m[32m        remainder = remainder.subtract(term);[m
[32m+[m[32m      }[m
[32m+[m[41m  [m
[32m+[m[32m      return new ModulusPoly[] { quotient, remainder };[m
[32m+[m[32m    }[m
[32m+[m[32m    */[m
[32m+[m[32m    // @Override[m
[32m+[m[32m    ModulusPoly.prototype.toString = function () {[m
[32m+[m[32m        var result = new StringBuilder_1.default( /*8 * this.getDegree()*/); // dynamic string size in JS[m
[32m+[m[32m        for (var degree /*int*/ = this.getDegree(); degree >= 0; degree--) {[m
[32m+[m[32m            var coefficient = /*int*/ this.getCoefficient(degree);[m
[32m+[m[32m            if (coefficient !== 0) {[m
[32m+[m[32m                if (coefficient < 0) {[m
[32m+[m[32m                    result.append(' - ');[m
[32m+[m[32m                    coefficient = -coefficient;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    if (result.length() > 0) {[m
[32m+[m[32m                        result.append(' + ');[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree === 0 || coefficient !== 1) {[m
[32m+[m[32m                    result.append(coefficient);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (degree !== 0) {[m
[32m+[m[32m                    if (degree === 1) {[m
[32m+[m[32m                        result.append('x');[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        result.append('x^');[m
[32m+[m[32m                        result.append(degree);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    return ModulusPoly;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ModulusPoly;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a94ce50[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.d.ts[m
[36m@@ -0,0 +1,84 @@[m
[32m+[m[32mimport BinaryBitmap from '../../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32mimport PDF417DetectorResult from './PDF417DetectorResult';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the[m
[32m+[m[32m * PDF417 Code is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Detector {[m
[32m+[m[32m    private static INDEXES_START_PATTERN;[m
[32m+[m[32m    private static INDEXES_STOP_PATTERN;[m
[32m+[m[32m    private static MAX_AVG_VARIANCE;[m
[32m+[m[32m    private static MAX_INDIVIDUAL_VARIANCE;[m
[32m+[m[32m    private static START_PATTERN;[m
[32m+[m[32m    private static STOP_PATTERN;[m
[32m+[m[32m    private static MAX_PIXEL_DRIFT;[m
[32m+[m[32m    private static MAX_PATTERN_DRIFT;[m
[32m+[m[32m    private static SKIPPED_ROW_COUNT_MAX;[m
[32m+[m[32m    private static ROW_STEP;[m
[32m+[m[32m    private static BARCODE_MIN_HEIGHT;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image barcode image to decode[m
[32m+[m[32m     * @param hints optional hints to detector[m
[32m+[m[32m     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will[m
[32m+[m[32m     * be found and returned[m
[32m+[m[32m     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code[m
[32m+[m[32m     * @throws NotFoundException if no PDF417 Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    static detectMultiple(image: BinaryBitmap, hints: Map<DecodeHintType, any>, multiple: boolean): PDF417DetectorResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detects PDF417 codes in an image. Only checks 0 degree rotation[m
[32m+[m[32m     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will[m
[32m+[m[32m     * be found and returned[m
[32m+[m[32m     * @param bitMatrix bit matrix to detect barcodes in[m
[32m+[m[32m     * @return List of ResultPoint arrays containing the coordinates of found barcodes[m
[32m+[m[32m     */[m
[32m+[m[32m    private static detect;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locate the vertices and the codewords area of a black blob using the Start[m
[32m+[m[32m     * and Stop patterns as locators.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param matrix the scanned barcode image.[m
[32m+[m[32m     * @return an array containing the vertices:[m
[32m+[m[32m     *           vertices[0] x, y top left barcode[m
[32m+[m[32m     *           vertices[1] x, y bottom left barcode[m
[32m+[m[32m     *           vertices[2] x, y top right barcode[m
[32m+[m[32m     *           vertices[3] x, y bottom right barcode[m
[32m+[m[32m     *           vertices[4] x, y top left codeword area[m
[32m+[m[32m     *           vertices[5] x, y bottom left codeword area[m
[32m+[m[32m     *           vertices[6] x, y top right codeword area[m
[32m+[m[32m     *           vertices[7] x, y bottom right codeword area[m
[32m+[m[32m     */[m
[32m+[m[32m    private static findVertices;[m
[32m+[m[32m    private static copyToResult;[m
[32m+[m[32m    private static findRowsWithPattern;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param matrix row of black/white values to search[m
[32m+[m[32m     * @param column x position to start search[m
[32m+[m[32m     * @param row y position to start search[m
[32m+[m[32m     * @param width the number of pixels to search on this row[m
[32m+[m[32m     * @param pattern pattern of counts of number of black and white pixels that are[m
[32m+[m[32m     *                 being searched for as a pattern[m
[32m+[m[32m     * @param counters array of counters, as long as pattern, to re-use[m
[32m+[m[32m     * @return start/end horizontal offset of guard pattern, as an array of two ints.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static findGuardPattern;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines how closely a set of observed counts of runs of black/white[m
[32m+[m[32m     * values matches a given target pattern. This is reported as the ratio of[m
[32m+[m[32m     * the total variance from the expected pattern proportions across all[m
[32m+[m[32m     * pattern elements, to the length of the pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param counters observed counters[m
[32m+[m[32m     * @param pattern expected pattern[m
[32m+[m[32m     * @param maxIndividualVariance The most any counter can differ before we give up[m
[32m+[m[32m     * @return ratio of total variance between counters and pattern compared to total pattern size[m
[32m+[m[32m     */[m
[32m+[m[32m    private static patternMatchVariance;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..acd8876[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js[m
[36m@@ -0,0 +1,339 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2009 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import com.google.zxing.NotFoundException;[m
[32m+[m[32m// import com.google.zxing.ResultPoint;[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar System_1 = require("../../util/System");[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar PDF417DetectorResult_1 = require("./PDF417DetectorResult");[m
[32m+[m[32m// import java.util.ArrayList;[m
[32m+[m[32m// import java.util.Arrays;[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m// import java.util.Map;[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the[m
[32m+[m[32m * PDF417 Code is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author SITA Lab (kevin.osullivan@sita.aero)[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar Detector = /** @class */ (function () {[m
[32m+[m[32m    function Detector() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image barcode image to decode[m
[32m+[m[32m     * @param hints optional hints to detector[m
[32m+[m[32m     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will[m
[32m+[m[32m     * be found and returned[m
[32m+[m[32m     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code[m
[32m+[m[32m     * @throws NotFoundException if no PDF417 Code can be found[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.detectMultiple = function (image, hints, multiple) {[m
[32m+[m[32m        // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even[m
[32m+[m[32m        // different binarizers[m
[32m+[m[32m        // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);[m
[32m+[m[32m        var bitMatrix = image.getBlackMatrix();[m
[32m+[m[32m        var barcodeCoordinates = Detector.detect(multiple, bitMatrix);[m
[32m+[m[32m        if (!barcodeCoordinates.length) {[m
[32m+[m[32m            bitMatrix = bitMatrix.clone();[m
[32m+[m[32m            bitMatrix.rotate180();[m
[32m+[m[32m            barcodeCoordinates = Detector.detect(multiple, bitMatrix);[m
[32m+[m[32m        }[m
[32m+[m[32m        return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Detects PDF417 codes in an image. Only checks 0 degree rotation[m
[32m+[m[32m     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will[m
[32m+[m[32m     * be found and returned[m
[32m+[m[32m     * @param bitMatrix bit matrix to detect barcodes in[m
[32m+[m[32m     * @return List of ResultPoint arrays containing the coordinates of found barcodes[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.detect = function (multiple, bitMatrix) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var barcodeCoordinates = new Array();[m
[32m+[m[32m        var row = 0;[m
[32m+[m[32m        var column = 0;[m
[32m+[m[32m        var foundBarcodeInRow = false;[m
[32m+[m[32m        while (row < bitMatrix.getHeight()) {[m
[32m+[m[32m            var vertices = Detector.findVertices(bitMatrix, row, column);[m
[32m+[m[32m            if (vertices[0] == null && vertices[3] == null) {[m
[32m+[m[32m                if (!foundBarcodeInRow) {[m
[32m+[m[32m                    // we didn't find any barcode so that's the end of searching[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly[m
[32m+[m[32m                // below the lowest barcode we found so far.[m
[32m+[m[32m                foundBarcodeInRow = false;[m
[32m+[m[32m                column = 0;[m
[32m+[m[32m                try {[m
[32m+[m[32m                    for (var barcodeCoordinates_1 = (e_1 = void 0, __values(barcodeCoordinates)), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {[m
[32m+[m[32m                        var barcodeCoordinate = barcodeCoordinates_1_1.value;[m
[32m+[m[32m                        if (barcodeCoordinate[1] != null) {[m
[32m+[m[32m                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (barcodeCoordinate[3] != null) {[m
[32m+[m[32m                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m                finally {[m
[32m+[m[32m                    try {[m
[32m+[m[32m                        if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m                }[m
[32m+[m[32m                row += Detector.ROW_STEP;[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            foundBarcodeInRow = true;[m
[32m+[m[32m            barcodeCoordinates.push(vertices);[m
[32m+[m[32m            if (!multiple) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            // if we didn't find a right row indicator column, then continue the search for the next barcode after the[m
[32m+[m[32m            // start pattern of the barcode just found.[m
[32m+[m[32m            if (vertices[2] != null) {[m
[32m+[m[32m                column = Math.trunc(vertices[2].getX());[m
[32m+[m[32m                row = Math.trunc(vertices[2].getY());[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                column = Math.trunc(vertices[4].getX());[m
[32m+[m[32m                row = Math.trunc(vertices[4].getY());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return barcodeCoordinates;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locate the vertices and the codewords area of a black blob using the Start[m
[32m+[m[32m     * and Stop patterns as locators.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param matrix the scanned barcode image.[m
[32m+[m[32m     * @return an array containing the vertices:[m
[32m+[m[32m     *           vertices[0] x, y top left barcode[m
[32m+[m[32m     *           vertices[1] x, y bottom left barcode[m
[32m+[m[32m     *           vertices[2] x, y top right barcode[m
[32m+[m[32m     *           vertices[3] x, y bottom right barcode[m
[32m+[m[32m     *           vertices[4] x, y top left codeword area[m
[32m+[m[32m     *           vertices[5] x, y bottom left codeword area[m
[32m+[m[32m     *           vertices[6] x, y top right codeword area[m
[32m+[m[32m     *           vertices[7] x, y bottom right codeword area[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.findVertices = function (matrix, startRow, startColumn) {[m
[32m+[m[32m        var height = matrix.getHeight();[m
[32m+[m[32m        var width = matrix.getWidth();[m
[32m+[m[32m        // const result = new ResultPoint[8];[m
[32m+[m[32m        var result = new Array(8);[m
[32m+[m[32m        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);[m
[32m+[m[32m        if (result[4] != null) {[m
[32m+[m[32m            startColumn = Math.trunc(result[4].getX());[m
[32m+[m[32m            startRow = Math.trunc(result[4].getY());[m
[32m+[m[32m        }[m
[32m+[m[32m        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.copyToResult = function (result, tmpResult, destinationIndexes) {[m
[32m+[m[32m        for (var i = 0; i < destinationIndexes.length; i++) {[m
[32m+[m[32m            result[destinationIndexes[i]] = tmpResult[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {[m
[32m+[m[32m        // const result = new ResultPoint[4];[m
[32m+[m[32m        var result = new Array(4);[m
[32m+[m[32m        var found = false;[m
[32m+[m[32m        var counters = new Int32Array(pattern.length);[m
[32m+[m[32m        for (; startRow < height; startRow += Detector.ROW_STEP) {[m
[32m+[m[32m            var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);[m
[32m+[m[32m            if (loc != null) {[m
[32m+[m[32m                while (startRow > 0) {[m
[32m+[m[32m                    var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);[m
[32m+[m[32m                    if (previousRowLoc != null) {[m
[32m+[m[32m                        loc = previousRowLoc;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        startRow++;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                result[0] = new ResultPoint_1.default(loc[0], startRow);[m
[32m+[m[32m                result[1] = new ResultPoint_1.default(loc[1], startRow);[m
[32m+[m[32m                found = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var stopRow = startRow + 1;[m
[32m+[m[32m        // Last row of the current symbol that contains pattern[m
[32m+[m[32m        if (found) {[m
[32m+[m[32m            var skippedRowCount = 0;[m
[32m+[m[32m            var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);[m
[32m+[m[32m            for (; stopRow < height; stopRow++) {[m
[32m+[m[32m                var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);[m
[32m+[m[32m                // a found pattern is only considered to belong to the same barcode if the start and end positions[m
[32m+[m[32m                // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With[m
[32m+[m[32m                // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly[m
[32m+[m[32m                // larger drift and don't check for skipped rows.[m
[32m+[m[32m                if (loc != null &&[m
[32m+[m[32m                    Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT &&[m
[32m+[m[32m                    Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {[m
[32m+[m[32m                    previousRowLoc = loc;[m
[32m+[m[32m                    skippedRowCount = 0;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        skippedRowCount++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            stopRow -= skippedRowCount + 1;[m
[32m+[m[32m            result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);[m
[32m+[m[32m            result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {[m
[32m+[m[32m            Arrays_1.default.fill(result, null);[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param matrix row of black/white values to search[m
[32m+[m[32m     * @param column x position to start search[m
[32m+[m[32m     * @param row y position to start search[m
[32m+[m[32m     * @param width the number of pixels to search on this row[m
[32m+[m[32m     * @param pattern pattern of counts of number of black and white pixels that are[m
[32m+[m[32m     *                 being searched for as a pattern[m
[32m+[m[32m     * @param counters array of counters, as long as pattern, to re-use[m
[32m+[m[32m     * @return start/end horizontal offset of guard pattern, as an array of two ints.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {[m
[32m+[m[32m        Arrays_1.default.fillWithin(counters, 0, counters.length, 0);[m
[32m+[m[32m        var patternStart = column;[m
[32m+[m[32m        var pixelDrift = 0;[m
[32m+[m[32m        // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels[m
[32m+[m[32m        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {[m
[32m+[m[32m            patternStart--;[m
[32m+[m[32m        }[m
[32m+[m[32m        var x = patternStart;[m
[32m+[m[32m        var counterPosition = 0;[m
[32m+[m[32m        var patternLength = pattern.length;[m
[32m+[m[32m        for (var isWhite = whiteFirst; x < width; x++) {[m
[32m+[m[32m            var pixel = matrix.get(x, row);[m
[32m+[m[32m            if (pixel !== isWhite) {[m
[32m+[m[32m                counters[counterPosition]++;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                if (counterPosition === patternLength - 1) {[m
[32m+[m[32m                    if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {[m
[32m+[m[32m                        return new Int32Array([patternStart, x]);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    patternStart += counters[0] + counters[1];[m
[32m+[m[32m                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);[m
[32m+[m[32m                    counters[counterPosition - 1] = 0;[m
[32m+[m[32m                    counters[counterPosition] = 0;[m
[32m+[m[32m                    counterPosition--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    counterPosition++;[m
[32m+[m[32m                }[m
[32m+[m[32m                counters[counterPosition] = 1;[m
[32m+[m[32m                isWhite = !isWhite;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (counterPosition === patternLength - 1 &&[m
[32m+[m[32m            Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {[m
[32m+[m[32m            return new Int32Array([patternStart, x - 1]);[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Determines how closely a set of observed counts of runs of black/white[m
[32m+[m[32m     * values matches a given target pattern. This is reported as the ratio of[m
[32m+[m[32m     * the total variance from the expected pattern proportions across all[m
[32m+[m[32m     * pattern elements, to the length of the pattern.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param counters observed counters[m
[32m+[m[32m     * @param pattern expected pattern[m
[32m+[m[32m     * @param maxIndividualVariance The most any counter can differ before we give up[m
[32m+[m[32m     * @return ratio of total variance between counters and pattern compared to total pattern size[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {[m
[32m+[m[32m        var numCounters = counters.length;[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        var patternLength = 0;[m
[32m+[m[32m        for (var i = 0; i < numCounters; i++) {[m
[32m+[m[32m            total += counters[i];[m
[32m+[m[32m            patternLength += pattern[i];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (total < patternLength) {[m
[32m+[m[32m            // If we don't even have one pixel per unit of bar width, assume this[m
[32m+[m[32m            // is too small to reliably match, so fail:[m
[32m+[m[32m            return /*Float.POSITIVE_INFINITY*/ Infinity;[m
[32m+[m[32m        }[m
[32m+[m[32m        // We're going to fake floating-point math in integers. We just need to use more bits.[m
[32m+[m[32m        // Scale up patternLength so that intermediate values below like scaledCounter will have[m
[32m+[m[32m        // more "significant digits".[m
[32m+[m[32m        var unitBarWidth = total / patternLength;[m
[32m+[m[32m        maxIndividualVariance *= unitBarWidth;[m
[32m+[m[32m        var totalVariance = 0.0;[m
[32m+[m[32m        for (var x = 0; x < numCounters; x++) {[m
[32m+[m[32m            var counter = counters[x];[m
[32m+[m[32m            var scaledPattern = pattern[x] * unitBarWidth;[m
[32m+[m[32m            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;[m
[32m+[m[32m            if (variance > maxIndividualVariance) {[m
[32m+[m[32m                return /*Float.POSITIVE_INFINITY*/ Infinity;[m
[32m+[m[32m            }[m
[32m+[m[32m            totalVariance += variance;[m
[32m+[m[32m        }[m
[32m+[m[32m        return totalVariance / total;[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);[m
[32m+[m[32m    Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);[m
[32m+[m[32m    Detector.MAX_AVG_VARIANCE = 0.42;[m
[32m+[m[32m    Detector.MAX_INDIVIDUAL_VARIANCE = 0.8;[m
[32m+[m[32m    // B S B S B S B S Bar/Space pattern[m
[32m+[m[32m    // 11111111 0 1 0 1 0 1 000[m
[32m+[m[32m    Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);[m
[32m+[m[32m    // 1111111 0 1 000 1 0 1 00 1[m
[32m+[m[32m    Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);[m
[32m+[m[32m    Detector.MAX_PIXEL_DRIFT = 3;[m
[32m+[m[32m    Detector.MAX_PATTERN_DRIFT = 5;[m
[32m+[m[32m    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.[m
[32m+[m[32m    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.[m
[32m+[m[32m    Detector.SKIPPED_ROW_COUNT_MAX = 25;[m
[32m+[m[32m    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least[m
[32m+[m[32m    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.[m
[32m+[m[32m    Detector.ROW_STEP = 5;[m
[32m+[m[32m    Detector.BARCODE_MIN_HEIGHT = 10;[m
[32m+[m[32m    return Detector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Detector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.d.ts b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..e29d0fe[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.d.ts[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mexport default class PDF417DetectorResult {[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    private points;[m
[32m+[m[32m    constructor(bits: BitMatrix, points: ResultPoint[][]);[m
[32m+[m[32m    getBits(): BitMatrix;[m
[32m+[m[32m    getPoints(): ResultPoint[][];[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js[m
[1mnew file mode 100644[m
[1mindex 0000000..aaad442[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/pdf417/detector/PDF417DetectorResult.js[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m* Copyright 2007 ZXing authors[m
[32m+[m[32m*[m
[32m+[m[32m* Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m* you may not use this file except in compliance with the License.[m
[32m+[m[32m* You may obtain a copy of the License at[m
[32m+[m[32m*[m
[32m+[m[32m*      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m*[m
[32m+[m[32m* Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m* distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m* See the License for the specific language governing permissions and[m
[32m+[m[32m* limitations under the License.[m
[32m+[m[32m*/[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// import java.util.List;[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Guenther Grau[m
[32m+[m[32m */[m
[32m+[m[32mvar PDF417DetectorResult = /** @class */ (function () {[m
[32m+[m[32m    function PDF417DetectorResult(bits, points) {[m
[32m+[m[32m        this.bits = bits;[m
[32m+[m[32m        this.points = points;[m
[32m+[m[32m    }[m
[32m+[m[32m    PDF417DetectorResult.prototype.getBits = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    PDF417DetectorResult.prototype.getPoints = function () {[m
[32m+[m[32m        return this.points;[m
[32m+[m[32m    };[m
[32m+[m[32m    return PDF417DetectorResult;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = PDF417DetectorResult;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..32906b4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.d.ts[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32mimport BinaryBitmap from '../BinaryBitmap';[m
[32m+[m[32mimport DecodeHintType from '../DecodeHintType';[m
[32m+[m[32mimport Reader from '../Reader';[m
[32m+[m[32mimport Result from '../Result';[m
[32m+[m[32mimport Decoder from './decoder/Decoder';[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode QR Codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class QRCodeReader implements Reader {[m
[32m+[m[32m    private static NO_POINTS;[m
[32m+[m[32m    private decoder;[m
[32m+[m[32m    protected getDecoder(): Decoder;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a QR code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a representing: string the content encoded by the QR code[m
[32m+[m[32m     * @throws NotFoundException if a QR code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    decode(image: BinaryBitmap, hints?: Map<DecodeHintType, any>): Result;[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method detects a code in a "pure" image -- that is, pure monochrome image[m
[32m+[m[32m     * which contains only an unrotated, unskewed, image of a code, with some white border[m
[32m+[m[32m     * around it. This is a specialized method that works exceptionally fast in this special[m
[32m+[m[32m     * case.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)[m
[32m+[m[32m     */[m
[32m+[m[32m    private static extractPureBits;[m
[32m+[m[32m    private static moduleSize;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e8b5877[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js[m
[36m@@ -0,0 +1,196 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar BitMatrix_1 = require("../common/BitMatrix");[m
[32m+[m[32mvar DecodeHintType_1 = require("../DecodeHintType");[m
[32m+[m[32mvar NotFoundException_1 = require("../NotFoundException");[m
[32m+[m[32mvar Result_1 = require("../Result");[m
[32m+[m[32mvar ResultMetadataType_1 = require("../ResultMetadataType");[m
[32m+[m[32m// import DetectorResult from '../common/DetectorResult';[m
[32m+[m[32mvar Decoder_1 = require("./decoder/Decoder");[m
[32m+[m[32mvar QRCodeDecoderMetaData_1 = require("./decoder/QRCodeDecoderMetaData");[m
[32m+[m[32mvar Detector_1 = require("./detector/Detector");[m
[32m+[m[32m/*import java.util.List;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * This implementation can detect and decode QR Codes in an image.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar QRCodeReader = /** @class */ (function () {[m
[32m+[m[32m    function QRCodeReader() {[m
[32m+[m[32m        this.decoder = new Decoder_1.default();[m
[32m+[m[32m    }[m
[32m+[m[32m    QRCodeReader.prototype.getDecoder = function () {[m
[32m+[m[32m        return this.decoder;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Locates and decodes a QR code in an image.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return a representing: string the content encoded by the QR code[m
[32m+[m[32m     * @throws NotFoundException if a QR code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {[m
[32m+[m[32m    //   return this.decode(image, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    QRCodeReader.prototype.decode = function (image, hints) {[m
[32m+[m[32m        var decoderResult;[m
[32m+[m[32m        var points;[m
[32m+[m[32m        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {[m
[32m+[m[32m            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());[m
[32m+[m[32m            decoderResult = this.decoder.decodeBitMatrix(bits, hints);[m
[32m+[m[32m            points = QRCodeReader.NO_POINTS;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);[m
[32m+[m[32m            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);[m
[32m+[m[32m            points = detectorResult.getPoints();[m
[32m+[m[32m        }[m
[32m+[m[32m        // If the code was mirrored: swap the bottom-left and the top-right points.[m
[32m+[m[32m        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {[m
[32m+[m[32m            decoderResult.getOther().applyMirroredCorrection(points);[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);[m
[32m+[m[32m        var byteSegments = decoderResult.getByteSegments();[m
[32m+[m[32m        if (byteSegments !== null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);[m
[32m+[m[32m        }[m
[32m+[m[32m        var ecLevel = decoderResult.getECLevel();[m
[32m+[m[32m        if (ecLevel !== null) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (decoderResult.hasStructuredAppend()) {[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());[m
[32m+[m[32m            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    QRCodeReader.prototype.reset = function () {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * This method detects a code in a "pure" image -- that is, pure monochrome image[m
[32m+[m[32m     * which contains only an unrotated, unskewed, image of a code, with some white border[m
[32m+[m[32m     * around it. This is a specialized method that works exceptionally fast in this special[m
[32m+[m[32m     * case.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)[m
[32m+[m[32m     */[m
[32m+[m[32m    QRCodeReader.extractPureBits = function (image) {[m
[32m+[m[32m        var leftTopBlack = image.getTopLeftOnBit();[m
[32m+[m[32m        var rightBottomBlack = image.getBottomRightOnBit();[m
[32m+[m[32m        if (leftTopBlack === null || rightBottomBlack === null) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var moduleSize = this.moduleSize(leftTopBlack, image);[m
[32m+[m[32m        var top = leftTopBlack[1];[m
[32m+[m[32m        var bottom = rightBottomBlack[1];[m
[32m+[m[32m        var left = leftTopBlack[0];[m
[32m+[m[32m        var right = rightBottomBlack[0];[m
[32m+[m[32m        // Sanity check![m
[32m+[m[32m        if (left >= right || top >= bottom) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bottom - top !== right - left) {[m
[32m+[m[32m            // Special case, where bottom-right module wasn't black so we found something else in the last row[m
[32m+[m[32m            // Assume it's a square, so use height as the width[m
[32m+[m[32m            right = left + (bottom - top);[m
[32m+[m[32m            if (right >= image.getWidth()) {[m
[32m+[m[32m                // Abort if that would not make sense -- off image[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var matrixWidth = Math.round((right - left + 1) / moduleSize);[m
[32m+[m[32m        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);[m
[32m+[m[32m        if (matrixWidth <= 0 || matrixHeight <= 0) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (matrixHeight !== matrixWidth) {[m
[32m+[m[32m            // Only possibly decode square regions[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Push in the "border" by half the module width so that we start[m
[32m+[m[32m        // sampling in the middle of the module. Just in case the image is a[m
[32m+[m[32m        // little off, this will help recover.[m
[32m+[m[32m        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);[m
[32m+[m[32m        top += nudge;[m
[32m+[m[32m        left += nudge;[m
[32m+[m[32m        // But careful that this does not sample off the edge[m
[32m+[m[32m        // "right" is the farthest-right valid pixel location -- right+1 is not necessarily[m
[32m+[m[32m        // This is positive by how much the inner x loop below would be too large[m
[32m+[m[32m        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;[m
[32m+[m[32m        if (nudgedTooFarRight > 0) {[m
[32m+[m[32m            if (nudgedTooFarRight > nudge) {[m
[32m+[m[32m                // Neither way fits; abort[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            left -= nudgedTooFarRight;[m
[32m+[m[32m        }[m
[32m+[m[32m        // See logic above[m
[32m+[m[32m        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;[m
[32m+[m[32m        if (nudgedTooFarDown > 0) {[m
[32m+[m[32m            if (nudgedTooFarDown > nudge) {[m
[32m+[m[32m                // Neither way fits; abort[m
[32m+[m[32m                throw new NotFoundException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            top -= nudgedTooFarDown;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now just read off the bits[m
[32m+[m[32m        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);[m
[32m+[m[32m        for (var y = 0; y < matrixHeight; y++) {[m
[32m+[m[32m            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);[m
[32m+[m[32m            for (var x = 0; x < matrixWidth; x++) {[m
[32m+[m[32m                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {[m
[32m+[m[32m                    bits.set(x, y);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCodeReader.moduleSize = function (leftTopBlack, image) {[m
[32m+[m[32m        var height = image.getHeight();[m
[32m+[m[32m        var width = image.getWidth();[m
[32m+[m[32m        var x = leftTopBlack[0];[m
[32m+[m[32m        var y = leftTopBlack[1];[m
[32m+[m[32m        var inBlack = true;[m
[32m+[m[32m        var transitions = 0;[m
[32m+[m[32m        while (x < width && y < height) {[m
[32m+[m[32m            if (inBlack !== image.get(x, y)) {[m
[32m+[m[32m                if (++transitions === 5) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                inBlack = !inBlack;[m
[32m+[m[32m            }[m
[32m+[m[32m            x++;[m
[32m+[m[32m            y++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (x === width || y === height) {[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return (x - leftTopBlack[0]) / 7.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCodeReader.NO_POINTS = new Array();[m
[32m+[m[32m    return QRCodeReader;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = QRCodeReader;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..3613063[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.d.ts[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mimport BarcodeFormat from '../BarcodeFormat';[m
[32m+[m[32mimport EncodeHintType from '../EncodeHintType';[m
[32m+[m[32mimport Writer from '../Writer';[m
[32m+[m[32mimport BitMatrix from '../common/BitMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * This object renders a QR Code as a BitMatrix 2D array of greyscale values.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class QRCodeWriter implements Writer {[m
[32m+[m[32m    private static QUIET_ZONE_SIZE;[m
[32m+[m[32m    encode(contents: string, format: BarcodeFormat, width: number, height: number, hints: Map<EncodeHintType, any>): BitMatrix;[m
[32m+[m[32m    private static renderResult;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js[m
[1mnew file mode 100644[m
[1mindex 0000000..cea6986[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/QRCodeWriter.js[m
[36m@@ -0,0 +1,98 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode {*/[m
[32m+[m[32mvar BarcodeFormat_1 = require("../BarcodeFormat");[m
[32m+[m[32mvar EncodeHintType_1 = require("../EncodeHintType");[m
[32m+[m[32mvar BitMatrix_1 = require("../common/BitMatrix");[m
[32m+[m[32mvar ErrorCorrectionLevel_1 = require("./decoder/ErrorCorrectionLevel");[m
[32m+[m[32mvar Encoder_1 = require("./encoder/Encoder");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32mvar IllegalStateException_1 = require("../IllegalStateException");[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * This object renders a QR Code as a BitMatrix 2D array of greyscale values.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar QRCodeWriter = /** @class */ (function () {[m
[32m+[m[32m    function QRCodeWriter() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix[m
[32m+[m[32m    //     /*throws WriterException */ {[m
[32m+[m[32m    //   return encode(contents, format, width, height, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {[m
[32m+[m[32m        if (contents.length === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Found empty contents');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (format !== BarcodeFormat_1.default.QR_CODE) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Can only encode QR_CODE, but got ' + format);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (width < 0 || height < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default("Requested dimensions are too small: " + width + "x" + height);[m
[32m+[m[32m        }[m
[32m+[m[32m        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;[m
[32m+[m[32m        var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;[m
[32m+[m[32m        if (hints !== null) {[m
[32m+[m[32m            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {[m
[32m+[m[32m                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());[m
[32m+[m[32m            }[m
[32m+[m[32m            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {[m
[32m+[m[32m                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);[m
[32m+[m[32m        return QRCodeWriter.renderResult(code, width, height, quietZone);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses[m
[32m+[m[32m    // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).[m
[32m+[m[32m    QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {[m
[32m+[m[32m        var input = code.getMatrix();[m
[32m+[m[32m        if (input === null) {[m
[32m+[m[32m            throw new IllegalStateException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var inputWidth = input.getWidth();[m
[32m+[m[32m        var inputHeight = input.getHeight();[m
[32m+[m[32m        var qrWidth = inputWidth + (quietZone * 2);[m
[32m+[m[32m        var qrHeight = inputHeight + (quietZone * 2);[m
[32m+[m[32m        var outputWidth = Math.max(width, qrWidth);[m
[32m+[m[32m        var outputHeight = Math.max(height, qrHeight);[m
[32m+[m[32m        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));[m
[32m+[m[32m        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested[m
[32m+[m[32m        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.[m
[32m+[m[32m        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will[m
[32m+[m[32m        // handle all the padding from 100x100 (the actual QR) up to 200x160.[m
[32m+[m[32m        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);[m
[32m+[m[32m        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);[m
[32m+[m[32m        var output = new BitMatrix_1.default(outputWidth, outputHeight);[m
[32m+[m[32m        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {[m
[32m+[m[32m            // Write the contents of this row of the barcode[m
[32m+[m[32m            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {[m
[32m+[m[32m                if (input.get(inputX, inputY) === 1) {[m
[32m+[m[32m                    output.setRegion(outputX, outputY, multiple, multiple);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return output;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCodeWriter.QUIET_ZONE_SIZE = 4;[m
[32m+[m[32m    return QRCodeWriter;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = QRCodeWriter;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..44f8ed9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.d.ts[m
[36m@@ -0,0 +1,58 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32mimport FormatInformation from './FormatInformation';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class BitMatrixParser {[m
[32m+[m[32m    private bitMatrix;[m
[32m+[m[32m    private parsedVersion;[m
[32m+[m[32m    private parsedFormatInfo;[m
[32m+[m[32m    private isMirror;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bitMatrix {@link BitMatrix} to parse[m
[32m+[m[32m     * @throws FormatException if dimension is not >= 21 and 1 mod 4[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(bitMatrix: BitMatrix);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads format information from one of its two locations within the QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link FormatInformation} encapsulating the QR Code's format info[m
[32m+[m[32m     * @throws FormatException if both format information locations cannot be parsed as[m
[32m+[m[32m     * the valid encoding of format information[m
[32m+[m[32m     */[m
[32m+[m[32m    readFormatInformation(): FormatInformation;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads version information from one of its two locations within the QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link Version} encapsulating the QR Code's version[m
[32m+[m[32m     * @throws FormatException if both version information locations cannot be parsed as[m
[32m+[m[32m     * the valid encoding of version information[m
[32m+[m[32m     */[m
[32m+[m[32m    readVersion(): Version;[m
[32m+[m[32m    private copyBit;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the[m
[32m+[m[32m     * correct order in order to reconstruct the codewords bytes contained within the[m
[32m+[m[32m     * QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the exact number of bytes expected is not read[m
[32m+[m[32m     */[m
[32m+[m[32m    readCodewords(): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.[m
[32m+[m[32m     */[m
[32m+[m[32m    remask(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Prepare the parser for a mirrored operation.[m
[32m+[m[32m     * This flag has effect only on the {@link #readFormatInformation()} and the[m
[32m+[m[32m     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the[m
[32m+[m[32m     * {@link #mirror()} method should be called.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mirror Whether to read version and format information mirrored.[m
[32m+[m[32m     */[m
[32m+[m[32m    setMirror(isMirror: boolean): void;[m
[32m+[m[32m    /** Mirror the bit matrix in order to attempt a second reading. */[m
[32m+[m[32m    mirror(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ceb33dc[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js[m
[36m@@ -0,0 +1,219 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar Version_1 = require("./Version");[m
[32m+[m[32mvar FormatInformation_1 = require("./FormatInformation");[m
[32m+[m[32mvar DataMask_1 = require("./DataMask");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar BitMatrixParser = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bitMatrix {@link BitMatrix} to parse[m
[32m+[m[32m     * @throws FormatException if dimension is not >= 21 and 1 mod 4[m
[32m+[m[32m     */[m
[32m+[m[32m    function BitMatrixParser(bitMatrix) {[m
[32m+[m[32m        var dimension = bitMatrix.getHeight();[m
[32m+[m[32m        if (dimension < 21 || (dimension & 0x03) !== 1) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bitMatrix = bitMatrix;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads format information from one of its two locations within the QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link FormatInformation} encapsulating the QR Code's format info[m
[32m+[m[32m     * @throws FormatException if both format information locations cannot be parsed as[m
[32m+[m[32m     * the valid encoding of format information[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readFormatInformation = function () {[m
[32m+[m[32m        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {[m
[32m+[m[32m            return this.parsedFormatInfo;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Read top-left format info bits[m
[32m+[m[32m        var formatInfoBits1 = 0;[m
[32m+[m[32m        for (var i = 0; i < 6; i++) {[m
[32m+[m[32m            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);[m
[32m+[m[32m        }[m
[32m+[m[32m        // .. and skip a bit in the timing pattern ...[m
[32m+[m[32m        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);[m
[32m+[m[32m        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);[m
[32m+[m[32m        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);[m
[32m+[m[32m        // .. and skip a bit in the timing pattern ...[m
[32m+[m[32m        for (var j = 5; j >= 0; j--) {[m
[32m+[m[32m            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Read the top-right/bottom-left pattern too[m
[32m+[m[32m        var dimension = this.bitMatrix.getHeight();[m
[32m+[m[32m        var formatInfoBits2 = 0;[m
[32m+[m[32m        var jMin = dimension - 7;[m
[32m+[m[32m        for (var j = dimension - 1; j >= jMin; j--) {[m
[32m+[m[32m            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = dimension - 8; i < dimension; i++) {[m
[32m+[m[32m            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);[m
[32m+[m[32m        if (this.parsedFormatInfo !== null) {[m
[32m+[m[32m            return this.parsedFormatInfo;[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new FormatException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads version information from one of its two locations within the QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link Version} encapsulating the QR Code's version[m
[32m+[m[32m     * @throws FormatException if both version information locations cannot be parsed as[m
[32m+[m[32m     * the valid encoding of version information[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readVersion = function () {[m
[32m+[m[32m        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {[m
[32m+[m[32m            return this.parsedVersion;[m
[32m+[m[32m        }[m
[32m+[m[32m        var dimension = this.bitMatrix.getHeight();[m
[32m+[m[32m        var provisionalVersion = Math.floor((dimension - 17) / 4);[m
[32m+[m[32m        if (provisionalVersion <= 6) {[m
[32m+[m[32m            return Version_1.default.getVersionForNumber(provisionalVersion);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Read top-right version info: 3 wide by 6 tall[m
[32m+[m[32m        var versionBits = 0;[m
[32m+[m[32m        var ijMin = dimension - 11;[m
[32m+[m[32m        for (var j = 5; j >= 0; j--) {[m
[32m+[m[32m            for (var i = dimension - 9; i >= ijMin; i--) {[m
[32m+[m[32m                versionBits = this.copyBit(i, j, versionBits);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);[m
[32m+[m[32m        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {[m
[32m+[m[32m            this.parsedVersion = theParsedVersion;[m
[32m+[m[32m            return theParsedVersion;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Hmm, failed. Try bottom left: 6 wide by 3 tall[m
[32m+[m[32m        versionBits = 0;[m
[32m+[m[32m        for (var i = 5; i >= 0; i--) {[m
[32m+[m[32m            for (var j = dimension - 9; j >= ijMin; j--) {[m
[32m+[m[32m                versionBits = this.copyBit(i, j, versionBits);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);[m
[32m+[m[32m        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {[m
[32m+[m[32m            this.parsedVersion = theParsedVersion;[m
[32m+[m[32m            return theParsedVersion;[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new FormatException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {[m
[32m+[m[32m        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);[m
[32m+[m[32m        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the[m
[32m+[m[32m     * correct order in order to reconstruct the codewords bytes contained within the[m
[32m+[m[32m     * QR Code.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the exact number of bytes expected is not read[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.readCodewords = function () {[m
[32m+[m[32m        var formatInfo = this.readFormatInformation();[m
[32m+[m[32m        var version = this.readVersion();[m
[32m+[m[32m        // Get the data mask for the format used in this QR Code. This will exclude[m
[32m+[m[32m        // some bits from reading as we wind through the bit matrix.[m
[32m+[m[32m        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());[m
[32m+[m[32m        var dimension = this.bitMatrix.getHeight();[m
[32m+[m[32m        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);[m
[32m+[m[32m        var functionPattern = version.buildFunctionPattern();[m
[32m+[m[32m        var readingUp = true;[m
[32m+[m[32m        var result = new Uint8Array(version.getTotalCodewords());[m
[32m+[m[32m        var resultOffset = 0;[m
[32m+[m[32m        var currentByte = 0;[m
[32m+[m[32m        var bitsRead = 0;[m
[32m+[m[32m        // Read columns in pairs, from right to left[m
[32m+[m[32m        for (var j = dimension - 1; j > 0; j -= 2) {[m
[32m+[m[32m            if (j === 6) {[m
[32m+[m[32m                // Skip whole column with vertical alignment pattern[m
[32m+[m[32m                // saves time and makes the other code proceed more cleanly[m
[32m+[m[32m                j--;[m
[32m+[m[32m            }[m
[32m+[m[32m            // Read alternatingly from bottom to top then top to bottom[m
[32m+[m[32m            for (var count = 0; count < dimension; count++) {[m
[32m+[m[32m                var i = readingUp ? dimension - 1 - count : count;[m
[32m+[m[32m                for (var col = 0; col < 2; col++) {[m
[32m+[m[32m                    // Ignore bits covered by the function pattern[m
[32m+[m[32m                    if (!functionPattern.get(j - col, i)) {[m
[32m+[m[32m                        // Read a bit[m
[32m+[m[32m                        bitsRead++;[m
[32m+[m[32m                        currentByte <<= 1;[m
[32m+[m[32m                        if (this.bitMatrix.get(j - col, i)) {[m
[32m+[m[32m                            currentByte |= 1;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        // If we've made a whole byte, save it off[m
[32m+[m[32m                        if (bitsRead === 8) {[m
[32m+[m[32m                            result[resultOffset++] = /*(byte) */ currentByte;[m
[32m+[m[32m                            bitsRead = 0;[m
[32m+[m[32m                            currentByte = 0;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions[m
[32m+[m[32m        }[m
[32m+[m[32m        if (resultOffset !== version.getTotalCodewords()) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.remask = function () {[m
[32m+[m[32m        if (this.parsedFormatInfo === null) {[m
[32m+[m[32m            return; // We have no format information, and have no data mask[m
[32m+[m[32m        }[m
[32m+[m[32m        var dataMask = DataMask_1.default.values.get(this.parsedFormatInfo.getDataMask());[m
[32m+[m[32m        var dimension = this.bitMatrix.getHeight();[m
[32m+[m[32m        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Prepare the parser for a mirrored operation.[m
[32m+[m[32m     * This flag has effect only on the {@link #readFormatInformation()} and the[m
[32m+[m[32m     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the[m
[32m+[m[32m     * {@link #mirror()} method should be called.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param mirror Whether to read version and format information mirrored.[m
[32m+[m[32m     */[m
[32m+[m[32m    BitMatrixParser.prototype.setMirror = function (isMirror) {[m
[32m+[m[32m        this.parsedVersion = null;[m
[32m+[m[32m        this.parsedFormatInfo = null;[m
[32m+[m[32m        this.isMirror = isMirror;[m
[32m+[m[32m    };[m
[32m+[m[32m    /** Mirror the bit matrix in order to attempt a second reading. */[m
[32m+[m[32m    BitMatrixParser.prototype.mirror = function () {[m
[32m+[m[32m        var bitMatrix = this.bitMatrix;[m
[32m+[m[32m        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {[m
[32m+[m[32m            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {[m
[32m+[m[32m                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {[m
[32m+[m[32m                    bitMatrix.flip(y, x);[m
[32m+[m[32m                    bitMatrix.flip(x, y);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return BitMatrixParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BitMatrixParser;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..999532e[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.d.ts[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32mimport ErrorCorrectionLevel from './ErrorCorrectionLevel';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into[m
[32m+[m[32m * multiple blocks, each of which is a unit of data and error-correction codewords. Each[m
[32m+[m[32m * is represented by an instance of this class.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DataBlock {[m
[32m+[m[32m    private numDataCodewords;[m
[32m+[m[32m    private codewords;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>When QR Codes use multiple data blocks, they are actually interleaved.[m
[32m+[m[32m     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This[m
[32m+[m[32m     * method will separate the data into original blocks.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rawCodewords bytes as read directly from the QR Code[m
[32m+[m[32m     * @param version version of the QR Code[m
[32m+[m[32m     * @param ecLevel error-correction level of the QR Code[m
[32m+[m[32m     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the[m
[32m+[m[32m     *         QR Code[m
[32m+[m[32m     */[m
[32m+[m[32m    static getDataBlocks(rawCodewords: Uint8Array, version: Version, ecLevel: ErrorCorrectionLevel): DataBlock[];[m
[32m+[m[32m    getNumDataCodewords(): number;[m
[32m+[m[32m    getCodewords(): Uint8Array;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9bd5487[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataBlock.js[m
[36m@@ -0,0 +1,141 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into[m
[32m+[m[32m * multiple blocks, each of which is a unit of data and error-correction codewords. Each[m
[32m+[m[32m * is represented by an instance of this class.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DataBlock = /** @class */ (function () {[m
[32m+[m[32m    function DataBlock(numDataCodewords /*int*/, codewords) {[m
[32m+[m[32m        this.numDataCodewords = numDataCodewords;[m
[32m+[m[32m        this.codewords = codewords;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>When QR Codes use multiple data blocks, they are actually interleaved.[m
[32m+[m[32m     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This[m
[32m+[m[32m     * method will separate the data into original blocks.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param rawCodewords bytes as read directly from the QR Code[m
[32m+[m[32m     * @param version version of the QR Code[m
[32m+[m[32m     * @param ecLevel error-correction level of the QR Code[m
[32m+[m[32m     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the[m
[32m+[m[32m     *         QR Code[m
[32m+[m[32m     */[m
[32m+[m[32m    DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        if (rawCodewords.length !== version.getTotalCodewords()) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Figure out the number and size of data blocks used by this version and[m
[32m+[m[32m        // error correction level[m
[32m+[m[32m        var ecBlocks = version.getECBlocksForLevel(ecLevel);[m
[32m+[m[32m        // First count the total number of data blocks[m
[32m+[m[32m        var totalBlocks = 0;[m
[32m+[m[32m        var ecBlockArray = ecBlocks.getECBlocks();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {[m
[32m+[m[32m                var ecBlock = ecBlockArray_1_1.value;[m
[32m+[m[32m                totalBlocks += ecBlock.getCount();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now establish DataBlocks of the appropriate size and number of data codewords[m
[32m+[m[32m        var result = new Array(totalBlocks);[m
[32m+[m[32m        var numResultBlocks = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {[m
[32m+[m[32m                var ecBlock = ecBlockArray_2_1.value;[m
[32m+[m[32m                for (var i = 0; i < ecBlock.getCount(); i++) {[m
[32m+[m[32m                    var numDataCodewords = ecBlock.getDataCodewords();[m
[32m+[m[32m                    var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;[m
[32m+[m[32m                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // All blocks have the same amount of data, except that the last n[m
[32m+[m[32m        // (where n may be 0) have 1 more byte. Figure out where these start.[m
[32m+[m[32m        var shorterBlocksTotalCodewords = result[0].codewords.length;[m
[32m+[m[32m        var longerBlocksStartAt = result.length - 1;[m
[32m+[m[32m        // TYPESCRIPTPORT: check length is correct here[m
[32m+[m[32m        while (longerBlocksStartAt >= 0) {[m
[32m+[m[32m            var numCodewords = result[longerBlocksStartAt].codewords.length;[m
[32m+[m[32m            if (numCodewords === shorterBlocksTotalCodewords) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            longerBlocksStartAt--;[m
[32m+[m[32m        }[m
[32m+[m[32m        longerBlocksStartAt++;[m
[32m+[m[32m        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();[m
[32m+[m[32m        // The last elements of result may be 1 element longer[m
[32m+[m[32m        // first fill out as many elements as all of them have[m
[32m+[m[32m        var rawCodewordsOffset = 0;[m
[32m+[m[32m        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {[m
[32m+[m[32m            for (var j = 0; j < numResultBlocks; j++) {[m
[32m+[m[32m                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Fill out the last data block in the longer ones[m
[32m+[m[32m        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {[m
[32m+[m[32m            result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now add in error correction blocks[m
[32m+[m[32m        var max = result[0].codewords.length;[m
[32m+[m[32m        for (var i = shorterBlocksNumDataCodewords; i < max; i++) {[m
[32m+[m[32m            for (var j = 0; j < numResultBlocks; j++) {[m
[32m+[m[32m                var iOffset = j < longerBlocksStartAt ? i : i + 1;[m
[32m+[m[32m                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataBlock.prototype.getNumDataCodewords = function () {[m
[32m+[m[32m        return this.numDataCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    DataBlock.prototype.getCodewords = function () {[m
[32m+[m[32m        return this.codewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    return DataBlock;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataBlock;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..0fdf267[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.d.ts[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mexport declare enum DataMaskValues {[m
[32m+[m[32m    DATA_MASK_000 = 0,[m
[32m+[m[32m    DATA_MASK_001 = 1,[m
[32m+[m[32m    DATA_MASK_010 = 2,[m
[32m+[m[32m    DATA_MASK_011 = 3,[m
[32m+[m[32m    DATA_MASK_100 = 4,[m
[32m+[m[32m    DATA_MASK_101 = 5,[m
[32m+[m[32m    DATA_MASK_110 = 6,[m
[32m+[m[32m    DATA_MASK_111 = 7[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations[m
[32m+[m[32m * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,[m
[32m+[m[32m * including areas used for finder patterns, timing patterns, etc. These areas should be unused[m
[32m+[m[32m * after the point they are unmasked anyway.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position[m
[32m+[m[32m * and j is row position. In fact, as the text says, i is row position and j is column position.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DataMask {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private isMasked;[m
[32m+[m[32m    constructor(value: DataMaskValues, isMasked: (i: number, j: number) => boolean);[m
[32m+[m[32m    static values: Map<DataMaskValues, DataMask>;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Implementations of this method reverse the data masking process applied to a QR Code and[m
[32m+[m[32m     * make its bits ready to read.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits representation of QR Code bits[m
[32m+[m[32m     * @param dimension dimension of QR Code, represented by bits, being unmasked[m
[32m+[m[32m     */[m
[32m+[m[32m    unmaskBitMatrix(bits: BitMatrix, dimension: number): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d34e8e9[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js[m
[36m@@ -0,0 +1,103 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.DataMaskValues = void 0;[m
[32m+[m[32mvar DataMaskValues;[m
[32m+[m[32m(function (DataMaskValues) {[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_000"] = 0] = "DATA_MASK_000";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_001"] = 1] = "DATA_MASK_001";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_010"] = 2] = "DATA_MASK_010";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_011"] = 3] = "DATA_MASK_011";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_100"] = 4] = "DATA_MASK_100";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_101"] = 5] = "DATA_MASK_101";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_110"] = 6] = "DATA_MASK_110";[m
[32m+[m[32m    DataMaskValues[DataMaskValues["DATA_MASK_111"] = 7] = "DATA_MASK_111";[m
[32m+[m[32m})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations[m
[32m+[m[32m * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,[m
[32m+[m[32m * including areas used for finder patterns, timing patterns, etc. These areas should be unused[m
[32m+[m[32m * after the point they are unmasked anyway.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position[m
[32m+[m[32m * and j is row position. In fact, as the text says, i is row position and j is column position.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DataMask = /** @class */ (function () {[m
[32m+[m[32m    // See ISO 18004:2006 6.8.1[m
[32m+[m[32m    function DataMask(value, isMasked) {[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.isMasked = isMasked;[m
[32m+[m[32m    }[m
[32m+[m[32m    // End of enum constants.[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Implementations of this method reverse the data masking process applied to a QR Code and[m
[32m+[m[32m     * make its bits ready to read.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits representation of QR Code bits[m
[32m+[m[32m     * @param dimension dimension of QR Code, represented by bits, being unmasked[m
[32m+[m[32m     */[m
[32m+[m[32m    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {[m
[32m+[m[32m        for (var i = 0; i < dimension; i++) {[m
[32m+[m[32m            for (var j = 0; j < dimension; j++) {[m
[32m+[m[32m                if (this.isMasked(i, j)) {[m
[32m+[m[32m                    bits.flip(j, i);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DataMask.values = new Map([[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 000: mask bits for which (x + y) mod 2 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 001: mask bits for which x mod 2 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 010: mask bits for which y mod 3 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 011: mask bits for which (x + y) mod 3 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 100: mask bits for which (x/2 + y/3) mod 2 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 101: mask bits for which xy mod 2 + xy mod 3 == 0[m
[32m+[m[32m         * equivalently, such that xy mod 6 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0[m
[32m+[m[32m         * equivalently, such that xy mod 6 < 3[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],[m
[32m+[m[32m        /**[m
[32m+[m[32m         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0[m
[32m+[m[32m         * equivalently, such that (x + y + xy mod 3) mod 2 == 0[m
[32m+[m[32m         */[m
[32m+[m[32m        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],[m
[32m+[m[32m    ]);[m
[32m+[m[32m    return DataMask;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DataMask;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..df89d64[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.d.ts[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32mimport ErrorCorrectionLevel from './ErrorCorrectionLevel';[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes[m
[32m+[m[32m * in one QR Code. This class decodes the bits back into text.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class DecodedBitStreamParser {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006, 6.4.4 Table 5[m
[32m+[m[32m     */[m
[32m+[m[32m    private static ALPHANUMERIC_CHARS;[m
[32m+[m[32m    private static GB2312_SUBSET;[m
[32m+[m[32m    static decode(bytes: Uint8Array, version: Version, ecLevel: ErrorCorrectionLevel, hints: Map<DecodeHintType, any>): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See specification GBT 18284-2000[m
[32m+[m[32m     */[m
[32m+[m[32m    private static decodeHanziSegment;[m
[32m+[m[32m    private static decodeKanjiSegment;[m
[32m+[m[32m    private static decodeByteSegment;[m
[32m+[m[32m    private static toAlphaNumericChar;[m
[32m+[m[32m    private static decodeAlphanumericSegment;[m
[32m+[m[32m    private static decodeNumericSegment;[m
[32m+[m[32m    private static parseECIValue;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5e37ede[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js[m
[36m@@ -0,0 +1,344 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.decoder {*/[m
[32m+[m[32mvar BitSource_1 = require("../../common/BitSource");[m
[32m+[m[32mvar CharacterSetECI_1 = require("../../common/CharacterSetECI");[m
[32m+[m[32mvar DecoderResult_1 = require("../../common/DecoderResult");[m
[32m+[m[32mvar StringUtils_1 = require("../../common/StringUtils");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32mvar StringEncoding_1 = require("../../util/StringEncoding");[m
[32m+[m[32mvar Mode_1 = require("./Mode");[m
[32m+[m[32m/*import java.io.UnsupportedEncodingException;*/[m
[32m+[m[32m/*import java.util.ArrayList;*/[m
[32m+[m[32m/*import java.util.Collection;*/[m
[32m+[m[32m/*import java.util.List;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes[m
[32m+[m[32m * in one QR Code. This class decodes the bits back into text.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar DecodedBitStreamParser = /** @class */ (function () {[m
[32m+[m[32m    function DecodedBitStreamParser() {[m
[32m+[m[32m    }[m
[32m+[m[32m    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {[m
[32m+[m[32m        var bits = new BitSource_1.default(bytes);[m
[32m+[m[32m        var result = new StringBuilder_1.default();[m
[32m+[m[32m        var byteSegments = new Array(); // 1[m
[32m+[m[32m        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below[m
[32m+[m[32m        var symbolSequence = -1;[m
[32m+[m[32m        var parityData = -1;[m
[32m+[m[32m        try {[m
[32m+[m[32m            var currentCharacterSetECI = null;[m
[32m+[m[32m            var fc1InEffect = false;[m
[32m+[m[32m            var mode = void 0;[m
[32m+[m[32m            do {[m
[32m+[m[32m                // While still another segment to read...[m
[32m+[m[32m                if (bits.available() < 4) {[m
[32m+[m[32m                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here[m
[32m+[m[32m                    mode = Mode_1.default.TERMINATOR;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    var modeBits = bits.readBits(4);[m
[32m+[m[32m                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits[m
[32m+[m[32m                }[m
[32m+[m[32m                switch (mode) {[m
[32m+[m[32m                    case Mode_1.default.TERMINATOR:[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode_1.default.FNC1_FIRST_POSITION:[m
[32m+[m[32m                    case Mode_1.default.FNC1_SECOND_POSITION:[m
[32m+[m[32m                        // We do little with FNC1 except alter the parsed result a bit according to the spec[m
[32m+[m[32m                        fc1InEffect = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode_1.default.STRUCTURED_APPEND:[m
[32m+[m[32m                        if (bits.available() < 16) {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        // sequence number and parity is added later to the result metadata[m
[32m+[m[32m                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue[m
[32m+[m[32m                        symbolSequence = bits.readBits(8);[m
[32m+[m[32m                        parityData = bits.readBits(8);[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode_1.default.ECI:[m
[32m+[m[32m                        // Count doesn't apply to ECI[m
[32m+[m[32m                        var value = DecodedBitStreamParser.parseECIValue(bits);[m
[32m+[m[32m                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);[m
[32m+[m[32m                        if (currentCharacterSetECI === null) {[m
[32m+[m[32m                            throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case Mode_1.default.HANZI:[m
[32m+[m[32m                        // First handle Hanzi mode which does not start with character count[m
[32m+[m[32m                        // Chinese mode contains a sub set indicator right after mode indicator[m
[32m+[m[32m                        var subset = bits.readBits(4);[m
[32m+[m[32m                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));[m
[32m+[m[32m                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {[m
[32m+[m[32m                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        // "Normal" QR code modes:[m
[32m+[m[32m                        // How many characters will follow, encoded in this mode?[m
[32m+[m[32m                        var count = bits.readBits(mode.getCharacterCountBits(version));[m
[32m+[m[32m                        switch (mode) {[m
[32m+[m[32m                            case Mode_1.default.NUMERIC:[m
[32m+[m[32m                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Mode_1.default.ALPHANUMERIC:[m
[32m+[m[32m                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Mode_1.default.BYTE:[m
[32m+[m[32m                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            case Mode_1.default.KANJI:[m
[32m+[m[32m                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);[m
[32m+[m[32m                                break;[m
[32m+[m[32m                            default:[m
[32m+[m[32m                                throw new FormatException_1.default();[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            } while (mode !== Mode_1.default.TERMINATOR);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (iae /*: IllegalArgumentException*/) {[m
[32m+[m[32m            // from readBits() calls[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See specification GBT 18284-2000[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {[m
[32m+[m[32m        // Don't crash trying to read more bits than we have available.[m
[32m+[m[32m        if (count * 13 > bits.available()) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Each character will require 2 bytes. Read the characters as 2-byte pairs[m
[32m+[m[32m        // and decode as GB2312 afterwards[m
[32m+[m[32m        var buffer = new Uint8Array(2 * count);[m
[32m+[m[32m        var offset = 0;[m
[32m+[m[32m        while (count > 0) {[m
[32m+[m[32m            // Each 13 bits encodes a 2-byte character[m
[32m+[m[32m            var twoBytes = bits.readBits(13);[m
[32m+[m[32m            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);[m
[32m+[m[32m            if (assembledTwoBytes < 0x003BF) {[m
[32m+[m[32m                // In the 0xA1A1 to 0xAAFE range[m
[32m+[m[32m                assembledTwoBytes += 0x0A1A1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // In the 0xB0A1 to 0xFAFE range[m
[32m+[m[32m                assembledTwoBytes += 0x0A6A1;[m
[32m+[m[32m            }[m
[32m+[m[32m            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);[m
[32m+[m[32m            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);[m
[32m+[m[32m            offset += 2;[m
[32m+[m[32m            count--;[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));[m
[32m+[m[32m            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            throw new FormatException_1.default(ignored);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {[m
[32m+[m[32m        // Don't crash trying to read more bits than we have available.[m
[32m+[m[32m        if (count * 13 > bits.available()) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Each character will require 2 bytes. Read the characters as 2-byte pairs[m
[32m+[m[32m        // and decode as Shift_JIS afterwards[m
[32m+[m[32m        var buffer = new Uint8Array(2 * count);[m
[32m+[m[32m        var offset = 0;[m
[32m+[m[32m        while (count > 0) {[m
[32m+[m[32m            // Each 13 bits encodes a 2-byte character[m
[32m+[m[32m            var twoBytes = bits.readBits(13);[m
[32m+[m[32m            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);[m
[32m+[m[32m            if (assembledTwoBytes < 0x01F00) {[m
[32m+[m[32m                // In the 0x8140 to 0x9FFC range[m
[32m+[m[32m                assembledTwoBytes += 0x08140;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // In the 0xE040 to 0xEBBF range[m
[32m+[m[32m                assembledTwoBytes += 0x0C140;[m
[32m+[m[32m            }[m
[32m+[m[32m            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);[m
[32m+[m[32m            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;[m
[32m+[m[32m            offset += 2;[m
[32m+[m[32m            count--;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Shift_JIS may not be supported in some environments:[m
[32m+[m[32m        try {[m
[32m+[m[32m            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));[m
[32m+[m[32m            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            throw new FormatException_1.default(ignored);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {[m
[32m+[m[32m        // Don't crash trying to read more bits than we have available.[m
[32m+[m[32m        if (8 * count > bits.available()) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var readBytes = new Uint8Array(count);[m
[32m+[m[32m        for (var i = 0; i < count; i++) {[m
[32m+[m[32m            readBytes[i] = /*(byte) */ bits.readBits(8);[m
[32m+[m[32m        }[m
[32m+[m[32m        var encoding;[m
[32m+[m[32m        if (currentCharacterSetECI === null) {[m
[32m+[m[32m            // The spec isn't clear on this mode; see[m
[32m+[m[32m            // section 6.4.5: t does not say which encoding to assuming[m
[32m+[m[32m            // upon decoding. I have seen ISO-8859-1 used as well as[m
[32m+[m[32m            // Shift_JIS -- without anything like an ECI designator to[m
[32m+[m[32m            // give a hint.[m
[32m+[m[32m            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            encoding = currentCharacterSetECI.getName();[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            result.append(StringEncoding_1.default.decode(readBytes, encoding));[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            throw new FormatException_1.default(ignored);[m
[32m+[m[32m        }[m
[32m+[m[32m        byteSegments.push(readBytes);[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {[m
[32m+[m[32m        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {[m
[32m+[m[32m        // Read two characters at a time[m
[32m+[m[32m        var start = result.length();[m
[32m+[m[32m        while (count > 1) {[m
[32m+[m[32m            if (bits.available() < 11) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var nextTwoCharsBits = bits.readBits(11);[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));[m
[32m+[m[32m            count -= 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (count === 1) {[m
[32m+[m[32m            // special case: one character left[m
[32m+[m[32m            if (bits.available() < 6) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));[m
[32m+[m[32m        }[m
[32m+[m[32m        // See section 6.4.8.1, 6.4.8.2[m
[32m+[m[32m        if (fc1InEffect) {[m
[32m+[m[32m            // We need to massage the result a bit if in an FNC1 mode:[m
[32m+[m[32m            for (var i = start; i < result.length(); i++) {[m
[32m+[m[32m                if (result.charAt(i) === '%') {[m
[32m+[m[32m                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {[m
[32m+[m[32m                        // %% is rendered as %[m
[32m+[m[32m                        result.deleteCharAt(i + 1);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        // In alpha mode, % should be converted to FNC1 separator 0x1D[m
[32m+[m[32m                        result.setCharAt(i, String.fromCharCode(0x1D));[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {[m
[32m+[m[32m        // Read three digits at a time[m
[32m+[m[32m        while (count >= 3) {[m
[32m+[m[32m            // Each 10 bits encodes three digits[m
[32m+[m[32m            if (bits.available() < 10) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var threeDigitsBits = bits.readBits(10);[m
[32m+[m[32m            if (threeDigitsBits >= 1000) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));[m
[32m+[m[32m            count -= 3;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (count === 2) {[m
[32m+[m[32m            // Two digits left over to read, encoded in 7 bits[m
[32m+[m[32m            if (bits.available() < 7) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var twoDigitsBits = bits.readBits(7);[m
[32m+[m[32m            if (twoDigitsBits >= 100) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (count === 1) {[m
[32m+[m[32m            // One digit left over to read[m
[32m+[m[32m            if (bits.available() < 4) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            var digitBits = bits.readBits(4);[m
[32m+[m[32m            if (digitBits >= 10) {[m
[32m+[m[32m                throw new FormatException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    DecodedBitStreamParser.parseECIValue = function (bits) {[m
[32m+[m[32m        var firstByte = bits.readBits(8);[m
[32m+[m[32m        if ((firstByte & 0x80) === 0) {[m
[32m+[m[32m            // just one byte[m
[32m+[m[32m            return firstByte & 0x7F;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ((firstByte & 0xC0) === 0x80) {[m
[32m+[m[32m            // two bytes[m
[32m+[m[32m            var secondByte = bits.readBits(8);[m
[32m+[m[32m            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ((firstByte & 0xE0) === 0xC0) {[m
[32m+[m[32m            // three bytes[m
[32m+[m[32m            var secondThirdBytes = bits.readBits(16);[m
[32m+[m[32m            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new FormatException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006, 6.4.4 Table 5[m
[32m+[m[32m     */[m
[32m+[m[32m    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';[m
[32m+[m[32m    DecodedBitStreamParser.GB2312_SUBSET = 1;[m
[32m+[m[32m    return DecodedBitStreamParser;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = DecodedBitStreamParser;[m
[32m+[m[32m// function Uint8ArrayToString(a: Uint8Array): string {[m
[32m+[m[32m//     const CHUNK_SZ = 0x8000;[m
[32m+[m[32m//     const c = new StringBuilder();[m
[32m+[m[32m//     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {[m
[32m+[m[32m//         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));[m
[32m+[m[32m//     }[m
[32m+[m[32m//     return c.toString();[m
[32m+[m[32m// }[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..a87958a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.d.ts[m
[36m@@ -0,0 +1,44 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport DecoderResult from '../../common/DecoderResult';[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the QR Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Decoder {[m
[32m+[m[32m    private rsDecoder;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.[m
[32m+[m[32m     * "true" is taken to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image booleans representing white/black QR Code modules[m
[32m+[m[32m     * @param hints decoding hints that should be used to influence decoding[m
[32m+[m[32m     * @return text and bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the QR Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeBooleanArray(image: boolean[][], hints?: Map<DecodeHintType, any>): DecoderResult;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits booleans representing white/black QR Code modules[m
[32m+[m[32m     * @param hints decoding hints that should be used to influence decoding[m
[32m+[m[32m     * @return text and bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the QR Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    decodeBitMatrix(bits: BitMatrix, hints?: Map<DecodeHintType, any>): DecoderResult;[m
[32m+[m[32m    private decodeBitMatrixParser;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place using Reed-Solomon error correction.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewordBytes data and error correction codewords[m
[32m+[m[32m     * @param numDataCodewords number of codewords that are data bytes[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    private correctErrors;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..72661ae[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js[m
[36m@@ -0,0 +1,195 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.decoder {*/[m
[32m+[m[32mvar ChecksumException_1 = require("../../ChecksumException");[m
[32m+[m[32mvar BitMatrix_1 = require("../../common/BitMatrix");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar ReedSolomonDecoder_1 = require("../../common/reedsolomon/ReedSolomonDecoder");[m
[32m+[m[32mvar BitMatrixParser_1 = require("./BitMatrixParser");[m
[32m+[m[32mvar DataBlock_1 = require("./DataBlock");[m
[32m+[m[32mvar DecodedBitStreamParser_1 = require("./DecodedBitStreamParser");[m
[32m+[m[32mvar QRCodeDecoderMetaData_1 = require("./QRCodeDecoderMetaData");[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting[m
[32m+[m[32m * the QR Code from an image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Decoder = /** @class */ (function () {[m
[32m+[m[32m    function Decoder() {[m
[32m+[m[32m        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);[m
[32m+[m[32m    }[m
[32m+[m[32m    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {[m
[32m+[m[32m    //   return decode(image, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.[m
[32m+[m[32m     * "true" is taken to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image booleans representing white/black QR Code modules[m
[32m+[m[32m     * @param hints decoding hints that should be used to influence decoding[m
[32m+[m[32m     * @return text and bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the QR Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.decodeBooleanArray = function (image, hints) {[m
[32m+[m[32m        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);[m
[32m+[m[32m    };[m
[32m+[m[32m    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {[m
[32m+[m[32m    //   return decode(bits, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param bits booleans representing white/black QR Code modules[m
[32m+[m[32m     * @param hints decoding hints that should be used to influence decoding[m
[32m+[m[32m     * @return text and bytes encoded within the QR Code[m
[32m+[m[32m     * @throws FormatException if the QR Code cannot be decoded[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.decodeBitMatrix = function (bits, hints) {[m
[32m+[m[32m        // Construct a parser and read version, error-correction level[m
[32m+[m[32m        var parser = new BitMatrixParser_1.default(bits);[m
[32m+[m[32m        var ex = null;[m
[32m+[m[32m        try {[m
[32m+[m[32m            return this.decodeBitMatrixParser(parser, hints);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e /*: FormatException, ChecksumException*/) {[m
[32m+[m[32m            ex = e;[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            // Revert the bit matrix[m
[32m+[m[32m            parser.remask();[m
[32m+[m[32m            // Will be attempting a mirrored reading of the version and format info.[m
[32m+[m[32m            parser.setMirror(true);[m
[32m+[m[32m            // Preemptively read the version.[m
[32m+[m[32m            parser.readVersion();[m
[32m+[m[32m            // Preemptively read the format information.[m
[32m+[m[32m            parser.readFormatInformation();[m
[32m+[m[32m            /*[m
[32m+[m[32m             * Since we're here, this means we have successfully detected some kind[m
[32m+[m[32m             * of version and format information when mirrored. This is a good sign,[m
[32m+[m[32m             * that the QR code may be mirrored, and we should try once more with a[m
[32m+[m[32m             * mirrored content.[m
[32m+[m[32m             */[m
[32m+[m[32m            // Prepare for a mirrored reading.[m
[32m+[m[32m            parser.mirror();[m
[32m+[m[32m            var result = this.decodeBitMatrixParser(parser, hints);[m
[32m+[m[32m            // Success! Notify the caller that the code was mirrored.[m
[32m+[m[32m            result.setOther(new QRCodeDecoderMetaData_1.default(true));[m
[32m+[m[32m            return result;[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e /*FormatException | ChecksumException*/) {[m
[32m+[m[32m            // Throw the exception from the original reading[m
[32m+[m[32m            if (ex !== null) {[m
[32m+[m[32m                throw ex;[m
[32m+[m[32m            }[m
[32m+[m[32m            throw e;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        var version = parser.readVersion();[m
[32m+[m[32m        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();[m
[32m+[m[32m        // Read codewords[m
[32m+[m[32m        var codewords = parser.readCodewords();[m
[32m+[m[32m        // Separate into data blocks[m
[32m+[m[32m        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);[m
[32m+[m[32m        // Count total number of data bytes[m
[32m+[m[32m        var totalBytes = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {[m
[32m+[m[32m                var dataBlock = dataBlocks_1_1.value;[m
[32m+[m[32m                totalBytes += dataBlock.getNumDataCodewords();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        var resultBytes = new Uint8Array(totalBytes);[m
[32m+[m[32m        var resultOffset = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            // Error-correct and copy data blocks together into a stream of bytes[m
[32m+[m[32m            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {[m
[32m+[m[32m                var dataBlock = dataBlocks_2_1.value;[m
[32m+[m[32m                var codewordBytes = dataBlock.getCodewords();[m
[32m+[m[32m                var numDataCodewords = dataBlock.getNumDataCodewords();[m
[32m+[m[32m                this.correctErrors(codewordBytes, numDataCodewords);[m
[32m+[m[32m                for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m                    resultBytes[resultOffset++] = codewordBytes[i];[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Decode the contents of that stream of bytes[m
[32m+[m[32m        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to[m
[32m+[m[32m     * correct the errors in-place using Reed-Solomon error correction.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param codewordBytes data and error correction codewords[m
[32m+[m[32m     * @param numDataCodewords number of codewords that are data bytes[m
[32m+[m[32m     * @throws ChecksumException if error correction fails[m
[32m+[m[32m     */[m
[32m+[m[32m    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {[m
[32m+[m[32m        // const numCodewords = codewordBytes.length;[m
[32m+[m[32m        // First read into an array of ints[m
[32m+[m[32m        var codewordsInts = new Int32Array(codewordBytes);[m
[32m+[m[32m        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?[m
[32m+[m[32m        // const codewordsInts = new Int32Array(numCodewords)[m
[32m+[m[32m        // for (let i = 0; i < numCodewords; i++) {[m
[32m+[m[32m        //   codewordsInts[i] = codewordBytes[i] & 0xFF[m
[32m+[m[32m        // }[m
[32m+[m[32m        try {[m
[32m+[m[32m            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: ReedSolomonException*/) {[m
[32m+[m[32m            throw new ChecksumException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Copy back into array of bytes -- only need to worry about the bytes that were data[m
[32m+[m[32m        // We don't care about errors in the error-correction codewords[m
[32m+[m[32m        for (var i = 0; i < numDataCodewords; i++) {[m
[32m+[m[32m            codewordBytes[i] = /*(byte) */ codewordsInts[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    return Decoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Decoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..fdf4d6b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.d.ts[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the parameters for one error-correction block in one symbol version.[m
[32m+[m[32m * This includes the number of data codewords, and the number of times a block with these[m
[32m+[m[32m * parameters is used consecutively in the QR code version's format.</p>[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ECB {[m
[32m+[m[32m    private count;[m
[32m+[m[32m    private dataCodewords;[m
[32m+[m[32m    constructor(count: number, dataCodewords: number);[m
[32m+[m[32m    getCount(): number;[m
[32m+[m[32m    getDataCodewords(): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js[m
[1mnew file mode 100644[m
[1mindex 0000000..460917c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECB.js[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates the parameters for one error-correction block in one symbol version.[m
[32m+[m[32m * This includes the number of data codewords, and the number of times a block with these[m
[32m+[m[32m * parameters is used consecutively in the QR code version's format.</p>[m
[32m+[m[32m */[m
[32m+[m[32mvar ECB = /** @class */ (function () {[m
[32m+[m[32m    function ECB(count /*int*/, dataCodewords /*int*/) {[m
[32m+[m[32m        this.count = count;[m
[32m+[m[32m        this.dataCodewords = dataCodewords;[m
[32m+[m[32m    }[m
[32m+[m[32m    ECB.prototype.getCount = function () {[m
[32m+[m[32m        return this.count;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECB.prototype.getDataCodewords = function () {[m
[32m+[m[32m        return this.dataCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ECB;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ECB;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..bcaf448[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.d.ts[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mimport ECB from './ECB';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will[m
[32m+[m[32m * use blocks of differing sizes within one version, so, this encapsulates the parameters for[m
[32m+[m[32m * each set of blocks. It also holds the number of error-correction codewords per block since it[m
[32m+[m[32m * will be the same across all blocks within one version.</p>[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ECBlocks {[m
[32m+[m[32m    private ecCodewordsPerBlock;[m
[32m+[m[32m    private ecBlocks;[m
[32m+[m[32m    constructor(ecCodewordsPerBlock: number, ...ecBlocks: ECB[]);[m
[32m+[m[32m    getECCodewordsPerBlock(): number;[m
[32m+[m[32m    getNumBlocks(): number;[m
[32m+[m[32m    getTotalECCodewords(): number;[m
[32m+[m[32m    getECBlocks(): ECB[];[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1788bce[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ECBlocks.js[m
[36m@@ -0,0 +1,59 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will[m
[32m+[m[32m * use blocks of differing sizes within one version, so, this encapsulates the parameters for[m
[32m+[m[32m * each set of blocks. It also holds the number of error-correction codewords per block since it[m
[32m+[m[32m * will be the same across all blocks within one version.</p>[m
[32m+[m[32m */[m
[32m+[m[32mvar ECBlocks = /** @class */ (function () {[m
[32m+[m[32m    function ECBlocks(ecCodewordsPerBlock /*int*/) {[m
[32m+[m[32m        var ecBlocks = [];[m
[32m+[m[32m        for (var _i = 1; _i < arguments.length; _i++) {[m
[32m+[m[32m            ecBlocks[_i - 1] = arguments[_i];[m
[32m+[m[32m        }[m
[32m+[m[32m        this.ecCodewordsPerBlock = ecCodewordsPerBlock;[m
[32m+[m[32m        this.ecBlocks = ecBlocks;[m
[32m+[m[32m    }[m
[32m+[m[32m    ECBlocks.prototype.getECCodewordsPerBlock = function () {[m
[32m+[m[32m        return this.ecCodewordsPerBlock;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECBlocks.prototype.getNumBlocks = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        var ecBlocks = this.ecBlocks;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {[m
[32m+[m[32m                var ecBlock = ecBlocks_1_1.value;[m
[32m+[m[32m                total += ecBlock.getCount();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return total;[m
[32m+[m[32m    };[m
[32m+[m[32m    ECBlocks.prototype.getTotalECCodewords = function () {[m
[32m+[m[32m        return this.ecCodewordsPerBlock * this.getNumBlocks();[m
[32m+[m[32m    };[m
[32m+[m[32m    ECBlocks.prototype.getECBlocks = function () {[m
[32m+[m[32m        return this.ecBlocks;[m
[32m+[m[32m    };[m
[32m+[m[32m    return ECBlocks;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ECBlocks;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..d7a1d8d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.d.ts[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32mexport declare enum ErrorCorrectionLevelValues {[m
[32m+[m[32m    L = 0,[m
[32m+[m[32m    M = 1,[m
[32m+[m[32m    Q = 2,[m
[32m+[m[32m    H = 3[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels[m
[32m+[m[32m * defined by the QR code standard.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ErrorCorrectionLevel {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private stringValue;[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    private static FOR_BITS;[m
[32m+[m[32m    private static FOR_VALUE;[m
[32m+[m[32m    /** L = ~7% correction */[m
[32m+[m[32m    static L: ErrorCorrectionLevel;[m
[32m+[m[32m    /** M = ~15% correction */[m
[32m+[m[32m    static M: ErrorCorrectionLevel;[m
[32m+[m[32m    /** Q = ~25% correction */[m
[32m+[m[32m    static Q: ErrorCorrectionLevel;[m
[32m+[m[32m    /** H = ~30% correction */[m
[32m+[m[32m    static H: ErrorCorrectionLevel;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    getValue(): ErrorCorrectionLevelValues;[m
[32m+[m[32m    getBits(): number;[m
[32m+[m[32m    static fromString(s: string): ErrorCorrectionLevel;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    equals(o: any): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bits int containing the two bits encoding a QR Code's error correction level[m
[32m+[m[32m     * @return ErrorCorrectionLevel representing the encoded error correction level[m
[32m+[m[32m     */[m
[32m+[m[32m    static forBits(bits: number): ErrorCorrectionLevel;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js[m
[1mnew file mode 100644[m
[1mindex 0000000..9900e40[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/ErrorCorrectionLevel.js[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.ErrorCorrectionLevelValues = void 0;[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.decoder {*/[m
[32m+[m[32mvar ArgumentException_1 = require("../../ArgumentException");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32mvar ErrorCorrectionLevelValues;[m
[32m+[m[32m(function (ErrorCorrectionLevelValues) {[m
[32m+[m[32m    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["L"] = 0] = "L";[m
[32m+[m[32m    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["M"] = 1] = "M";[m
[32m+[m[32m    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["Q"] = 2] = "Q";[m
[32m+[m[32m    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["H"] = 3] = "H";[m
[32m+[m[32m})(ErrorCorrectionLevelValues = exports.ErrorCorrectionLevelValues || (exports.ErrorCorrectionLevelValues = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels[m
[32m+[m[32m * defined by the QR code standard.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar ErrorCorrectionLevel = /** @class */ (function () {[m
[32m+[m[32m    function ErrorCorrectionLevel(value, stringValue, bits /*int*/) {[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.stringValue = stringValue;[m
[32m+[m[32m        this.bits = bits;[m
[32m+[m[32m        ErrorCorrectionLevel.FOR_BITS.set(bits, this);[m
[32m+[m[32m        ErrorCorrectionLevel.FOR_VALUE.set(value, this);[m
[32m+[m[32m    }[m
[32m+[m[32m    ErrorCorrectionLevel.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrectionLevel.prototype.getBits = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrectionLevel.fromString = function (s) {[m
[32m+[m[32m        switch (s) {[m
[32m+[m[32m            case 'L': return ErrorCorrectionLevel.L;[m
[32m+[m[32m            case 'M': return ErrorCorrectionLevel.M;[m
[32m+[m[32m            case 'Q': return ErrorCorrectionLevel.Q;[m
[32m+[m[32m            case 'H': return ErrorCorrectionLevel.H;[m
[32m+[m[32m            default: throw new ArgumentException_1.default(s + 'not available');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrectionLevel.prototype.toString = function () {[m
[32m+[m[32m        return this.stringValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrectionLevel.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof ErrorCorrectionLevel)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.value === other.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bits int containing the two bits encoding a QR Code's error correction level[m
[32m+[m[32m     * @return ErrorCorrectionLevel representing the encoded error correction level[m
[32m+[m[32m     */[m
[32m+[m[32m    ErrorCorrectionLevel.forBits = function (bits /*int*/) {[m
[32m+[m[32m        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return ErrorCorrectionLevel.FOR_BITS.get(bits);[m
[32m+[m[32m    };[m
[32m+[m[32m    ErrorCorrectionLevel.FOR_BITS = new Map();[m
[32m+[m[32m    ErrorCorrectionLevel.FOR_VALUE = new Map();[m
[32m+[m[32m    /** L = ~7% correction */[m
[32m+[m[32m    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);[m
[32m+[m[32m    /** M = ~15% correction */[m
[32m+[m[32m    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);[m
[32m+[m[32m    /** Q = ~25% correction */[m
[32m+[m[32m    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);[m
[32m+[m[32m    /** H = ~30% correction */[m
[32m+[m[32m    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);[m
[32m+[m[32m    return ErrorCorrectionLevel;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ErrorCorrectionLevel;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9471f2c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.d.ts[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32mimport ErrorCorrectionLevel from './ErrorCorrectionLevel';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a QR Code's format information, including the data mask used and[m
[32m+[m[32m * error correction level.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see DataMask[m
[32m+[m[32m * @see ErrorCorrectionLevel[m
[32m+[m[32m */[m
[32m+[m[32mexport default class FormatInformation {[m
[32m+[m[32m    private static FORMAT_INFO_MASK_QR;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006, Annex C, Table C.1[m
[32m+[m[32m     */[m
[32m+[m[32m    private static FORMAT_INFO_DECODE_LOOKUP;[m
[32m+[m[32m    private errorCorrectionLevel;[m
[32m+[m[32m    private dataMask;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    static numBitsDiffering(a: number, b: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param maskedFormatInfo1 format info indicator, with mask still applied[m
[32m+[m[32m     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time[m
[32m+[m[32m     *  to establish best match[m
[32m+[m[32m     * @return information about the format it specifies, or {@code null}[m
[32m+[m[32m     *  if doesn't seem to match any known pattern[m
[32m+[m[32m     */[m
[32m+[m[32m    static decodeFormatInformation(maskedFormatInfo1: number, maskedFormatInfo2: number): FormatInformation;[m
[32m+[m[32m    private static doDecodeFormatInformation;[m
[32m+[m[32m    getErrorCorrectionLevel(): ErrorCorrectionLevel;[m
[32m+[m[32m    getDataMask(): number;[m
[32m+[m[32m    hashCode(): number;[m
[32m+[m[32m    equals(o: Object): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6223992[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js[m
[36m@@ -0,0 +1,168 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.decoder {*/[m
[32m+[m[32mvar ErrorCorrectionLevel_1 = require("./ErrorCorrectionLevel");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a QR Code's format information, including the data mask used and[m
[32m+[m[32m * error correction level.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m * @see DataMask[m
[32m+[m[32m * @see ErrorCorrectionLevel[m
[32m+[m[32m */[m
[32m+[m[32mvar FormatInformation = /** @class */ (function () {[m
[32m+[m[32m    function FormatInformation(formatInfo /*int*/) {[m
[32m+[m[32m        // Bits 3,4[m
[32m+[m[32m        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);[m
[32m+[m[32m        // Bottom 3 bits[m
[32m+[m[32m        this.dataMask = /*(byte) */ (formatInfo & 0x07);[m
[32m+[m[32m    }[m
[32m+[m[32m    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {[m
[32m+[m[32m        return Integer_1.default.bitCount(a ^ b);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param maskedFormatInfo1 format info indicator, with mask still applied[m
[32m+[m[32m     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time[m
[32m+[m[32m     *  to establish best match[m
[32m+[m[32m     * @return information about the format it specifies, or {@code null}[m
[32m+[m[32m     *  if doesn't seem to match any known pattern[m
[32m+[m[32m     */[m
[32m+[m[32m    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {[m
[32m+[m[32m        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);[m
[32m+[m[32m        if (formatInfo !== null) {[m
[32m+[m[32m            return formatInfo;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Should return null, but, some QR codes apparently[m
[32m+[m[32m        // do not mask this info. Try again by actually masking the pattern[m
[32m+[m[32m        // first[m
[32m+[m[32m        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);[m
[32m+[m[32m    };[m
[32m+[m[32m    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing[m
[32m+[m[32m        var bestDifference = Number.MAX_SAFE_INTEGER;[m
[32m+[m[32m        var bestFormatInfo = 0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var decodeInfo = _c.value;[m
[32m+[m[32m                var targetInfo = decodeInfo[0];[m
[32m+[m[32m                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {[m
[32m+[m[32m                    // Found an exact match[m
[32m+[m[32m                    return new FormatInformation(decodeInfo[1]);[m
[32m+[m[32m                }[m
[32m+[m[32m                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);[m
[32m+[m[32m                if (bitsDifference < bestDifference) {[m
[32m+[m[32m                    bestFormatInfo = decodeInfo[1];[m
[32m+[m[32m                    bestDifference = bitsDifference;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (maskedFormatInfo1 !== maskedFormatInfo2) {[m
[32m+[m[32m                    // also try the other option[m
[32m+[m[32m                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);[m
[32m+[m[32m                    if (bitsDifference < bestDifference) {[m
[32m+[m[32m                        bestFormatInfo = decodeInfo[1];[m
[32m+[m[32m                        bestDifference = bitsDifference;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits[m
[32m+[m[32m        // differing means we found a match[m
[32m+[m[32m        if (bestDifference <= 3) {[m
[32m+[m[32m            return new FormatInformation(bestFormatInfo);[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    FormatInformation.prototype.getErrorCorrectionLevel = function () {[m
[32m+[m[32m        return this.errorCorrectionLevel;[m
[32m+[m[32m    };[m
[32m+[m[32m    FormatInformation.prototype.getDataMask = function () {[m
[32m+[m[32m        return this.dataMask;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    FormatInformation.prototype.hashCode = function () {[m
[32m+[m[32m        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    FormatInformation.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof FormatInformation)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.errorCorrectionLevel === other.errorCorrectionLevel &&[m
[32m+[m[32m            this.dataMask === other.dataMask;[m
[32m+[m[32m    };[m
[32m+[m[32m    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006, Annex C, Table C.1[m
[32m+[m[32m     */[m
[32m+[m[32m    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [[m
[32m+[m[32m        Int32Array.from([0x5412, 0x00]),[m
[32m+[m[32m        Int32Array.from([0x5125, 0x01]),[m
[32m+[m[32m        Int32Array.from([0x5E7C, 0x02]),[m
[32m+[m[32m        Int32Array.from([0x5B4B, 0x03]),[m
[32m+[m[32m        Int32Array.from([0x45F9, 0x04]),[m
[32m+[m[32m        Int32Array.from([0x40CE, 0x05]),[m
[32m+[m[32m        Int32Array.from([0x4F97, 0x06]),[m
[32m+[m[32m        Int32Array.from([0x4AA0, 0x07]),[m
[32m+[m[32m        Int32Array.from([0x77C4, 0x08]),[m
[32m+[m[32m        Int32Array.from([0x72F3, 0x09]),[m
[32m+[m[32m        Int32Array.from([0x7DAA, 0x0A]),[m
[32m+[m[32m        Int32Array.from([0x789D, 0x0B]),[m
[32m+[m[32m        Int32Array.from([0x662F, 0x0C]),[m
[32m+[m[32m        Int32Array.from([0x6318, 0x0D]),[m
[32m+[m[32m        Int32Array.from([0x6C41, 0x0E]),[m
[32m+[m[32m        Int32Array.from([0x6976, 0x0F]),[m
[32m+[m[32m        Int32Array.from([0x1689, 0x10]),[m
[32m+[m[32m        Int32Array.from([0x13BE, 0x11]),[m
[32m+[m[32m        Int32Array.from([0x1CE7, 0x12]),[m
[32m+[m[32m        Int32Array.from([0x19D0, 0x13]),[m
[32m+[m[32m        Int32Array.from([0x0762, 0x14]),[m
[32m+[m[32m        Int32Array.from([0x0255, 0x15]),[m
[32m+[m[32m        Int32Array.from([0x0D0C, 0x16]),[m
[32m+[m[32m        Int32Array.from([0x083B, 0x17]),[m
[32m+[m[32m        Int32Array.from([0x355F, 0x18]),[m
[32m+[m[32m        Int32Array.from([0x3068, 0x19]),[m
[32m+[m[32m        Int32Array.from([0x3F31, 0x1A]),[m
[32m+[m[32m        Int32Array.from([0x3A06, 0x1B]),[m
[32m+[m[32m        Int32Array.from([0x24B4, 0x1C]),[m
[32m+[m[32m        Int32Array.from([0x2183, 0x1D]),[m
[32m+[m[32m        Int32Array.from([0x2EDA, 0x1E]),[m
[32m+[m[32m        Int32Array.from([0x2BED, 0x1F]),[m
[32m+[m[32m    ];[m
[32m+[m[32m    return FormatInformation;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = FormatInformation;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..44d49f6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.d.ts[m
[36m@@ -0,0 +1,56 @@[m
[32m+[m[32mimport Version from './Version';[m
[32m+[m[32mexport declare enum ModeValues {[m
[32m+[m[32m    TERMINATOR = 0,[m
[32m+[m[32m    NUMERIC = 1,[m
[32m+[m[32m    ALPHANUMERIC = 2,[m
[32m+[m[32m    STRUCTURED_APPEND = 3,[m
[32m+[m[32m    BYTE = 4,[m
[32m+[m[32m    ECI = 5,[m
[32m+[m[32m    KANJI = 6,[m
[32m+[m[32m    FNC1_FIRST_POSITION = 7,[m
[32m+[m[32m    FNC1_SECOND_POSITION = 8,[m
[32m+[m[32m    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */[m
[32m+[m[32m    HANZI = 9[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which[m
[32m+[m[32m * data can be encoded to bits in the QR code standard.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Mode {[m
[32m+[m[32m    private value;[m
[32m+[m[32m    private stringValue;[m
[32m+[m[32m    private characterCountBitsForVersions;[m
[32m+[m[32m    private bits;[m
[32m+[m[32m    private static FOR_BITS;[m
[32m+[m[32m    private static FOR_VALUE;[m
[32m+[m[32m    static TERMINATOR: Mode;[m
[32m+[m[32m    static NUMERIC: Mode;[m
[32m+[m[32m    static ALPHANUMERIC: Mode;[m
[32m+[m[32m    static STRUCTURED_APPEND: Mode;[m
[32m+[m[32m    static BYTE: Mode;[m
[32m+[m[32m    static ECI: Mode;[m
[32m+[m[32m    static KANJI: Mode;[m
[32m+[m[32m    static FNC1_FIRST_POSITION: Mode;[m
[32m+[m[32m    static FNC1_SECOND_POSITION: Mode;[m
[32m+[m[32m    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */[m
[32m+[m[32m    static HANZI: Mode;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bits four bits encoding a QR Code data mode[m
[32m+[m[32m     * @return Mode encoded by these bits[m
[32m+[m[32m     * @throws IllegalArgumentException if bits do not correspond to a known mode[m
[32m+[m[32m     */[m
[32m+[m[32m    static forBits(bits: number): Mode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param version version in question[m
[32m+[m[32m     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the[m
[32m+[m[32m     *         count of characters that will follow encoded in this Mode[m
[32m+[m[32m     */[m
[32m+[m[32m    getCharacterCountBits(version: Version): number;[m
[32m+[m[32m    getValue(): ModeValues;[m
[32m+[m[32m    getBits(): number;[m
[32m+[m[32m    equals(o: any): boolean;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js[m
[1mnew file mode 100644[m
[1mindex 0000000..3459f87[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Mode.js[m
[36m@@ -0,0 +1,111 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mexports.ModeValues = void 0;[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32mvar ModeValues;[m
[32m+[m[32m(function (ModeValues) {[m
[32m+[m[32m    ModeValues[ModeValues["TERMINATOR"] = 0] = "TERMINATOR";[m
[32m+[m[32m    ModeValues[ModeValues["NUMERIC"] = 1] = "NUMERIC";[m
[32m+[m[32m    ModeValues[ModeValues["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";[m
[32m+[m[32m    ModeValues[ModeValues["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";[m
[32m+[m[32m    ModeValues[ModeValues["BYTE"] = 4] = "BYTE";[m
[32m+[m[32m    ModeValues[ModeValues["ECI"] = 5] = "ECI";[m
[32m+[m[32m    ModeValues[ModeValues["KANJI"] = 6] = "KANJI";[m
[32m+[m[32m    ModeValues[ModeValues["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";[m
[32m+[m[32m    ModeValues[ModeValues["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";[m
[32m+[m[32m    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */[m
[32m+[m[32m    ModeValues[ModeValues["HANZI"] = 9] = "HANZI";[m
[32m+[m[32m})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which[m
[32m+[m[32m * data can be encoded to bits in the QR code standard.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Mode = /** @class */ (function () {[m
[32m+[m[32m    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {[m
[32m+[m[32m        this.value = value;[m
[32m+[m[32m        this.stringValue = stringValue;[m
[32m+[m[32m        this.characterCountBitsForVersions = characterCountBitsForVersions;[m
[32m+[m[32m        this.bits = bits;[m
[32m+[m[32m        Mode.FOR_BITS.set(bits, this);[m
[32m+[m[32m        Mode.FOR_VALUE.set(value, this);[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param bits four bits encoding a QR Code data mode[m
[32m+[m[32m     * @return Mode encoded by these bits[m
[32m+[m[32m     * @throws IllegalArgumentException if bits do not correspond to a known mode[m
[32m+[m[32m     */[m
[32m+[m[32m    Mode.forBits = function (bits /*int*/) {[m
[32m+[m[32m        var mode = Mode.FOR_BITS.get(bits);[m
[32m+[m[32m        if (undefined === mode) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param version version in question[m
[32m+[m[32m     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the[m
[32m+[m[32m     *         count of characters that will follow encoded in this Mode[m
[32m+[m[32m     */[m
[32m+[m[32m    Mode.prototype.getCharacterCountBits = function (version) {[m
[32m+[m[32m        var versionNumber = version.getVersionNumber();[m
[32m+[m[32m        var offset;[m
[32m+[m[32m        if (versionNumber <= 9) {[m
[32m+[m[32m            offset = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (versionNumber <= 26) {[m
[32m+[m[32m            offset = 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            offset = 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.characterCountBitsForVersions[offset];[m
[32m+[m[32m    };[m
[32m+[m[32m    Mode.prototype.getValue = function () {[m
[32m+[m[32m        return this.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    Mode.prototype.getBits = function () {[m
[32m+[m[32m        return this.bits;[m
[32m+[m[32m    };[m
[32m+[m[32m    Mode.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof Mode)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        return this.value === other.value;[m
[32m+[m[32m    };[m
[32m+[m[32m    Mode.prototype.toString = function () {[m
[32m+[m[32m        return this.stringValue;[m
[32m+[m[32m    };[m
[32m+[m[32m    Mode.FOR_BITS = new Map();[m
[32m+[m[32m    Mode.FOR_VALUE = new Map();[m
[32m+[m[32m    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...[m
[32m+[m[32m    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);[m
[32m+[m[32m    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);[m
[32m+[m[32m    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported[m
[32m+[m[32m    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);[m
[32m+[m[32m    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply[m
[32m+[m[32m    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);[m
[32m+[m[32m    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);[m
[32m+[m[32m    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);[m
[32m+[m[32m    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */[m
[32m+[m[32m    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);[m
[32m+[m[32m    return Mode;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Mode;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5fd0ef6[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.d.ts[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32m/**[m
[32m+[m[32m * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the[m
[32m+[m[32m * decoding caller. Callers are expected to process this.[m
[32m+[m[32m *[m
[32m+[m[32m * @see com.google.zxing.common.DecoderResult#getOther()[m
[32m+[m[32m */[m
[32m+[m[32mexport default class QRCodeDecoderMetaData {[m
[32m+[m[32m    private mirrored;[m
[32m+[m[32m    constructor(mirrored: boolean);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the QR Code was mirrored.[m
[32m+[m[32m     */[m
[32m+[m[32m    isMirrored(): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply the result points' order correction due to mirroring.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param points Array of points to apply mirror correction to.[m
[32m+[m[32m     */[m
[32m+[m[32m    applyMirroredCorrection(points: Array<ResultPoint>): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js[m
[1mnew file mode 100644[m
[1mindex 0000000..6112a11[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/QRCodeDecoderMetaData.js[m
[36m@@ -0,0 +1,50 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2013 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the[m
[32m+[m[32m * decoding caller. Callers are expected to process this.[m
[32m+[m[32m *[m
[32m+[m[32m * @see com.google.zxing.common.DecoderResult#getOther()[m
[32m+[m[32m */[m
[32m+[m[32mvar QRCodeDecoderMetaData = /** @class */ (function () {[m
[32m+[m[32m    function QRCodeDecoderMetaData(mirrored) {[m
[32m+[m[32m        this.mirrored = mirrored;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the QR Code was mirrored.[m
[32m+[m[32m     */[m
[32m+[m[32m    QRCodeDecoderMetaData.prototype.isMirrored = function () {[m
[32m+[m[32m        return this.mirrored;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply the result points' order correction due to mirroring.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param points Array of points to apply mirror correction to.[m
[32m+[m[32m     */[m
[32m+[m[32m    QRCodeDecoderMetaData.prototype.applyMirroredCorrection = function (points) {[m
[32m+[m[32m        if (!this.mirrored || points === null || points.length < 3) {[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var bottomLeft = points[0];[m
[32m+[m[32m        points[0] = points[2];[m
[32m+[m[32m        points[2] = bottomLeft;[m
[32m+[m[32m        // No need to 'fix' top-left and alignment pattern.[m
[32m+[m[32m    };[m
[32m+[m[32m    return QRCodeDecoderMetaData;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = QRCodeDecoderMetaData;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..5b68a76[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.d.ts[m
[36m@@ -0,0 +1,44 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport ErrorCorrectionLevel from './ErrorCorrectionLevel';[m
[32m+[m[32mimport ECBlocks from './ECBlocks';[m
[32m+[m[32m/**[m
[32m+[m[32m * See ISO 18004:2006 Annex D[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Version {[m
[32m+[m[32m    private versionNumber;[m
[32m+[m[32m    private alignmentPatternCenters;[m
[32m+[m[32m    /**[m
[32m+[m[32m       * See ISO 18004:2006 Annex D.[m
[32m+[m[32m       * Element i represents the raw version bits that specify version i + 7[m
[32m+[m[32m       */[m
[32m+[m[32m    private static VERSION_DECODE_INFO;[m
[32m+[m[32m    /**[m
[32m+[m[32m       * See ISO 18004:2006 6.5.1 Table 9[m
[32m+[m[32m       */[m
[32m+[m[32m    private static VERSIONS;[m
[32m+[m[32m    private ecBlocks;[m
[32m+[m[32m    private totalCodewords;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    getVersionNumber(): number;[m
[32m+[m[32m    getAlignmentPatternCenters(): Int32Array;[m
[32m+[m[32m    getTotalCodewords(): number;[m
[32m+[m[32m    getDimensionForVersion(): number;[m
[32m+[m[32m    getECBlocksForLevel(ecLevel: ErrorCorrectionLevel): ECBlocks;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Deduces version information purely from QR Code dimensions.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param dimension dimension in modules[m
[32m+[m[32m     * @return Version for a QR Code of that dimension[m
[32m+[m[32m     * @throws FormatException if dimension is not 1 mod 4[m
[32m+[m[32m     */[m
[32m+[m[32m    static getProvisionalVersionForDimension(dimension: number): Version;[m
[32m+[m[32m    static getVersionForNumber(versionNumber: number): Version;[m
[32m+[m[32m    static decodeVersionInformation(versionBits: number): Version;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006 Annex E[m
[32m+[m[32m     */[m
[32m+[m[32m    buildFunctionPattern(): BitMatrix;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f5702b7[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/decoder/Version.js[m
[36m@@ -0,0 +1,235 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.decoder {*/[m
[32m+[m[32mvar BitMatrix_1 = require("../../common/BitMatrix");[m
[32m+[m[32mvar FormatInformation_1 = require("./FormatInformation");[m
[32m+[m[32mvar ECBlocks_1 = require("./ECBlocks");[m
[32m+[m[32mvar ECB_1 = require("./ECB");[m
[32m+[m[32mvar FormatException_1 = require("../../FormatException");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * See ISO 18004:2006 Annex D[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Version = /** @class */ (function () {[m
[32m+[m[32m    function Version(versionNumber /*int*/, alignmentPatternCenters) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var ecBlocks = [];[m
[32m+[m[32m        for (var _i = 2; _i < arguments.length; _i++) {[m
[32m+[m[32m            ecBlocks[_i - 2] = arguments[_i];[m
[32m+[m[32m        }[m
[32m+[m[32m        this.versionNumber = versionNumber;[m
[32m+[m[32m        this.alignmentPatternCenters = alignmentPatternCenters;[m
[32m+[m[32m        this.ecBlocks = ecBlocks;[m
[32m+[m[32m        var total = 0;[m
[32m+[m[32m        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();[m
[32m+[m[32m        var ecbArray = ecBlocks[0].getECBlocks();[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {[m
[32m+[m[32m                var ecBlock = ecbArray_1_1.value;[m
[32m+[m[32m                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        this.totalCodewords = total;[m
[32m+[m[32m    }[m
[32m+[m[32m    Version.prototype.getVersionNumber = function () {[m
[32m+[m[32m        return this.versionNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getAlignmentPatternCenters = function () {[m
[32m+[m[32m        return this.alignmentPatternCenters;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getTotalCodewords = function () {[m
[32m+[m[32m        return this.totalCodewords;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getDimensionForVersion = function () {[m
[32m+[m[32m        return 17 + 4 * this.versionNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.prototype.getECBlocksForLevel = function (ecLevel) {[m
[32m+[m[32m        return this.ecBlocks[ecLevel.getValue()];[m
[32m+[m[32m        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)[m
[32m+[m[32m        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Deduces version information purely from QR Code dimensions.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param dimension dimension in modules[m
[32m+[m[32m     * @return Version for a QR Code of that dimension[m
[32m+[m[32m     * @throws FormatException if dimension is not 1 mod 4[m
[32m+[m[32m     */[m
[32m+[m[32m    Version.getProvisionalVersionForDimension = function (dimension /*int*/) {[m
[32m+[m[32m        if (dimension % 4 !== 1) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        try {[m
[32m+[m[32m            return this.getVersionForNumber((dimension - 17) / 4);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: IllegalArgumentException*/) {[m
[32m+[m[32m            throw new FormatException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.getVersionForNumber = function (versionNumber /*int*/) {[m
[32m+[m[32m        if (versionNumber < 1 || versionNumber > 40) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        return Version.VERSIONS[versionNumber - 1];[m
[32m+[m[32m    };[m
[32m+[m[32m    Version.decodeVersionInformation = function (versionBits /*int*/) {[m
[32m+[m[32m        var bestDifference = Number.MAX_SAFE_INTEGER;[m
[32m+[m[32m        var bestVersion = 0;[m
[32m+[m[32m        for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {[m
[32m+[m[32m            var targetVersion = Version.VERSION_DECODE_INFO[i];[m
[32m+[m[32m            // Do the version info bits match exactly? done.[m
[32m+[m[32m            if (targetVersion === versionBits) {[m
[32m+[m[32m                return Version.getVersionForNumber(i + 7);[m
[32m+[m[32m            }[m
[32m+[m[32m            // Otherwise see if this is the closest to a real version info bit string[m
[32m+[m[32m            // we have seen so far[m
[32m+[m[32m            var bitsDifference = FormatInformation_1.default.numBitsDiffering(versionBits, targetVersion);[m
[32m+[m[32m            if (bitsDifference < bestDifference) {[m
[32m+[m[32m                bestVersion = i + 7;[m
[32m+[m[32m                bestDifference = bitsDifference;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // We can tolerate up to 3 bits of error since no two version info codewords will[m
[32m+[m[32m        // differ in less than 8 bits.[m
[32m+[m[32m        if (bestDifference <= 3) {[m
[32m+[m[32m            return Version.getVersionForNumber(bestVersion);[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we didn't find a close enough match, fail[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See ISO 18004:2006 Annex E[m
[32m+[m[32m     */[m
[32m+[m[32m    Version.prototype.buildFunctionPattern = function () {[m
[32m+[m[32m        var dimension = this.getDimensionForVersion();[m
[32m+[m[32m        var bitMatrix = new BitMatrix_1.default(dimension);[m
[32m+[m[32m        // Top left finder pattern + separator + format[m
[32m+[m[32m        bitMatrix.setRegion(0, 0, 9, 9);[m
[32m+[m[32m        // Top right finder pattern + separator + format[m
[32m+[m[32m        bitMatrix.setRegion(dimension - 8, 0, 8, 9);[m
[32m+[m[32m        // Bottom left finder pattern + separator + format[m
[32m+[m[32m        bitMatrix.setRegion(0, dimension - 8, 9, 8);[m
[32m+[m[32m        // Alignment patterns[m
[32m+[m[32m        var max = this.alignmentPatternCenters.length;[m
[32m+[m[32m        for (var x = 0; x < max; x++) {[m
[32m+[m[32m            var i = this.alignmentPatternCenters[x] - 2;[m
[32m+[m[32m            for (var y = 0; y < max; y++) {[m
[32m+[m[32m                if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {[m
[32m+[m[32m                    // No alignment patterns near the three finder patterns[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Vertical timing pattern[m
[32m+[m[32m        bitMatrix.setRegion(6, 9, 1, dimension - 17);[m
[32m+[m[32m        // Horizontal timing pattern[m
[32m+[m[32m        bitMatrix.setRegion(9, 6, dimension - 17, 1);[m
[32m+[m[32m        if (this.versionNumber > 6) {[m
[32m+[m[32m            // Version info, top right[m
[32m+[m[32m            bitMatrix.setRegion(dimension - 11, 0, 3, 6);[m
[32m+[m[32m            // Version info, bottom left[m
[32m+[m[32m            bitMatrix.setRegion(0, dimension - 11, 6, 3);[m
[32m+[m[32m        }[m
[32m+[m[32m        return bitMatrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    Version.prototype.toString = function () {[m
[32m+[m[32m        return '' + this.versionNumber;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m       * See ISO 18004:2006 Annex D.[m
[32m+[m[32m       * Element i represents the raw version bits that specify version i + 7[m
[32m+[m[32m       */[m
[32m+[m[32m    Version.VERSION_DECODE_INFO = Int32Array.from([[m
[32m+[m[32m        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,[m
[32m+[m[32m        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,[m
[32m+[m[32m        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,[m
[32m+[m[32m        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,[m
[32m+[m[32m        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,[m
[32m+[m[32m        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,[m
[32m+[m[32m        0x2542E, 0x26A64, 0x27541, 0x28C69[m
[32m+[m[32m    ]);[m
[32m+[m[32m    /**[m
[32m+[m[32m       * See ISO 18004:2006 6.5.1 Table 9[m
[32m+[m[32m       */[m
[32m+[m[32m    Version.VERSIONS = [[m
[32m+[m[32m        new Version(1, new Int32Array(0), new ECBlocks_1.default(7, new ECB_1.default(1, 19)), new ECBlocks_1.default(10, new ECB_1.default(1, 16)), new ECBlocks_1.default(13, new ECB_1.default(1, 13)), new ECBlocks_1.default(17, new ECB_1.default(1, 9))),[m
[32m+[m[32m        new Version(2, Int32Array.from([6, 18]), new ECBlocks_1.default(10, new ECB_1.default(1, 34)), new ECBlocks_1.default(16, new ECB_1.default(1, 28)), new ECBlocks_1.default(22, new ECB_1.default(1, 22)), new ECBlocks_1.default(28, new ECB_1.default(1, 16))),[m
[32m+[m[32m        new Version(3, Int32Array.from([6, 22]), new ECBlocks_1.default(15, new ECB_1.default(1, 55)), new ECBlocks_1.default(26, new ECB_1.default(1, 44)), new ECBlocks_1.default(18, new ECB_1.default(2, 17)), new ECBlocks_1.default(22, new ECB_1.default(2, 13))),[m
[32m+[m[32m        new Version(4, Int32Array.from([6, 26]), new ECBlocks_1.default(20, new ECB_1.default(1, 80)), new ECBlocks_1.default(18, new ECB_1.default(2, 32)), new ECBlocks_1.default(26, new ECB_1.default(2, 24)), new ECBlocks_1.default(16, new ECB_1.default(4, 9))),[m
[32m+[m[32m        new Version(5, Int32Array.from([6, 30]), new ECBlocks_1.default(26, new ECB_1.default(1, 108)), new ECBlocks_1.default(24, new ECB_1.default(2, 43)), new ECBlocks_1.default(18, new ECB_1.default(2, 15), new ECB_1.default(2, 16)), new ECBlocks_1.default(22, new ECB_1.default(2, 11), new ECB_1.default(2, 12))),[m
[32m+[m[32m        new Version(6, Int32Array.from([6, 34]), new ECBlocks_1.default(18, new ECB_1.default(2, 68)), new ECBlocks_1.default(16, new ECB_1.default(4, 27)), new ECBlocks_1.default(24, new ECB_1.default(4, 19)), new ECBlocks_1.default(28, new ECB_1.default(4, 15))),[m
[32m+[m[32m        new Version(7, Int32Array.from([6, 22, 38]), new ECBlocks_1.default(20, new ECB_1.default(2, 78)), new ECBlocks_1.default(18, new ECB_1.default(4, 31)), new ECBlocks_1.default(18, new ECB_1.default(2, 14), new ECB_1.default(4, 15)), new ECBlocks_1.default(26, new ECB_1.default(4, 13), new ECB_1.default(1, 14))),[m
[32m+[m[32m        new Version(8, Int32Array.from([6, 24, 42]), new ECBlocks_1.default(24, new ECB_1.default(2, 97)), new ECBlocks_1.default(22, new ECB_1.default(2, 38), new ECB_1.default(2, 39)), new ECBlocks_1.default(22, new ECB_1.default(4, 18), new ECB_1.default(2, 19)), new ECBlocks_1.default(26, new ECB_1.default(4, 14), new ECB_1.default(2, 15))),[m
[32m+[m[32m        new Version(9, Int32Array.from([6, 26, 46]), new ECBlocks_1.default(30, new ECB_1.default(2, 116)), new ECBlocks_1.default(22, new ECB_1.default(3, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(20, new ECB_1.default(4, 16), new ECB_1.default(4, 17)), new ECBlocks_1.default(24, new ECB_1.default(4, 12), new ECB_1.default(4, 13))),[m
[32m+[m[32m        new Version(10, Int32Array.from([6, 28, 50]), new ECBlocks_1.default(18, new ECB_1.default(2, 68), new ECB_1.default(2, 69)), new ECBlocks_1.default(26, new ECB_1.default(4, 43), new ECB_1.default(1, 44)), new ECBlocks_1.default(24, new ECB_1.default(6, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(28, new ECB_1.default(6, 15), new ECB_1.default(2, 16))),[m
[32m+[m[32m        new Version(11, Int32Array.from([6, 30, 54]), new ECBlocks_1.default(20, new ECB_1.default(4, 81)), new ECBlocks_1.default(30, new ECB_1.default(1, 50), new ECB_1.default(4, 51)), new ECBlocks_1.default(28, new ECB_1.default(4, 22), new ECB_1.default(4, 23)), new ECBlocks_1.default(24, new ECB_1.default(3, 12), new ECB_1.default(8, 13))),[m
[32m+[m[32m        new Version(12, Int32Array.from([6, 32, 58]), new ECBlocks_1.default(24, new ECB_1.default(2, 92), new ECB_1.default(2, 93)), new ECBlocks_1.default(22, new ECB_1.default(6, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(26, new ECB_1.default(4, 20), new ECB_1.default(6, 21)), new ECBlocks_1.default(28, new ECB_1.default(7, 14), new ECB_1.default(4, 15))),[m
[32m+[m[32m        new Version(13, Int32Array.from([6, 34, 62]), new ECBlocks_1.default(26, new ECB_1.default(4, 107)), new ECBlocks_1.default(22, new ECB_1.default(8, 37), new ECB_1.default(1, 38)), new ECBlocks_1.default(24, new ECB_1.default(8, 20), new ECB_1.default(4, 21)), new ECBlocks_1.default(22, new ECB_1.default(12, 11), new ECB_1.default(4, 12))),[m
[32m+[m[32m        new Version(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_1.default(30, new ECB_1.default(3, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(24, new ECB_1.default(4, 40), new ECB_1.default(5, 41)), new ECBlocks_1.default(20, new ECB_1.default(11, 16), new ECB_1.default(5, 17)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(5, 13))),[m
[32m+[m[32m        new Version(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_1.default(22, new ECB_1.default(5, 87), new ECB_1.default(1, 88)), new ECBlocks_1.default(24, new ECB_1.default(5, 41), new ECB_1.default(5, 42)), new ECBlocks_1.default(30, new ECB_1.default(5, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(7, 13))),[m
[32m+[m[32m        new Version(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_1.default(24, new ECB_1.default(5, 98), new ECB_1.default(1, 99)), new ECBlocks_1.default(28, new ECB_1.default(7, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(24, new ECB_1.default(15, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(30, new ECB_1.default(3, 15), new ECB_1.default(13, 16))),[m
[32m+[m[32m        new Version(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_1.default(28, new ECB_1.default(1, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(1, 47)), new ECBlocks_1.default(28, new ECB_1.default(1, 22), new ECB_1.default(15, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(17, 15))),[m
[32m+[m[32m        new Version(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_1.default(30, new ECB_1.default(5, 120), new ECB_1.default(1, 121)), new ECBlocks_1.default(26, new ECB_1.default(9, 43), new ECB_1.default(4, 44)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(1, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(19, 15))),[m
[32m+[m[32m        new Version(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_1.default(28, new ECB_1.default(3, 113), new ECB_1.default(4, 114)), new ECBlocks_1.default(26, new ECB_1.default(3, 44), new ECB_1.default(11, 45)), new ECBlocks_1.default(26, new ECB_1.default(17, 21), new ECB_1.default(4, 22)), new ECBlocks_1.default(26, new ECB_1.default(9, 13), new ECB_1.default(16, 14))),[m
[32m+[m[32m        new Version(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_1.default(28, new ECB_1.default(3, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(26, new ECB_1.default(3, 41), new ECB_1.default(13, 42)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(5, 25)), new ECBlocks_1.default(28, new ECB_1.default(15, 15), new ECB_1.default(10, 16))),[m
[32m+[m[32m        new Version(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_1.default(28, new ECB_1.default(4, 116), new ECB_1.default(4, 117)), new ECBlocks_1.default(26, new ECB_1.default(17, 42)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(19, 16), new ECB_1.default(6, 17))),[m
[32m+[m[32m        new Version(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_1.default(28, new ECB_1.default(2, 111), new ECB_1.default(7, 112)), new ECBlocks_1.default(28, new ECB_1.default(17, 46)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(24, new ECB_1.default(34, 13))),[m
[32m+[m[32m        new Version(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_1.default(30, new ECB_1.default(4, 121), new ECB_1.default(5, 122)), new ECBlocks_1.default(28, new ECB_1.default(4, 47), new ECB_1.default(14, 48)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(16, 15), new ECB_1.default(14, 16))),[m
[32m+[m[32m        new Version(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_1.default(30, new ECB_1.default(6, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(6, 45), new ECB_1.default(14, 46)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(30, new ECB_1.default(30, 16), new ECB_1.default(2, 17))),[m
[32m+[m[32m        new Version(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_1.default(26, new ECB_1.default(8, 106), new ECB_1.default(4, 107)), new ECBlocks_1.default(28, new ECB_1.default(8, 47), new ECB_1.default(13, 48)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(13, 16))),[m
[32m+[m[32m        new Version(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_1.default(28, new ECB_1.default(10, 114), new ECB_1.default(2, 115)), new ECBlocks_1.default(28, new ECB_1.default(19, 46), new ECB_1.default(4, 47)), new ECBlocks_1.default(28, new ECB_1.default(28, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(33, 16), new ECB_1.default(4, 17))),[m
[32m+[m[32m        new Version(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_1.default(30, new ECB_1.default(8, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(22, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(30, new ECB_1.default(8, 23), new ECB_1.default(26, 24)), new ECBlocks_1.default(30, new ECB_1.default(12, 15), new ECB_1.default(28, 16))),[m
[32m+[m[32m        new Version(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_1.default(30, new ECB_1.default(3, 117), new ECB_1.default(10, 118)), new ECBlocks_1.default(28, new ECB_1.default(3, 45), new ECB_1.default(23, 46)), new ECBlocks_1.default(30, new ECB_1.default(4, 24), new ECB_1.default(31, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(31, 16))),[m
[32m+[m[32m        new Version(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_1.default(30, new ECB_1.default(7, 116), new ECB_1.default(7, 117)), new ECBlocks_1.default(28, new ECB_1.default(21, 45), new ECB_1.default(7, 46)), new ECBlocks_1.default(30, new ECB_1.default(1, 23), new ECB_1.default(37, 24)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(26, 16))),[m
[32m+[m[32m        new Version(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_1.default(30, new ECB_1.default(5, 115), new ECB_1.default(10, 116)), new ECBlocks_1.default(28, new ECB_1.default(19, 47), new ECB_1.default(10, 48)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(25, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(25, 16))),[m
[32m+[m[32m        new Version(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(3, 116)), new ECBlocks_1.default(28, new ECB_1.default(2, 46), new ECB_1.default(29, 47)), new ECBlocks_1.default(30, new ECB_1.default(42, 24), new ECB_1.default(1, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(28, 16))),[m
[32m+[m[32m        new Version(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_1.default(30, new ECB_1.default(17, 115)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(10, 24), new ECB_1.default(35, 25)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(35, 16))),[m
[32m+[m[32m        new Version(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_1.default(30, new ECB_1.default(17, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(21, 47)), new ECBlocks_1.default(30, new ECB_1.default(29, 24), new ECB_1.default(19, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(46, 16))),[m
[32m+[m[32m        new Version(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(6, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(44, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(30, new ECB_1.default(59, 16), new ECB_1.default(1, 17))),[m
[32m+[m[32m        new Version(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_1.default(30, new ECB_1.default(12, 121), new ECB_1.default(7, 122)), new ECBlocks_1.default(28, new ECB_1.default(12, 47), new ECB_1.default(26, 48)), new ECBlocks_1.default(30, new ECB_1.default(39, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(41, 16))),[m
[32m+[m[32m        new Version(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_1.default(30, new ECB_1.default(6, 121), new ECB_1.default(14, 122)), new ECBlocks_1.default(28, new ECB_1.default(6, 47), new ECB_1.default(34, 48)), new ECBlocks_1.default(30, new ECB_1.default(46, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(2, 15), new ECB_1.default(64, 16))),[m
[32m+[m[32m        new Version(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_1.default(30, new ECB_1.default(17, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(29, 46), new ECB_1.default(14, 47)), new ECBlocks_1.default(30, new ECB_1.default(49, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(24, 15), new ECB_1.default(46, 16))),[m
[32m+[m[32m        new Version(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_1.default(30, new ECB_1.default(4, 122), new ECB_1.default(18, 123)), new ECBlocks_1.default(28, new ECB_1.default(13, 46), new ECB_1.default(32, 47)), new ECBlocks_1.default(30, new ECB_1.default(48, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(42, 15), new ECB_1.default(32, 16))),[m
[32m+[m[32m        new Version(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_1.default(30, new ECB_1.default(20, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(40, 47), new ECB_1.default(7, 48)), new ECBlocks_1.default(30, new ECB_1.default(43, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(10, 15), new ECB_1.default(67, 16))),[m
[32m+[m[32m        new Version(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_1.default(30, new ECB_1.default(19, 118), new ECB_1.default(6, 119)), new ECBlocks_1.default(28, new ECB_1.default(18, 47), new ECB_1.default(31, 48)), new ECBlocks_1.default(30, new ECB_1.default(34, 24), new ECB_1.default(34, 25)), new ECBlocks_1.default(30, new ECB_1.default(20, 15), new ECB_1.default(61, 16)))[m
[32m+[m[32m    ];[m
[32m+[m[32m    return Version;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Version;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..b745040[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.d.ts[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in[m
[32m+[m[32m * all but the simplest QR Codes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AlignmentPattern extends ResultPoint {[m
[32m+[m[32m    private estimatedModuleSize;[m
[32m+[m[32m    constructor(posX: number, posY: number, estimatedModuleSize: number);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated[m
[32m+[m[32m     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    aboutEquals(moduleSize: number, i: number, j: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Combines this object's current estimate of a finder pattern position and module size[m
[32m+[m[32m     * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.[m
[32m+[m[32m     */[m
[32m+[m[32m    combineEstimate(i: number, j: number, newModuleSize: number): AlignmentPattern;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d67db97[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPattern.js[m
[36m@@ -0,0 +1,69 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.detector {*/[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in[m
[32m+[m[32m * all but the simplest QR Codes.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar AlignmentPattern = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(AlignmentPattern, _super);[m
[32m+[m[32m    function AlignmentPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {[m
[32m+[m[32m        var _this = _super.call(this, posX, posY) || this;[m
[32m+[m[32m        _this.estimatedModuleSize = estimatedModuleSize;[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated[m
[32m+[m[32m     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {[m
[32m+[m[32m        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {[m
[32m+[m[32m            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);[m
[32m+[m[32m            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Combines this object's current estimate of a finder pattern position and module size[m
[32m+[m[32m     * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {[m
[32m+[m[32m        var combinedX = (this.getX() + j) / 2.0;[m
[32m+[m[32m        var combinedY = (this.getY() + i) / 2.0;[m
[32m+[m[32m        var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;[m
[32m+[m[32m        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);[m
[32m+[m[32m    };[m
[32m+[m[32m    return AlignmentPattern;[m
[32m+[m[32m}(ResultPoint_1.default));[m
[32m+[m[32mexports.default = AlignmentPattern;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..1c850ad[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.d.ts[m
[36m@@ -0,0 +1,82 @@[m
[32m+[m[32mimport ResultPointCallback from '../../ResultPointCallback';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport AlignmentPattern from './AlignmentPattern';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder[m
[32m+[m[32m * patterns but are smaller and appear at regular intervals throughout the image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>At the moment this only looks for the bottom-right alignment pattern.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,[m
[32m+[m[32m * pasted and stripped down here for maximum performance but does unfortunately duplicate[m
[32m+[m[32m * some code.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class AlignmentPatternFinder {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private startX;[m
[32m+[m[32m    private startY;[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    private moduleSize;[m
[32m+[m[32m    private resultPointCallback;[m
[32m+[m[32m    private possibleCenters;[m
[32m+[m[32m    private crossCheckStateCount;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates a finder that will look in a portion of the whole image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image to search[m
[32m+[m[32m     * @param startX left column from which to start searching[m
[32m+[m[32m     * @param startY top row from which to start searching[m
[32m+[m[32m     * @param width width of region to search[m
[32m+[m[32m     * @param height height of region to search[m
[32m+[m[32m     * @param moduleSize estimated module size so far[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(image: BitMatrix, startX: number, startY: number, width: number, height: number, moduleSize: number, resultPointCallback: ResultPointCallback);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since[m
[32m+[m[32m     * it's pretty performance-critical and so is written to be fast foremost.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link AlignmentPattern} if found[m
[32m+[m[32m     * @throws NotFoundException if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    find(): AlignmentPattern;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Given a count of black/white/black pixels just seen and an end position,[m
[32m+[m[32m     * figures the location of the center of this black/white/black run.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static centerFromEnd;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param stateCount count of black/white/black pixels just read[m
[32m+[m[32m     * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios[m
[32m+[m[32m     *         used by alignment patterns to be considered a match[m
[32m+[m[32m     */[m
[32m+[m[32m    private foundPatternCross;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>After a horizontal scan finds a potential alignment pattern, this method[m
[32m+[m[32m     * "cross-checks" by scanning down vertically through the center of the possible[m
[32m+[m[32m     * alignment pattern to see if the same proportion is detected.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where an alignment pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross an alignment pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     * observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @return vertical center of alignment pattern, or {@link Float#NaN} if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    private crossCheckVertical;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will[m
[32m+[m[32m     * cross check with a vertical scan, and if successful, will see if this pattern had been[m
[32m+[m[32m     * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have[m
[32m+[m[32m     * found the alignment pattern.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stateCount reading state module counts from horizontal scan[m
[32m+[m[32m     * @param i row where alignment pattern may be found[m
[32m+[m[32m     * @param j end of possible alignment pattern in row[m
[32m+[m[32m     * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not[m
[32m+[m[32m     */[m
[32m+[m[32m    private handlePossibleCenter;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c9dfb80[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/AlignmentPatternFinder.js[m
[36m@@ -0,0 +1,271 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar AlignmentPattern_1 = require("./AlignmentPattern");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m/*import java.util.ArrayList;*/[m
[32m+[m[32m/*import java.util.List;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder[m
[32m+[m[32m * patterns but are smaller and appear at regular intervals throughout the image.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>At the moment this only looks for the bottom-right alignment pattern.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,[m
[32m+[m[32m * pasted and stripped down here for maximum performance but does unfortunately duplicate[m
[32m+[m[32m * some code.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar AlignmentPatternFinder = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates a finder that will look in a portion of the whole image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image to search[m
[32m+[m[32m     * @param startX left column from which to start searching[m
[32m+[m[32m     * @param startY top row from which to start searching[m
[32m+[m[32m     * @param width width of region to search[m
[32m+[m[32m     * @param height height of region to search[m
[32m+[m[32m     * @param moduleSize estimated module size so far[m
[32m+[m[32m     */[m
[32m+[m[32m    function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.startX = startX;[m
[32m+[m[32m        this.startY = startY;[m
[32m+[m[32m        this.width = width;[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m        this.moduleSize = moduleSize;[m
[32m+[m[32m        this.resultPointCallback = resultPointCallback;[m
[32m+[m[32m        this.possibleCenters = []; // new Array<any>(5))[m
[32m+[m[32m        // TYPESCRIPTPORT: array initialization without size as the length is checked below[m
[32m+[m[32m        this.crossCheckStateCount = new Int32Array(3);[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since[m
[32m+[m[32m     * it's pretty performance-critical and so is written to be fast foremost.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link AlignmentPattern} if found[m
[32m+[m[32m     * @throws NotFoundException if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPatternFinder.prototype.find = function () {[m
[32m+[m[32m        var startX = this.startX;[m
[32m+[m[32m        var height = this.height;[m
[32m+[m[32m        var width = this.width;[m
[32m+[m[32m        var maxJ = startX + width;[m
[32m+[m[32m        var middleI = this.startY + (height / 2);[m
[32m+[m[32m        // We are looking for black/white/black modules in 1:1:1 ratio[m
[32m+[m[32m        // this tracks the number of black/white/black modules seen so far[m
[32m+[m[32m        var stateCount = new Int32Array(3);[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        for (var iGen = 0; iGen < height; iGen++) {[m
[32m+[m[32m            // Search from middle outwards[m
[32m+[m[32m            var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));[m
[32m+[m[32m            stateCount[0] = 0;[m
[32m+[m[32m            stateCount[1] = 0;[m
[32m+[m[32m            stateCount[2] = 0;[m
[32m+[m[32m            var j = startX;[m
[32m+[m[32m            // Burn off leading white pixels before anything else; if we start in the middle of[m
[32m+[m[32m            // a white run, it doesn't make sense to count its length, since we don't know if the[m
[32m+[m[32m            // white run continued to the left of the start point[m
[32m+[m[32m            while (j < maxJ && !image.get(j, i)) {[m
[32m+[m[32m                j++;[m
[32m+[m[32m            }[m
[32m+[m[32m            var currentState = 0;[m
[32m+[m[32m            while (j < maxJ) {[m
[32m+[m[32m                if (image.get(j, i)) {[m
[32m+[m[32m                    // Black pixel[m
[32m+[m[32m                    if (currentState === 1) { // Counting black pixels[m
[32m+[m[32m                        stateCount[1]++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else { // Counting white pixels[m
[32m+[m[32m                        if (currentState === 2) { // A winner?[m
[32m+[m[32m                            if (this.foundPatternCross(stateCount)) { // Yes[m
[32m+[m[32m                                var confirmed = this.handlePossibleCenter(stateCount, i, j);[m
[32m+[m[32m                                if (confirmed !== null) {[m
[32m+[m[32m                                    return confirmed;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                            stateCount[0] = stateCount[2];[m
[32m+[m[32m                            stateCount[1] = 1;[m
[32m+[m[32m                            stateCount[2] = 0;[m
[32m+[m[32m                            currentState = 1;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            stateCount[++currentState]++;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else { // White pixel[m
[32m+[m[32m                    if (currentState === 1) { // Counting black pixels[m
[32m+[m[32m                        currentState++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    stateCount[currentState]++;[m
[32m+[m[32m                }[m
[32m+[m[32m                j++;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (this.foundPatternCross(stateCount)) {[m
[32m+[m[32m                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);[m
[32m+[m[32m                if (confirmed !== null) {[m
[32m+[m[32m                    return confirmed;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Hmm, nothing we saw was observed and confirmed twice. If we had[m
[32m+[m[32m        // any guess at all, return it.[m
[32m+[m[32m        if (this.possibleCenters.length !== 0) {[m
[32m+[m[32m            return this.possibleCenters[0];[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new NotFoundException_1.default();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Given a count of black/white/black pixels just seen and an end position,[m
[32m+[m[32m     * figures the location of the center of this black/white/black run.[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {[m
[32m+[m[32m        return (end - stateCount[2]) - stateCount[1] / 2.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param stateCount count of black/white/black pixels just read[m
[32m+[m[32m     * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios[m
[32m+[m[32m     *         used by alignment patterns to be considered a match[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {[m
[32m+[m[32m        var moduleSize = this.moduleSize;[m
[32m+[m[32m        var maxVariance = moduleSize / 2.0;[m
[32m+[m[32m        for (var i = 0; i < 3; i++) {[m
[32m+[m[32m            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>After a horizontal scan finds a potential alignment pattern, this method[m
[32m+[m[32m     * "cross-checks" by scanning down vertically through the center of the possible[m
[32m+[m[32m     * alignment pattern to see if the same proportion is detected.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where an alignment pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross an alignment pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     * observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @return vertical center of alignment pattern, or {@link Float#NaN} if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        var maxI = image.getHeight();[m
[32m+[m[32m        var stateCount = this.crossCheckStateCount;[m
[32m+[m[32m        stateCount[0] = 0;[m
[32m+[m[32m        stateCount[1] = 0;[m
[32m+[m[32m        stateCount[2] = 0;[m
[32m+[m[32m        // Start counting up from center[m
[32m+[m[32m        var i = startI;[m
[32m+[m[32m        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {[m
[32m+[m[32m            stateCount[1]++;[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If already too many modules in this state or ran off the edge:[m
[32m+[m[32m        if (i < 0 || stateCount[1] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {[m
[32m+[m[32m            stateCount[0]++;[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[0] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now also count down from center[m
[32m+[m[32m        i = startI + 1;[m
[32m+[m[32m        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {[m
[32m+[m[32m            stateCount[1]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (i === maxI || stateCount[1] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[2] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];[m
[32m+[m[32m        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will[m
[32m+[m[32m     * cross check with a vertical scan, and if successful, will see if this pattern had been[m
[32m+[m[32m     * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have[m
[32m+[m[32m     * found the alignment pattern.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stateCount reading state module counts from horizontal scan[m
[32m+[m[32m     * @param i row where alignment pattern may be found[m
[32m+[m[32m     * @param j end of possible alignment pattern in row[m
[32m+[m[32m     * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not[m
[32m+[m[32m     */[m
[32m+[m[32m    AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];[m
[32m+[m[32m        var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);[m
[32m+[m[32m        var centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);[m
[32m+[m[32m        if (!isNaN(centerI)) {[m
[32m+[m[32m            var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                    var center = _c.value;[m
[32m+[m[32m                    // Look for about the same center and module size:[m
[32m+[m[32m                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {[m
[32m+[m[32m                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            // Hadn't found this before; save it[m
[32m+[m[32m            var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);[m
[32m+[m[32m            this.possibleCenters.push(point);[m
[32m+[m[32m            if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {[m
[32m+[m[32m                this.resultPointCallback.foundPossibleResultPoint(point);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return null;[m
[32m+[m[32m    };[m
[32m+[m[32m    return AlignmentPatternFinder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = AlignmentPatternFinder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..f01db95[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.d.ts[m
[36m@@ -0,0 +1,87 @@[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport DetectorResult from '../../common/DetectorResult';[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32mimport ResultPointCallback from '../../ResultPointCallback';[m
[32m+[m[32mimport AlignmentPattern from './AlignmentPattern';[m
[32m+[m[32mimport FinderPatternInfo from './FinderPatternInfo';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Detector {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private resultPointCallback;[m
[32m+[m[32m    constructor(image: BitMatrix);[m
[32m+[m[32m    protected getImage(): BitMatrix;[m
[32m+[m[32m    protected getResultPointCallback(): ResultPointCallback;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a QR Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a QR Code[m
[32m+[m[32m     * @throws NotFoundException if QR Code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR Code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a QR Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param hints optional hints to detector[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a QR Code[m
[32m+[m[32m     * @throws NotFoundException if QR Code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR Code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    detect(hints: Map<DecodeHintType, any>): DetectorResult;[m
[32m+[m[32m    protected processFinderPatternInfo(info: FinderPatternInfo): DetectorResult;[m
[32m+[m[32m    private static createTransform;[m
[32m+[m[32m    private static sampleGrid;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position[m
[32m+[m[32m     * of the finder patterns and estimated module size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    private static computeDimension;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Computes an average estimated module size based on estimated derived from the positions[m
[32m+[m[32m     * of the three finder patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param topLeft detected top-left finder pattern center[m
[32m+[m[32m     * @param topRight detected top-right finder pattern center[m
[32m+[m[32m     * @param bottomLeft detected bottom-left finder pattern center[m
[32m+[m[32m     * @return estimated module size[m
[32m+[m[32m     */[m
[32m+[m[32m    protected calculateModuleSize(topLeft: ResultPoint, topRight: ResultPoint, bottomLeft: ResultPoint): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Estimates module size based on two finder patterns -- it uses[m
[32m+[m[32m     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the[m
[32m+[m[32m     * width of each, measuring along the axis between their centers.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    private calculateModuleSizeOneWay;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of[m
[32m+[m[32m     * a finder pattern by looking for a black-white-black run from the center in the direction[m
[32m+[m[32m     * of another point (another finder pattern center), and in the opposite direction too.[m
[32m+[m[32m     */[m
[32m+[m[32m    private sizeOfBlackWhiteBlackRunBothWays;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This method traces a line from a point in the image, in the direction towards another point.[m
[32m+[m[32m     * It begins in a black region, and keeps going until it finds white, then black, then white again.[m
[32m+[m[32m     * It reports the distance from the start to this point.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern[m
[32m+[m[32m     * may be skewed or rotated.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    private sizeOfBlackWhiteBlackRun;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is[m
[32m+[m[32m     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param overallEstModuleSize estimated module size so far[m
[32m+[m[32m     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern[m
[32m+[m[32m     * @param estAlignmentY y coordinate of above[m
[32m+[m[32m     * @param allowanceFactor number of pixels in all directions to search from the center[m
[32m+[m[32m     * @return {@link AlignmentPattern} if found, or null otherwise[m
[32m+[m[32m     * @throws NotFoundException if an unexpected error occurs during detection[m
[32m+[m[32m     */[m
[32m+[m[32m    protected findAlignmentInRegion(overallEstModuleSize: number, estAlignmentX: number, estAlignmentY: number, allowanceFactor: number): AlignmentPattern;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js[m
[1mnew file mode 100644[m
[1mindex 0000000..e20ebf4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js[m
[36m@@ -0,0 +1,325 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar MathUtils_1 = require("../../common/detector/MathUtils");[m
[32m+[m[32mvar DetectorResult_1 = require("../../common/DetectorResult");[m
[32m+[m[32m// import GridSampler from '../../common/GridSampler';[m
[32m+[m[32mvar GridSamplerInstance_1 = require("../../common/GridSamplerInstance");[m
[32m+[m[32mvar PerspectiveTransform_1 = require("../../common/PerspectiveTransform");[m
[32m+[m[32mvar DecodeHintType_1 = require("../../DecodeHintType");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar Version_1 = require("../decoder/Version");[m
[32m+[m[32mvar AlignmentPatternFinder_1 = require("./AlignmentPatternFinder");[m
[32m+[m[32mvar FinderPatternFinder_1 = require("./FinderPatternFinder");[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code[m
[32m+[m[32m * is rotated or skewed, or partially obscured.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar Detector = /** @class */ (function () {[m
[32m+[m[32m    function Detector(image) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m    }[m
[32m+[m[32m    Detector.prototype.getImage = function () {[m
[32m+[m[32m        return this.image;[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.getResultPointCallback = function () {[m
[32m+[m[32m        return this.resultPointCallback;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a QR Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a QR Code[m
[32m+[m[32m     * @throws NotFoundException if QR Code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR Code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {[m
[32m+[m[32m    //   return detect(null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Detects a QR Code in an image.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param hints optional hints to detector[m
[32m+[m[32m     * @return {@link DetectorResult} encapsulating results of detecting a QR Code[m
[32m+[m[32m     * @throws NotFoundException if QR Code cannot be found[m
[32m+[m[32m     * @throws FormatException if a QR Code cannot be decoded[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.detect = function (hints) {[m
[32m+[m[32m        this.resultPointCallback = (hints === null || hints === undefined) ? null :[m
[32m+[m[32m            /*(ResultPointCallback) */ hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);[m
[32m+[m[32m        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);[m
[32m+[m[32m        var info = finder.find(hints);[m
[32m+[m[32m        return this.processFinderPatternInfo(info);[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.prototype.processFinderPatternInfo = function (info) {[m
[32m+[m[32m        var topLeft = info.getTopLeft();[m
[32m+[m[32m        var topRight = info.getTopRight();[m
[32m+[m[32m        var bottomLeft = info.getBottomLeft();[m
[32m+[m[32m        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);[m
[32m+[m[32m        if (moduleSize < 1.0) {[m
[32m+[m[32m            throw new NotFoundException_1.default('No pattern found in proccess finder.');[m
[32m+[m[32m        }[m
[32m+[m[32m        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);[m
[32m+[m[32m        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);[m
[32m+[m[32m        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;[m
[32m+[m[32m        var alignmentPattern = null;[m
[32m+[m[32m        // Anything above version 1 has an alignment pattern[m
[32m+[m[32m        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {[m
[32m+[m[32m            // Guess where a "bottom right" finder pattern would have been[m
[32m+[m[32m            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();[m
[32m+[m[32m            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();[m
[32m+[m[32m            // Estimate that alignment pattern is closer by 3 modules[m
[32m+[m[32m            // from "bottom right" to known top left location[m
[32m+[m[32m            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;[m
[32m+[m[32m            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));[m
[32m+[m[32m            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));[m
[32m+[m[32m            // Kind of arbitrary -- expand search radius before giving up[m
[32m+[m[32m            for (var i = 4; i <= 16; i <<= 1) {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                catch (re /*NotFoundException*/) {[m
[32m+[m[32m                    if (!(re instanceof NotFoundException_1.default)) {[m
[32m+[m[32m                        throw re;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // try next round[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            // If we didn't find alignment pattern... well try anyway without it[m
[32m+[m[32m        }[m
[32m+[m[32m        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);[m
[32m+[m[32m        var bits = Detector.sampleGrid(this.image, transform, dimension);[m
[32m+[m[32m        var points;[m
[32m+[m[32m        if (alignmentPattern === null) {[m
[32m+[m[32m            points = [bottomLeft, topLeft, topRight];[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            points = [bottomLeft, topLeft, topRight, alignmentPattern];[m
[32m+[m[32m        }[m
[32m+[m[32m        return new DetectorResult_1.default(bits, points);[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {[m
[32m+[m[32m        var dimMinusThree = dimension - 3.5;[m
[32m+[m[32m        var bottomRightX; /*float*/[m
[32m+[m[32m        var bottomRightY; /*float*/[m
[32m+[m[32m        var sourceBottomRightX; /*float*/[m
[32m+[m[32m        var sourceBottomRightY; /*float*/[m
[32m+[m[32m        if (alignmentPattern !== null) {[m
[32m+[m[32m            bottomRightX = alignmentPattern.getX();[m
[32m+[m[32m            bottomRightY = alignmentPattern.getY();[m
[32m+[m[32m            sourceBottomRightX = dimMinusThree - 3.0;[m
[32m+[m[32m            sourceBottomRightY = sourceBottomRightX;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            // Don't have an alignment pattern, just make up the bottom-right point[m
[32m+[m[32m            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();[m
[32m+[m[32m            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();[m
[32m+[m[32m            sourceBottomRightX = dimMinusThree;[m
[32m+[m[32m            sourceBottomRightY = dimMinusThree;[m
[32m+[m[32m        }[m
[32m+[m[32m        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());[m
[32m+[m[32m    };[m
[32m+[m[32m    Detector.sampleGrid = function (image, transform, dimension /*int*/) {[m
[32m+[m[32m        var sampler = GridSamplerInstance_1.default.getInstance();[m
[32m+[m[32m        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position[m
[32m+[m[32m     * of the finder patterns and estimated module size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {[m
[32m+[m[32m        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);[m
[32m+[m[32m        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);[m
[32m+[m[32m        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;[m
[32m+[m[32m        switch (dimension & 0x03) { // mod 4[m
[32m+[m[32m            case 0:[m
[32m+[m[32m                dimension++;[m
[32m+[m[32m                break;[m
[32m+[m[32m            // 1? do nothing[m
[32m+[m[32m            case 2:[m
[32m+[m[32m                dimension--;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 3:[m
[32m+[m[32m                throw new NotFoundException_1.default('Dimensions could be not found.');[m
[32m+[m[32m        }[m
[32m+[m[32m        return dimension;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Computes an average estimated module size based on estimated derived from the positions[m
[32m+[m[32m     * of the three finder patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param topLeft detected top-left finder pattern center[m
[32m+[m[32m     * @param topRight detected top-right finder pattern center[m
[32m+[m[32m     * @param bottomLeft detected bottom-left finder pattern center[m
[32m+[m[32m     * @return estimated module size[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {[m
[32m+[m[32m        // Take the average[m
[32m+[m[32m        return (this.calculateModuleSizeOneWay(topLeft, topRight) +[m
[32m+[m[32m            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Estimates module size based on two finder patterns -- it uses[m
[32m+[m[32m     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the[m
[32m+[m[32m     * width of each, measuring along the axis between their centers.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {[m
[32m+[m[32m        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(pattern.getY()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(otherPattern.getX()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(otherPattern.getY()));[m
[32m+[m[32m        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(otherPattern.getY()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(pattern.getX()),[m[41m [m
[32m+[m[32m        /*(int) */ Math.floor(pattern.getY()));[m
[32m+[m[32m        if (isNaN(moduleSizeEst1)) {[m
[32m+[m[32m            return moduleSizeEst2 / 7.0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (isNaN(moduleSizeEst2)) {[m
[32m+[m[32m            return moduleSizeEst1 / 7.0;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Average them, and divide by 7 since we've counted the width of 3 black modules,[m
[32m+[m[32m        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.[m
[32m+[m[32m        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of[m
[32m+[m[32m     * a finder pattern by looking for a black-white-black run from the center in the direction[m
[32m+[m[32m     * of another point (another finder pattern center), and in the opposite direction too.[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {[m
[32m+[m[32m        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);[m
[32m+[m[32m        // Now count other way -- don't run off image though of course[m
[32m+[m[32m        var scale = 1.0;[m
[32m+[m[32m        var otherToX = fromX - (toX - fromX);[m
[32m+[m[32m        if (otherToX < 0) {[m
[32m+[m[32m            scale = fromX / /*(float) */ (fromX - otherToX);[m
[32m+[m[32m            otherToX = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (otherToX >= this.image.getWidth()) {[m
[32m+[m[32m            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);[m
[32m+[m[32m            otherToX = this.image.getWidth() - 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);[m
[32m+[m[32m        scale = 1.0;[m
[32m+[m[32m        if (otherToY < 0) {[m
[32m+[m[32m            scale = fromY / /*(float) */ (fromY - otherToY);[m
[32m+[m[32m            otherToY = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (otherToY >= this.image.getHeight()) {[m
[32m+[m[32m            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);[m
[32m+[m[32m            otherToY = this.image.getHeight() - 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);[m
[32m+[m[32m        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);[m
[32m+[m[32m        // Middle pixel is double-counted this way; subtract 1[m
[32m+[m[32m        return result - 1.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This method traces a line from a point in the image, in the direction towards another point.[m
[32m+[m[32m     * It begins in a black region, and keeps going until it finds white, then black, then white again.[m
[32m+[m[32m     * It reports the distance from the start to this point.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern[m
[32m+[m[32m     * may be skewed or rotated.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {[m
[32m+[m[32m        // Mild variant of Bresenham's algorithm[m
[32m+[m[32m        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm[m
[32m+[m[32m        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);[m
[32m+[m[32m        if (steep) {[m
[32m+[m[32m            var temp = fromX;[m
[32m+[m[32m            fromX = fromY;[m
[32m+[m[32m            fromY = temp;[m
[32m+[m[32m            temp = toX;[m
[32m+[m[32m            toX = toY;[m
[32m+[m[32m            toY = temp;[m
[32m+[m[32m        }[m
[32m+[m[32m        var dx = Math.abs(toX - fromX);[m
[32m+[m[32m        var dy = Math.abs(toY - fromY);[m
[32m+[m[32m        var error = -dx / 2;[m
[32m+[m[32m        var xstep = fromX < toX ? 1 : -1;[m
[32m+[m[32m        var ystep = fromY < toY ? 1 : -1;[m
[32m+[m[32m        // In black pixels, looking for white, first or second time.[m
[32m+[m[32m        var state = 0;[m
[32m+[m[32m        // Loop up until x == toX, but not beyond[m
[32m+[m[32m        var xLimit = toX + xstep;[m
[32m+[m[32m        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {[m
[32m+[m[32m            var realX = steep ? y : x;[m
[32m+[m[32m            var realY = steep ? x : y;[m
[32m+[m[32m            // Does current pixel mean we have moved white to black or vice versa?[m
[32m+[m[32m            // Scanning black in state 0,2 and white in state 1, so if we find the wrong[m
[32m+[m[32m            // color, advance to next state or end if we are in state 2 already[m
[32m+[m[32m            if ((state === 1) === this.image.get(realX, realY)) {[m
[32m+[m[32m                if (state === 2) {[m
[32m+[m[32m                    return MathUtils_1.default.distance(x, y, fromX, fromY);[m
[32m+[m[32m                }[m
[32m+[m[32m                state++;[m
[32m+[m[32m            }[m
[32m+[m[32m            error += dy;[m
[32m+[m[32m            if (error > 0) {[m
[32m+[m[32m                if (y === toY) {[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m                y += ystep;[m
[32m+[m[32m                error -= dx;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image[m
[32m+[m[32m        // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a[m
[32m+[m[32m        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.[m
[32m+[m[32m        if (state === 2) {[m
[32m+[m[32m            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);[m
[32m+[m[32m        }[m
[32m+[m[32m        // else we didn't find even black-white-black; no estimate is really possible[m
[32m+[m[32m        return NaN;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is[m
[32m+[m[32m     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param overallEstModuleSize estimated module size so far[m
[32m+[m[32m     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern[m
[32m+[m[32m     * @param estAlignmentY y coordinate of above[m
[32m+[m[32m     * @param allowanceFactor number of pixels in all directions to search from the center[m
[32m+[m[32m     * @return {@link AlignmentPattern} if found, or null otherwise[m
[32m+[m[32m     * @throws NotFoundException if an unexpected error occurs during detection[m
[32m+[m[32m     */[m
[32m+[m[32m    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {[m
[32m+[m[32m        // Look for an alignment pattern (3 modules in size) around where it[m
[32m+[m[32m        // should be[m
[32m+[m[32m        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);[m
[32m+[m[32m        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);[m
[32m+[m[32m        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);[m
[32m+[m[32m        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {[m
[32m+[m[32m            throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');[m
[32m+[m[32m        }[m
[32m+[m[32m        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);[m
[32m+[m[32m        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);[m
[32m+[m[32m        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {[m
[32m+[m[32m            throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');[m
[32m+[m[32m        }[m
[32m+[m[32m        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);[m
[32m+[m[32m        return alignmentFinder.find();[m
[32m+[m[32m    };[m
[32m+[m[32m    return Detector;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Detector;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c40380a[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.d.ts[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mimport ResultPoint from '../../ResultPoint';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a finder pattern, which are the three square patterns found in[m
[32m+[m[32m * the corners of QR Codes. It also encapsulates a count of similar finder patterns,[m
[32m+[m[32m * as a convenience to the finder's bookkeeping.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class FinderPattern extends ResultPoint {[m
[32m+[m[32m    private estimatedModuleSize;[m
[32m+[m[32m    private count?;[m
[32m+[m[32m    constructor(posX: number, posY: number, estimatedModuleSize: number, count?: number);[m
[32m+[m[32m    getEstimatedModuleSize(): number;[m
[32m+[m[32m    getCount(): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Determines if this finder pattern "about equals" a finder pattern at the stated[m
[32m+[m[32m     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    aboutEquals(moduleSize: number, i: number, j: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Combines this object's current estimate of a finder pattern position and module size[m
[32m+[m[32m     * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average[m
[32m+[m[32m     * based on count.[m
[32m+[m[32m     */[m
[32m+[m[32m    combineEstimate(i: number, j: number, newModuleSize: number): FinderPattern;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js[m
[1mnew file mode 100644[m
[1mindex 0000000..ce2d5fb[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPattern.js[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.detector {*/[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates a finder pattern, which are the three square patterns found in[m
[32m+[m[32m * the corners of QR Codes. It also encapsulates a count of similar finder patterns,[m
[32m+[m[32m * as a convenience to the finder's bookkeeping.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar FinderPattern = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(FinderPattern, _super);[m
[32m+[m[32m    // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {[m
[32m+[m[32m    //   this(posX, posY, estimatedModuleSize, 1)[m
[32m+[m[32m    // }[m
[32m+[m[32m    function FinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {[m
[32m+[m[32m        var _this = _super.call(this, posX, posY) || this;[m
[32m+[m[32m        _this.estimatedModuleSize = estimatedModuleSize;[m
[32m+[m[32m        _this.count = count;[m
[32m+[m[32m        if (undefined === count) {[m
[32m+[m[32m            _this.count = 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    FinderPattern.prototype.getEstimatedModuleSize = function () {[m
[32m+[m[32m        return this.estimatedModuleSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPattern.prototype.getCount = function () {[m
[32m+[m[32m        return this.count;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    void incrementCount() {[m
[32m+[m[32m      this.count++[m
[32m+[m[32m    }[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Determines if this finder pattern "about equals" a finder pattern at the stated[m
[32m+[m[32m     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {[m
[32m+[m[32m        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {[m
[32m+[m[32m            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);[m
[32m+[m[32m            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Combines this object's current estimate of a finder pattern position and module size[m
[32m+[m[32m     * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average[m
[32m+[m[32m     * based on count.[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {[m
[32m+[m[32m        var combinedCount = this.count + 1;[m
[32m+[m[32m        var combinedX = (this.count * this.getX() + j) / combinedCount;[m
[32m+[m[32m        var combinedY = (this.count * this.getY() + i) / combinedCount;[m
[32m+[m[32m        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;[m
[32m+[m[32m        return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    return FinderPattern;[m
[32m+[m[32m}(ResultPoint_1.default));[m
[32m+[m[32mexports.default = FinderPattern;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..7ed0853[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.d.ts[m
[36m@@ -0,0 +1,114 @@[m
[32m+[m[32mimport DecodeHintType from '../../DecodeHintType';[m
[32m+[m[32mimport ResultPointCallback from '../../ResultPointCallback';[m
[32m+[m[32mimport BitMatrix from '../../common/BitMatrix';[m
[32m+[m[32mimport FinderPattern from './FinderPattern';[m
[32m+[m[32mimport FinderPatternInfo from './FinderPatternInfo';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square[m
[32m+[m[32m * markers at three corners of a QR Code.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class FinderPatternFinder {[m
[32m+[m[32m    private image;[m
[32m+[m[32m    private resultPointCallback;[m
[32m+[m[32m    private static CENTER_QUORUM;[m
[32m+[m[32m    protected static MIN_SKIP: number;[m
[32m+[m[32m    protected static MAX_MODULES: number;[m
[32m+[m[32m    private possibleCenters;[m
[32m+[m[32m    private hasSkipped;[m
[32m+[m[32m    private crossCheckStateCount;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates a finder that will search the image for three finder patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image to search[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(image: BitMatrix, resultPointCallback: ResultPointCallback);[m
[32m+[m[32m    protected getImage(): BitMatrix;[m
[32m+[m[32m    protected getPossibleCenters(): FinderPattern[];[m
[32m+[m[32m    find(hints: Map<DecodeHintType, any>): FinderPatternInfo;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Given a count of black/white/black/white/black pixels just seen and an end position,[m
[32m+[m[32m     * figures the location of the center of this run.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static centerFromEnd;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param stateCount count of black/white/black/white/black pixels just read[m
[32m+[m[32m     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios[m
[32m+[m[32m     *         used by finder patterns to be considered a match[m
[32m+[m[32m     */[m
[32m+[m[32m    protected static foundPatternCross(stateCount: Int32Array): boolean;[m
[32m+[m[32m    private getCrossCheckStateCount;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * After a vertical and horizontal scan finds a potential finder pattern, this method[m
[32m+[m[32m     * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible[m
[32m+[m[32m     * finder pattern to see if the same proportion is detected.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where a finder pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross a finder pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     *  observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @param originalStateCountTotal The original state count total.[m
[32m+[m[32m     * @return true if proportions are withing expected limits[m
[32m+[m[32m     */[m
[32m+[m[32m    private crossCheckDiagonal;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>After a horizontal scan finds a potential finder pattern, this method[m
[32m+[m[32m     * "cross-checks" by scanning down vertically through the center of the possible[m
[32m+[m[32m     * finder pattern to see if the same proportion is detected.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where a finder pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross a finder pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     * observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @return vertical center of finder pattern, or {@link Float#NaN} if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    private crossCheckVertical;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,[m
[32m+[m[32m     * except it reads horizontally instead of vertically. This is used to cross-cross[m
[32m+[m[32m     * check a vertical cross check and locate the real center of the alignment pattern.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    private crossCheckHorizontal;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will[m
[32m+[m[32m     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check[m
[32m+[m[32m     * with another horizontal scan. This is needed primarily to locate the real horizontal[m
[32m+[m[32m     * center of the pattern in cases of extreme skew.[m
[32m+[m[32m     * And then we cross-cross-cross check with another diagonal scan.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>If that succeeds the finder pattern location is added to a list that tracks[m
[32m+[m[32m     * the number of times each location has been nearly-matched as a finder pattern.[m
[32m+[m[32m     * Each additional find is more evidence that the location is in fact a finder[m
[32m+[m[32m     * pattern center[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stateCount reading state module counts from horizontal scan[m
[32m+[m[32m     * @param i row where finder pattern may be found[m
[32m+[m[32m     * @param j end of possible finder pattern in row[m
[32m+[m[32m     * @param pureBarcode true if in "pure barcode" mode[m
[32m+[m[32m     * @return true if a finder pattern candidate was found this time[m
[32m+[m[32m     */[m
[32m+[m[32m    protected handlePossibleCenter(stateCount: Int32Array, i: number, j: number, pureBarcode: boolean): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of rows we could safely skip during scanning, based on the first[m
[32m+[m[32m     *         two finder patterns that have been located. In some cases their position will[m
[32m+[m[32m     *         allow us to infer that the third pattern must lie below a certain point farther[m
[32m+[m[32m     *         down in the image.[m
[32m+[m[32m     */[m
[32m+[m[32m    private findRowSkip;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff we have found at least 3 finder patterns that have been detected[m
[32m+[m[32m     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the[m
[32m+[m[32m     *         candidates is "pretty similar"[m
[32m+[m[32m     */[m
[32m+[m[32m    private haveMultiplyConfirmedCenters;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are[m
[32m+[m[32m     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module[m
[32m+[m[32m     *         size differs from the average among those patterns the least[m
[32m+[m[32m     * @throws NotFoundException if 3 such finder patterns do not exist[m
[32m+[m[32m     */[m
[32m+[m[32m    private selectBestPatterns;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a226c89[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js[m
[36m@@ -0,0 +1,679 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.detector {*/[m
[32m+[m[32mvar DecodeHintType_1 = require("../../DecodeHintType");[m
[32m+[m[32mvar ResultPoint_1 = require("../../ResultPoint");[m
[32m+[m[32mvar FinderPattern_1 = require("./FinderPattern");[m
[32m+[m[32mvar FinderPatternInfo_1 = require("./FinderPatternInfo");[m
[32m+[m[32mvar NotFoundException_1 = require("../../NotFoundException");[m
[32m+[m[32m/*import java.io.Serializable;*/[m
[32m+[m[32m/*import java.util.ArrayList;*/[m
[32m+[m[32m/*import java.util.Collections;*/[m
[32m+[m[32m/*import java.util.Comparator;*/[m
[32m+[m[32m/*import java.util.List;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square[m
[32m+[m[32m * markers at three corners of a QR Code.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar FinderPatternFinder = /** @class */ (function () {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Creates a finder that will search the image for three finder patterns.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param image image to search[m
[32m+[m[32m     */[m
[32m+[m[32m    // public constructor(image: BitMatrix) {[m
[32m+[m[32m    //   this(image, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    function FinderPatternFinder(image, resultPointCallback) {[m
[32m+[m[32m        this.image = image;[m
[32m+[m[32m        this.resultPointCallback = resultPointCallback;[m
[32m+[m[32m        this.possibleCenters = [];[m
[32m+[m[32m        this.crossCheckStateCount = new Int32Array(5);[m
[32m+[m[32m        this.resultPointCallback = resultPointCallback;[m
[32m+[m[32m    }[m
[32m+[m[32m    FinderPatternFinder.prototype.getImage = function () {[m
[32m+[m[32m        return this.image;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternFinder.prototype.getPossibleCenters = function () {[m
[32m+[m[32m        return this.possibleCenters;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternFinder.prototype.find = function (hints) {[m
[32m+[m[32m        var tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);[m
[32m+[m[32m        var pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE);[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        var maxI = image.getHeight();[m
[32m+[m[32m        var maxJ = image.getWidth();[m
[32m+[m[32m        // We are looking for black/white/black/white/black modules in[m
[32m+[m[32m        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far[m
[32m+[m[32m        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the[m
[32m+[m[32m        // image, and then account for the center being 3 modules in size. This gives the smallest[m
[32m+[m[32m        // number of pixels the center could be, so skip this often. When trying harder, look for all[m
[32m+[m[32m        // QR versions regardless of how dense they are.[m
[32m+[m[32m        var iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));[m
[32m+[m[32m        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {[m
[32m+[m[32m            iSkip = FinderPatternFinder.MIN_SKIP;[m
[32m+[m[32m        }[m
[32m+[m[32m        var done = false;[m
[32m+[m[32m        var stateCount = new Int32Array(5);[m
[32m+[m[32m        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {[m
[32m+[m[32m            // Get a row of black/white values[m
[32m+[m[32m            stateCount[0] = 0;[m
[32m+[m[32m            stateCount[1] = 0;[m
[32m+[m[32m            stateCount[2] = 0;[m
[32m+[m[32m            stateCount[3] = 0;[m
[32m+[m[32m            stateCount[4] = 0;[m
[32m+[m[32m            var currentState = 0;[m
[32m+[m[32m            for (var j = 0; j < maxJ; j++) {[m
[32m+[m[32m                if (image.get(j, i)) {[m
[32m+[m[32m                    // Black pixel[m
[32m+[m[32m                    if ((currentState & 1) === 1) { // Counting white pixels[m
[32m+[m[32m                        currentState++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    stateCount[currentState]++;[m
[32m+[m[32m                }[m
[32m+[m[32m                else { // White pixel[m
[32m+[m[32m                    if ((currentState & 1) === 0) { // Counting black pixels[m
[32m+[m[32m                        if (currentState === 4) { // A winner?[m
[32m+[m[32m                            if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes[m
[32m+[m[32m                                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);[m
[32m+[m[32m                                if (confirmed === true) {[m
[32m+[m[32m                                    // Start examining every other line. Checking each line turned out to be too[m
[32m+[m[32m                                    // expensive and didn't improve performance.[m
[32m+[m[32m                                    iSkip = 2;[m
[32m+[m[32m                                    if (this.hasSkipped === true) {[m
[32m+[m[32m                                        done = this.haveMultiplyConfirmedCenters();[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                    else {[m
[32m+[m[32m                                        var rowSkip = this.findRowSkip();[m
[32m+[m[32m                                        if (rowSkip > stateCount[2]) {[m
[32m+[m[32m                                            // Skip rows between row of lower confirmed center[m
[32m+[m[32m                                            // and top of presumed third confirmed center[m
[32m+[m[32m                                            // but back up a bit to get a full chance of detecting[m
[32m+[m[32m                                            // it, entire width of center of finder pattern[m
[32m+[m[32m                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center[m
[32m+[m[32m                                            // of pattern we saw) to be conservative, and also back off by iSkip which[m
[32m+[m[32m                                            // is about to be re-added[m
[32m+[m[32m                                            i += rowSkip - stateCount[2] - iSkip;[m
[32m+[m[32m                                            j = maxJ - 1;[m
[32m+[m[32m                                        }[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                else {[m
[32m+[m[32m                                    stateCount[0] = stateCount[2];[m
[32m+[m[32m                                    stateCount[1] = stateCount[3];[m
[32m+[m[32m                                    stateCount[2] = stateCount[4];[m
[32m+[m[32m                                    stateCount[3] = 1;[m
[32m+[m[32m                                    stateCount[4] = 0;[m
[32m+[m[32m                                    currentState = 3;[m
[32m+[m[32m                                    continue;[m
[32m+[m[32m                                }[m
[32m+[m[32m                                // Clear state to start looking again[m
[32m+[m[32m                                currentState = 0;[m
[32m+[m[32m                                stateCount[0] = 0;[m
[32m+[m[32m                                stateCount[1] = 0;[m
[32m+[m[32m                                stateCount[2] = 0;[m
[32m+[m[32m                                stateCount[3] = 0;[m
[32m+[m[32m                                stateCount[4] = 0;[m
[32m+[m[32m                            }[m
[32m+[m[32m                            else { // No, shift counts back by two[m
[32m+[m[32m                                stateCount[0] = stateCount[2];[m
[32m+[m[32m                                stateCount[1] = stateCount[3];[m
[32m+[m[32m                                stateCount[2] = stateCount[4];[m
[32m+[m[32m                                stateCount[3] = 1;[m
[32m+[m[32m                                stateCount[4] = 0;[m
[32m+[m[32m                                currentState = 3;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else {[m
[32m+[m[32m                            stateCount[++currentState]++;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else { // Counting white pixels[m
[32m+[m[32m                        stateCount[currentState]++;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (FinderPatternFinder.foundPatternCross(stateCount)) {[m
[32m+[m[32m                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);[m
[32m+[m[32m                if (confirmed === true) {[m
[32m+[m[32m                    iSkip = stateCount[0];[m
[32m+[m[32m                    if (this.hasSkipped) {[m
[32m+[m[32m                        // Found a third one[m
[32m+[m[32m                        done = this.haveMultiplyConfirmedCenters();[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var patternInfo = this.selectBestPatterns();[m
[32m+[m[32m        ResultPoint_1.default.orderBestPatterns(patternInfo);[m
[32m+[m[32m        return new FinderPatternInfo_1.default(patternInfo);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Given a count of black/white/black/white/black pixels just seen and an end position,[m
[32m+[m[32m     * figures the location of the center of this run.[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {[m
[32m+[m[32m        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param stateCount count of black/white/black/white/black pixels just read[m
[32m+[m[32m     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios[m
[32m+[m[32m     *         used by finder patterns to be considered a match[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.foundPatternCross = function (stateCount) {[m
[32m+[m[32m        var totalModuleSize = 0;[m
[32m+[m[32m        for (var i = 0; i < 5; i++) {[m
[32m+[m[32m            var count = stateCount[i];[m
[32m+[m[32m            if (count === 0) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m            totalModuleSize += count;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (totalModuleSize < 7) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var moduleSize = totalModuleSize / 7.0;[m
[32m+[m[32m        var maxVariance = moduleSize / 2.0;[m
[32m+[m[32m        // Allow less than 50% variance from 1-1-3-1-1 proportions[m
[32m+[m[32m        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&[m
[32m+[m[32m            Math.abs(moduleSize - stateCount[1]) < maxVariance &&[m
[32m+[m[32m            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&[m
[32m+[m[32m            Math.abs(moduleSize - stateCount[3]) < maxVariance &&[m
[32m+[m[32m            Math.abs(moduleSize - stateCount[4]) < maxVariance;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {[m
[32m+[m[32m        var crossCheckStateCount = this.crossCheckStateCount;[m
[32m+[m[32m        crossCheckStateCount[0] = 0;[m
[32m+[m[32m        crossCheckStateCount[1] = 0;[m
[32m+[m[32m        crossCheckStateCount[2] = 0;[m
[32m+[m[32m        crossCheckStateCount[3] = 0;[m
[32m+[m[32m        crossCheckStateCount[4] = 0;[m
[32m+[m[32m        return crossCheckStateCount;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * After a vertical and horizontal scan finds a potential finder pattern, this method[m
[32m+[m[32m     * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible[m
[32m+[m[32m     * finder pattern to see if the same proportion is detected.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where a finder pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross a finder pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     *  observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @param originalStateCountTotal The original state count total.[m
[32m+[m[32m     * @return true if proportions are withing expected limits[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {[m
[32m+[m[32m        var stateCount = this.getCrossCheckStateCount();[m
[32m+[m[32m        // Start counting up, left from center finding black center mass[m
[32m+[m[32m        var i = 0;[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (startI < i || centerJ < i) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Continue up, left finding white space[m
[32m+[m[32m        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&[m
[32m+[m[32m            stateCount[1] <= maxCount) {[m
[32m+[m[32m            stateCount[1]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If already too many modules in this state or ran off the edge:[m
[32m+[m[32m        if (startI < i || centerJ < i || stateCount[1] > maxCount) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Continue up, left finding black border[m
[32m+[m[32m        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&[m
[32m+[m[32m            stateCount[0] <= maxCount) {[m
[32m+[m[32m            stateCount[0]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[0] > maxCount) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var maxI = image.getHeight();[m
[32m+[m[32m        var maxJ = image.getWidth();[m
[32m+[m[32m        // Now also count down, right from center[m
[32m+[m[32m        i = 1;[m
[32m+[m[32m        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Ran off the edge?[m
[32m+[m[32m        if (startI + i >= maxI || centerJ + i >= maxJ) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&[m
[32m+[m[32m            stateCount[3] < maxCount) {[m
[32m+[m[32m            stateCount[3]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&[m
[32m+[m[32m            stateCount[4] < maxCount) {[m
[32m+[m[32m            stateCount[4]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[4] >= maxCount) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we found a finder-pattern-like section, but its size is more than 100% different than[m
[32m+[m[32m        // the original, assume it's a false positive[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];[m
[32m+[m[32m        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&[m
[32m+[m[32m            FinderPatternFinder.foundPatternCross(stateCount);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>After a horizontal scan finds a potential finder pattern, this method[m
[32m+[m[32m     * "cross-checks" by scanning down vertically through the center of the possible[m
[32m+[m[32m     * finder pattern to see if the same proportion is detected.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param startI row where a finder pattern was detected[m
[32m+[m[32m     * @param centerJ center of the section that appears to cross a finder pattern[m
[32m+[m[32m     * @param maxCount maximum reasonable number of modules that should be[m
[32m+[m[32m     * observed in any reading state, based on the results of the horizontal scan[m
[32m+[m[32m     * @return vertical center of finder pattern, or {@link Float#NaN} if not found[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        var maxI = image.getHeight();[m
[32m+[m[32m        var stateCount = this.getCrossCheckStateCount();[m
[32m+[m[32m        // Start counting up from center[m
[32m+[m[32m        var i = startI;[m
[32m+[m[32m        while (i >= 0 && image.get(centerJ, i)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (i < 0) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {[m
[32m+[m[32m            stateCount[1]++;[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If already too many modules in this state or ran off the edge:[m
[32m+[m[32m        if (i < 0 || stateCount[1] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {[m
[32m+[m[32m            stateCount[0]++;[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[0] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now also count down from center[m
[32m+[m[32m        i = startI + 1;[m
[32m+[m[32m        while (i < maxI && image.get(centerJ, i)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (i === maxI) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {[m
[32m+[m[32m            stateCount[3]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (i === maxI || stateCount[3] >= maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {[m
[32m+[m[32m            stateCount[4]++;[m
[32m+[m[32m            i++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[4] >= maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we found a finder-pattern-like section, but its size is more than 40% different than[m
[32m+[m[32m        // the original, assume it's a false positive[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +[m
[32m+[m[32m            stateCount[4];[m
[32m+[m[32m        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,[m
[32m+[m[32m     * except it reads horizontally instead of vertically. This is used to cross-cross[m
[32m+[m[32m     * check a vertical cross check and locate the real center of the alignment pattern.</p>[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {[m
[32m+[m[32m        var image = this.image;[m
[32m+[m[32m        var maxJ = image.getWidth();[m
[32m+[m[32m        var stateCount = this.getCrossCheckStateCount();[m
[32m+[m[32m        var j = startJ;[m
[32m+[m[32m        while (j >= 0 && image.get(j, centerI)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            j--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (j < 0) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {[m
[32m+[m[32m            stateCount[1]++;[m
[32m+[m[32m            j--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (j < 0 || stateCount[1] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {[m
[32m+[m[32m            stateCount[0]++;[m
[32m+[m[32m            j--;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[0] > maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        j = startJ + 1;[m
[32m+[m[32m        while (j < maxJ && image.get(j, centerI)) {[m
[32m+[m[32m            stateCount[2]++;[m
[32m+[m[32m            j++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (j === maxJ) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {[m
[32m+[m[32m            stateCount[3]++;[m
[32m+[m[32m            j++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (j === maxJ || stateCount[3] >= maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {[m
[32m+[m[32m            stateCount[4]++;[m
[32m+[m[32m            j++;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (stateCount[4] >= maxCount) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we found a finder-pattern-like section, but its size is significantly different than[m
[32m+[m[32m        // the original, assume it's a false positive[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +[m
[32m+[m[32m            stateCount[4];[m
[32m+[m[32m        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {[m
[32m+[m[32m            return NaN;[m
[32m+[m[32m        }[m
[32m+[m[32m        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will[m
[32m+[m[32m     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check[m
[32m+[m[32m     * with another horizontal scan. This is needed primarily to locate the real horizontal[m
[32m+[m[32m     * center of the pattern in cases of extreme skew.[m
[32m+[m[32m     * And then we cross-cross-cross check with another diagonal scan.</p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p>If that succeeds the finder pattern location is added to a list that tracks[m
[32m+[m[32m     * the number of times each location has been nearly-matched as a finder pattern.[m
[32m+[m[32m     * Each additional find is more evidence that the location is in fact a finder[m
[32m+[m[32m     * pattern center[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param stateCount reading state module counts from horizontal scan[m
[32m+[m[32m     * @param i row where finder pattern may be found[m
[32m+[m[32m     * @param j end of possible finder pattern in row[m
[32m+[m[32m     * @param pureBarcode true if in "pure barcode" mode[m
[32m+[m[32m     * @return true if a finder pattern candidate was found this time[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {[m
[32m+[m[32m        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +[m
[32m+[m[32m            stateCount[4];[m
[32m+[m[32m        var centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);[m
[32m+[m[32m        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);[m
[32m+[m[32m        if (!isNaN(centerI)) {[m
[32m+[m[32m            // Re-cross check[m
[32m+[m[32m            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);[m
[32m+[m[32m            if (!isNaN(centerJ) &&[m
[32m+[m[32m                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {[m
[32m+[m[32m                var estimatedModuleSize = stateCountTotal / 7.0;[m
[32m+[m[32m                var found = false;[m
[32m+[m[32m                var possibleCenters = this.possibleCenters;[m
[32m+[m[32m                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {[m
[32m+[m[32m                    var center = possibleCenters[index];[m
[32m+[m[32m                    // Look for about the same center and module size:[m
[32m+[m[32m                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {[m
[32m+[m[32m                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);[m
[32m+[m[32m                        found = true;[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                if (!found) {[m
[32m+[m[32m                    var point = new FinderPattern_1.default(centerJ, centerI, estimatedModuleSize);[m
[32m+[m[32m                    possibleCenters.push(point);[m
[32m+[m[32m                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {[m
[32m+[m[32m                        this.resultPointCallback.foundPossibleResultPoint(point);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                return true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return false;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return number of rows we could safely skip during scanning, based on the first[m
[32m+[m[32m     *         two finder patterns that have been located. In some cases their position will[m
[32m+[m[32m     *         allow us to infer that the third pattern must lie below a certain point farther[m
[32m+[m[32m     *         down in the image.[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.findRowSkip = function () {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        var max = this.possibleCenters.length;[m
[32m+[m[32m        if (max <= 1) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var firstConfirmedCenter = null;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var center = _c.value;[m
[32m+[m[32m                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {[m
[32m+[m[32m                    if (firstConfirmedCenter == null) {[m
[32m+[m[32m                        firstConfirmedCenter = center;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        // We have two confirmed centers[m
[32m+[m[32m                        // How far down can we skip before resuming looking for the next[m
[32m+[m[32m                        // pattern? In the worst case, only the difference between the[m
[32m+[m[32m                        // difference in the x / y coordinates of the two centers.[m
[32m+[m[32m                        // This is the case where you find top left last.[m
[32m+[m[32m                        this.hasSkipped = true;[m
[32m+[m[32m                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -[m
[32m+[m[32m                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true iff we have found at least 3 finder patterns that have been detected[m
[32m+[m[32m     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the[m
[32m+[m[32m     *         candidates is "pretty similar"[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {[m
[32m+[m[32m        var e_2, _a, e_3, _b;[m
[32m+[m[32m        var confirmedCount = 0;[m
[32m+[m[32m        var totalModuleSize = 0.0;[m
[32m+[m[32m        var max = this.possibleCenters.length;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {[m
[32m+[m[32m                var pattern = _d.value;[m
[32m+[m[32m                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {[m
[32m+[m[32m                    confirmedCount++;[m
[32m+[m[32m                    totalModuleSize += pattern.getEstimatedModuleSize();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (confirmedCount < 3) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"[m
[32m+[m[32m        // and that we need to keep looking. We detect this by asking if the estimated module sizes[m
[32m+[m[32m        // vary too much. We arbitrarily say that when the total deviation from average exceeds[m
[32m+[m[32m        // 5% of the total module size estimates, it's too much.[m
[32m+[m[32m        var average = totalModuleSize / max;[m
[32m+[m[32m        var totalDeviation = 0.0;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {[m
[32m+[m[32m                var pattern = _f.value;[m
[32m+[m[32m                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_3_1) { e_3 = { error: e_3_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_3) throw e_3.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return totalDeviation <= 0.05 * totalModuleSize;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are[m
[32m+[m[32m     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module[m
[32m+[m[32m     *         size differs from the average among those patterns the least[m
[32m+[m[32m     * @throws NotFoundException if 3 such finder patterns do not exist[m
[32m+[m[32m     */[m
[32m+[m[32m    FinderPatternFinder.prototype.selectBestPatterns = function () {[m
[32m+[m[32m        var e_4, _a, e_5, _b;[m
[32m+[m[32m        var startSize = this.possibleCenters.length;[m
[32m+[m[32m        if (startSize < 3) {[m
[32m+[m[32m            // Couldn't find enough finder patterns[m
[32m+[m[32m            throw new NotFoundException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        var possibleCenters = this.possibleCenters;[m
[32m+[m[32m        var average;[m
[32m+[m[32m        // Filter outlier possibilities whose module size is too different[m
[32m+[m[32m        if (startSize > 3) {[m
[32m+[m[32m            // But we can only afford to do so if we have at least 4 possibilities to choose from[m
[32m+[m[32m            var totalModuleSize = 0.0;[m
[32m+[m[32m            var square = 0.0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {[m
[32m+[m[32m                    var center = _d.value;[m
[32m+[m[32m                    var size = center.getEstimatedModuleSize();[m
[32m+[m[32m                    totalModuleSize += size;[m
[32m+[m[32m                    square += size * size;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_4_1) { e_4 = { error: e_4_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_4) throw e_4.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            average = totalModuleSize / startSize;[m
[32m+[m[32m            var stdDev = Math.sqrt(square / startSize - average * average);[m
[32m+[m[32m            possibleCenters.sort([m
[32m+[m[32m            /**[m
[32m+[m[32m             * <p>Orders by furthest from average</p>[m
[32m+[m[32m             */[m
[32m+[m[32m            // FurthestFromAverageComparator implements Comparator<FinderPattern>[m
[32m+[m[32m            function (center1, center2) {[m
[32m+[m[32m                var dA = Math.abs(center2.getEstimatedModuleSize() - average);[m
[32m+[m[32m                var dB = Math.abs(center1.getEstimatedModuleSize() - average);[m
[32m+[m[32m                return dA < dB ? -1 : dA > dB ? 1 : 0;[m
[32m+[m[32m            });[m
[32m+[m[32m            var limit = Math.max(0.2 * average, stdDev);[m
[32m+[m[32m            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {[m
[32m+[m[32m                var pattern = possibleCenters[i];[m
[32m+[m[32m                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {[m
[32m+[m[32m                    possibleCenters.splice(i, 1);[m
[32m+[m[32m                    i--;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (possibleCenters.length > 3) {[m
[32m+[m[32m            // Throw away all but those first size candidate points we found.[m
[32m+[m[32m            var totalModuleSize = 0.0;[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {[m
[32m+[m[32m                    var possibleCenter = possibleCenters_1_1.value;[m
[32m+[m[32m                    totalModuleSize += possibleCenter.getEstimatedModuleSize();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_5_1) { e_5 = { error: e_5_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_5) throw e_5.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m            average = totalModuleSize / possibleCenters.length;[m
[32m+[m[32m            possibleCenters.sort([m
[32m+[m[32m            /**[m
[32m+[m[32m             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>[m
[32m+[m[32m             */[m
[32m+[m[32m            // CenterComparator implements Comparator<FinderPattern>[m
[32m+[m[32m            function (center1, center2) {[m
[32m+[m[32m                if (center2.getCount() === center1.getCount()) {[m
[32m+[m[32m                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);[m
[32m+[m[32m                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);[m
[32m+[m[32m                    return dA < dB ? 1 : dA > dB ? -1 : 0;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    return center2.getCount() - center1.getCount();[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m[32m            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway[m
[32m+[m[32m        }[m
[32m+[m[32m        return [[m
[32m+[m[32m            possibleCenters[0],[m
[32m+[m[32m            possibleCenters[1],[m
[32m+[m[32m            possibleCenters[2][m
[32m+[m[32m        ];[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternFinder.CENTER_QUORUM = 2;[m
[32m+[m[32m    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center[m
[32m+[m[32m    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients[m
[32m+[m[32m    return FinderPatternFinder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = FinderPatternFinder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..c75bd63[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.d.ts[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mimport FinderPattern from './FinderPattern';[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates information about finder patterns in an image, including the location of[m
[32m+[m[32m * the three finder patterns, and their estimated module size.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class FinderPatternInfo {[m
[32m+[m[32m    private bottomLeft;[m
[32m+[m[32m    private topLeft;[m
[32m+[m[32m    private topRight;[m
[32m+[m[32m    constructor(patternCenters: FinderPattern[]);[m
[32m+[m[32m    getBottomLeft(): FinderPattern;[m
[32m+[m[32m    getTopLeft(): FinderPattern;[m
[32m+[m[32m    getTopRight(): FinderPattern;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js[m
[1mnew file mode 100644[m
[1mindex 0000000..1b0b397[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternInfo.js[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2007 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Encapsulates information about finder patterns in an image, including the location of[m
[32m+[m[32m * the three finder patterns, and their estimated module size.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar FinderPatternInfo = /** @class */ (function () {[m
[32m+[m[32m    function FinderPatternInfo(patternCenters) {[m
[32m+[m[32m        this.bottomLeft = patternCenters[0];[m
[32m+[m[32m        this.topLeft = patternCenters[1];[m
[32m+[m[32m        this.topRight = patternCenters[2];[m
[32m+[m[32m    }[m
[32m+[m[32m    FinderPatternInfo.prototype.getBottomLeft = function () {[m
[32m+[m[32m        return this.bottomLeft;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternInfo.prototype.getTopLeft = function () {[m
[32m+[m[32m        return this.topLeft;[m
[32m+[m[32m    };[m
[32m+[m[32m    FinderPatternInfo.prototype.getTopRight = function () {[m
[32m+[m[32m        return this.topRight;[m
[32m+[m[32m    };[m
[32m+[m[32m    return FinderPatternInfo;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = FinderPatternInfo;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9f8cc30[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.d.ts[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mexport default class BlockPair {[m
[32m+[m[32m    private dataBytes;[m
[32m+[m[32m    private errorCorrectionBytes;[m
[32m+[m[32m    constructor(dataBytes: Uint8Array, errorCorrectionBytes: Uint8Array);[m
[32m+[m[32m    getDataBytes(): Uint8Array;[m
[32m+[m[32m    getErrorCorrectionBytes(): Uint8Array;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js[m
[1mnew file mode 100644[m
[1mindex 0000000..0b746aa[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/BlockPair.js[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.encoder {*/[m
[32m+[m[32mvar BlockPair = /** @class */ (function () {[m
[32m+[m[32m    function BlockPair(dataBytes, errorCorrectionBytes) {[m
[32m+[m[32m        this.dataBytes = dataBytes;[m
[32m+[m[32m        this.errorCorrectionBytes = errorCorrectionBytes;[m
[32m+[m[32m    }[m
[32m+[m[32m    BlockPair.prototype.getDataBytes = function () {[m
[32m+[m[32m        return this.dataBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    BlockPair.prototype.getErrorCorrectionBytes = function () {[m
[32m+[m[32m        return this.errorCorrectionBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    return BlockPair;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = BlockPair;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..dc7e595[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.d.ts[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned[m
[32m+[m[32m * -1, 0, and 1, I'm going to use less memory and go with bytes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ByteMatrix {[m
[32m+[m[32m    private width;[m
[32m+[m[32m    private height;[m
[32m+[m[32m    private bytes;[m
[32m+[m[32m    constructor(width: number, height: number);[m
[32m+[m[32m    getHeight(): number;[m
[32m+[m[32m    getWidth(): number;[m
[32m+[m[32m    get(x: number, y: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)[m
[32m+[m[32m     */[m
[32m+[m[32m    getArray(): Array<Uint8Array>;[m
[32m+[m[32m    setNumber(x: number, y: number, value: number): void;[m
[32m+[m[32m    setBoolean(x: number, y: number, value: boolean): void;[m
[32m+[m[32m    clear(value: number): void;[m
[32m+[m[32m    equals(o: any): boolean;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js[m
[1mnew file mode 100644[m
[1mindex 0000000..deaaf96[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/ByteMatrix.js[m
[36m@@ -0,0 +1,136 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.encoder {*/[m
[32m+[m[32m/*import java.util.Arrays;*/[m
[32m+[m[32mvar Arrays_1 = require("../../util/Arrays");[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32m/**[m
[32m+[m[32m * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned[m
[32m+[m[32m * -1, 0, and 1, I'm going to use less memory and go with bytes.[m
[32m+[m[32m *[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin)[m
[32m+[m[32m */[m
[32m+[m[32mvar ByteMatrix = /** @class */ (function () {[m
[32m+[m[32m    function ByteMatrix(width /*int*/, height /*int*/) {[m
[32m+[m[32m        this.width = width;[m
[32m+[m[32m        this.height = height;[m
[32m+[m[32m        var bytes = new Array(height); // [height][width][m
[32m+[m[32m        for (var i = 0; i !== height; i++) {[m
[32m+[m[32m            bytes[i] = new Uint8Array(width);[m
[32m+[m[32m        }[m
[32m+[m[32m        this.bytes = bytes;[m
[32m+[m[32m    }[m
[32m+[m[32m    ByteMatrix.prototype.getHeight = function () {[m
[32m+[m[32m        return this.height;[m
[32m+[m[32m    };[m
[32m+[m[32m    ByteMatrix.prototype.getWidth = function () {[m
[32m+[m[32m        return this.width;[m
[32m+[m[32m    };[m
[32m+[m[32m    ByteMatrix.prototype.get = function (x /*int*/, y /*int*/) {[m
[32m+[m[32m        return this.bytes[y][x];[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteMatrix.prototype.getArray = function () {[m
[32m+[m[32m        return this.bytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside[m
[32m+[m[32m    ByteMatrix.prototype.setNumber = function (x /*int*/, y /*int*/, value /*byte|int*/) {[m
[32m+[m[32m        this.bytes[y][x] = value;[m
[32m+[m[32m    };[m
[32m+[m[32m    // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {[m
[32m+[m[32m    //   bytes[y][x] = (byte) value[m
[32m+[m[32m    // }[m
[32m+[m[32m    ByteMatrix.prototype.setBoolean = function (x /*int*/, y /*int*/, value) {[m
[32m+[m[32m        this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);[m
[32m+[m[32m    };[m
[32m+[m[32m    ByteMatrix.prototype.clear = function (value /*byte*/) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var _b = __values(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {[m
[32m+[m[32m                var aByte = _c.value;[m
[32m+[m[32m                Arrays_1.default.fill(aByte, value);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    ByteMatrix.prototype.equals = function (o) {[m
[32m+[m[32m        if (!(o instanceof ByteMatrix)) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var other = o;[m
[32m+[m[32m        if (this.width !== other.width) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (this.height !== other.height) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var y = 0, height = this.height; y < height; ++y) {[m
[32m+[m[32m            var bytesY = this.bytes[y];[m
[32m+[m[32m            var otherBytesY = other.bytes[y];[m
[32m+[m[32m            for (var x = 0, width = this.width; x < width; ++x) {[m
[32m+[m[32m                if (bytesY[x] !== otherBytesY[x]) {[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    ByteMatrix.prototype.toString = function () {[m
[32m+[m[32m        var result = new StringBuilder_1.default(); // (2 * width * height + 2)[m
[32m+[m[32m        for (var y = 0, height = this.height; y < height; ++y) {[m
[32m+[m[32m            var bytesY = this.bytes[y];[m
[32m+[m[32m            for (var x = 0, width = this.width; x < width; ++x) {[m
[32m+[m[32m                switch (bytesY[x]) {[m
[32m+[m[32m                    case 0:[m
[32m+[m[32m                        result.append(' 0');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case 1:[m
[32m+[m[32m                        result.append(' 1');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        result.append('  ');[m
[32m+[m[32m                        break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            result.append('\n');[m
[32m+[m[32m        }[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    return ByteMatrix;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = ByteMatrix;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..293813c[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.d.ts[m
[36m@@ -0,0 +1,87 @@[m
[32m+[m[32mimport EncodeHintType from '../../EncodeHintType';[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport ErrorCorrectionLevel from '../decoder/ErrorCorrectionLevel';[m
[32m+[m[32mimport Mode from '../decoder/Mode';[m
[32m+[m[32mimport Version from '../decoder/Version';[m
[32m+[m[32mimport QRCode from './QRCode';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mexport default class Encoder {[m
[32m+[m[32m    private static ALPHANUMERIC_TABLE;[m
[32m+[m[32m    static DEFAULT_BYTE_MODE_ENCODING: string;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    private static calculateMaskPenalty;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param content text to encode[m
[32m+[m[32m     * @param ecLevel error correction level to use[m
[32m+[m[32m     * @return {@link QRCode} representing the encoded QR code[m
[32m+[m[32m     * @throws WriterException if encoding can't succeed, because of for example invalid content[m
[32m+[m[32m     *   or configuration[m
[32m+[m[32m     */[m
[32m+[m[32m    static encode(content: string, ecLevel: ErrorCorrectionLevel, hints?: Map<EncodeHintType, any>): QRCode;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decides the smallest version of QR code that will contain all of the provided data.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws WriterException if the data cannot fit in any version[m
[32m+[m[32m     */[m
[32m+[m[32m    private static recommendVersion;[m
[32m+[m[32m    private static calculateBitsNeeded;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the code point of the table used in alphanumeric mode or[m
[32m+[m[32m     *  -1 if there is no corresponding code in the table.[m
[32m+[m[32m     */[m
[32m+[m[32m    static getAlphanumericCode(code: number): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;[m
[32m+[m[32m     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.[m
[32m+[m[32m     */[m
[32m+[m[32m    static chooseMode(content: string, encoding?: string): Mode;[m
[32m+[m[32m    private static isOnlyDoubleByteKanji;[m
[32m+[m[32m    private static chooseMaskPattern;[m
[32m+[m[32m    private static chooseVersion;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the number of input bits will fit in a code with the specified version and[m
[32m+[m[32m     * error correction level.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static willFit;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).[m
[32m+[m[32m     */[m
[32m+[m[32m    static terminateBits(numDataBytes: number, bits: BitArray): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Get number of data bytes and number of error correction bytes for block id "blockID". Store[m
[32m+[m[32m     * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of[m
[32m+[m[32m     * JISX0510:2004 (p.30)[m
[32m+[m[32m     */[m
[32m+[m[32m    static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes: number, numDataBytes: number, numRSBlocks: number, blockID: number, numDataBytesInBlock: Int32Array, numECBytesInBlock: Int32Array): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Interleave "bits" with corresponding error correction bytes. On success, store the result in[m
[32m+[m[32m     * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.[m
[32m+[m[32m     */[m
[32m+[m[32m    static interleaveWithECBytes(bits: BitArray, numTotalBytes: number, numDataBytes: number, numRSBlocks: number): BitArray;[m
[32m+[m[32m    static generateECBytes(dataBytes: Uint8Array, numEcBytesInBlock: number): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append mode info. On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    static appendModeInfo(mode: Mode, bits: BitArray): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append length info. On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    static appendLengthInfo(numLetters: number, version: Version, mode: Mode, bits: BitArray): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    static appendBytes(content: string, mode: Mode, bits: BitArray, encoding: string): void;[m
[32m+[m[32m    private static getDigit;[m
[32m+[m[32m    private static isDigit;[m
[32m+[m[32m    static appendNumericBytes(content: string, bits: BitArray): void;[m
[32m+[m[32m    static appendAlphanumericBytes(content: string, bits: BitArray): void;[m
[32m+[m[32m    static append8BitBytes(content: string, bits: BitArray, encoding: string): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws WriterException[m
[32m+[m[32m     */[m
[32m+[m[32m    static appendKanjiBytes(content: string, bits: BitArray): void;[m
[32m+[m[32m    private static appendECI;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js[m
[1mnew file mode 100644[m
[1mindex 0000000..d902a50[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js[m
[36m@@ -0,0 +1,586 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.encoder {*/[m
[32m+[m[32mvar EncodeHintType_1 = require("../../EncodeHintType");[m
[32m+[m[32mvar BitArray_1 = require("../../common/BitArray");[m
[32m+[m[32mvar CharacterSetECI_1 = require("../../common/CharacterSetECI");[m
[32m+[m[32mvar GenericGF_1 = require("../../common/reedsolomon/GenericGF");[m
[32m+[m[32mvar ReedSolomonEncoder_1 = require("../../common/reedsolomon/ReedSolomonEncoder");[m
[32m+[m[32mvar Mode_1 = require("../decoder/Mode");[m
[32m+[m[32mvar Version_1 = require("../decoder/Version");[m
[32m+[m[32mvar MaskUtil_1 = require("./MaskUtil");[m
[32m+[m[32mvar ByteMatrix_1 = require("./ByteMatrix");[m
[32m+[m[32mvar QRCode_1 = require("./QRCode");[m
[32m+[m[32mvar MatrixUtil_1 = require("./MatrixUtil");[m
[32m+[m[32mvar StringEncoding_1 = require("../../util/StringEncoding");[m
[32m+[m[32mvar BlockPair_1 = require("./BlockPair");[m
[32m+[m[32mvar WriterException_1 = require("../../WriterException");[m
[32m+[m[32m/*import java.io.UnsupportedEncodingException;*/[m
[32m+[m[32m/*import java.util.ArrayList;*/[m
[32m+[m[32m/*import java.util.Collection;*/[m
[32m+[m[32m/*import java.util.Map;*/[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mvar Encoder = /** @class */ (function () {[m
[32m+[m[32m    // TYPESCRIPTPORT: changed to UTF8, the default for js[m
[32m+[m[32m    function Encoder() {[m
[32m+[m[32m    }[m
[32m+[m[32m    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.[m
[32m+[m[32m    // Basically it applies four rules and summate all penalties.[m
[32m+[m[32m    Encoder.calculateMaskPenalty = function (matrix) {[m
[32m+[m[32m        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)[m
[32m+[m[32m            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)[m
[32m+[m[32m            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)[m
[32m+[m[32m            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param content text to encode[m
[32m+[m[32m     * @param ecLevel error correction level to use[m
[32m+[m[32m     * @return {@link QRCode} representing the encoded QR code[m
[32m+[m[32m     * @throws WriterException if encoding can't succeed, because of for example invalid content[m
[32m+[m[32m     *   or configuration[m
[32m+[m[32m     */[m
[32m+[m[32m    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {[m
[32m+[m[32m    //   return encode(content, ecLevel, null)[m
[32m+[m[32m    // }[m
[32m+[m[32m    Encoder.encode = function (content, ecLevel, hints) {[m
[32m+[m[32m        if (hints === void 0) { hints = null; }[m
[32m+[m[32m        // Determine what character encoding has been specified by the caller, if any[m
[32m+[m[32m        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;[m
[32m+[m[32m        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);[m
[32m+[m[32m        if (hasEncodingHint) {[m
[32m+[m[32m            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();[m
[32m+[m[32m        }[m
[32m+[m[32m        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use[m
[32m+[m[32m        // multiple modes / segments even if that were more efficient. Twould be nice.[m
[32m+[m[32m        var mode = this.chooseMode(content, encoding);[m
[32m+[m[32m        // This will store the header information, like mode and[m
[32m+[m[32m        // length, as well as "header" segments like an ECI segment.[m
[32m+[m[32m        var headerBits = new BitArray_1.default();[m
[32m+[m[32m        // Append ECI segment if applicable[m
[32m+[m[32m        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {[m
[32m+[m[32m            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);[m
[32m+[m[32m            if (eci !== undefined) {[m
[32m+[m[32m                this.appendECI(eci, headerBits);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // (With ECI in place,) Write the mode marker[m
[32m+[m[32m        this.appendModeInfo(mode, headerBits);[m
[32m+[m[32m        // Collect data within the main segment, separately, to count its size if needed. Don't add it to[m
[32m+[m[32m        // main payload yet.[m
[32m+[m[32m        var dataBits = new BitArray_1.default();[m
[32m+[m[32m        this.appendBytes(content, mode, dataBits, encoding);[m
[32m+[m[32m        var version;[m
[32m+[m[32m        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {[m
[32m+[m[32m            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);[m
[32m+[m[32m            version = Version_1.default.getVersionForNumber(versionNumber);[m
[32m+[m[32m            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);[m
[32m+[m[32m            if (!this.willFit(bitsNeeded, version, ecLevel)) {[m
[32m+[m[32m                throw new WriterException_1.default('Data too big for requested version');[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);[m
[32m+[m[32m        }[m
[32m+[m[32m        var headerAndDataBits = new BitArray_1.default();[m
[32m+[m[32m        headerAndDataBits.appendBitArray(headerBits);[m
[32m+[m[32m        // Find "length" of main segment and write it[m
[32m+[m[32m        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;[m
[32m+[m[32m        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);[m
[32m+[m[32m        // Put data together into the overall payload[m
[32m+[m[32m        headerAndDataBits.appendBitArray(dataBits);[m
[32m+[m[32m        var ecBlocks = version.getECBlocksForLevel(ecLevel);[m
[32m+[m[32m        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();[m
[32m+[m[32m        // Terminate the bits properly.[m
[32m+[m[32m        this.terminateBits(numDataBytes, headerAndDataBits);[m
[32m+[m[32m        // Interleave data bits with error correction code.[m
[32m+[m[32m        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());[m
[32m+[m[32m        var qrCode = new QRCode_1.default();[m
[32m+[m[32m        qrCode.setECLevel(ecLevel);[m
[32m+[m[32m        qrCode.setMode(mode);[m
[32m+[m[32m        qrCode.setVersion(version);[m
[32m+[m[32m        //  Choose the mask pattern and set to "qrCode".[m
[32m+[m[32m        var dimension = version.getDimensionForVersion();[m
[32m+[m[32m        var matrix = new ByteMatrix_1.default(dimension, dimension);[m
[32m+[m[32m        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);[m
[32m+[m[32m        qrCode.setMaskPattern(maskPattern);[m
[32m+[m[32m        // Build the matrix and set it to "qrCode".[m
[32m+[m[32m        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);[m
[32m+[m[32m        qrCode.setMatrix(matrix);[m
[32m+[m[32m        return qrCode;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Decides the smallest version of QR code that will contain all of the provided data.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws WriterException if the data cannot fit in any version[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {[m
[32m+[m[32m        // Hard part: need to know version to know how many bits length takes. But need to know how many[m
[32m+[m[32m        // bits it takes to know version. First we take a guess at version by assuming version will be[m
[32m+[m[32m        // the minimum, 1:[m
[32m+[m[32m        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));[m
[32m+[m[32m        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);[m
[32m+[m[32m        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.[m
[32m+[m[32m        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);[m
[32m+[m[32m        return this.chooseVersion(bitsNeeded, ecLevel);[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {[m
[32m+[m[32m        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return the code point of the table used in alphanumeric mode or[m
[32m+[m[32m     *  -1 if there is no corresponding code in the table.[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.getAlphanumericCode = function (code /*int*/) {[m
[32m+[m[32m        if (code < Encoder.ALPHANUMERIC_TABLE.length) {[m
[32m+[m[32m            return Encoder.ALPHANUMERIC_TABLE[code];[m
[32m+[m[32m        }[m
[32m+[m[32m        return -1;[m
[32m+[m[32m    };[m
[32m+[m[32m    // public static chooseMode(content: string): Mode {[m
[32m+[m[32m    //   return chooseMode(content, null);[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;[m
[32m+[m[32m     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.chooseMode = function (content, encoding) {[m
[32m+[m[32m        if (encoding === void 0) { encoding = null; }[m
[32m+[m[32m        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {[m
[32m+[m[32m            // Choose Kanji mode if all input are double-byte characters[m
[32m+[m[32m            return Mode_1.default.KANJI;[m
[32m+[m[32m        }[m
[32m+[m[32m        var hasNumeric = false;[m
[32m+[m[32m        var hasAlphanumeric = false;[m
[32m+[m[32m        for (var i = 0, length_1 = content.length; i < length_1; ++i) {[m
[32m+[m[32m            var c = content.charAt(i);[m
[32m+[m[32m            if (Encoder.isDigit(c)) {[m
[32m+[m[32m                hasNumeric = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {[m
[32m+[m[32m                hasAlphanumeric = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                return Mode_1.default.BYTE;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (hasAlphanumeric) {[m
[32m+[m[32m            return Mode_1.default.ALPHANUMERIC;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (hasNumeric) {[m
[32m+[m[32m            return Mode_1.default.NUMERIC;[m
[32m+[m[32m        }[m
[32m+[m[32m        return Mode_1.default.BYTE;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.isOnlyDoubleByteKanji = function (content) {[m
[32m+[m[32m        var bytes;[m
[32m+[m[32m        try {[m
[32m+[m[32m            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes("Shift_JIS"))[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (ignored /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        var length = bytes.length;[m
[32m+[m[32m        if (length % 2 !== 0) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < length; i += 2) {[m
[32m+[m[32m            var byte1 = bytes[i] & 0xFF;[m
[32m+[m[32m            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {[m
[32m+[m[32m        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.[m
[32m+[m[32m        var bestMaskPattern = -1;[m
[32m+[m[32m        // We try all mask patterns to choose the best one.[m
[32m+[m[32m        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {[m
[32m+[m[32m            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);[m
[32m+[m[32m            var penalty = this.calculateMaskPenalty(matrix);[m
[32m+[m[32m            if (penalty < minPenalty) {[m
[32m+[m[32m                minPenalty = penalty;[m
[32m+[m[32m                bestMaskPattern = maskPattern;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return bestMaskPattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {[m
[32m+[m[32m        for (var versionNum = 1; versionNum <= 40; versionNum++) {[m
[32m+[m[32m            var version = Version_1.default.getVersionForNumber(versionNum);[m
[32m+[m[32m            if (Encoder.willFit(numInputBits, version, ecLevel)) {[m
[32m+[m[32m                return version;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        throw new WriterException_1.default('Data too big');[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @return true if the number of input bits will fit in a code with the specified version and[m
[32m+[m[32m     * error correction level.[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {[m
[32m+[m[32m        // In the following comments, we use numbers of Version 7-H.[m
[32m+[m[32m        // numBytes = 196[m
[32m+[m[32m        var numBytes = version.getTotalCodewords();[m
[32m+[m[32m        // getNumECBytes = 130[m
[32m+[m[32m        var ecBlocks = version.getECBlocksForLevel(ecLevel);[m
[32m+[m[32m        var numEcBytes = ecBlocks.getTotalECCodewords();[m
[32m+[m[32m        // getNumDataBytes = 196 - 130 = 66[m
[32m+[m[32m        var numDataBytes = numBytes - numEcBytes;[m
[32m+[m[32m        var totalInputBytes = (numInputBits + 7) / 8;[m
[32m+[m[32m        return numDataBytes >= totalInputBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {[m
[32m+[m[32m        var capacity = numDataBytes * 8;[m
[32m+[m[32m        if (bits.getSize() > capacity) {[m
[32m+[m[32m            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +[m
[32m+[m[32m                capacity);[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {[m
[32m+[m[32m            bits.appendBit(false);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.[m
[32m+[m[32m        // If the last byte isn't 8-bit aligned, we'll add padding bits.[m
[32m+[m[32m        var numBitsInLastByte = bits.getSize() & 0x07;[m
[32m+[m[32m        if (numBitsInLastByte > 0) {[m
[32m+[m[32m            for (var i = numBitsInLastByte; i < 8; i++) {[m
[32m+[m[32m                bits.appendBit(false);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).[m
[32m+[m[32m        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();[m
[32m+[m[32m        for (var i = 0; i < numPaddingBytes; ++i) {[m
[32m+[m[32m            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (bits.getSize() !== capacity) {[m
[32m+[m[32m            throw new WriterException_1.default('Bits size does not equal capacity');[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Get number of data bytes and number of error correction bytes for block id "blockID". Store[m
[32m+[m[32m     * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of[m
[32m+[m[32m     * JISX0510:2004 (p.30)[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {[m
[32m+[m[32m        if (blockID >= numRSBlocks) {[m
[32m+[m[32m            throw new WriterException_1.default('Block ID too large');[m
[32m+[m[32m        }[m
[32m+[m[32m        // numRsBlocksInGroup2 = 196 % 5 = 1[m
[32m+[m[32m        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;[m
[32m+[m[32m        // numRsBlocksInGroup1 = 5 - 1 = 4[m
[32m+[m[32m        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;[m
[32m+[m[32m        // numTotalBytesInGroup1 = 196 / 5 = 39[m
[32m+[m[32m        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);[m
[32m+[m[32m        // numTotalBytesInGroup2 = 39 + 1 = 40[m
[32m+[m[32m        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;[m
[32m+[m[32m        // numDataBytesInGroup1 = 66 / 5 = 13[m
[32m+[m[32m        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);[m
[32m+[m[32m        // numDataBytesInGroup2 = 13 + 1 = 14[m
[32m+[m[32m        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;[m
[32m+[m[32m        // numEcBytesInGroup1 = 39 - 13 = 26[m
[32m+[m[32m        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;[m
[32m+[m[32m        // numEcBytesInGroup2 = 40 - 14 = 26[m
[32m+[m[32m        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;[m
[32m+[m[32m        // Sanity checks.[m
[32m+[m[32m        // 26 = 26[m
[32m+[m[32m        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {[m
[32m+[m[32m            throw new WriterException_1.default('EC bytes mismatch');[m
[32m+[m[32m        }[m
[32m+[m[32m        // 5 = 4 + 1.[m
[32m+[m[32m        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {[m
[32m+[m[32m            throw new WriterException_1.default('RS blocks mismatch');[m
[32m+[m[32m        }[m
[32m+[m[32m        // 196 = (13 + 26) * 4 + (14 + 26) * 1[m
[32m+[m[32m        if (numTotalBytes !==[m
[32m+[m[32m            ((numDataBytesInGroup1 + numEcBytesInGroup1) *[m
[32m+[m[32m                numRsBlocksInGroup1) +[m
[32m+[m[32m                ((numDataBytesInGroup2 + numEcBytesInGroup2) *[m
[32m+[m[32m                    numRsBlocksInGroup2)) {[m
[32m+[m[32m            throw new WriterException_1.default('Total bytes mismatch');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (blockID < numRsBlocksInGroup1) {[m
[32m+[m[32m            numDataBytesInBlock[0] = numDataBytesInGroup1;[m
[32m+[m[32m            numECBytesInBlock[0] = numEcBytesInGroup1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            numDataBytesInBlock[0] = numDataBytesInGroup2;[m
[32m+[m[32m            numECBytesInBlock[0] = numEcBytesInGroup2;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Interleave "bits" with corresponding error correction bytes. On success, store the result in[m
[32m+[m[32m     * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {[m
[32m+[m[32m        var e_1, _a, e_2, _b;[m
[32m+[m[32m        // "bits" must have "getNumDataBytes" bytes of data.[m
[32m+[m[32m        if (bits.getSizeInBytes() !== numDataBytes) {[m
[32m+[m[32m            throw new WriterException_1.default('Number of bits and data bytes does not match');[m
[32m+[m[32m        }[m
[32m+[m[32m        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll[m
[32m+[m[32m        // store the divided data bytes blocks and error correction bytes blocks into "blocks".[m
[32m+[m[32m        var dataBytesOffset = 0;[m
[32m+[m[32m        var maxNumDataBytes = 0;[m
[32m+[m[32m        var maxNumEcBytes = 0;[m
[32m+[m[32m        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.[m
[32m+[m[32m        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)[m
[32m+[m[32m        for (var i = 0; i < numRSBlocks; ++i) {[m
[32m+[m[32m            var numDataBytesInBlock = new Int32Array(1);[m
[32m+[m[32m            var numEcBytesInBlock = new Int32Array(1);[m
[32m+[m[32m            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);[m
[32m+[m[32m            var size = numDataBytesInBlock[0];[m
[32m+[m[32m            var dataBytes = new Uint8Array(size);[m
[32m+[m[32m            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);[m
[32m+[m[32m            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);[m
[32m+[m[32m            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));[m
[32m+[m[32m            maxNumDataBytes = Math.max(maxNumDataBytes, size);[m
[32m+[m[32m            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);[m
[32m+[m[32m            dataBytesOffset += numDataBytesInBlock[0];[m
[32m+[m[32m        }[m
[32m+[m[32m        if (numDataBytes !== dataBytesOffset) {[m
[32m+[m[32m            throw new WriterException_1.default('Data bytes does not match offset');[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = new BitArray_1.default();[m
[32m+[m[32m        // First, place data blocks.[m
[32m+[m[32m        for (var i = 0; i < maxNumDataBytes; ++i) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var blocks_1 = (e_1 = void 0, __values(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {[m
[32m+[m[32m                    var block = blocks_1_1.value;[m
[32m+[m[32m                    var dataBytes = block.getDataBytes();[m
[32m+[m[32m                    if (i < dataBytes.length) {[m
[32m+[m[32m                        result.appendBits(dataBytes[i], 8);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Then, place error correction blocks.[m
[32m+[m[32m        for (var i = 0; i < maxNumEcBytes; ++i) {[m
[32m+[m[32m            try {[m
[32m+[m[32m                for (var blocks_2 = (e_2 = void 0, __values(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {[m
[32m+[m[32m                    var block = blocks_2_1.value;[m
[32m+[m[32m                    var ecBytes = block.getErrorCorrectionBytes();[m
[32m+[m[32m                    if (i < ecBytes.length) {[m
[32m+[m[32m                        result.appendBits(ecBytes[i], 8);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            catch (e_2_1) { e_2 = { error: e_2_1 }; }[m
[32m+[m[32m            finally {[m
[32m+[m[32m                try {[m
[32m+[m[32m                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);[m
[32m+[m[32m                }[m
[32m+[m[32m                finally { if (e_2) throw e_2.error; }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.[m
[32m+[m[32m            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +[m
[32m+[m[32m                result.getSizeInBytes() + ' differ.');[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {[m
[32m+[m[32m        var numDataBytes = dataBytes.length;[m
[32m+[m[32m        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock][m
[32m+[m[32m        for (var i = 0; i < numDataBytes; i++) {[m
[32m+[m[32m            toEncode[i] = dataBytes[i] & 0xFF;[m
[32m+[m[32m        }[m
[32m+[m[32m        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);[m
[32m+[m[32m        var ecBytes = new Uint8Array(numEcBytesInBlock);[m
[32m+[m[32m        for (var i = 0; i < numEcBytesInBlock; i++) {[m
[32m+[m[32m            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return ecBytes;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append mode info. On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.appendModeInfo = function (mode, bits) {[m
[32m+[m[32m        bits.appendBits(mode.getBits(), 4);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append length info. On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {[m
[32m+[m[32m        var numBits = mode.getCharacterCountBits(version);[m
[32m+[m[32m        if (numLetters >= (1 << numBits)) {[m
[32m+[m[32m            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));[m
[32m+[m[32m        }[m
[32m+[m[32m        bits.appendBits(numLetters, numBits);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.appendBytes = function (content, mode, bits, encoding) {[m
[32m+[m[32m        switch (mode) {[m
[32m+[m[32m            case Mode_1.default.NUMERIC:[m
[32m+[m[32m                Encoder.appendNumericBytes(content, bits);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode_1.default.ALPHANUMERIC:[m
[32m+[m[32m                Encoder.appendAlphanumericBytes(content, bits);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode_1.default.BYTE:[m
[32m+[m[32m                Encoder.append8BitBytes(content, bits, encoding);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case Mode_1.default.KANJI:[m
[32m+[m[32m                Encoder.appendKanjiBytes(content, bits);[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new WriterException_1.default('Invalid mode: ' + mode);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.getDigit = function (singleCharacter) {[m
[32m+[m[32m        return singleCharacter.charCodeAt(0) - 48;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.isDigit = function (singleCharacter) {[m
[32m+[m[32m        var cn = Encoder.getDigit(singleCharacter);[m
[32m+[m[32m        return cn >= 0 && cn <= 9;[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.appendNumericBytes = function (content, bits) {[m
[32m+[m[32m        var length = content.length;[m
[32m+[m[32m        var i = 0;[m
[32m+[m[32m        while (i < length) {[m
[32m+[m[32m            var num1 = Encoder.getDigit(content.charAt(i));[m
[32m+[m[32m            if (i + 2 < length) {[m
[32m+[m[32m                // Encode three numeric letters in ten bits.[m
[32m+[m[32m                var num2 = Encoder.getDigit(content.charAt(i + 1));[m
[32m+[m[32m                var num3 = Encoder.getDigit(content.charAt(i + 2));[m
[32m+[m[32m                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);[m
[32m+[m[32m                i += 3;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (i + 1 < length) {[m
[32m+[m[32m                // Encode two numeric letters in seven bits.[m
[32m+[m[32m                var num2 = Encoder.getDigit(content.charAt(i + 1));[m
[32m+[m[32m                bits.appendBits(num1 * 10 + num2, 7);[m
[32m+[m[32m                i += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Encode one numeric letter in four bits.[m
[32m+[m[32m                bits.appendBits(num1, 4);[m
[32m+[m[32m                i++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.appendAlphanumericBytes = function (content, bits) {[m
[32m+[m[32m        var length = content.length;[m
[32m+[m[32m        var i = 0;[m
[32m+[m[32m        while (i < length) {[m
[32m+[m[32m            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));[m
[32m+[m[32m            if (code1 === -1) {[m
[32m+[m[32m                throw new WriterException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            if (i + 1 < length) {[m
[32m+[m[32m                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));[m
[32m+[m[32m                if (code2 === -1) {[m
[32m+[m[32m                    throw new WriterException_1.default();[m
[32m+[m[32m                }[m
[32m+[m[32m                // Encode two alphanumeric letters in 11 bits.[m
[32m+[m[32m                bits.appendBits(code1 * 45 + code2, 11);[m
[32m+[m[32m                i += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Encode one alphanumeric letter in six bits.[m
[32m+[m[32m                bits.appendBits(code1, 6);[m
[32m+[m[32m                i++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.append8BitBytes = function (content, bits, encoding) {[m
[32m+[m[32m        var bytes;[m
[32m+[m[32m        try {[m
[32m+[m[32m            bytes = StringEncoding_1.default.encode(content, encoding);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (uee /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            throw new WriterException_1.default(uee);[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {[m
[32m+[m[32m            var b = bytes[i];[m
[32m+[m[32m            bits.appendBits(b, 8);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @throws WriterException[m
[32m+[m[32m     */[m
[32m+[m[32m    Encoder.appendKanjiBytes = function (content, bits) {[m
[32m+[m[32m        var bytes;[m
[32m+[m[32m        try {[m
[32m+[m[32m            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (uee /*: UnsupportedEncodingException*/) {[m
[32m+[m[32m            throw new WriterException_1.default(uee);[m
[32m+[m[32m        }[m
[32m+[m[32m        var length = bytes.length;[m
[32m+[m[32m        for (var i = 0; i < length; i += 2) {[m
[32m+[m[32m            var byte1 = bytes[i] & 0xFF;[m
[32m+[m[32m            var byte2 = bytes[i + 1] & 0xFF;[m
[32m+[m[32m            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;[m
[32m+[m[32m            var subtracted = -1;[m
[32m+[m[32m            if (code >= 0x8140 && code <= 0x9ffc) {[m
[32m+[m[32m                subtracted = code - 0x8140;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (code >= 0xe040 && code <= 0xebbf) {[m
[32m+[m[32m                subtracted = code - 0xc140;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (subtracted === -1) {[m
[32m+[m[32m                throw new WriterException_1.default('Invalid byte sequence');[m
[32m+[m[32m            }[m
[32m+[m[32m            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);[m
[32m+[m[32m            bits.appendBits(encoded, 13);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Encoder.appendECI = function (eci, bits) {[m
[32m+[m[32m        bits.appendBits(Mode_1.default.ECI.getBits(), 4);[m
[32m+[m[32m        // This is correct for values up to 127, which is all we need now.[m
[32m+[m[32m        bits.appendBits(eci.getValue(), 8);[m
[32m+[m[32m    };[m
[32m+[m[32m    // The original table is defined in the table 5 of JISX0510:2004 (p.19).[m
[32m+[m[32m    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([[m
[32m+[m[32m        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,[m
[32m+[m[32m        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,[m
[32m+[m[32m        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,[m
[32m+[m[32m        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,[m
[32m+[m[32m        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,[m
[32m+[m[32m        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,[m
[32m+[m[32m    ]);[m
[32m+[m[32m    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // "ISO-8859-1"[m
[32m+[m[32m    return Encoder;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Encoder;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..1db1576[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.d.ts[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32mimport ByteMatrix from './ByteMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Satoru Takabayashi[m
[32m+[m[32m * @author Daniel Switkin[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MaskUtil {[m
[32m+[m[32m    private static N1;[m
[32m+[m[32m    private static N2;[m
[32m+[m[32m    private static N3;[m
[32m+[m[32m    private static N4;[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and[m
[32m+[m[32m     * give penalty to them. Example: 00000 or 11111.[m
[32m+[m[32m     */[m
[32m+[m[32m    static applyMaskPenaltyRule1(matrix: ByteMatrix): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give[m
[32m+[m[32m     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a[m
[32m+[m[32m     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.[m
[32m+[m[32m     */[m
[32m+[m[32m    static applyMaskPenaltyRule2(matrix: ByteMatrix): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4[m
[32m+[m[32m     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we[m
[32m+[m[32m     * find patterns like 000010111010000, we give penalty once.[m
[32m+[m[32m     */[m
[32m+[m[32m    static applyMaskPenaltyRule3(matrix: ByteMatrix): number;[m
[32m+[m[32m    private static isWhiteHorizontal;[m
[32m+[m[32m    private static isWhiteVertical;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give[m
[32m+[m[32m     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.[m
[32m+[m[32m     */[m
[32m+[m[32m    static applyMaskPenaltyRule4(matrix: ByteMatrix): number;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask[m
[32m+[m[32m     * pattern conditions.[m
[32m+[m[32m     */[m
[32m+[m[32m    static getDataMaskBit(maskPattern: number, x: number, y: number): boolean;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both[m
[32m+[m[32m     * vertical and horizontal orders respectively.[m
[32m+[m[32m     */[m
[32m+[m[32m    private static applyMaskPenaltyRule1Internal;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a4795c5[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js[m
[36m@@ -0,0 +1,214 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author Satoru Takabayashi[m
[32m+[m[32m * @author Daniel Switkin[m
[32m+[m[32m * @author Sean Owen[m
[32m+[m[32m */[m
[32m+[m[32mvar MaskUtil = /** @class */ (function () {[m
[32m+[m[32m    function MaskUtil() {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and[m
[32m+[m[32m     * give penalty to them. Example: 00000 or 11111.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.applyMaskPenaltyRule1 = function (matrix) {[m
[32m+[m[32m        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give[m
[32m+[m[32m     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a[m
[32m+[m[32m     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.applyMaskPenaltyRule2 = function (matrix) {[m
[32m+[m[32m        var penalty = 0;[m
[32m+[m[32m        var array = matrix.getArray();[m
[32m+[m[32m        var width = matrix.getWidth();[m
[32m+[m[32m        var height = matrix.getHeight();[m
[32m+[m[32m        for (var y = 0; y < height - 1; y++) {[m
[32m+[m[32m            var arrayY = array[y];[m
[32m+[m[32m            for (var x = 0; x < width - 1; x++) {[m
[32m+[m[32m                var value = arrayY[x];[m
[32m+[m[32m                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {[m
[32m+[m[32m                    penalty++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return MaskUtil.N2 * penalty;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4[m
[32m+[m[32m     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we[m
[32m+[m[32m     * find patterns like 000010111010000, we give penalty once.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.applyMaskPenaltyRule3 = function (matrix) {[m
[32m+[m[32m        var numPenalties = 0;[m
[32m+[m[32m        var array = matrix.getArray();[m
[32m+[m[32m        var width = matrix.getWidth();[m
[32m+[m[32m        var height = matrix.getHeight();[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            for (var x = 0; x < width; x++) {[m
[32m+[m[32m                var arrayY = array[y]; // We can at least optimize this access[m
[32m+[m[32m                if (x + 6 < width &&[m
[32m+[m[32m                    arrayY[x] === 1 &&[m
[32m+[m[32m                    arrayY[x + 1] === 0 &&[m
[32m+[m[32m                    arrayY[x + 2] === 1 &&[m
[32m+[m[32m                    arrayY[x + 3] === 1 &&[m
[32m+[m[32m                    arrayY[x + 4] === 1 &&[m
[32m+[m[32m                    arrayY[x + 5] === 0 &&[m
[32m+[m[32m                    arrayY[x + 6] === 1 &&[m
[32m+[m[32m                    (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {[m
[32m+[m[32m                    numPenalties++;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (y + 6 < height &&[m
[32m+[m[32m                    array[y][x] === 1 &&[m
[32m+[m[32m                    array[y + 1][x] === 0 &&[m
[32m+[m[32m                    array[y + 2][x] === 1 &&[m
[32m+[m[32m                    array[y + 3][x] === 1 &&[m
[32m+[m[32m                    array[y + 4][x] === 1 &&[m
[32m+[m[32m                    array[y + 5][x] === 0 &&[m
[32m+[m[32m                    array[y + 6][x] === 1 &&[m
[32m+[m[32m                    (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {[m
[32m+[m[32m                    numPenalties++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return numPenalties * MaskUtil.N3;[m
[32m+[m[32m    };[m
[32m+[m[32m    MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {[m
[32m+[m[32m        from = Math.max(from, 0);[m
[32m+[m[32m        to = Math.min(to, rowArray.length);[m
[32m+[m[32m        for (var i = from; i < to; i++) {[m
[32m+[m[32m            if (rowArray[i] === 1) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {[m
[32m+[m[32m        from = Math.max(from, 0);[m
[32m+[m[32m        to = Math.min(to, array.length);[m
[32m+[m[32m        for (var i = from; i < to; i++) {[m
[32m+[m[32m            if (array[i][col] === 1) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give[m
[32m+[m[32m     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.applyMaskPenaltyRule4 = function (matrix) {[m
[32m+[m[32m        var numDarkCells = 0;[m
[32m+[m[32m        var array = matrix.getArray();[m
[32m+[m[32m        var width = matrix.getWidth();[m
[32m+[m[32m        var height = matrix.getHeight();[m
[32m+[m[32m        for (var y = 0; y < height; y++) {[m
[32m+[m[32m            var arrayY = array[y];[m
[32m+[m[32m            for (var x = 0; x < width; x++) {[m
[32m+[m[32m                if (arrayY[x] === 1) {[m
[32m+[m[32m                    numDarkCells++;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        var numTotalCells = matrix.getHeight() * matrix.getWidth();[m
[32m+[m[32m        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);[m
[32m+[m[32m        return fivePercentVariances * MaskUtil.N4;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask[m
[32m+[m[32m     * pattern conditions.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {[m
[32m+[m[32m        var intermediate; /*int*/[m
[32m+[m[32m        var temp; /*int*/[m
[32m+[m[32m        switch (maskPattern) {[m
[32m+[m[32m            case 0:[m
[32m+[m[32m                intermediate = (y + x) & 0x1;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 1:[m
[32m+[m[32m                intermediate = y & 0x1;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 2:[m
[32m+[m[32m                intermediate = x % 3;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 3:[m
[32m+[m[32m                intermediate = (y + x) % 3;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 4:[m
[32m+[m[32m                intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 5:[m
[32m+[m[32m                temp = y * x;[m
[32m+[m[32m                intermediate = (temp & 0x1) + (temp % 3);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 6:[m
[32m+[m[32m                temp = y * x;[m
[32m+[m[32m                intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case 7:[m
[32m+[m[32m                temp = y * x;[m
[32m+[m[32m                intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;[m
[32m+[m[32m                break;[m
[32m+[m[32m            default:[m
[32m+[m[32m                throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);[m
[32m+[m[32m        }[m
[32m+[m[32m        return intermediate === 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both[m
[32m+[m[32m     * vertical and horizontal orders respectively.[m
[32m+[m[32m     */[m
[32m+[m[32m    MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {[m
[32m+[m[32m        var penalty = 0;[m
[32m+[m[32m        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();[m
[32m+[m[32m        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();[m
[32m+[m[32m        var array = matrix.getArray();[m
[32m+[m[32m        for (var i = 0; i < iLimit; i++) {[m
[32m+[m[32m            var numSameBitCells = 0;[m
[32m+[m[32m            var prevBit = -1;[m
[32m+[m[32m            for (var j = 0; j < jLimit; j++) {[m
[32m+[m[32m                var bit = isHorizontal ? array[i][j] : array[j][i];[m
[32m+[m[32m                if (bit === prevBit) {[m
[32m+[m[32m                    numSameBitCells++;[m
[32m+[m[32m                }[m
[32m+[m[32m                else {[m
[32m+[m[32m                    if (numSameBitCells >= 5) {[m
[32m+[m[32m                        penalty += MaskUtil.N1 + (numSameBitCells - 5);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    numSameBitCells = 1; // Include the cell itself.[m
[32m+[m[32m                    prevBit = bit;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (numSameBitCells >= 5) {[m
[32m+[m[32m                penalty += MaskUtil.N1 + (numSameBitCells - 5);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return penalty;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Penalty weights from section 6.8.2.1[m
[32m+[m[32m    MaskUtil.N1 = 3;[m
[32m+[m[32m    MaskUtil.N2 = 3;[m
[32m+[m[32m    MaskUtil.N3 = 40;[m
[32m+[m[32m    MaskUtil.N4 = 10;[m
[32m+[m[32m    return MaskUtil;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = MaskUtil;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..505a5ed[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.d.ts[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32mimport BitArray from '../../common/BitArray';[m
[32m+[m[32mimport ErrorCorrectionLevel from '../decoder/ErrorCorrectionLevel';[m
[32m+[m[32mimport Version from '../decoder/Version';[m
[32m+[m[32mimport ByteMatrix from './ByteMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mexport default class MatrixUtil {[m
[32m+[m[32m    private constructor();[m
[32m+[m[32m    private static POSITION_DETECTION_PATTERN;[m
[32m+[m[32m    private static POSITION_ADJUSTMENT_PATTERN;[m
[32m+[m[32m    private static POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;[m
[32m+[m[32m    private static TYPE_INFO_COORDINATES;[m
[32m+[m[32m    private static VERSION_INFO_POLY;[m
[32m+[m[32m    private static TYPE_INFO_POLY;[m
[32m+[m[32m    private static TYPE_INFO_MASK_PATTERN;[m
[32m+[m[32m    static clearMatrix(matrix: ByteMatrix): void;[m
[32m+[m[32m    static buildMatrix(dataBits: BitArray, ecLevel: ErrorCorrectionLevel, version: Version, maskPattern: number, matrix: ByteMatrix): void;[m
[32m+[m[32m    static embedBasicPatterns(version: Version, matrix: ByteMatrix): void;[m
[32m+[m[32m    static embedTypeInfo(ecLevel: ErrorCorrectionLevel, maskPattern: number, matrix: ByteMatrix): void;[m
[32m+[m[32m    static maybeEmbedVersionInfo(version: Version, matrix: ByteMatrix): void;[m
[32m+[m[32m    static embedDataBits(dataBits: BitArray, maskPattern: number, matrix: ByteMatrix): void;[m
[32m+[m[32m    static findMSBSet(value: number): number;[m
[32m+[m[32m    static calculateBCHCode(value: number, poly: number): number;[m
[32m+[m[32m    static makeTypeInfoBits(ecLevel: ErrorCorrectionLevel, maskPattern: number, bits: BitArray): void;[m
[32m+[m[32m    static makeVersionInfoBits(version: Version, bits: BitArray): void;[m
[32m+[m[32m    private static isEmpty;[m
[32m+[m[32m    private static embedTimingPatterns;[m
[32m+[m[32m    private static embedDarkDotAtLeftBottomCorner;[m
[32m+[m[32m    private static embedHorizontalSeparationPattern;[m
[32m+[m[32m    private static embedVerticalSeparationPattern;[m
[32m+[m[32m    private static embedPositionAdjustmentPattern;[m
[32m+[m[32m    private static embedPositionDetectionPattern;[m
[32m+[m[32m    private static embedPositionDetectionPatternsAndSeparators;[m
[32m+[m[32m    private static maybeEmbedPositionAdjustmentPatterns;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js[m
[1mnew file mode 100644[m
[1mindex 0000000..a92c59d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/MatrixUtil.js[m
[36m@@ -0,0 +1,432 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m/*namespace com.google.zxing.qrcode.encoder {*/[m
[32m+[m[32mvar BitArray_1 = require("../../common/BitArray");[m
[32m+[m[32mvar Integer_1 = require("../../util/Integer");[m
[32m+[m[32mvar QRCode_1 = require("./QRCode");[m
[32m+[m[32mvar MaskUtil_1 = require("./MaskUtil");[m
[32m+[m[32mvar WriterException_1 = require("../../WriterException");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../../IllegalArgumentException");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mvar MatrixUtil = /** @class */ (function () {[m
[32m+[m[32m    function MatrixUtil() {[m
[32m+[m[32m        // do nothing[m
[32m+[m[32m    }[m
[32m+[m[32m    // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).[m
[32m+[m[32m    //[m
[32m+[m[32m    // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding[m
[32m+[m[32m    // with the ByteMatrix initialized all to zero.[m
[32m+[m[32m    MatrixUtil.clearMatrix = function (matrix) {[m
[32m+[m[32m        // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255[m
[32m+[m[32m        matrix.clear(/*(byte) */ /*-1*/ 255);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On[m
[32m+[m[32m    // success, store the result in "matrix" and return true.[m
[32m+[m[32m    MatrixUtil.buildMatrix = function (dataBits, ecLevel, version, maskPattern /*int*/, matrix) {[m
[32m+[m[32m        MatrixUtil.clearMatrix(matrix);[m
[32m+[m[32m        MatrixUtil.embedBasicPatterns(version, matrix);[m
[32m+[m[32m        // Type information appear with any version.[m
[32m+[m[32m        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);[m
[32m+[m[32m        // Version info appear if version >= 7.[m
[32m+[m[32m        MatrixUtil.maybeEmbedVersionInfo(version, matrix);[m
[32m+[m[32m        // Data should be embedded at end.[m
[32m+[m[32m        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed basic patterns. On success, modify the matrix and return true.[m
[32m+[m[32m    // The basic patterns are:[m
[32m+[m[32m    // - Position detection patterns[m
[32m+[m[32m    // - Timing patterns[m
[32m+[m[32m    // - Dark dot at the left bottom corner[m
[32m+[m[32m    // - Position adjustment patterns, if need be[m
[32m+[m[32m    MatrixUtil.embedBasicPatterns = function (version, matrix) {[m
[32m+[m[32m        // Let's get started with embedding big squares at corners.[m
[32m+[m[32m        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);[m
[32m+[m[32m        // Then, embed the dark dot at the left bottom corner.[m
[32m+[m[32m        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);[m
[32m+[m[32m        // Position adjustment patterns appear if version >= 2.[m
[32m+[m[32m        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);[m
[32m+[m[32m        // Timing patterns should be embedded after position adj. patterns.[m
[32m+[m[32m        MatrixUtil.embedTimingPatterns(matrix);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed type information. On success, modify the matrix.[m
[32m+[m[32m    MatrixUtil.embedTypeInfo = function (ecLevel, maskPattern /*int*/, matrix) {[m
[32m+[m[32m        var typeInfoBits = new BitArray_1.default();[m
[32m+[m[32m        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);[m
[32m+[m[32m        for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {[m
[32m+[m[32m            // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in[m
[32m+[m[32m            // "typeInfoBits".[m
[32m+[m[32m            var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);[m
[32m+[m[32m            // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).[m
[32m+[m[32m            var coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];[m
[32m+[m[32m            var x1 = coordinates[0];[m
[32m+[m[32m            var y1 = coordinates[1];[m
[32m+[m[32m            matrix.setBoolean(x1, y1, bit);[m
[32m+[m[32m            if (i < 8) {[m
[32m+[m[32m                // Right top corner.[m
[32m+[m[32m                var x2 = matrix.getWidth() - i - 1;[m
[32m+[m[32m                var y2 = 8;[m
[32m+[m[32m                matrix.setBoolean(x2, y2, bit);[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                // Left bottom corner.[m
[32m+[m[32m                var x2 = 8;[m
[32m+[m[32m                var y2 = matrix.getHeight() - 7 + (i - 8);[m
[32m+[m[32m                matrix.setBoolean(x2, y2, bit);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed version information if need be. On success, modify the matrix and return true.[m
[32m+[m[32m    // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.[m
[32m+[m[32m    MatrixUtil.maybeEmbedVersionInfo = function (version, matrix) {[m
[32m+[m[32m        if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.[m
[32m+[m[32m            return; // Don't need version info.[m
[32m+[m[32m        }[m
[32m+[m[32m        var versionInfoBits = new BitArray_1.default();[m
[32m+[m[32m        MatrixUtil.makeVersionInfoBits(version, versionInfoBits);[m
[32m+[m[32m        var bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.[m
[32m+[m[32m        for (var i = 0; i < 6; ++i) {[m
[32m+[m[32m            for (var j = 0; j < 3; ++j) {[m
[32m+[m[32m                // Place bits in LSB (least significant bit) to MSB order.[m
[32m+[m[32m                var bit = versionInfoBits.get(bitIndex);[m
[32m+[m[32m                bitIndex--;[m
[32m+[m[32m                // Left bottom corner.[m
[32m+[m[32m                matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);[m
[32m+[m[32m                // Right bottom corner.[m
[32m+[m[32m                matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.[m
[32m+[m[32m    // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).[m
[32m+[m[32m    // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.[m
[32m+[m[32m    MatrixUtil.embedDataBits = function (dataBits, maskPattern /*int*/, matrix) {[m
[32m+[m[32m        var bitIndex = 0;[m
[32m+[m[32m        var direction = -1;[m
[32m+[m[32m        // Start from the right bottom cell.[m
[32m+[m[32m        var x = matrix.getWidth() - 1;[m
[32m+[m[32m        var y = matrix.getHeight() - 1;[m
[32m+[m[32m        while (x > 0) {[m
[32m+[m[32m            // Skip the vertical timing pattern.[m
[32m+[m[32m            if (x === 6) {[m
[32m+[m[32m                x -= 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            while (y >= 0 && y < matrix.getHeight()) {[m
[32m+[m[32m                for (var i = 0; i < 2; ++i) {[m
[32m+[m[32m                    var xx = x - i;[m
[32m+[m[32m                    // Skip the cell if it's not empty.[m
[32m+[m[32m                    if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    var bit = void 0;[m
[32m+[m[32m                    if (bitIndex < dataBits.getSize()) {[m
[32m+[m[32m                        bit = dataBits.get(bitIndex);[m
[32m+[m[32m                        ++bitIndex;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else {[m
[32m+[m[32m                        // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described[m
[32m+[m[32m                        // in 8.4.9 of JISX0510:2004 (p. 24).[m
[32m+[m[32m                        bit = false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).[m
[32m+[m[32m                    if (maskPattern !== 255 && MaskUtil_1.default.getDataMaskBit(maskPattern, xx, y)) {[m
[32m+[m[32m                        bit = !bit;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    matrix.setBoolean(xx, y, bit);[m
[32m+[m[32m                }[m
[32m+[m[32m                y += direction;[m
[32m+[m[32m            }[m
[32m+[m[32m            direction = -direction; // Reverse the direction.[m
[32m+[m[32m            y += direction;[m
[32m+[m[32m            x -= 2; // Move to the left.[m
[32m+[m[32m        }[m
[32m+[m[32m        // All bits should be consumed.[m
[32m+[m[32m        if (bitIndex !== dataBits.getSize()) {[m
[32m+[m[32m            throw new WriterException_1.default('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Return the position of the most significant bit set (one: to) in the "value". The most[m
[32m+[m[32m    // significant bit is position 32. If there is no bit set, return 0. Examples:[m
[32m+[m[32m    // - findMSBSet(0) => 0[m
[32m+[m[32m    // - findMSBSet(1) => 1[m
[32m+[m[32m    // - findMSBSet(255) => 8[m
[32m+[m[32m    MatrixUtil.findMSBSet = function (value /*int*/) {[m
[32m+[m[32m        return 32 - Integer_1.default.numberOfLeadingZeros(value);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH[m
[32m+[m[32m    // code is used for encoding type information and version information.[m
[32m+[m[32m    // Example: Calculation of version information of 7.[m
[32m+[m[32m    // f(x) is created from 7.[m
[32m+[m[32m    //   - 7 = 000111 in 6 bits[m
[32m+[m[32m    //   - f(x) = x^2 + x^1 + x^0[m
[32m+[m[32m    // g(x) is given by the standard (p. 67)[m
[32m+[m[32m    //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1[m
[32m+[m[32m    // Multiply f(x) by x^(18 - 6)[m
[32m+[m[32m    //   - f'(x) = f(x) * x^(18 - 6)[m
[32m+[m[32m    //   - f'(x) = x^14 + x^13 + x^12[m
[32m+[m[32m    // Calculate the remainder of f'(x) / g(x)[m
[32m+[m[32m    //         x^2[m
[32m+[m[32m    //         __________________________________________________[m
[32m+[m[32m    //   g(x) )x^14 + x^13 + x^12[m
[32m+[m[32m    //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2[m
[32m+[m[32m    //         --------------------------------------------------[m
[32m+[m[32m    //                              x^11 + x^10 + x^7 + x^4 + x^2[m
[32m+[m[32m    //[m
[32m+[m[32m    // The remainder is x^11 + x^10 + x^7 + x^4 + x^2[m
[32m+[m[32m    // Encode it in binary: 110010010100[m
[32m+[m[32m    // The return value is 0xc94 (1100 1001 0100)[m
[32m+[m[32m    //[m
[32m+[m[32m    // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit[m
[32m+[m[32m    // operations. We don't care if coefficients are positive or negative.[m
[32m+[m[32m    MatrixUtil.calculateBCHCode = function (value /*int*/, poly /*int*/) {[m
[32m+[m[32m        if (poly === 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('0 polynomial');[m
[32m+[m[32m        }[m
[32m+[m[32m        // If poly is "1 1111 0010 0101" (version info poly), msbSetInPoly is 13. We'll subtract 1[m
[32m+[m[32m        // from 13 to make it 12.[m
[32m+[m[32m        var msbSetInPoly = MatrixUtil.findMSBSet(poly);[m
[32m+[m[32m        value <<= msbSetInPoly - 1;[m
[32m+[m[32m        // Do the division business using exclusive-or operations.[m
[32m+[m[32m        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {[m
[32m+[m[32m            value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);[m
[32m+[m[32m        }[m
[32m+[m[32m        // Now the "value" is the remainder (i.e. the BCH code)[m
[32m+[m[32m        return value;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Make bit vector of type information. On success, store the result in "bits" and return true.[m
[32m+[m[32m    // Encode error correction level and mask pattern. See 8.9 of[m
[32m+[m[32m    // JISX0510:2004 (p.45) for details.[m
[32m+[m[32m    MatrixUtil.makeTypeInfoBits = function (ecLevel, maskPattern /*int*/, bits) {[m
[32m+[m[32m        if (!QRCode_1.default.isValidMaskPattern(maskPattern)) {[m
[32m+[m[32m            throw new WriterException_1.default('Invalid mask pattern');[m
[32m+[m[32m        }[m
[32m+[m[32m        var typeInfo = (ecLevel.getBits() << 3) | maskPattern;[m
[32m+[m[32m        bits.appendBits(typeInfo, 5);[m
[32m+[m[32m        var bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);[m
[32m+[m[32m        bits.appendBits(bchCode, 10);[m
[32m+[m[32m        var maskBits = new BitArray_1.default();[m
[32m+[m[32m        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);[m
[32m+[m[32m        bits.xor(maskBits);[m
[32m+[m[32m        if (bits.getSize() !== 15) { // Just in case.[m
[32m+[m[32m            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Make bit vector of version information. On success, store the result in "bits" and return true.[m
[32m+[m[32m    // See 8.10 of JISX0510:2004 (p.45) for details.[m
[32m+[m[32m    MatrixUtil.makeVersionInfoBits = function (version, bits) {[m
[32m+[m[32m        bits.appendBits(version.getVersionNumber(), 6);[m
[32m+[m[32m        var bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);[m
[32m+[m[32m        bits.appendBits(bchCode, 12);[m
[32m+[m[32m        if (bits.getSize() !== 18) { // Just in case.[m
[32m+[m[32m            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Check if "value" is empty.[m
[32m+[m[32m    MatrixUtil.isEmpty = function (value /*int*/) {[m
[32m+[m[32m        return value === 255; // -1[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.embedTimingPatterns = function (matrix) {[m
[32m+[m[32m        // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical[m
[32m+[m[32m        // separation patterns (1: size). Thus, 8 = 7 + 1.[m
[32m+[m[32m        for (var i = 8; i < matrix.getWidth() - 8; ++i) {[m
[32m+[m[32m            var bit = (i + 1) % 2;[m
[32m+[m[32m            // Horizontal line.[m
[32m+[m[32m            if (MatrixUtil.isEmpty(matrix.get(i, 6))) {[m
[32m+[m[32m                matrix.setNumber(i, 6, bit);[m
[32m+[m[32m            }[m
[32m+[m[32m            // Vertical line.[m
[32m+[m[32m            if (MatrixUtil.isEmpty(matrix.get(6, i))) {[m
[32m+[m[32m                matrix.setNumber(6, i, bit);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)[m
[32m+[m[32m    MatrixUtil.embedDarkDotAtLeftBottomCorner = function (matrix) {[m
[32m+[m[32m        if (matrix.get(8, matrix.getHeight() - 8) === 0) {[m
[32m+[m[32m            throw new WriterException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        matrix.setNumber(8, matrix.getHeight() - 8, 1);[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.embedHorizontalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {[m
[32m+[m[32m        for (var x = 0; x < 8; ++x) {[m
[32m+[m[32m            if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {[m
[32m+[m[32m                throw new WriterException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            matrix.setNumber(xStart + x, yStart, 0);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.embedVerticalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {[m
[32m+[m[32m        for (var y = 0; y < 7; ++y) {[m
[32m+[m[32m            if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {[m
[32m+[m[32m                throw new WriterException_1.default();[m
[32m+[m[32m            }[m
[32m+[m[32m            matrix.setNumber(xStart, yStart + y, 0);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.embedPositionAdjustmentPattern = function (xStart /*int*/, yStart /*int*/, matrix) {[m
[32m+[m[32m        for (var y = 0; y < 5; ++y) {[m
[32m+[m[32m            var patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];[m
[32m+[m[32m            for (var x = 0; x < 5; ++x) {[m
[32m+[m[32m                matrix.setNumber(xStart + x, yStart + y, patternY[x]);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.embedPositionDetectionPattern = function (xStart /*int*/, yStart /*int*/, matrix) {[m
[32m+[m[32m        for (var y = 0; y < 7; ++y) {[m
[32m+[m[32m            var patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];[m
[32m+[m[32m            for (var x = 0; x < 7; ++x) {[m
[32m+[m[32m                matrix.setNumber(xStart + x, yStart + y, patternY[x]);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed position detection patterns and surrounding vertical/horizontal separators.[m
[32m+[m[32m    MatrixUtil.embedPositionDetectionPatternsAndSeparators = function (matrix) {[m
[32m+[m[32m        // Embed three big squares at corners.[m
[32m+[m[32m        var pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;[m
[32m+[m[32m        // Left top corner.[m
[32m+[m[32m        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);[m
[32m+[m[32m        // Right top corner.[m
[32m+[m[32m        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);[m
[32m+[m[32m        // Left bottom corner.[m
[32m+[m[32m        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);[m
[32m+[m[32m        // Embed horizontal separation patterns around the squares.[m
[32m+[m[32m        var hspWidth = 8;[m
[32m+[m[32m        // Left top corner.[m
[32m+[m[32m        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);[m
[32m+[m[32m        // Right top corner.[m
[32m+[m[32m        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);[m
[32m+[m[32m        // Left bottom corner.[m
[32m+[m[32m        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);[m
[32m+[m[32m        // Embed vertical separation patterns around the squares.[m
[32m+[m[32m        var vspSize = 7;[m
[32m+[m[32m        // Left top corner.[m
[32m+[m[32m        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);[m
[32m+[m[32m        // Right top corner.[m
[32m+[m[32m        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);[m
[32m+[m[32m        // Left bottom corner.[m
[32m+[m[32m        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);[m
[32m+[m[32m    };[m
[32m+[m[32m    // Embed position adjustment patterns if need be.[m
[32m+[m[32m    MatrixUtil.maybeEmbedPositionAdjustmentPatterns = function (version, matrix) {[m
[32m+[m[32m        if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        var index = version.getVersionNumber() - 1;[m
[32m+[m[32m        var coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];[m
[32m+[m[32m        for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {[m
[32m+[m[32m            var y = coordinates[i];[m
[32m+[m[32m            if (y >= 0) {[m
[32m+[m[32m                for (var j = 0; j !== length_1; j++) {[m
[32m+[m[32m                    var x = coordinates[j];[m
[32m+[m[32m                    if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {[m
[32m+[m[32m                        // If the cell is unset, we embed the position adjustment pattern here.[m
[32m+[m[32m                        // -2 is necessary since the x/y coordinates point to the center of the pattern, not the[m
[32m+[m[32m                        // left top corner.[m
[32m+[m[32m                        MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),[m
[32m+[m[32m    ]);[m
[32m+[m[32m    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 1, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 0, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 1, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 0, 0, 0, 1]),[m
[32m+[m[32m        Int32Array.from([1, 1, 1, 1, 1]),[m
[32m+[m[32m    ]);[m
[32m+[m[32m    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.[m
[32m+[m[32m    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([[m
[32m+[m[32m        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),[m
[32m+[m[32m        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),[m
[32m+[m[32m        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),[m
[32m+[m[32m        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),[m
[32m+[m[32m        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),[m
[32m+[m[32m        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),[m
[32m+[m[32m        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),[m
[32m+[m[32m        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),[m
[32m+[m[32m        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),[m
[32m+[m[32m    ]);[m
[32m+[m[32m    // Type info cells at the left top corner.[m
[32m+[m[32m    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([[m
[32m+[m[32m        Int32Array.from([8, 0]),[m
[32m+[m[32m        Int32Array.from([8, 1]),[m
[32m+[m[32m        Int32Array.from([8, 2]),[m
[32m+[m[32m        Int32Array.from([8, 3]),[m
[32m+[m[32m        Int32Array.from([8, 4]),[m
[32m+[m[32m        Int32Array.from([8, 5]),[m
[32m+[m[32m        Int32Array.from([8, 7]),[m
[32m+[m[32m        Int32Array.from([8, 8]),[m
[32m+[m[32m        Int32Array.from([7, 8]),[m
[32m+[m[32m        Int32Array.from([5, 8]),[m
[32m+[m[32m        Int32Array.from([4, 8]),[m
[32m+[m[32m        Int32Array.from([3, 8]),[m
[32m+[m[32m        Int32Array.from([2, 8]),[m
[32m+[m[32m        Int32Array.from([1, 8]),[m
[32m+[m[32m        Int32Array.from([0, 8]),[m
[32m+[m[32m    ]);[m
[32m+[m[32m    // From Appendix D in JISX0510:2004 (p. 67)[m
[32m+[m[32m    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101[m
[32m+[m[32m    // From Appendix C in JISX0510:2004 (p.65).[m
[32m+[m[32m    MatrixUtil.TYPE_INFO_POLY = 0x537;[m
[32m+[m[32m    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;[m
[32m+[m[32m    return MatrixUtil;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = MatrixUtil;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.d.ts b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..54ae399[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.d.ts[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mimport ErrorCorrectionLevel from '../decoder/ErrorCorrectionLevel';[m
[32m+[m[32mimport Mode from '../decoder/Mode';[m
[32m+[m[32mimport Version from '../decoder/Version';[m
[32m+[m[32mimport ByteMatrix from './ByteMatrix';[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mexport default class QRCode {[m
[32m+[m[32m    static NUM_MASK_PATTERNS: number;[m
[32m+[m[32m    private mode;[m
[32m+[m[32m    private ecLevel;[m
[32m+[m[32m    private version;[m
[32m+[m[32m    private maskPattern;[m
[32m+[m[32m    private matrix;[m
[32m+[m[32m    constructor();[m
[32m+[m[32m    getMode(): Mode;[m
[32m+[m[32m    getECLevel(): ErrorCorrectionLevel;[m
[32m+[m[32m    getVersion(): Version;[m
[32m+[m[32m    getMaskPattern(): number;[m
[32m+[m[32m    getMatrix(): ByteMatrix;[m
[32m+[m[32m    toString(): string;[m
[32m+[m[32m    setMode(value: Mode): void;[m
[32m+[m[32m    setECLevel(value: ErrorCorrectionLevel): void;[m
[32m+[m[32m    setVersion(version: Version): void;[m
[32m+[m[32m    setMaskPattern(value: number): void;[m
[32m+[m[32m    setMatrix(value: ByteMatrix): void;[m
[32m+[m[32m    static isValidMaskPattern(maskPattern: number): boolean;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js[m
[1mnew file mode 100644[m
[1mindex 0000000..40c0a1b[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/qrcode/encoder/QRCode.js[m
[36m@@ -0,0 +1,86 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright 2008 ZXing authors[m
[32m+[m[32m *[m
[32m+[m[32m * Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m * you may not use this file except in compliance with the License.[m
[32m+[m[32m * You may obtain a copy of the License at[m
[32m+[m[32m *[m
[32m+[m[32m *      http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m *[m
[32m+[m[32m * Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m * distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m * See the License for the specific language governing permissions and[m
[32m+[m[32m * limitations under the License.[m
[32m+[m[32m */[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar StringBuilder_1 = require("../../util/StringBuilder");[m
[32m+[m[32m/**[m
[32m+[m[32m * @author satorux@google.com (Satoru Takabayashi) - creator[m
[32m+[m[32m * @author dswitkin@google.com (Daniel Switkin) - ported from C++[m
[32m+[m[32m */[m
[32m+[m[32mvar QRCode = /** @class */ (function () {[m
[32m+[m[32m    function QRCode() {[m
[32m+[m[32m        this.maskPattern = -1;[m
[32m+[m[32m    }[m
[32m+[m[32m    QRCode.prototype.getMode = function () {[m
[32m+[m[32m        return this.mode;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.getECLevel = function () {[m
[32m+[m[32m        return this.ecLevel;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.getVersion = function () {[m
[32m+[m[32m        return this.version;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.getMaskPattern = function () {[m
[32m+[m[32m        return this.maskPattern;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.getMatrix = function () {[m
[32m+[m[32m        return this.matrix;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*@Override*/[m
[32m+[m[32m    QRCode.prototype.toString = function () {[m
[32m+[m[32m        var result = new StringBuilder_1.default(); // (200)[m
[32m+[m[32m        result.append('<<\n');[m
[32m+[m[32m        result.append(' mode: ');[m
[32m+[m[32m        result.append(this.mode ? this.mode.toString() : 'null');[m
[32m+[m[32m        result.append('\n ecLevel: ');[m
[32m+[m[32m        result.append(this.ecLevel ? this.ecLevel.toString() : 'null');[m
[32m+[m[32m        result.append('\n version: ');[m
[32m+[m[32m        result.append(this.version ? this.version.toString() : 'null');[m
[32m+[m[32m        result.append('\n maskPattern: ');[m
[32m+[m[32m        result.append(this.maskPattern.toString());[m
[32m+[m[32m        if (this.matrix) {[m
[32m+[m[32m            result.append('\n matrix:\n');[m
[32m+[m[32m            result.append(this.matrix.toString());[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            result.append('\n matrix: null\n');[m
[32m+[m[32m        }[m
[32m+[m[32m        result.append('>>\n');[m
[32m+[m[32m        return result.toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.setMode = function (value) {[m
[32m+[m[32m        this.mode = value;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.setECLevel = function (value) {[m
[32m+[m[32m        this.ecLevel = value;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.setVersion = function (version) {[m
[32m+[m[32m        this.version = version;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.setMaskPattern = function (value /*int*/) {[m
[32m+[m[32m        this.maskPattern = value;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.prototype.setMatrix = function (value) {[m
[32m+[m[32m        this.matrix = value;[m
[32m+[m[32m    };[m
[32m+[m[32m    // Check if "mask_pattern" is valid.[m
[32m+[m[32m    QRCode.isValidMaskPattern = function (maskPattern /*int*/) {[m
[32m+[m[32m        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;[m
[32m+[m[32m    };[m
[32m+[m[32m    QRCode.NUM_MASK_PATTERNS = 8;[m
[32m+[m[32m    return QRCode;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = QRCode;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.d.ts b/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..2d5d304[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.d.ts[m
[36m@@ -0,0 +1,45 @@[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32mexport default class Arrays {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assigns the specified int value to each element of the specified array[m
[32m+[m[32m     * of ints.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a the array to be filled[m
[32m+[m[32m     * @param val the value to be stored in all elements of the array[m
[32m+[m[32m     */[m
[32m+[m[32m    static fill(a: Int32Array | Uint8Array | any[], val: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assigns the specified int value to each element of the specified[m
[32m+[m[32m     * range of the specified array of ints.  The range to be filled[m
[32m+[m[32m     * extends from index {@code fromIndex}, inclusive, to index[m
[32m+[m[32m     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the[m
[32m+[m[32m     * range to be filled is empty.)[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a the array to be filled[m
[32m+[m[32m     * @param fromIndex the index of the first element (inclusive) to be[m
[32m+[m[32m     *        filled with the specified value[m
[32m+[m[32m     * @param toIndex the index of the last element (exclusive) to be[m
[32m+[m[32m     *        filled with the specified value[m
[32m+[m[32m     * @param val the value to be stored in all elements of the array[m
[32m+[m[32m     * @throws IllegalArgumentException if {@code fromIndex > toIndex}[m
[32m+[m[32m     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or[m
[32m+[m[32m     *         {@code toIndex > a.length}[m
[32m+[m[32m     */[m
[32m+[m[32m    static fillWithin(a: Int32Array, fromIndex: int, toIndex: int, val: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Checks that {@code fromIndex} and {@code toIndex} are in[m
[32m+[m[32m     * the range and throws an exception if they aren't.[m
[32m+[m[32m     */[m
[32m+[m[32m    static rangeCheck(arrayLength: int, fromIndex: int, toIndex: int): void;[m
[32m+[m[32m    static asList<T = any>(...args: T[]): T[];[m
[32m+[m[32m    static create<T = any>(rows: int, cols: int, value?: T): T[][];[m
[32m+[m[32m    static createInt32Array(rows: int, cols: int, value?: int): Int32Array[];[m
[32m+[m[32m    static equals(first: any, second: any): boolean;[m
[32m+[m[32m    static hashCode(a: any): number;[m
[32m+[m[32m    static fillUint8Array(a: Uint8Array, value: number): void;[m
[32m+[m[32m    static copyOf(original: Int32Array, newLength: number): Int32Array;[m
[32m+[m[32m    static copyOfUint8Array(original: Uint8Array, newLength: number): Uint8Array;[m
[32m+[m[32m    static copyOfRange(original: Int32Array, from: number, to: number): Int32Array;[m
[32m+[m[32m    static binarySearch(ar: Int32Array, el: number, comparator?: (a: number, b: number) => number): number;[m
[32m+[m[32m    static numberComparator(a: number, b: number): number;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.js b/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5d5030d[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/util/Arrays.js[m
[36m@@ -0,0 +1,190 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32mvar __values = (this && this.__values) || function(o) {[m
[32m+[m[32m    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;[m
[32m+[m[32m    if (m) return m.call(o);[m
[32m+[m[32m    if (o && typeof o.length === "number") return {[m
[32m+[m[32m        next: function () {[m
[32m+[m[32m            if (o && i >= o.length) o = void 0;[m
[32m+[m[32m            return { value: o && o[i++], done: !o };[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");[m
[32m+[m[32m};[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32mvar System_1 = require("./System");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32mvar ArrayIndexOutOfBoundsException_1 = require("../ArrayIndexOutOfBoundsException");[m
[32m+[m[32mvar Arrays = /** @class */ (function () {[m
[32m+[m[32m    function Arrays() {[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assigns the specified int value to each element of the specified array[m
[32m+[m[32m     * of ints.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a the array to be filled[m
[32m+[m[32m     * @param val the value to be stored in all elements of the array[m
[32m+[m[32m     */[m
[32m+[m[32m    Arrays.fill = function (a, val) {[m
[32m+[m[32m        for (var i = 0, len = a.length; i < len; i++)[m
[32m+[m[32m            a[i] = val;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Assigns the specified int value to each element of the specified[m
[32m+[m[32m     * range of the specified array of ints.  The range to be filled[m
[32m+[m[32m     * extends from index {@code fromIndex}, inclusive, to index[m
[32m+[m[32m     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the[m
[32m+[m[32m     * range to be filled is empty.)[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param a the array to be filled[m
[32m+[m[32m     * @param fromIndex the index of the first element (inclusive) to be[m
[32m+[m[32m     *        filled with the specified value[m
[32m+[m[32m     * @param toIndex the index of the last element (exclusive) to be[m
[32m+[m[32m     *        filled with the specified value[m
[32m+[m[32m     * @param val the value to be stored in all elements of the array[m
[32m+[m[32m     * @throws IllegalArgumentException if {@code fromIndex > toIndex}[m
[32m+[m[32m     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or[m
[32m+[m[32m     *         {@code toIndex > a.length}[m
[32m+[m[32m     */[m
[32m+[m[32m    Arrays.fillWithin = function (a, fromIndex, toIndex, val) {[m
[32m+[m[32m        Arrays.rangeCheck(a.length, fromIndex, toIndex);[m
[32m+[m[32m        for (var i = fromIndex; i < toIndex; i++)[m
[32m+[m[32m            a[i] = val;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Checks that {@code fromIndex} and {@code toIndex} are in[m
[32m+[m[32m     * the range and throws an exception if they aren't.[m
[32m+[m[32m     */[m
[32m+[m[32m    Arrays.rangeCheck = function (arrayLength, fromIndex, toIndex) {[m
[32m+[m[32m        if (fromIndex > toIndex) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');[m
[32m+[m[32m        }[m
[32m+[m[32m        if (fromIndex < 0) {[m
[32m+[m[32m            throw new ArrayIndexOutOfBoundsException_1.default(fromIndex);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (toIndex > arrayLength) {[m
[32m+[m[32m            throw new ArrayIndexOutOfBoundsException_1.default(toIndex);[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.asList = function () {[m
[32m+[m[32m        var args = [];[m
[32m+[m[32m        for (var _i = 0; _i < arguments.length; _i++) {[m
[32m+[m[32m            args[_i] = arguments[_i];[m
[32m+[m[32m        }[m
[32m+[m[32m        return args;[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.create = function (rows, cols, value) {[m
[32m+[m[32m        var arr = Array.from({ length: rows });[m
[32m+[m[32m        return arr.map(function (x) { return Array.from({ length: cols }).fill(value); });[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.createInt32Array = function (rows, cols, value) {[m
[32m+[m[32m        var arr = Array.from({ length: rows });[m
[32m+[m[32m        return arr.map(function (x) { return Int32Array.from({ length: cols }).fill(value); });[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.equals = function (first, second) {[m
[32m+[m[32m        if (!first) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!second) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!first.length) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!second.length) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (first.length !== second.length) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (var i = 0, length_1 = first.length; i < length_1; i++) {[m
[32m+[m[32m            if (first[i] !== second[i]) {[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.hashCode = function (a) {[m
[32m+[m[32m        var e_1, _a;[m
[32m+[m[32m        if (a === null) {[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        var result = 1;[m
[32m+[m[32m        try {[m
[32m+[m[32m            for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {[m
[32m+[m[32m                var element = a_1_1.value;[m
[32m+[m[32m                result = 31 * result + element;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        catch (e_1_1) { e_1 = { error: e_1_1 }; }[m
[32m+[m[32m        finally {[m
[32m+[m[32m            try {[m
[32m+[m[32m                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);[m
[32m+[m[32m            }[m
[32m+[m[32m            finally { if (e_1) throw e_1.error; }[m
[32m+[m[32m        }[m
[32m+[m[32m        return result;[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.fillUint8Array = function (a, value) {[m
[32m+[m[32m        for (var i = 0; i !== a.length; i++) {[m
[32m+[m[32m            a[i] = value;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.copyOf = function (original, newLength) {[m
[32m+[m[32m        return original.slice(0, newLength);[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.copyOfUint8Array = function (original, newLength) {[m
[32m+[m[32m        if (original.length <= newLength) {[m
[32m+[m[32m            var newArray = new Uint8Array(newLength);[m
[32m+[m[32m            newArray.set(original);[m
[32m+[m[32m            return newArray;[m
[32m+[m[32m        }[m
[32m+[m[32m        return original.slice(0, newLength);[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.copyOfRange = function (original, from, to) {[m
[32m+[m[32m        var newLength = to - from;[m
[32m+[m[32m        var copy = new Int32Array(newLength);[m
[32m+[m[32m        System_1.default.arraycopy(original, from, copy, 0, newLength);[m
[32m+[m[32m        return copy;[m
[32m+[m[32m    };[m
[32m+[m[32m    /*[m
[32m+[m[32m    * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point[m
[32m+[m[32m    * for the new element.[m
[32m+[m[32m    * Parameters:[m
[32m+[m[32m    *     ar - A sorted array[m
[32m+[m[32m    *     el - An element to search for[m
[32m+[m[32m    *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:[m
[32m+[m[32m    *        a negative number  if a is less than b;[m
[32m+[m[32m    *        0 if a is equal to b;[m
[32m+[m[32m    *        a positive number of a is greater than b.[m
[32m+[m[32m    * The array may contain duplicate elements. If there are more than one equal elements in the array,[m
[32m+[m[32m    * the returned value can be the index of any one of the equal elements.[m
[32m+[m[32m    *[m
[32m+[m[32m    * http://jsfiddle.net/aryzhov/pkfst550/[m
[32m+[m[32m    */[m
[32m+[m[32m    Arrays.binarySearch = function (ar, el, comparator) {[m
[32m+[m[32m        if (undefined === comparator) {[m
[32m+[m[32m            comparator = Arrays.numberComparator;[m
[32m+[m[32m        }[m
[32m+[m[32m        var m = 0;[m
[32m+[m[32m        var n = ar.length - 1;[m
[32m+[m[32m        while (m <= n) {[m
[32m+[m[32m            var k = (n + m) >> 1;[m
[32m+[m[32m            var cmp = comparator(el, ar[k]);[m
[32m+[m[32m            if (cmp > 0) {[m
[32m+[m[32m                m = k + 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (cmp < 0) {[m
[32m+[m[32m                n = k - 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            else {[m
[32m+[m[32m                return k;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return -m - 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    Arrays.numberComparator = function (a, b) {[m
[32m+[m[32m        return a - b;[m
[32m+[m[32m    };[m
[32m+[m[32m    return Arrays;[m
[32m+[m[32m}());[m
[32m+[m[32mexports.default = Arrays;[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.d.ts b/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.d.ts[m
[1mnew file mode 100644[m
[1mindex 0000000..9f030d4[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.d.ts[m
[36m@@ -0,0 +1,174 @@[m
[32m+[m[32mimport OutputStream from './OutputStream';[m
[32m+[m[32mimport { int } from '../../customTypings';[m
[32m+[m[32m/**[m
[32m+[m[32m * This class implements an output stream in which the data is[m
[32m+[m[32m * written into a byte array. The buffer automatically grows as data[m
[32m+[m[32m * is written to it.[m
[32m+[m[32m * The data can be retrieved using <code>toByteArray()</code> and[m
[32m+[m[32m * <code>toString()</code>.[m
[32m+[m[32m * <p>[m
[32m+[m[32m * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in[m
[32m+[m[32m * this class can be called after the stream has been closed without[m
[32m+[m[32m * generating an <tt>IOException</tt>.[m
[32m+[m[32m *[m
[32m+[m[32m * @author  Arthur van Hoff[m
[32m+[m[32m * @since   JDK1.0[m
[32m+[m[32m */[m
[32m+[m[32mexport default class ByteArrayOutputStream extends OutputStream {[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The buffer where data is stored.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected buf: Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The number of valid bytes in the buffer.[m
[32m+[m[32m     */[m
[32m+[m[32m    protected count: int;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a new byte array output stream. The buffer capacity is[m
[32m+[m[32m     * initially 32 bytes, though its size increases if necessary.[m
[32m+[m[32m     */[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a new byte array output stream, with a buffer capacity of[m
[32m+[m[32m     * the specified size, in bytes.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   size   the initial size.[m
[32m+[m[32m     * @exception  IllegalArgumentException if size is negative.[m
[32m+[m[32m     */[m
[32m+[m[32m    constructor(size?: int);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Increases the capacity if necessary to ensure that it can hold[m
[32m+[m[32m     * at least the number of elements specified by the minimum[m
[32m+[m[32m     * capacity argument.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param minCapacity the desired minimum capacity[m
[32m+[m[32m     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is[m
[32m+[m[32m     * interpreted as a request for the unsatisfiably large capacity[m
[32m+[m[32m     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    private ensureCapacity;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Increases the capacity to ensure that it can hold at least the[m
[32m+[m[32m     * number of elements specified by the minimum capacity argument.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param minCapacity the desired minimum capacity[m
[32m+[m[32m     */[m
[32m+[m[32m    private grow;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the specified byte to this byte array output stream.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   b   the byte to be written.[m
[32m+[m[32m     */[m
[32m+[m[32m    write(b: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes <code>len</code> bytes from the specified byte array[m
[32m+[m[32m     * starting at offset <code>off</code> to this byte array output stream.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   b     the data.[m
[32m+[m[32m     * @param   off   the start offset in the data.[m
[32m+[m[32m     * @param   len   the number of bytes to write.[m
[32m+[m[32m     */[m
[32m+[m[32m    writeBytesOffset(b: Uint8Array, off: int, len: int): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the complete contents of this byte array output stream to[m
[32m+[m[32m     * the specified output stream argument, as if by calling the output[m
[32m+[m[32m     * stream's write method using <code>out.write(buf, 0, count)</code>.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param      out   the output stream to which to write the data.[m
[32m+[m[32m     * @exception  IOException  if an I/O error occurs.[m
[32m+[m[32m     */[m
[32m+[m[32m    writeTo(out: OutputStream): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Resets the <code>count</code> field of this byte array output[m
[32m+[m[32m     * stream to zero, so that all currently accumulated output in the[m
[32m+[m[32m     * output stream is discarded. The output stream can be used again,[m
[32m+[m[32m     * reusing the already allocated buffer space.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see     java.io.ByteArrayInputStream#count[m
[32m+[m[32m     */[m
[32m+[m[32m    reset(): void;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a newly allocated byte array. Its size is the current[m
[32m+[m[32m     * size of this output stream and the valid contents of the buffer[m
[32m+[m[32m     * have been copied into it.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the current contents of this output stream, as a byte array.[m
[32m+[m[32m     * @see     java.io.ByteArrayOutputStream#size()[m
[32m+[m[32m     */[m
[32m+[m[32m    toByteArray(): Uint8Array;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the current size of the buffer.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the value of the <code>count</code> field, which is the number[m
[32m+[m[32m     *          of valid bytes in this output stream.[m
[32m+[m[32m     * @see     java.io.ByteArrayOutputStream#count[m
[32m+[m[32m     */[m
[32m+[m[32m    size(): int;[m
[32m+[m[32m    toString(param?: number | string): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts the buffer's contents into a string decoding bytes using the[m
[32m+[m[32m     * platform's default character set. The length of the new <tt>String</tt>[m
[32m+[m[32m     * is a function of the character set, and hence may not be equal to the[m
[32m+[m[32m     * size of the buffer.[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p> This method always replaces malformed-input and unmappable-character[m
[32m+[m[32m     * sequences with the default replacement string for the platform's[m
[32m+[m[32m     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}[m
[32m+[m[32m     * class should be used when more control over the decoding process is[m
[32m+[m[32m     * required.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return String decoded from the buffer's contents.[m
[32m+[m[32m     * @since  JDK1.1[m
[32m+[m[32m     */[m
[32m+[m[32m    toString_void(): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts the buffer's contents into a string by decoding the bytes using[m
[32m+[m[32m     * the specified {@link java.nio.charset.Charset charsetName}. The length of[m
[32m+[m[32m     * the new <tt>String</tt> is a function of the charset, and hence may not be[m
[32m+[m[32m     * equal to the length of the byte array.[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p> This method always replaces malformed-input and unmappable-character[m
[32m+[m[32m     * sequences with this charset's default replacement string. The {@link[m
[32m+[m[32m     * java.nio.charset.CharsetDecoder} class should be used when more control[m
[32m+[m[32m     * over the decoding process is required.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param  charsetName  the name of a supported[m
[32m+[m[32m     *              {@linkplain java.nio.charset.Charset </code>charset<code>}[m
[32m+[m[32m     * @return String decoded from the buffer's contents.[m
[32m+[m[32m     * @exception  UnsupportedEncodingException[m
[32m+[m[32m     *             If the named charset is not supported[m
[32m+[m[32m     * @since   JDK1.1[m
[32m+[m[32m     */[m
[32m+[m[32m    toString_string(charsetName: string): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a newly allocated string. Its size is the current size of[m
[32m+[m[32m     * the output stream and the valid contents of the buffer have been[m
[32m+[m[32m     * copied into it. Each character <i>c</i> in the resulting string is[m
[32m+[m[32m     * constructed from the corresponding element <i>b</i> in the byte[m
[32m+[m[32m     * array such that:[m
[32m+[m[32m     * <blockquote><pre>[m
[32m+[m[32m     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))[m
[32m+[m[32m     * </pre></blockquote>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated This method does not properly convert bytes into characters.[m
[32m+[m[32m     * As of JDK&nbsp;1.1, the preferred way to do this is via the[m
[32m+[m[32m     * <code>toString(String enc)</code> method, which takes an encoding-name[m
[32m+[m[32m     * argument, or the <code>toString()</code> method, which uses the[m
[32m+[m[32m     * platform's default character encoding.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param      hibyte    the high byte of each resulting Unicode character.[m
[32m+[m[32m     * @return     the current contents of the output stream, as a string.[m
[32m+[m[32m     * @see        java.io.ByteArrayOutputStream#size()[m
[32m+[m[32m     * @see        java.io.ByteArrayOutputStream#toString(String)[m
[32m+[m[32m     * @see        java.io.ByteArrayOutputStream#toString()[m
[32m+[m[32m     */[m
[32m+[m[32m    toString_number(hibyte: int): string;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in[m
[32m+[m[32m     * this class can be called after the stream has been closed without[m
[32m+[m[32m     * generating an <tt>IOException</tt>.[m
[32m+[m[32m     * <p>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @throws IOException[m
[32m+[m[32m     */[m
[32m+[m[32m    close(): void;[m
[32m+[m[32m}[m
[1mdiff --git a/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js b/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2dd16a3[m
[1m--- /dev/null[m
[1m+++ b/frontend/node_modules/@zxing/library/cjs/core/util/ByteArrayOutputStream.js[m
[36m@@ -0,0 +1,283 @@[m
[32m+[m[32m"use strict";[m
[32m+[m[32m/*[m
[32m+[m[32m * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.[m
[32m+[m[32m * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.[m
[32m+[m[32m *[m
[32m+[m[32m * This code is free software; you can redistribute it and/or modify it[m
[32m+[m[32m * under the terms of the GNU General Public License version 2 only, as[m
[32m+[m[32m * published by the Free Software Foundation.  Oracle designates this[m
[32m+[m[32m * particular file as subject to the "Classpath" exception as provided[m
[32m+[m[32m * by Oracle in the LICENSE file that accompanied this code.[m
[32m+[m[32m *[m
[32m+[m[32m * This code is distributed in the hope that it will be useful, but WITHOUT[m
[32m+[m[32m * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or[m
[32m+[m[32m * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License[m
[32m+[m[32m * version 2 for more details (a copy is included in the LICENSE file that[m
[32m+[m[32m * accompanied this code).[m
[32m+[m[32m *[m
[32m+[m[32m * You should have received a copy of the GNU General Public License version[m
[32m+[m[32m * 2 along with this work; if not, write to the Free Software Foundation,[m
[32m+[m[32m * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.[m
[32m+[m[32m *[m
[32m+[m[32m * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA[m
[32m+[m[32m * or visit www.oracle.com if you need additional information or have any[m
[32m+[m[32m * questions.[m
[32m+[m[32m */[m
[32m+[m[32mvar __extends = (this && this.__extends) || (function () {[m
[32m+[m[32m    var extendStatics = function (d, b) {[m
[32m+[m[32m        extendStatics = Object.setPrototypeOf ||[m
[32m+[m[32m            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||[m
[32m+[m[32m            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };[m
[32m+[m[32m        return extendStatics(d, b);[m
[32m+[m[32m    };[m
[32m+[m[32m    return function (d, b) {[m
[32m+[m[32m        extendStatics(d, b);[m
[32m+[m[32m        function __() { this.constructor = d; }[m
[32m+[m[32m        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());[m
[32m+[m[32m    };[m
[32m+[m[32m})();[m
[32m+[m[32mObject.defineProperty(exports, "__esModule", { value: true });[m
[32m+[m[32m// package java.io;[m
[32m+[m[32m// import java.util.Arrays;[m
[32m+[m[32mvar Arrays_1 = require("./Arrays");[m
[32m+[m[32mvar OutputStream_1 = require("./OutputStream");[m
[32m+[m[32mvar Integer_1 = require("./Integer");[m
[32m+[m[32mvar IllegalArgumentException_1 = require("../IllegalArgumentException");[m
[32m+[m[32mvar OutOfMemoryError_1 = require("../OutOfMemoryError");[m
[32m+[m[32mvar System_1 = require("./System");[m
[32m+[m[32mvar IndexOutOfBoundsException_1 = require("../IndexOutOfBoundsException");[m
[32m+[m[32m/**[m
[32m+[m[32m * This class implements an output stream in which the data is[m
[32m+[m[32m * written into a byte array. The buffer automatically grows as data[m
[32m+[m[32m * is written to it.[m
[32m+[m[32m * The data can be retrieved using <code>toByteArray()</code> and[m
[32m+[m[32m * <code>toString()</code>.[m
[32m+[m[32m * <p>[m
[32m+[m[32m * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in[m
[32m+[m[32m * this class can be called after the stream has been closed without[m
[32m+[m[32m * generating an <tt>IOException</tt>.[m
[32m+[m[32m *[m
[32m+[m[32m * @author  Arthur van Hoff[m
[32m+[m[32m * @since   JDK1.0[m
[32m+[m[32m */[m
[32m+[m[32mvar ByteArrayOutputStream = /** @class */ (function (_super) {[m
[32m+[m[32m    __extends(ByteArrayOutputStream, _super);[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a new byte array output stream. The buffer capacity is[m
[32m+[m[32m     * initially 32 bytes, though its size increases if necessary.[m
[32m+[m[32m     */[m
[32m+[m[32m    // public constructor() {[m
[32m+[m[32m    //     this(32);[m
[32m+[m[32m    // }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a new byte array output stream, with a buffer capacity of[m
[32m+[m[32m     * the specified size, in bytes.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   size   the initial size.[m
[32m+[m[32m     * @exception  IllegalArgumentException if size is negative.[m
[32m+[m[32m     */[m
[32m+[m[32m    function ByteArrayOutputStream(size) {[m
[32m+[m[32m        if (size === void 0) { size = 32; }[m
[32m+[m[32m        var _this = _super.call(this) || this;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * The number of valid bytes in the buffer.[m
[32m+[m[32m         */[m
[32m+[m[32m        _this.count = 0;[m
[32m+[m[32m        if (size < 0) {[m
[32m+[m[32m            throw new IllegalArgumentException_1.default('Negative initial size: '[m
[32m+[m[32m                + size);[m
[32m+[m[32m        }[m
[32m+[m[32m        _this.buf = new Uint8Array(size);[m
[32m+[m[32m        return _this;[m
[32m+[m[32m    }[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Increases the capacity if necessary to ensure that it can hold[m
[32m+[m[32m     * at least the number of elements specified by the minimum[m
[32m+[m[32m     * capacity argument.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param minCapacity the desired minimum capacity[m
[32m+[m[32m     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is[m
[32m+[m[32m     * interpreted as a request for the unsatisfiably large capacity[m
[32m+[m[32m     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {[m
[32m+[m[32m        // overflow-conscious code[m
[32m+[m[32m        if (minCapacity - this.buf.length > 0)[m
[32m+[m[32m            this.grow(minCapacity);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Increases the capacity to ensure that it can hold at least the[m
[32m+[m[32m     * number of elements specified by the minimum capacity argument.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param minCapacity the desired minimum capacity[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.grow = function (minCapacity) {[m
[32m+[m[32m        // overflow-conscious code[m
[32m+[m[32m        var oldCapacity = this.buf.length;[m
[32m+[m[32m        var newCapacity = oldCapacity << 1;[m
[32m+[m[32m        if (newCapacity - minCapacity < 0)[m
[32m+[m[32m            newCapacity = minCapacity;[m
[32m+[m[32m        if (newCapacity < 0) {[m
[32m+[m[32m            if (minCapacity < 0) // overflow[m
[32m+[m[32m                throw new OutOfMemoryError_1.default();[m
[32m+[m[32m            newCapacity = Integer_1.default.MAX_VALUE;[m
[32m+[m[32m        }[m
[32m+[m[32m        this.buf = Arrays_1.default.copyOfUint8Array(this.buf, newCapacity);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the specified byte to this byte array output stream.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   b   the byte to be written.[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.write = function (b) {[m
[32m+[m[32m        this.ensureCapacity(this.count + 1);[m
[32m+[m[32m        this.buf[this.count] = /*(byte)*/ b;[m
[32m+[m[32m        this.count += 1;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes <code>len</code> bytes from the specified byte array[m
[32m+[m[32m     * starting at offset <code>off</code> to this byte array output stream.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param   b     the data.[m
[32m+[m[32m     * @param   off   the start offset in the data.[m
[32m+[m[32m     * @param   len   the number of bytes to write.[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {[m
[32m+[m[32m        if ((off < 0) || (off > b.length) || (len < 0) ||[m
[32m+[m[32m            ((off + len) - b.length > 0)) {[m
[32m+[m[32m            throw new IndexOutOfBoundsException_1.default();[m
[32m+[m[32m        }[m
[32m+[m[32m        this.ensureCapacity(this.count + len);[m
[32m+[m[32m        System_1.default.arraycopy(b, off, this.buf, this.count, len);[m
[32m+[m[32m        this.count += len;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Writes the complete contents of this byte array output stream to[m
[32m+[m[32m     * the specified output stream argument, as if by calling the output[m
[32m+[m[32m     * stream's write method using <code>out.write(buf, 0, count)</code>.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param      out   the output stream to which to write the data.[m
[32m+[m[32m     * @exception  IOException  if an I/O error occurs.[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.writeTo = function (out) {[m
[32m+[m[32m        out.writeBytesOffset(this.buf, 0, this.count);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Resets the <code>count</code> field of this byte array output[m
[32m+[m[32m     * stream to zero, so that all currently accumulated output in the[m
[32m+[m[32m     * output stream is discarded. The output stream can be used again,[m
[32m+[m[32m     * reusing the already allocated buffer space.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @see     java.io.ByteArrayInputStream#count[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.reset = function () {[m
[32m+[m[32m        this.count = 0;[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a newly allocated byte array. Its size is the current[m
[32m+[m[32m     * size of this output stream and the valid contents of the buffer[m
[32m+[m[32m     * have been copied into it.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the current contents of this output stream, as a byte array.[m
[32m+[m[32m     * @see     java.io.ByteArrayOutputStream#size()[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.toByteArray = function () {[m
[32m+[m[32m        return Arrays_1.default.copyOfUint8Array(this.buf, this.count);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Returns the current size of the buffer.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return  the value of the <code>count</code> field, which is the number[m
[32m+[m[32m     *          of valid bytes in this output stream.[m
[32m+[m[32m     * @see     java.io.ByteArrayOutputStream#count[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.size = function () {[m
[32m+[m[32m        return this.count;[m
[32m+[m[32m    };[m
[32m+[m[32m    ByteArrayOutputStream.prototype.toString = function (param) {[m
[32m+[m[32m        if (!param) {[m
[32m+[m[32m            return this.toString_void();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (typeof param === 'string') {[m
[32m+[m[32m            return this.toString_string(param);[m
[32m+[m[32m        }[m
[32m+[m[32m        return this.toString_number(param);[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts the buffer's contents into a string decoding bytes using the[m
[32m+[m[32m     * platform's default character set. The length of the new <tt>String</tt>[m
[32m+[m[32m     * is a function of the character set, and hence may not be equal to the[m
[32m+[m[32m     * size of the buffer.[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p> This method always replaces malformed-input and unmappable-character[m
[32m+[m[32m     * sequences with the default replacement string for the platform's[m
[32m+[m[32m     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}[m
[32m+[m[32m     * class should be used when more control over the decoding process is[m
[32m+[m[32m     * required.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @return String decoded from the buffer's contents.[m
[32m+[m[32m     * @since  JDK1.1[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.toString_void = function () {[m
[32m+[m[32m        return new String(this.buf /*, 0, this.count*/).toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Converts the buffer's contents into a string by decoding the bytes using[m
[32m+[m[32m     * the specified {@link java.nio.charset.Charset charsetName}. The length of[m
[32m+[m[32m     * the new <tt>String</tt> is a function of the charset, and hence may not be[m
[32m+[m[32m     * equal to the length of the byte array.[m
[32m+[m[32m     *[m
[32m+[m[32m     * <p> This method always replaces malformed-input and unmappable-character[m
[32m+[m[32m     * sequences with this charset's default replacement string. The {@link[m
[32m+[m[32m     * java.nio.charset.CharsetDecoder} class should be used when more control[m
[32m+[m[32m     * over the decoding process is required.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param  charsetName  the name of a supported[m
[32m+[m[32m     *              {@linkplain java.nio.charset.Charset </code>charset<code>}[m
[32m+[m[32m     * @return String decoded from the buffer's contents.[m
[32m+[m[32m     * @exception  UnsupportedEncodingException[m
[32m+[m[32m     *             If the named charset is not supported[m
[32m+[m[32m     * @since   JDK1.1[m
[32m+[m[32m     */[m
[32m+[m[32m    ByteArrayOutputStream.prototype.toString_string = function (charsetName) {[m
[32m+[m[32m        return new String(this.buf /*, 0, this.count, charsetName*/).toString();[m
[32m+[m[32m    };[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a newly allocated string. Its size is the current size of[m
[32m+[m[32m     * the output stream and the valid contents of the buffer have been[m
[32m+[m[32m     * copied into it. Each character <i>c</i> in the resulting string is[m
[32m+[m[32m     * constructed from the corresponding element <i>b</i> in the byte[m
[32m+[m[32m     * array such that:[m
[32m+[m[32m     * <blockquote><pre>[m
[32m+[m[32m     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))[m
[32m+[m[32m     * </pre></blockquote>[m
[32m+[m[32m     *[m
[32m+[m[32m     * @deprecated This method does not properly convert bytes into characters.[m
[32m+[m[32m     * As of JDK&nbsp;1.1, the preferred way to do this is via the[m
[32m+[m[32m     * <code>toString(String enc)</code> method, which takes an encoding-name[m
[32m+[m[32m     * argument, or the <code>toString()</code> method, which uses the[m
[32m+[m[32m     * platform's default character encoding.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param      hibyte    the high byte of each resulting Unicode character.[m
[32m+[m[32m     * @return     the current contents of the output stream, as a string.[m
[32m+[m[32m     * @see        java.io.ByteArrayOutputStream#size()[m
[32m+[m[32m     * @